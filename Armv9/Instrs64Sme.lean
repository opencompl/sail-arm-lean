import Armv9.Instrs64Sve

set_option maxHeartbeats 1_000_000_000
set_option maxRecDepth 1_000_000
set_option linter.unusedVariables false
set_option match.ignoreUnusedAlts true

open Sail

noncomputable section

namespace Armv9.Functions

open signal
open option
open exception
open arm_acc_type
open __InstrEnc
open WFxType
open VFPNegMul
open VCGTtype
open VCGEType
open VBitOps
open VBitOp
open VARange
open Unpredictable
open TranslationStage
open TimeStamp
open TMFailure
open TLBIOp
open TLBIMemAttr
open TLBILevel
open TGx
open SystemHintOp
open Signal
open ShiftType
open Shareability
open SecurityState
open SVECmp
open SRType
open SMEExceptionType
open SDFType
open RestrictType
open Register
open Regime
open ReduceOp
open PrivilegeLevel
open PrefetchHint
open PSTATEField
open PGSe
open PASpace
open PARTIDspaceType
open OpType
open MoveWideOp
open MemType
open MemTagType
open MemOp
open MemAtomicOp
open MOPSStage
open MBReqTypes
open MBReqDomain
open LogicalOp
open InterruptID
open InstrSet
open ImmediateOp
open GPCF
open GCSInstruction
open Feature
open Fault
open FPUnaryOp
open FPType
open FPRounding
open FPMaxMinOp
open FPExc
open FPConvOp
open ExtendType
open ExceptionalOccurrenceTargetState
open Exception
open ErrorState
open DeviceType
open DescriptorType
open DSBAlias
open CrossTriggerIn
open CountOp
open Constraint
open CompareOp
open CacheType
open CachePASpace
open CacheOpScope
open CacheOp
open BranchType
open Barrier
open ArchVersion
open AccessType
open ATAccess

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_FMOPA_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 row esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 col esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                     mask2 col esize)))
            then
              (do
                let element1 ← (( do
                  bif sub_op
                  then
                    (do
                      (FPNeg element1))
                  else (pure element1) ) : SailM (BitVec esize) )
                (Elem_set result ((row *i dim) +i col) esize
                  (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ()))))))
            else
              (do
                (Elem_set result ((row *i dim) +i col) esize element3))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_FMOPA_ZA_PP_ZZ_32 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  match VL with
  | 128 => (execute_FMOPA_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n sub_op)
  | 256 => (execute_FMOPA_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n sub_op)
  | 512 => (execute_FMOPA_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n sub_op)
  | 1024 => (execute_FMOPA_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op)
  | 2048 => (execute_FMOPA_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_FMOPS_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 row esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 col esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                     mask2 col esize)))
            then
              (do
                let element1 ← (( do
                  bif sub_op
                  then
                    (do
                      (FPNeg element1))
                  else (pure element1) ) : SailM (BitVec esize) )
                (Elem_set result ((row *i dim) +i col) esize
                  (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ()))))))
            else
              (do
                (Elem_set result ((row *i dim) +i col) esize element3))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_FMOPS_ZA_PP_ZZ_32 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  match VL with
  | 128 => (execute_FMOPS_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n sub_op)
  | 256 => (execute_FMOPS_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n sub_op)
  | 512 => (execute_FMOPS_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n sub_op)
  | 1024 => (execute_FMOPS_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op)
  | 2048 => (execute_FMOPS_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_FMOPA_ZA_PP_ZZ_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 row esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 col esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                     mask2 col esize)))
            then
              (do
                let element1 ← (( do
                  bif sub_op
                  then
                    (do
                      (FPNeg element1))
                  else (pure element1) ) : SailM (BitVec esize) )
                (Elem_set result ((row *i dim) +i col) esize
                  (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ()))))))
            else
              (do
                (Elem_set result ((row *i dim) +i col) esize element3))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_FMOPA_ZA_PP_ZZ_64 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF64F64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  match VL with
  | 128 => (execute_FMOPA_ZA_PP_ZZ_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n sub_op)
  | 256 => (execute_FMOPA_ZA_PP_ZZ_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n sub_op)
  | 512 => (execute_FMOPA_ZA_PP_ZZ_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n sub_op)
  | 1024 => (execute_FMOPA_ZA_PP_ZZ_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op)
  | 2048 => (execute_FMOPA_ZA_PP_ZZ_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_FMOPS_ZA_PP_ZZ_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 row esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 col esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                     mask2 col esize)))
            then
              (do
                let element1 ← (( do
                  bif sub_op
                  then
                    (do
                      (FPNeg element1))
                  else (pure element1) ) : SailM (BitVec esize) )
                (Elem_set result ((row *i dim) +i col) esize
                  (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ()))))))
            else
              (do
                (Elem_set result ((row *i dim) +i col) esize element3))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_FMOPS_ZA_PP_ZZ_64 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF64F64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  match VL with
  | 128 => (execute_FMOPS_ZA_PP_ZZ_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n sub_op)
  | 256 => (execute_FMOPS_ZA_PP_ZZ_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n sub_op)
  | 512 => (execute_FMOPS_ZA_PP_ZZ_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n sub_op)
  | 1024 => (execute_FMOPS_ZA_PP_ZZ_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op)
  | 2048 => (execute_FMOPS_ZA_PP_ZZ_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_32 : Nat, m : Nat, n : Nat, k_sub_op
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) ∧ dim_dim_32 = (VL / 32 * (VL / 32 * 32)) -/
def execute_BFMOPA_ZA32_PP_ZZ__ (VL : Nat) (dim_dim_32 : Nat) (a : Nat) (b : Nat) (da : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL 32)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da 32 dim_dim_32) ) : SailM (BitVec dim_dim_32) )
  let result ← (( do (undefined_bitvector dim_dim_32) ) : SailM (BitVec dim_dim_32) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let prow_0 ← (( do (ActivePredicateElement mask1 ((2 *i row) +i 0) 16) ) : SailM Bool
              )
            let prow_1 ← (( do (ActivePredicateElement mask1 ((2 *i row) +i 1) 16) ) : SailM Bool
              )
            let pcol_0 ← (( do (ActivePredicateElement mask2 ((2 *i col) +i 0) 16) ) : SailM Bool
              )
            let pcol_1 ← (( do (ActivePredicateElement mask2 ((2 *i col) +i 1) 16) ) : SailM Bool
              )
            let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) 32) ) : SailM (BitVec 32) )
            let sum ← (( do
              bif ((prow_0 && pcol_0) || (prow_1 && pcol_1))
              then
                (do
                  let erow_0 ← (( do
                    bif prow_0
                    then (Elem_read operand1 ((2 *i row) +i 0) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let erow_1 ← (( do
                    bif prow_1
                    then (Elem_read operand1 ((2 *i row) +i 1) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let ecol_0 ← (( do
                    bif pcol_0
                    then (Elem_read operand2 ((2 *i col) +i 0) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let ecol_1 ← (( do
                    bif pcol_1
                    then (Elem_read operand2 ((2 *i col) +i 1) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let (erow_0, erow_1) ← (( do
                    bif sub_op
                    then
                      (do
                        let honor_altfp : Bool := false
                        let erow_0 ← (( do
                          bif prow_0
                          then
                            (do
                              (BFNeg__1 erow_0 honor_altfp))
                          else (pure erow_0) ) : SailM (BitVec 16) )
                        let erow_1 ← (( do
                          bif prow_1
                          then
                            (do
                              (BFNeg__1 erow_1 honor_altfp))
                          else (pure erow_1) ) : SailM (BitVec 16) )
                        (pure (erow_0, erow_1)))
                    else (pure (erow_0, erow_1)) ) : SailM ((BitVec 16) × (BitVec 16)) )
                  (BFDotAdd sum erow_0 erow_1 ecol_0 ecol_1 (← (FPCR_read ()))))
              else (pure sum) ) : SailM (BitVec 32) )
            (Elem_set result ((row *i dim) +i col) 32 sum)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_32) )
  (ZAtile_set VL da 32 dim_dim_32 result)

def decode_BFMOPA_ZA32_PP_ZZ__ (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  match VL with
  | 128 => (execute_BFMOPA_ZA32_PP_ZZ__ 128 (((Int.ediv 128 32) *i (Int.ediv 128 32)) *i 32) a b da
      m n sub_op)
  | 256 => (execute_BFMOPA_ZA32_PP_ZZ__ 256 (((Int.ediv 256 32) *i (Int.ediv 256 32)) *i 32) a b da
      m n sub_op)
  | 512 => (execute_BFMOPA_ZA32_PP_ZZ__ 512 (((Int.ediv 512 32) *i (Int.ediv 512 32)) *i 32) a b da
      m n sub_op)
  | 1024 => (execute_BFMOPA_ZA32_PP_ZZ__ 1024 (((Int.ediv 1024 32) *i (Int.ediv 1024 32)) *i 32) a b
      da m n sub_op)
  | 2048 => (execute_BFMOPA_ZA32_PP_ZZ__ 2048 (((Int.ediv 2048 32) *i (Int.ediv 2048 32)) *i 32) a b
      da m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_32 : Nat, m : Nat, n : Nat, k_sub_op
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) ∧ dim_dim_32 = (VL / 32 * (VL / 32 * 32)) -/
def execute_BFMOPS_ZA32_PP_ZZ__ (VL : Nat) (dim_dim_32 : Nat) (a : Nat) (b : Nat) (da : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL 32)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da 32 dim_dim_32) ) : SailM (BitVec dim_dim_32) )
  let result ← (( do (undefined_bitvector dim_dim_32) ) : SailM (BitVec dim_dim_32) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let prow_0 ← (( do (ActivePredicateElement mask1 ((2 *i row) +i 0) 16) ) : SailM Bool
              )
            let prow_1 ← (( do (ActivePredicateElement mask1 ((2 *i row) +i 1) 16) ) : SailM Bool
              )
            let pcol_0 ← (( do (ActivePredicateElement mask2 ((2 *i col) +i 0) 16) ) : SailM Bool
              )
            let pcol_1 ← (( do (ActivePredicateElement mask2 ((2 *i col) +i 1) 16) ) : SailM Bool
              )
            let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) 32) ) : SailM (BitVec 32) )
            let sum ← (( do
              bif ((prow_0 && pcol_0) || (prow_1 && pcol_1))
              then
                (do
                  let erow_0 ← (( do
                    bif prow_0
                    then (Elem_read operand1 ((2 *i row) +i 0) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let erow_1 ← (( do
                    bif prow_1
                    then (Elem_read operand1 ((2 *i row) +i 1) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let ecol_0 ← (( do
                    bif pcol_0
                    then (Elem_read operand2 ((2 *i col) +i 0) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let ecol_1 ← (( do
                    bif pcol_1
                    then (Elem_read operand2 ((2 *i col) +i 1) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let (erow_0, erow_1) ← (( do
                    bif sub_op
                    then
                      (do
                        let honor_altfp : Bool := false
                        let erow_0 ← (( do
                          bif prow_0
                          then
                            (do
                              (BFNeg__1 erow_0 honor_altfp))
                          else (pure erow_0) ) : SailM (BitVec 16) )
                        let erow_1 ← (( do
                          bif prow_1
                          then
                            (do
                              (BFNeg__1 erow_1 honor_altfp))
                          else (pure erow_1) ) : SailM (BitVec 16) )
                        (pure (erow_0, erow_1)))
                    else (pure (erow_0, erow_1)) ) : SailM ((BitVec 16) × (BitVec 16)) )
                  (BFDotAdd sum erow_0 erow_1 ecol_0 ecol_1 (← (FPCR_read ()))))
              else (pure sum) ) : SailM (BitVec 32) )
            (Elem_set result ((row *i dim) +i col) 32 sum)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_32) )
  (ZAtile_set VL da 32 dim_dim_32 result)

def decode_BFMOPS_ZA32_PP_ZZ__ (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  match VL with
  | 128 => (execute_BFMOPS_ZA32_PP_ZZ__ 128 (((Int.ediv 128 32) *i (Int.ediv 128 32)) *i 32) a b da
      m n sub_op)
  | 256 => (execute_BFMOPS_ZA32_PP_ZZ__ 256 (((Int.ediv 256 32) *i (Int.ediv 256 32)) *i 32) a b da
      m n sub_op)
  | 512 => (execute_BFMOPS_ZA32_PP_ZZ__ 512 (((Int.ediv 512 32) *i (Int.ediv 512 32)) *i 32) a b da
      m n sub_op)
  | 1024 => (execute_BFMOPS_ZA32_PP_ZZ__ 1024 (((Int.ediv 1024 32) *i (Int.ediv 1024 32)) *i 32) a b
      da m n sub_op)
  | 2048 => (execute_BFMOPS_ZA32_PP_ZZ__ 2048 (((Int.ediv 2048 32) *i (Int.ediv 2048 32)) *i 32) a b
      da m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_32 : Nat, m : Nat, n : Nat, k_sub_op
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) ∧ dim_dim_32 = (VL / 32 * (VL / 32 * 32)) -/
def execute_FMOPA_ZA32_PP_ZZ_16 (VL : Nat) (dim_dim_32 : Nat) (a : Nat) (b : Nat) (da : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL 32)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da 32 dim_dim_32) ) : SailM (BitVec dim_dim_32) )
  let result ← (( do (undefined_bitvector dim_dim_32) ) : SailM (BitVec dim_dim_32) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let prow_0 ← (( do (ActivePredicateElement mask1 ((2 *i row) +i 0) 16) ) : SailM Bool
              )
            let prow_1 ← (( do (ActivePredicateElement mask1 ((2 *i row) +i 1) 16) ) : SailM Bool
              )
            let pcol_0 ← (( do (ActivePredicateElement mask2 ((2 *i col) +i 0) 16) ) : SailM Bool
              )
            let pcol_1 ← (( do (ActivePredicateElement mask2 ((2 *i col) +i 1) 16) ) : SailM Bool
              )
            let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) 32) ) : SailM (BitVec 32) )
            let sum ← (( do
              bif ((prow_0 && pcol_0) || (prow_1 && pcol_1))
              then
                (do
                  let erow_0 ← (( do
                    bif prow_0
                    then (Elem_read operand1 ((2 *i row) +i 0) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let erow_1 ← (( do
                    bif prow_1
                    then (Elem_read operand1 ((2 *i row) +i 1) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let ecol_0 ← (( do
                    bif pcol_0
                    then (Elem_read operand2 ((2 *i col) +i 0) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let ecol_1 ← (( do
                    bif pcol_1
                    then (Elem_read operand2 ((2 *i col) +i 1) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let (erow_0, erow_1) ← (( do
                    bif sub_op
                    then
                      (do
                        let erow_0 ← (( do
                          bif prow_0
                          then
                            (do
                              (FPNeg erow_0))
                          else (pure erow_0) ) : SailM (BitVec 16) )
                        let erow_1 ← (( do
                          bif prow_1
                          then
                            (do
                              (FPNeg erow_1))
                          else (pure erow_1) ) : SailM (BitVec 16) )
                        (pure (erow_0, erow_1)))
                    else (pure (erow_0, erow_1)) ) : SailM ((BitVec 16) × (BitVec 16)) )
                  (FPDotAdd_ZA sum erow_0 erow_1 ecol_0 ecol_1 (← (FPCR_read ()))))
              else (pure sum) ) : SailM (BitVec 32) )
            (Elem_set result ((row *i dim) +i col) 32 sum)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_32) )
  (ZAtile_set VL da 32 dim_dim_32 result)

def decode_FMOPA_ZA32_PP_ZZ_16 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  match VL with
  | 128 => (execute_FMOPA_ZA32_PP_ZZ_16 128 (((Int.ediv 128 32) *i (Int.ediv 128 32)) *i 32) a b da
      m n sub_op)
  | 256 => (execute_FMOPA_ZA32_PP_ZZ_16 256 (((Int.ediv 256 32) *i (Int.ediv 256 32)) *i 32) a b da
      m n sub_op)
  | 512 => (execute_FMOPA_ZA32_PP_ZZ_16 512 (((Int.ediv 512 32) *i (Int.ediv 512 32)) *i 32) a b da
      m n sub_op)
  | 1024 => (execute_FMOPA_ZA32_PP_ZZ_16 1024 (((Int.ediv 1024 32) *i (Int.ediv 1024 32)) *i 32) a b
      da m n sub_op)
  | 2048 => (execute_FMOPA_ZA32_PP_ZZ_16 2048 (((Int.ediv 2048 32) *i (Int.ediv 2048 32)) *i 32) a b
      da m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_32 : Nat, m : Nat, n : Nat, k_sub_op
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) ∧ dim_dim_32 = (VL / 32 * (VL / 32 * 32)) -/
def execute_FMOPS_ZA32_PP_ZZ_16 (VL : Nat) (dim_dim_32 : Nat) (a : Nat) (b : Nat) (da : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL 32)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da 32 dim_dim_32) ) : SailM (BitVec dim_dim_32) )
  let result ← (( do (undefined_bitvector dim_dim_32) ) : SailM (BitVec dim_dim_32) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let prow_0 ← (( do (ActivePredicateElement mask1 ((2 *i row) +i 0) 16) ) : SailM Bool
              )
            let prow_1 ← (( do (ActivePredicateElement mask1 ((2 *i row) +i 1) 16) ) : SailM Bool
              )
            let pcol_0 ← (( do (ActivePredicateElement mask2 ((2 *i col) +i 0) 16) ) : SailM Bool
              )
            let pcol_1 ← (( do (ActivePredicateElement mask2 ((2 *i col) +i 1) 16) ) : SailM Bool
              )
            let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) 32) ) : SailM (BitVec 32) )
            let sum ← (( do
              bif ((prow_0 && pcol_0) || (prow_1 && pcol_1))
              then
                (do
                  let erow_0 ← (( do
                    bif prow_0
                    then (Elem_read operand1 ((2 *i row) +i 0) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let erow_1 ← (( do
                    bif prow_1
                    then (Elem_read operand1 ((2 *i row) +i 1) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let ecol_0 ← (( do
                    bif pcol_0
                    then (Elem_read operand2 ((2 *i col) +i 0) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let ecol_1 ← (( do
                    bif pcol_1
                    then (Elem_read operand2 ((2 *i col) +i 1) 16)
                    else (FPZero (0b0 : (BitVec 1)) 16) ) : SailM (BitVec 16) )
                  let (erow_0, erow_1) ← (( do
                    bif sub_op
                    then
                      (do
                        let erow_0 ← (( do
                          bif prow_0
                          then
                            (do
                              (FPNeg erow_0))
                          else (pure erow_0) ) : SailM (BitVec 16) )
                        let erow_1 ← (( do
                          bif prow_1
                          then
                            (do
                              (FPNeg erow_1))
                          else (pure erow_1) ) : SailM (BitVec 16) )
                        (pure (erow_0, erow_1)))
                    else (pure (erow_0, erow_1)) ) : SailM ((BitVec 16) × (BitVec 16)) )
                  (FPDotAdd_ZA sum erow_0 erow_1 ecol_0 ecol_1 (← (FPCR_read ()))))
              else (pure sum) ) : SailM (BitVec 32) )
            (Elem_set result ((row *i dim) +i col) 32 sum)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_32) )
  (ZAtile_set VL da 32 dim_dim_32 result)

def decode_FMOPS_ZA32_PP_ZZ_16 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  match VL with
  | 128 => (execute_FMOPS_ZA32_PP_ZZ_16 128 (((Int.ediv 128 32) *i (Int.ediv 128 32)) *i 32) a b da
      m n sub_op)
  | 256 => (execute_FMOPS_ZA32_PP_ZZ_16 256 (((Int.ediv 256 32) *i (Int.ediv 256 32)) *i 32) a b da
      m n sub_op)
  | 512 => (execute_FMOPS_ZA32_PP_ZZ_16 512 (((Int.ediv 512 32) *i (Int.ediv 512 32)) *i 32) a b da
      m n sub_op)
  | 1024 => (execute_FMOPS_ZA32_PP_ZZ_16 1024 (((Int.ediv 1024 32) *i (Int.ediv 1024 32)) *i 32) a b
      da m n sub_op)
  | 2048 => (execute_FMOPS_ZA32_PP_ZZ_16 2048 (((Int.ediv 2048 32) *i (Int.ediv 2048 32)) *i 32) a b
      da m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_SMOPA_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_SMOPA_ZA_PP_ZZ_32 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  let op1_unsigned : Bool := false
  let op2_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMOPA_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_SMOPA_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_SMOPA_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_SMOPA_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_SMOPA_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_SUMOPA_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_SUMOPA_ZA_PP_ZZ_32 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  let op1_unsigned : Bool := false
  let op2_unsigned : Bool := true
  match VL with
  | 128 => (execute_SUMOPA_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_SUMOPA_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_SUMOPA_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_SUMOPA_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_SUMOPA_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_USMOPA_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_USMOPA_ZA_PP_ZZ_32 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  let op1_unsigned : Bool := true
  let op2_unsigned : Bool := false
  match VL with
  | 128 => (execute_USMOPA_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_USMOPA_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_USMOPA_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_USMOPA_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_USMOPA_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_UMOPA_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_UMOPA_ZA_PP_ZZ_32 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  let op1_unsigned : Bool := true
  let op2_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMOPA_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_UMOPA_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_UMOPA_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_UMOPA_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_UMOPA_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_SMOPS_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_SMOPS_ZA_PP_ZZ_32 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  let op1_unsigned : Bool := false
  let op2_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMOPS_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_SMOPS_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_SMOPS_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_SMOPS_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_SMOPS_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_SUMOPS_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_SUMOPS_ZA_PP_ZZ_32 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  let op1_unsigned : Bool := false
  let op2_unsigned : Bool := true
  match VL with
  | 128 => (execute_SUMOPS_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_SUMOPS_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_SUMOPS_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_SUMOPS_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_SUMOPS_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_USMOPS_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_USMOPS_ZA_PP_ZZ_32 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  let op1_unsigned : Bool := true
  let op2_unsigned : Bool := false
  match VL with
  | 128 => (execute_USMOPS_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_USMOPS_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_USMOPS_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_USMOPS_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_USMOPS_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_UMOPS_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_UMOPS_ZA_PP_ZZ_32 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  let op1_unsigned : Bool := true
  let op2_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMOPS_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_UMOPS_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_UMOPS_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_UMOPS_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_UMOPS_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_SMOPA_ZA_PP_ZZ_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_SMOPA_ZA_PP_ZZ_64 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEI16I64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  let op1_unsigned : Bool := false
  let op2_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMOPA_ZA_PP_ZZ_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_SMOPA_ZA_PP_ZZ_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_SMOPA_ZA_PP_ZZ_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_SMOPA_ZA_PP_ZZ_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_SMOPA_ZA_PP_ZZ_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_SUMOPA_ZA_PP_ZZ_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_SUMOPA_ZA_PP_ZZ_64 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEI16I64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  let op1_unsigned : Bool := false
  let op2_unsigned : Bool := true
  match VL with
  | 128 => (execute_SUMOPA_ZA_PP_ZZ_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_SUMOPA_ZA_PP_ZZ_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_SUMOPA_ZA_PP_ZZ_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_SUMOPA_ZA_PP_ZZ_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_SUMOPA_ZA_PP_ZZ_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_USMOPA_ZA_PP_ZZ_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_USMOPA_ZA_PP_ZZ_64 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEI16I64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  let op1_unsigned : Bool := true
  let op2_unsigned : Bool := false
  match VL with
  | 128 => (execute_USMOPA_ZA_PP_ZZ_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_USMOPA_ZA_PP_ZZ_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_USMOPA_ZA_PP_ZZ_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_USMOPA_ZA_PP_ZZ_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_USMOPA_ZA_PP_ZZ_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_UMOPA_ZA_PP_ZZ_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_UMOPA_ZA_PP_ZZ_64 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEI16I64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  let op1_unsigned : Bool := true
  let op2_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMOPA_ZA_PP_ZZ_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_UMOPA_ZA_PP_ZZ_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_UMOPA_ZA_PP_ZZ_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_UMOPA_ZA_PP_ZZ_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_UMOPA_ZA_PP_ZZ_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_SMOPS_ZA_PP_ZZ_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_SMOPS_ZA_PP_ZZ_64 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEI16I64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  let op1_unsigned : Bool := false
  let op2_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMOPS_ZA_PP_ZZ_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_SMOPS_ZA_PP_ZZ_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_SMOPS_ZA_PP_ZZ_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_SMOPS_ZA_PP_ZZ_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_SMOPS_ZA_PP_ZZ_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_SUMOPS_ZA_PP_ZZ_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_SUMOPS_ZA_PP_ZZ_64 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEI16I64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  let op1_unsigned : Bool := false
  let op2_unsigned : Bool := true
  match VL with
  | 128 => (execute_SUMOPS_ZA_PP_ZZ_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_SUMOPS_ZA_PP_ZZ_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_SUMOPS_ZA_PP_ZZ_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_SUMOPS_ZA_PP_ZZ_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_SUMOPS_ZA_PP_ZZ_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_USMOPS_ZA_PP_ZZ_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_USMOPS_ZA_PP_ZZ_64 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEI16I64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  let op1_unsigned : Bool := true
  let op2_unsigned : Bool := false
  match VL with
  | 128 => (execute_USMOPS_ZA_PP_ZZ_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_USMOPS_ZA_PP_ZZ_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_USMOPS_ZA_PP_ZZ_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_USMOPS_ZA_PP_ZZ_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_USMOPS_ZA_PP_ZZ_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_UMOPS_ZA_PP_ZZ_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 3
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((4 *i row) +i k) (Int.ediv esize 4))) && (← (ActivePredicateElement
                               mask2 ((4 *i col) +i k) (Int.ediv esize 4))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((4 *i row) +i k) (Int.ediv esize 4)))
                                    op1_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((4 *i col) +i k) (Int.ediv esize 4)))
                                    op2_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_UMOPS_ZA_PP_ZZ_64 (u0 : (BitVec 1)) (u1 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEI16I64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  let op1_unsigned : Bool := true
  let op2_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMOPS_ZA_PP_ZZ_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 256 => (execute_UMOPS_ZA_PP_ZZ_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 512 => (execute_UMOPS_ZA_PP_ZZ_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n op1_unsigned op2_unsigned sub_op)
  | 1024 => (execute_UMOPS_ZA_PP_ZZ_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | 2048 => (execute_UMOPS_ZA_PP_ZZ_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n op1_unsigned
      op2_unsigned sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ d = 0 ∧ is_VL(VL) -/
def execute_MOVA_ZA_P_RZ_B (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let result ← (( do (ZAslice_read d esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize element))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (ZAslice_set d esize vertical slice_name VL result)

def decode_MOVA_ZA_P_RZ_B (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (off4 : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat Zn)
  let d := 0
  let offset := (BitVec.toNat off4)
  let esize := 8
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA_P_RZ_B 128 d esize g n offset s vertical)
  | 256 => (execute_MOVA_ZA_P_RZ_B 256 d esize g n offset s vertical)
  | 512 => (execute_MOVA_ZA_P_RZ_B 512 d esize g n offset s vertical)
  | 1024 => (execute_MOVA_ZA_P_RZ_B 1024 d esize g n offset s vertical)
  | 2048 => (execute_MOVA_ZA_P_RZ_B 2048 d esize g n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ d ∈ {0, 1} ∧ is_VL(VL) -/
def execute_MOVA_ZA_P_RZ_H (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let result ← (( do (ZAslice_read d esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize element))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (ZAslice_set d esize vertical slice_name VL result)

def decode_MOVA_ZA_P_RZ_H (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ZAd : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat ZAd)
  let offset := (BitVec.toNat off3)
  let esize := 16
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA_P_RZ_H 128 d esize g n offset s vertical)
  | 256 => (execute_MOVA_ZA_P_RZ_H 256 d esize g n offset s vertical)
  | 512 => (execute_MOVA_ZA_P_RZ_H 512 d esize g n offset s vertical)
  | 1024 => (execute_MOVA_ZA_P_RZ_H 1024 d esize g n offset s vertical)
  | 2048 => (execute_MOVA_ZA_P_RZ_H 2048 d esize g n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ d ∈ {0, 1, 2, 3} ∧ is_VL(VL) -/
def execute_MOVA_ZA_P_RZ_W (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let result ← (( do (ZAslice_read d esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize element))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (ZAslice_set d esize vertical slice_name VL result)

def decode_MOVA_ZA_P_RZ_W (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ZAd : (BitVec 2)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat ZAd)
  let offset := (BitVec.toNat off2)
  let esize := 32
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA_P_RZ_W 128 d esize g n offset s vertical)
  | 256 => (execute_MOVA_ZA_P_RZ_W 256 d esize g n offset s vertical)
  | 512 => (execute_MOVA_ZA_P_RZ_W 512 d esize g n offset s vertical)
  | 1024 => (execute_MOVA_ZA_P_RZ_W 1024 d esize g n offset s vertical)
  | 2048 => (execute_MOVA_ZA_P_RZ_W 2048 d esize g n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ d ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_MOVA_ZA_P_RZ_D (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let result ← (( do (ZAslice_read d esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize element))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (ZAslice_set d esize vertical slice_name VL result)

def decode_MOVA_ZA_P_RZ_D (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ZAd : (BitVec 3)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat ZAd)
  let offset := (BitVec.toNat o1)
  let esize := 64
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA_P_RZ_D 128 d esize g n offset s vertical)
  | 256 => (execute_MOVA_ZA_P_RZ_D 256 d esize g n offset s vertical)
  | 512 => (execute_MOVA_ZA_P_RZ_D 512 d esize g n offset s vertical)
  | 1024 => (execute_MOVA_ZA_P_RZ_D 1024 d esize g n offset s vertical)
  | 2048 => (execute_MOVA_ZA_P_RZ_D 2048 d esize g n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_MOVA_ZA_P_RZ_Q (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let result ← (( do (ZAslice_read d esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize element))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (ZAslice_set d esize vertical slice_name VL result)

def decode_MOVA_ZA_P_RZ_Q (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ZAd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat ZAd)
  let offset := 0
  let esize := 128
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA_P_RZ_Q 128 d esize g n offset s vertical)
  | 256 => (execute_MOVA_ZA_P_RZ_Q 256 d esize g n offset s vertical)
  | 512 => (execute_MOVA_ZA_P_RZ_Q 512 d esize g n offset s vertical)
  | 1024 => (execute_MOVA_ZA_P_RZ_Q 1024 d esize g n offset s vertical)
  | 2048 => (execute_MOVA_ZA_P_RZ_Q 2048 d esize g n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  n = 0 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_Z_P_RZA_B (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let operand ← (( do (ZAslice_read n esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize element))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MOVA_Z_P_RZA_B (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (off4 : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := 0
  let offset := (BitVec.toNat off4)
  let esize := 8
  let d := (BitVec.toNat Zd)
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_Z_P_RZA_B 128 d esize g n offset s vertical)
  | 256 => (execute_MOVA_Z_P_RZA_B 256 d esize g n offset s vertical)
  | 512 => (execute_MOVA_Z_P_RZA_B 512 d esize g n offset s vertical)
  | 1024 => (execute_MOVA_Z_P_RZA_B 1024 d esize g n offset s vertical)
  | 2048 => (execute_MOVA_Z_P_RZA_B 2048 d esize g n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  n ∈ {0, 1} ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_Z_P_RZA_H (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let operand ← (( do (ZAslice_read n esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize element))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MOVA_Z_P_RZA_H (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (ZAn : (BitVec 1)) (off3 : (BitVec 3)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat off3)
  let esize := 16
  let d := (BitVec.toNat Zd)
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_Z_P_RZA_H 128 d esize g n offset s vertical)
  | 256 => (execute_MOVA_Z_P_RZA_H 256 d esize g n offset s vertical)
  | 512 => (execute_MOVA_Z_P_RZA_H 512 d esize g n offset s vertical)
  | 1024 => (execute_MOVA_Z_P_RZA_H 1024 d esize g n offset s vertical)
  | 2048 => (execute_MOVA_Z_P_RZA_H 2048 d esize g n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3} ∧
  n ∈ {0, 1, 2, 3} ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_Z_P_RZA_W (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let operand ← (( do (ZAslice_read n esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize element))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MOVA_Z_P_RZA_W (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (ZAn : (BitVec 2)) (off2 : (BitVec 2)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat off2)
  let esize := 32
  let d := (BitVec.toNat Zd)
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_Z_P_RZA_W 128 d esize g n offset s vertical)
  | 256 => (execute_MOVA_Z_P_RZA_W 256 d esize g n offset s vertical)
  | 512 => (execute_MOVA_Z_P_RZA_W 512 d esize g n offset s vertical)
  | 1024 => (execute_MOVA_Z_P_RZA_W 1024 d esize g n offset s vertical)
  | 2048 => (execute_MOVA_Z_P_RZA_W 2048 d esize g n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1} ∧
  n ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_Z_P_RZA_D (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let operand ← (( do (ZAslice_read n esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize element))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MOVA_Z_P_RZA_D (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (ZAn : (BitVec 3)) (o1 : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat o1)
  let esize := 64
  let d := (BitVec.toNat Zd)
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_Z_P_RZA_D 128 d esize g n offset s vertical)
  | 256 => (execute_MOVA_Z_P_RZA_D 256 d esize g n offset s vertical)
  | 512 => (execute_MOVA_Z_P_RZA_D 512 d esize g n offset s vertical)
  | 1024 => (execute_MOVA_Z_P_RZA_D 1024 d esize g n offset s vertical)
  | 2048 => (execute_MOVA_Z_P_RZA_D 2048 d esize g n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  0 ≤ n ∧
  n ≤ 15 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_Z_P_RZA_Q (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let operand ← (( do (ZAslice_read n esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize element))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MOVA_Z_P_RZA_Q (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (ZAn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat ZAn)
  let offset := 0
  let esize := 128
  let d := (BitVec.toNat Zd)
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_Z_P_RZA_Q 128 d esize g n offset s vertical)
  | 256 => (execute_MOVA_Z_P_RZA_Q 256 d esize g n offset s vertical)
  | 512 => (execute_MOVA_Z_P_RZA_Q 512 d esize g n offset s vertical)
  | 1024 => (execute_MOVA_Z_P_RZA_Q 1024 d esize g n offset s vertical)
  | 2048 => (execute_MOVA_Z_P_RZA_Q 2048 d esize g n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: SVL : Nat, n : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧ 0 ≤ offset ∧ offset ≤ 15 ∧ 0 ≤ n ∧ n ≤ 31 ∧ is_VL(SVL) -/
def execute_LDR_ZA_RI__ (SVL : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckSMEAndZAEnabled ())
  let SVL := SVL
  let dim := (Int.ediv SVL 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let moffs : Int := (offset *i dim)
  let result ← (( do (undefined_bitvector SVL) ) : SailM (BitVec SVL) )
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec := (Nat.div ((BitVec.toNat vbase) +i offset) dim)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSME MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  bif ((← (HaveTME ())) && ((← readReg TSTATE).depth >b 0))
  then (FailTransaction TMFailure_ERR false)
  else (pure ())
  let base ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let aligned : Bool := (IsAligned__1 (BitVec.addInt base moffs) 16)
  bif ((! aligned) && (← (AlignmentEnforced ())))
  then (AArch64_Abort (BitVec.addInt base moffs) (← (AlignmentFault accdesc)))
  else (pure ())
  let (moffs, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (moffs, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (moffs, result) := loop_vars
      loop_vars ← do
        let moffs := moffs
        let result ←
          (Elem_set result e 8
            (← (AArch64_MemSingle_read (BitVec.addInt base moffs) 1 accdesc aligned)))
        (pure ())
        let moffs : Int := (moffs +i 1)
        (pure (moffs, result))
    (pure loop_vars) ) : SailM (Int × (BitVec SVL)) )
  (ZAvector_set vec SVL result)

def decode_LDR_ZA_RI__ (Rv : (BitVec 2)) (Rn : (BitVec 5)) (off4 : (BitVec 4)) : SailM Unit := do
  let SVL ← do (CurrentSVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let v := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat off4)
  match SVL with
  | 128 => (execute_LDR_ZA_RI__ 128 n offset v)
  | 256 => (execute_LDR_ZA_RI__ 256 n offset v)
  | 512 => (execute_LDR_ZA_RI__ 512 n offset v)
  | 1024 => (execute_LDR_ZA_RI__ 1024 n offset v)
  | 2048 => (execute_LDR_ZA_RI__ 2048 n offset v)
  | _ => (pure ())

/-- Type quantifiers: SVL : Nat, n : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧ 0 ≤ offset ∧ offset ≤ 15 ∧ 0 ≤ n ∧ n ≤ 31 ∧ is_VL(SVL) -/
def execute_STR_ZA_RI__ (SVL : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckSMEAndZAEnabled ())
  let SVL := SVL
  let dim := (Int.ediv SVL 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let moffs : Int := (offset *i dim)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec := (Nat.div ((BitVec.toNat vbase) +i offset) dim)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSME MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  bif ((← (HaveTME ())) && ((← readReg TSTATE).depth >b 0))
  then (FailTransaction TMFailure_ERR false)
  else (pure ())
  let base ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do (ZAvector_read vec SVL) ) : SailM (BitVec SVL) )
  let aligned : Bool := (IsAligned__1 (BitVec.addInt base moffs) 16)
  bif ((! aligned) && (← (AlignmentEnforced ())))
  then (AArch64_Abort (BitVec.addInt base moffs) (← (AlignmentFault accdesc)))
  else (pure ())
  let moffs ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := moffs
    for e in [loop_e_lower:loop_e_upper:1]i do
      let moffs := loop_vars
      loop_vars ← do
        let moffs := moffs
        (AArch64_MemSingle_set (BitVec.addInt base moffs) 1 accdesc aligned
          (← (Elem_read src e 8)))
        (pure (moffs +i 1))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_STR_ZA_RI__ (Rv : (BitVec 2)) (Rn : (BitVec 5)) (off4 : (BitVec 4)) : SailM Unit := do
  let SVL ← do (CurrentSVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let v := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat off4)
  match SVL with
  | 128 => (execute_STR_ZA_RI__ 128 n offset v)
  | 256 => (execute_STR_ZA_RI__ 256 n offset v)
  | 512 => (execute_STR_ZA_RI__ 512 n offset v)
  | 1024 => (execute_STR_ZA_RI__ 1024 n offset v)
  | 2048 => (execute_STR_ZA_RI__ 2048 n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, offset : Nat, s : Nat, t :
  Nat, k_vertical : Bool, t = 0 ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_ZA_P_RRR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (offset : Nat) (s : Nat) (t : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let addr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let moffs ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSME MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (n == 31)
    then
      (do
        bif ((← (AnyActiveElement mask esize)) || (← (ConstrainUnpredictableBool
                 Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let (addr, moffs, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (addr, moffs, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (addr, moffs, result) := loop_vars
      loop_vars ← do
        let addr : (BitVec 64) := (BitVec.addInt base ((BitVec.toNat moffs) *i mbytes))
        let result ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
          else
            (do
              (Elem_set result e esize (Zeros (n := esize)))) ) : SailM (BitVec VL) )
        let moffs : (BitVec 64) := (BitVec.addInt moffs 1)
        (pure (addr, moffs, result))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  (ZAslice_set t esize vertical slice_name VL result)

def decode_LD1B_ZA_P_RRR__ (msz : (BitVec 2)) (Rm : (BitVec 5)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (off4 : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Pg))
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let t := 0
  let offset := (BitVec.toNat off4)
  let esize := 8
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_LD1B_ZA_P_RRR__ 128 esize g m n offset s t vertical)
  | 256 => (execute_LD1B_ZA_P_RRR__ 256 esize g m n offset s t vertical)
  | 512 => (execute_LD1B_ZA_P_RRR__ 512 esize g m n offset s t vertical)
  | 1024 => (execute_LD1B_ZA_P_RRR__ 1024 esize g m n offset s t vertical)
  | 2048 => (execute_LD1B_ZA_P_RRR__ 2048 esize g m n offset s t vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, offset : Nat, s : Nat, t :
  Nat, k_vertical : Bool, t ∈ {0, 1} ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_ZA_P_RRR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (offset : Nat) (s : Nat) (t : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let addr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let moffs ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSME MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (n == 31)
    then
      (do
        bif ((← (AnyActiveElement mask esize)) || (← (ConstrainUnpredictableBool
                 Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let (addr, moffs, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (addr, moffs, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (addr, moffs, result) := loop_vars
      loop_vars ← do
        let addr : (BitVec 64) := (BitVec.addInt base ((BitVec.toNat moffs) *i mbytes))
        let result ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
          else
            (do
              (Elem_set result e esize (Zeros (n := esize)))) ) : SailM (BitVec VL) )
        let moffs : (BitVec 64) := (BitVec.addInt moffs 1)
        (pure (addr, moffs, result))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  (ZAslice_set t esize vertical slice_name VL result)

def decode_LD1H_ZA_P_RRR__ (msz : (BitVec 2)) (Rm : (BitVec 5)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (ZAt : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Pg))
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let t := (BitVec.toNat ZAt)
  let offset := (BitVec.toNat off3)
  let esize := 16
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_LD1H_ZA_P_RRR__ 128 esize g m n offset s t vertical)
  | 256 => (execute_LD1H_ZA_P_RRR__ 256 esize g m n offset s t vertical)
  | 512 => (execute_LD1H_ZA_P_RRR__ 512 esize g m n offset s t vertical)
  | 1024 => (execute_LD1H_ZA_P_RRR__ 1024 esize g m n offset s t vertical)
  | 2048 => (execute_LD1H_ZA_P_RRR__ 2048 esize g m n offset s t vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, offset : Nat, s : Nat, t :
  Nat, k_vertical : Bool, t ∈ {0, 1, 2, 3} ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_ZA_P_RRR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (offset : Nat) (s : Nat) (t : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let addr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let moffs ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSME MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (n == 31)
    then
      (do
        bif ((← (AnyActiveElement mask esize)) || (← (ConstrainUnpredictableBool
                 Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let (addr, moffs, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (addr, moffs, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (addr, moffs, result) := loop_vars
      loop_vars ← do
        let addr : (BitVec 64) := (BitVec.addInt base ((BitVec.toNat moffs) *i mbytes))
        let result ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
          else
            (do
              (Elem_set result e esize (Zeros (n := esize)))) ) : SailM (BitVec VL) )
        let moffs : (BitVec 64) := (BitVec.addInt moffs 1)
        (pure (addr, moffs, result))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  (ZAslice_set t esize vertical slice_name VL result)

def decode_LD1W_ZA_P_RRR__ (msz : (BitVec 2)) (Rm : (BitVec 5)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (ZAt : (BitVec 2)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Pg))
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let t := (BitVec.toNat ZAt)
  let offset := (BitVec.toNat off2)
  let esize := 32
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_LD1W_ZA_P_RRR__ 128 esize g m n offset s t vertical)
  | 256 => (execute_LD1W_ZA_P_RRR__ 256 esize g m n offset s t vertical)
  | 512 => (execute_LD1W_ZA_P_RRR__ 512 esize g m n offset s t vertical)
  | 1024 => (execute_LD1W_ZA_P_RRR__ 1024 esize g m n offset s t vertical)
  | 2048 => (execute_LD1W_ZA_P_RRR__ 2048 esize g m n offset s t vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, offset : Nat, s : Nat, t :
  Nat, k_vertical : Bool, t ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_ZA_P_RRR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (offset : Nat) (s : Nat) (t : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let addr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let moffs ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSME MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (n == 31)
    then
      (do
        bif ((← (AnyActiveElement mask esize)) || (← (ConstrainUnpredictableBool
                 Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let (addr, moffs, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (addr, moffs, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (addr, moffs, result) := loop_vars
      loop_vars ← do
        let addr : (BitVec 64) := (BitVec.addInt base ((BitVec.toNat moffs) *i mbytes))
        let result ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
          else
            (do
              (Elem_set result e esize (Zeros (n := esize)))) ) : SailM (BitVec VL) )
        let moffs : (BitVec 64) := (BitVec.addInt moffs 1)
        (pure (addr, moffs, result))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  (ZAslice_set t esize vertical slice_name VL result)

def decode_LD1D_ZA_P_RRR__ (msz : (BitVec 2)) (Rm : (BitVec 5)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (ZAt : (BitVec 3)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Pg))
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let t := (BitVec.toNat ZAt)
  let offset := (BitVec.toNat o1)
  let esize := 64
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_LD1D_ZA_P_RRR__ 128 esize g m n offset s t vertical)
  | 256 => (execute_LD1D_ZA_P_RRR__ 256 esize g m n offset s t vertical)
  | 512 => (execute_LD1D_ZA_P_RRR__ 512 esize g m n offset s t vertical)
  | 1024 => (execute_LD1D_ZA_P_RRR__ 1024 esize g m n offset s t vertical)
  | 2048 => (execute_LD1D_ZA_P_RRR__ 2048 esize g m n offset s t vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, offset : Nat, s : Nat, t :
  Nat, k_vertical : Bool, 0 ≤ t ∧
  t ≤ 15 ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD1Q_ZA_P_RRR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (offset : Nat) (s : Nat) (t : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let addr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let moffs ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSME MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (n == 31)
    then
      (do
        bif ((← (AnyActiveElement mask esize)) || (← (ConstrainUnpredictableBool
                 Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let (addr, moffs, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (addr, moffs, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (addr, moffs, result) := loop_vars
      loop_vars ← do
        let addr : (BitVec 64) := (BitVec.addInt base ((BitVec.toNat moffs) *i mbytes))
        let result ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
          else
            (do
              (Elem_set result e esize (Zeros (n := esize)))) ) : SailM (BitVec VL) )
        let moffs : (BitVec 64) := (BitVec.addInt moffs 1)
        (pure (addr, moffs, result))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  (ZAslice_set t esize vertical slice_name VL result)

def decode_LD1Q_ZA_P_RRR__ (Rm : (BitVec 5)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (ZAt : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Pg))
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let t := (BitVec.toNat ZAt)
  let offset := 0
  let esize := 128
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_LD1Q_ZA_P_RRR__ 128 esize g m n offset s t vertical)
  | 256 => (execute_LD1Q_ZA_P_RRR__ 256 esize g m n offset s t vertical)
  | 512 => (execute_LD1Q_ZA_P_RRR__ 512 esize g m n offset s t vertical)
  | 1024 => (execute_LD1Q_ZA_P_RRR__ 1024 esize g m n offset s t vertical)
  | 2048 => (execute_LD1Q_ZA_P_RRR__ 2048 esize g m n offset s t vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, offset : Nat, s : Nat, t :
  Nat, k_vertical : Bool, t = 0 ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST1B_ZA_P_RRR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (offset : Nat) (s : Nat) (t : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let addr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let moffs ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSME MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (n == 31)
    then
      (do
        bif ((← (AnyActiveElement mask esize)) || (← (ConstrainUnpredictableBool
                 Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do (ZAslice_read t esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let (addr, moffs) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (addr, moffs)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (addr, moffs) := loop_vars
      loop_vars ← do
        let addr : (BitVec 64) := (BitVec.addInt base ((BitVec.toNat moffs) *i mbytes))
        bif (← (ActivePredicateElement mask e esize))
        then (Mem_set addr mbytes accdesc (← (Elem_read src e esize)))
        else (pure ())
        let moffs : (BitVec 64) := (BitVec.addInt moffs 1)
        (pure (addr, moffs))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_ST1B_ZA_P_RRR__ (msz : (BitVec 2)) (Rm : (BitVec 5)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (off4 : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Pg))
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let t := 0
  let offset := (BitVec.toNat off4)
  let esize := 8
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_ST1B_ZA_P_RRR__ 128 esize g m n offset s t vertical)
  | 256 => (execute_ST1B_ZA_P_RRR__ 256 esize g m n offset s t vertical)
  | 512 => (execute_ST1B_ZA_P_RRR__ 512 esize g m n offset s t vertical)
  | 1024 => (execute_ST1B_ZA_P_RRR__ 1024 esize g m n offset s t vertical)
  | 2048 => (execute_ST1B_ZA_P_RRR__ 2048 esize g m n offset s t vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, offset : Nat, s : Nat, t :
  Nat, k_vertical : Bool, t ∈ {0, 1} ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST1H_ZA_P_RRR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (offset : Nat) (s : Nat) (t : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let addr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let moffs ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSME MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (n == 31)
    then
      (do
        bif ((← (AnyActiveElement mask esize)) || (← (ConstrainUnpredictableBool
                 Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do (ZAslice_read t esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let (addr, moffs) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (addr, moffs)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (addr, moffs) := loop_vars
      loop_vars ← do
        let addr : (BitVec 64) := (BitVec.addInt base ((BitVec.toNat moffs) *i mbytes))
        bif (← (ActivePredicateElement mask e esize))
        then (Mem_set addr mbytes accdesc (← (Elem_read src e esize)))
        else (pure ())
        let moffs : (BitVec 64) := (BitVec.addInt moffs 1)
        (pure (addr, moffs))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_ST1H_ZA_P_RRR__ (msz : (BitVec 2)) (Rm : (BitVec 5)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (ZAt : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Pg))
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let t := (BitVec.toNat ZAt)
  let offset := (BitVec.toNat off3)
  let esize := 16
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_ST1H_ZA_P_RRR__ 128 esize g m n offset s t vertical)
  | 256 => (execute_ST1H_ZA_P_RRR__ 256 esize g m n offset s t vertical)
  | 512 => (execute_ST1H_ZA_P_RRR__ 512 esize g m n offset s t vertical)
  | 1024 => (execute_ST1H_ZA_P_RRR__ 1024 esize g m n offset s t vertical)
  | 2048 => (execute_ST1H_ZA_P_RRR__ 2048 esize g m n offset s t vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, offset : Nat, s : Nat, t :
  Nat, k_vertical : Bool, t ∈ {0, 1, 2, 3} ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_ZA_P_RRR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (offset : Nat) (s : Nat) (t : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let addr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let moffs ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSME MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (n == 31)
    then
      (do
        bif ((← (AnyActiveElement mask esize)) || (← (ConstrainUnpredictableBool
                 Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do (ZAslice_read t esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let (addr, moffs) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (addr, moffs)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (addr, moffs) := loop_vars
      loop_vars ← do
        let addr : (BitVec 64) := (BitVec.addInt base ((BitVec.toNat moffs) *i mbytes))
        bif (← (ActivePredicateElement mask e esize))
        then (Mem_set addr mbytes accdesc (← (Elem_read src e esize)))
        else (pure ())
        let moffs : (BitVec 64) := (BitVec.addInt moffs 1)
        (pure (addr, moffs))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_ST1W_ZA_P_RRR__ (msz : (BitVec 2)) (Rm : (BitVec 5)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (ZAt : (BitVec 2)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Pg))
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let t := (BitVec.toNat ZAt)
  let offset := (BitVec.toNat off2)
  let esize := 32
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_ST1W_ZA_P_RRR__ 128 esize g m n offset s t vertical)
  | 256 => (execute_ST1W_ZA_P_RRR__ 256 esize g m n offset s t vertical)
  | 512 => (execute_ST1W_ZA_P_RRR__ 512 esize g m n offset s t vertical)
  | 1024 => (execute_ST1W_ZA_P_RRR__ 1024 esize g m n offset s t vertical)
  | 2048 => (execute_ST1W_ZA_P_RRR__ 2048 esize g m n offset s t vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, offset : Nat, s : Nat, t :
  Nat, k_vertical : Bool, t ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_ZA_P_RRR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (offset : Nat) (s : Nat) (t : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let addr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let moffs ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSME MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (n == 31)
    then
      (do
        bif ((← (AnyActiveElement mask esize)) || (← (ConstrainUnpredictableBool
                 Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do (ZAslice_read t esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let (addr, moffs) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (addr, moffs)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (addr, moffs) := loop_vars
      loop_vars ← do
        let addr : (BitVec 64) := (BitVec.addInt base ((BitVec.toNat moffs) *i mbytes))
        bif (← (ActivePredicateElement mask e esize))
        then (Mem_set addr mbytes accdesc (← (Elem_read src e esize)))
        else (pure ())
        let moffs : (BitVec 64) := (BitVec.addInt moffs 1)
        (pure (addr, moffs))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_ST1D_ZA_P_RRR__ (msz : (BitVec 2)) (Rm : (BitVec 5)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (ZAt : (BitVec 3)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Pg))
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let t := (BitVec.toNat ZAt)
  let offset := (BitVec.toNat o1)
  let esize := 64
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_ST1D_ZA_P_RRR__ 128 esize g m n offset s t vertical)
  | 256 => (execute_ST1D_ZA_P_RRR__ 256 esize g m n offset s t vertical)
  | 512 => (execute_ST1D_ZA_P_RRR__ 512 esize g m n offset s t vertical)
  | 1024 => (execute_ST1D_ZA_P_RRR__ 1024 esize g m n offset s t vertical)
  | 2048 => (execute_ST1D_ZA_P_RRR__ 2048 esize g m n offset s t vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, offset : Nat, s : Nat, t :
  Nat, k_vertical : Bool, 0 ≤ t ∧
  t ≤ 15 ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST1Q_ZA_P_RRR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (offset : Nat) (s : Nat) (t : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let addr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let moffs ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSME MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (n == 31)
    then
      (do
        bif ((← (AnyActiveElement mask esize)) || (← (ConstrainUnpredictableBool
                 Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do (ZAslice_read t esize vertical slice_name VL) ) : SailM (BitVec VL) )
  let (addr, moffs) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (dim -i 1)
    let mut loop_vars := (addr, moffs)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (addr, moffs) := loop_vars
      loop_vars ← do
        let addr : (BitVec 64) := (BitVec.addInt base ((BitVec.toNat moffs) *i mbytes))
        bif (← (ActivePredicateElement mask e esize))
        then (Mem_set addr mbytes accdesc (← (Elem_read src e esize)))
        else (pure ())
        let moffs : (BitVec 64) := (BitVec.addInt moffs 1)
        (pure (addr, moffs))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_ST1Q_ZA_P_RRR__ (Rm : (BitVec 5)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (ZAt : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Pg))
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let t := (BitVec.toNat ZAt)
  let offset := 0
  let esize := 128
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_ST1Q_ZA_P_RRR__ 128 esize g m n offset s t vertical)
  | 256 => (execute_ST1Q_ZA_P_RRR__ 256 esize g m n offset s t vertical)
  | 512 => (execute_ST1Q_ZA_P_RRR__ 512 esize g m n offset s t vertical)
  | 1024 => (execute_ST1Q_ZA_P_RRR__ 1024 esize g m n offset s t vertical)
  | 2048 => (execute_ST1Q_ZA_P_RRR__ 2048 esize g m n offset s t vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_ADDHA_ZA_PP_Z_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand_src ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand_acc ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize)
    )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_col_lower := 0
    let loop_col_upper := (dim -i 1)
    let mut loop_vars := result
    for col in [loop_col_lower:loop_col_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand_src col esize) ) : SailM (BitVec esize) )
        let loop_row_lower := 0
        let loop_row_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for row in [loop_row_lower:loop_row_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let res ← (( do (Elem_read operand_acc ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            let res ← (( do
              bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                       mask2 col esize)))
              then (pure (res + element))
              else (pure res) ) : SailM (BitVec esize) )
            (Elem_set result ((row *i dim) +i col) esize res)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_ADDHA_ZA_PP_Z_32 (V : (BitVec 1)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let da := (BitVec.toNat ZAda)
  match VL with
  | 128 => (execute_ADDHA_ZA_PP_Z_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize) a
      b da esize n)
  | 256 => (execute_ADDHA_ZA_PP_Z_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize) a
      b da esize n)
  | 512 => (execute_ADDHA_ZA_PP_Z_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize) a
      b da esize n)
  | 1024 => (execute_ADDHA_ZA_PP_Z_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize n)
  | 2048 => (execute_ADDHA_ZA_PP_Z_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_ADDHA_ZA_PP_Z_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand_src ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand_acc ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize)
    )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_col_lower := 0
    let loop_col_upper := (dim -i 1)
    let mut loop_vars := result
    for col in [loop_col_lower:loop_col_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand_src col esize) ) : SailM (BitVec esize) )
        let loop_row_lower := 0
        let loop_row_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for row in [loop_row_lower:loop_row_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let res ← (( do (Elem_read operand_acc ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            let res ← (( do
              bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                       mask2 col esize)))
              then (pure (res + element))
              else (pure res) ) : SailM (BitVec esize) )
            (Elem_set result ((row *i dim) +i col) esize res)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_ADDHA_ZA_PP_Z_64 (V : (BitVec 1)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEI16I64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let da := (BitVec.toNat ZAda)
  match VL with
  | 128 => (execute_ADDHA_ZA_PP_Z_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize) a
      b da esize n)
  | 256 => (execute_ADDHA_ZA_PP_Z_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize) a
      b da esize n)
  | 512 => (execute_ADDHA_ZA_PP_Z_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize) a
      b da esize n)
  | 1024 => (execute_ADDHA_ZA_PP_Z_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize n)
  | 2048 => (execute_ADDHA_ZA_PP_Z_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_ADDVA_ZA_PP_Z_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand_src ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand_acc ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize)
    )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand_src row esize) ) : SailM (BitVec esize) )
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let res ← (( do (Elem_read operand_acc ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            let res ← (( do
              bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                       mask2 col esize)))
              then (pure (res + element))
              else (pure res) ) : SailM (BitVec esize) )
            (Elem_set result ((row *i dim) +i col) esize res)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_ADDVA_ZA_PP_Z_32 (V : (BitVec 1)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let da := (BitVec.toNat ZAda)
  match VL with
  | 128 => (execute_ADDVA_ZA_PP_Z_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize) a
      b da esize n)
  | 256 => (execute_ADDVA_ZA_PP_Z_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize) a
      b da esize n)
  | 512 => (execute_ADDVA_ZA_PP_Z_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize) a
      b da esize n)
  | 1024 => (execute_ADDVA_ZA_PP_Z_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize n)
  | 2048 => (execute_ADDVA_ZA_PP_Z_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize = 64 ∧
  da ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_ADDVA_ZA_PP_Z_64 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand_src ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand_acc ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize)
    )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand_src row esize) ) : SailM (BitVec esize) )
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let res ← (( do (Elem_read operand_acc ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            let res ← (( do
              bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                       mask2 col esize)))
              then (pure (res + element))
              else (pure res) ) : SailM (BitVec esize) )
            (Elem_set result ((row *i dim) +i col) esize res)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_ADDVA_ZA_PP_Z_64 (V : (BitVec 1)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (ZAda : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEI16I64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let da := (BitVec.toNat ZAda)
  match VL with
  | 128 => (execute_ADDVA_ZA_PP_Z_64 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize) a
      b da esize n)
  | 256 => (execute_ADDVA_ZA_PP_Z_64 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize) a
      b da esize n)
  | 512 => (execute_ADDVA_ZA_PP_Z_64 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize) a
      b da esize n)
  | 1024 => (execute_ADDVA_ZA_PP_Z_64 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize n)
  | 2048 => (execute_ADDVA_ZA_PP_Z_64 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize n)
  | _ => (pure ())

/-- Type quantifiers: SVL : Nat, dim_dim_esize : Nat, esize : Nat, esize = 64 ∧
  is_VL(SVL) ∧ dim_dim_esize = (SVL / esize * (SVL / esize * esize)) -/
def execute_ZERO_ZA_I__ (SVL : Nat) (dim_dim_esize : Nat) (esize : Nat) (mask : (BitVec 8)) : SailM Unit := do
  (CheckSMEAndZAEnabled ())
  let SVL := SVL
  let dim := (Int.ediv SVL esize)
  let result : (BitVec dim_dim_esize) := (Zeros (n := dim_dim_esize))
  bif ((← (HaveTME ())) && ((← readReg TSTATE).depth >b 0))
  then (FailTransaction TMFailure_ERR false)
  else (pure ())
  let loop_i_lower := 0
  let loop_i_upper := 7
  let mut loop_vars := ()
  for i in [loop_i_lower:loop_i_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif ((BitVec.join1 [(BitVec.access mask i)]) == (0b1 : (BitVec 1)))
      then (ZAtile_set SVL i esize dim_dim_esize result)
      else (pure ())
  (pure loop_vars)

def decode_ZERO_ZA_I__ (imm8 : (BitVec 8)) : SailM Unit := do
  let SVL ← do (CurrentSVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let mask : (BitVec 8) := imm8
  let esize := 64
  match SVL with
  | 128 => (execute_ZERO_ZA_I__ 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize) esize
      mask)
  | 256 => (execute_ZERO_ZA_I__ 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize) esize
      mask)
  | 512 => (execute_ZERO_ZA_I__ 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize) esize
      mask)
  | 1024 => (execute_ZERO_ZA_I__ 1024 (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize)
      esize mask)
  | 2048 => (execute_ZERO_ZA_I__ 2048 (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize)
      esize mask)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧ nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize = 8 ∧ d = 0 ∧ is_VL(VL) -/
def execute_MOVA_ZA2_Z_B1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
      (ZAslice_set d esize vertical (slice_name +i r) VL result)
  (pure loop_vars)

def decode_MOVA_ZA2_Z_B1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Zn : (BitVec 4)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 8
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := 0
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA2_Z_B1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_ZA2_Z_B1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_ZA2_Z_B1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_ZA2_Z_B1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_ZA2_Z_B1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize = 16 ∧ d ∈ {0, 1} ∧ is_VL(VL) -/
def execute_MOVA_ZA2_Z_H1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
      (ZAslice_set d esize vertical (slice_name +i r) VL result)
  (pure loop_vars)

def decode_MOVA_ZA2_Z_H1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Zn : (BitVec 4)) (ZAd : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat ZAd)
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA2_Z_H1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_ZA2_Z_H1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_ZA2_Z_H1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_ZA2_Z_H1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_ZA2_Z_H1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize = 32 ∧ d ∈ {0, 1, 2, 3} ∧ is_VL(VL) -/
def execute_MOVA_ZA2_Z_W1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
      (ZAslice_set d esize vertical (slice_name +i r) VL result)
  (pure loop_vars)

def decode_MOVA_ZA2_Z_W1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Zn : (BitVec 4)) (ZAd : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat ZAd)
  let offset := (BitVec.toNat (o1 ++ (0b0 : (BitVec 1))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA2_Z_W1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_ZA2_Z_W1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_ZA2_Z_W1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_ZA2_Z_W1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_ZA2_Z_W1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize = 64 ∧ d ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_MOVA_ZA2_Z_D1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
      (ZAslice_set d esize vertical (slice_name +i r) VL result)
  (pure loop_vars)

def decode_MOVA_ZA2_Z_D1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Zn : (BitVec 4)) (ZAd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat ZAd)
  let offset := 0
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA2_Z_D1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_ZA2_Z_D1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_ZA2_Z_D1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_ZA2_Z_D1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_ZA2_Z_D1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧ nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize = 8 ∧ d = 0 ∧ is_VL(VL) -/
def execute_MOVA_ZA4_Z_B1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
      (ZAslice_set d esize vertical (slice_name +i r) VL result)
  (pure loop_vars)

def decode_MOVA_ZA4_Z_B1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Zn : (BitVec 3)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 8
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := 0
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA4_Z_B1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_ZA4_Z_B1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_ZA4_Z_B1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_ZA4_Z_B1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_ZA4_Z_B1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize = 16 ∧ d ∈ {0, 1} ∧ is_VL(VL) -/
def execute_MOVA_ZA4_Z_H1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
      (ZAslice_set d esize vertical (slice_name +i r) VL result)
  (pure loop_vars)

def decode_MOVA_ZA4_Z_H1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Zn : (BitVec 3)) (ZAd : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat ZAd)
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA4_Z_H1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_ZA4_Z_H1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_ZA4_Z_H1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_ZA4_Z_H1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_ZA4_Z_H1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize = 32 ∧ d ∈ {0, 1, 2, 3} ∧ is_VL(VL) -/
def execute_MOVA_ZA4_Z_W1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
      (ZAslice_set d esize vertical (slice_name +i r) VL result)
  (pure loop_vars)

def decode_MOVA_ZA4_Z_W1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Zn : (BitVec 3)) (ZAd : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat ZAd)
  let offset := 0
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA4_Z_W1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_ZA4_Z_W1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_ZA4_Z_W1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_ZA4_Z_W1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_ZA4_Z_W1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize = 64 ∧ d ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_MOVA_ZA4_Z_D1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  bif (((nreg == 4) && (esize == 64)) && (VL == 128))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
      (ZAslice_set d esize vertical (slice_name +i r) VL result)
  (pure loop_vars)

def decode_MOVA_ZA4_Z_D1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (Zn : (BitVec 3)) (ZAd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat ZAd)
  let offset := 0
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_ZA4_Z_D1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_ZA4_Z_D1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_ZA4_Z_D1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_ZA4_Z_D1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_ZA4_Z_D1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_ZA_MZ2_1 (VL : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let result ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_MOVA_ZA_MZ2_1 (Rv : (BitVec 2)) (Zn : (BitVec 4)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat off3)
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_MOVA_ZA_MZ2_1 128 n nreg offset v)
  | 256 => (execute_MOVA_ZA_MZ2_1 256 n nreg offset v)
  | 512 => (execute_MOVA_ZA_MZ2_1 512 n nreg offset v)
  | 1024 => (execute_MOVA_ZA_MZ2_1 1024 n nreg offset v)
  | 2048 => (execute_MOVA_ZA_MZ2_1 2048 n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_ZA_MZ4_1 (VL : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let result ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_MOVA_ZA_MZ4_1 (Rv : (BitVec 2)) (Zn : (BitVec 3)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat off3)
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_MOVA_ZA_MZ4_1 128 n nreg offset v)
  | 256 => (execute_MOVA_ZA_MZ4_1 256 n nreg offset v)
  | 512 => (execute_MOVA_ZA_MZ4_1 512 n nreg offset v)
  | 1024 => (execute_MOVA_ZA_MZ4_1 1024 n nreg offset v)
  | 2048 => (execute_MOVA_ZA_MZ4_1 2048 n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧ nreg = 2 ∧ n = 0 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_MZ2_ZA_B1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVA_MZ2_ZA_B1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (off3 : (BitVec 3)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 8
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let n := 0
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_MZ2_ZA_B1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_MZ2_ZA_B1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_MZ2_ZA_B1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_MZ2_ZA_B1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_MZ2_ZA_B1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ n ∈ {0, 1} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_MZ2_ZA_H1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVA_MZ2_ZA_H1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 1)) (off2 : (BitVec 2)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 16
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_MZ2_ZA_H1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_MZ2_ZA_H1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_MZ2_ZA_H1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_MZ2_ZA_H1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_MZ2_ZA_H1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3} ∧
  nreg = 2 ∧ n ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_MZ2_ZA_W1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVA_MZ2_ZA_W1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 2)) (o1 : (BitVec 1)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 32
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat (o1 ++ (0b0 : (BitVec 1))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_MZ2_ZA_W1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_MZ2_ZA_W1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_MZ2_ZA_W1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_MZ2_ZA_W1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_MZ2_ZA_W1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  nreg = 2 ∧ n ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_MZ2_ZA_D1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVA_MZ2_ZA_D1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 3)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 64
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let n := (BitVec.toNat ZAn)
  let offset := 0
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_MZ2_ZA_D1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_MZ2_ZA_D1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_MZ2_ZA_D1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_MZ2_ZA_D1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_MZ2_ZA_D1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧ nreg = 4 ∧ n = 0 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_MZ4_ZA_B1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVA_MZ4_ZA_B1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (off2 : (BitVec 2)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 8
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let n := 0
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_MZ4_ZA_B1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_MZ4_ZA_B1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_MZ4_ZA_B1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_MZ4_ZA_B1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_MZ4_ZA_B1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ n ∈ {0, 1} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_MZ4_ZA_H1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVA_MZ4_ZA_H1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 1)) (o1 : (BitVec 1)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 16
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_MZ4_ZA_H1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_MZ4_ZA_H1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_MZ4_ZA_H1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_MZ4_ZA_H1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_MZ4_ZA_H1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  nreg = 4 ∧ n ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_MZ4_ZA_W1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVA_MZ4_ZA_W1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 2)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 32
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let n := (BitVec.toNat ZAn)
  let offset := 0
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_MZ4_ZA_W1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_MZ4_ZA_W1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_MZ4_ZA_W1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_MZ4_ZA_W1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_MZ4_ZA_W1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  nreg = 4 ∧ n ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_MZ4_ZA_D1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  bif (((nreg == 4) && (esize == 64)) && (VL == 128))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVA_MZ4_ZA_D1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 64
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let n := (BitVec.toNat ZAn)
  let offset := 0
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVA_MZ4_ZA_D1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVA_MZ4_ZA_D1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVA_MZ4_ZA_D1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVA_MZ4_ZA_D1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVA_MZ4_ZA_D1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nreg = 2 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_MZ_ZA2_1 (VL : Nat) (d : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let result ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        (Z_set (d +i r) VL result)
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_MOVA_MZ_ZA2_1 (Rv : (BitVec 2)) (off3 : (BitVec 3)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat off3)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_MOVA_MZ_ZA2_1 128 d nreg offset v)
  | 256 => (execute_MOVA_MZ_ZA2_1 256 d nreg offset v)
  | 512 => (execute_MOVA_MZ_ZA2_1 512 d nreg offset v)
  | 1024 => (execute_MOVA_MZ_ZA2_1 1024 d nreg offset v)
  | 2048 => (execute_MOVA_MZ_ZA2_1 2048 d nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nreg = 4 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVA_MZ_ZA4_1 (VL : Nat) (d : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let result ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        (Z_set (d +i r) VL result)
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_MOVA_MZ_ZA4_1 (Rv : (BitVec 2)) (off3 : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat off3)
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_MOVA_MZ_ZA4_1 128 d nreg offset v)
  | 256 => (execute_MOVA_MZ_ZA4_1 256 d nreg offset v)
  | 512 => (execute_MOVA_MZ_ZA4_1 512 d nreg offset v)
  | 1024 => (execute_MOVA_MZ_ZA4_1 1024 d nreg offset v)
  | 2048 => (execute_MOVA_MZ_ZA4_1 2048 d nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1B_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 8
  match VL with
  | 128 => (execute_LD1B_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_LD1B_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_LD1B_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_LD1B_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LD1B_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1H_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 16
  match VL with
  | 128 => (execute_LD1H_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_LD1H_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_LD1H_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_LD1H_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LD1H_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1W_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 32
  match VL with
  | 128 => (execute_LD1W_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_LD1W_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_LD1W_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_LD1W_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LD1W_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1D_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 64
  match VL with
  | 128 => (execute_LD1D_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_LD1D_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_LD1D_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_LD1D_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LD1D_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1B_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 8
  match VL with
  | 128 => (execute_LD1B_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_LD1B_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_LD1B_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_LD1B_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LD1B_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1H_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 16
  match VL with
  | 128 => (execute_LD1H_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_LD1H_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_LD1H_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_LD1H_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LD1H_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1W_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 32
  match VL with
  | 128 => (execute_LD1W_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_LD1W_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_LD1W_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_LD1W_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LD1W_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1D_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 64
  match VL with
  | 128 => (execute_LD1D_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_LD1D_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_LD1D_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_LD1D_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LD1D_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNT1B_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1B_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 8
  match VL with
  | 128 => (execute_LDNT1B_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_LDNT1B_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_LDNT1B_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_LDNT1B_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LDNT1B_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNT1H_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1H_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 16
  match VL with
  | 128 => (execute_LDNT1H_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_LDNT1H_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_LDNT1H_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_LDNT1H_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LDNT1H_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1W_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 32
  match VL with
  | 128 => (execute_LDNT1W_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_LDNT1W_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_LDNT1W_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_LDNT1W_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LDNT1W_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1D_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 64
  match VL with
  | 128 => (execute_LDNT1D_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_LDNT1D_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_LDNT1D_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_LDNT1D_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LDNT1D_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNT1B_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1B_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 8
  match VL with
  | 128 => (execute_LDNT1B_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_LDNT1B_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_LDNT1B_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_LDNT1B_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LDNT1B_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNT1H_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1H_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 16
  match VL with
  | 128 => (execute_LDNT1H_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_LDNT1H_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_LDNT1H_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_LDNT1H_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LDNT1H_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1W_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 32
  match VL with
  | 128 => (execute_LDNT1W_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_LDNT1W_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_LDNT1W_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_LDNT1W_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LDNT1W_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1D_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 64
  match VL with
  | 128 => (execute_LDNT1D_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_LDNT1D_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_LDNT1D_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_LDNT1D_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_LDNT1D_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST1B_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1B_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 8
  match VL with
  | 128 => (execute_ST1B_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_ST1B_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_ST1B_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_ST1B_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_ST1B_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST1H_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1H_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 16
  match VL with
  | 128 => (execute_ST1H_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_ST1H_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_ST1H_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_ST1H_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_ST1H_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1W_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 32
  match VL with
  | 128 => (execute_ST1W_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_ST1W_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_ST1W_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_ST1W_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_ST1W_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1D_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 64
  match VL with
  | 128 => (execute_ST1D_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_ST1D_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_ST1D_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_ST1D_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_ST1D_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST1B_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1B_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 8
  match VL with
  | 128 => (execute_ST1B_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_ST1B_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_ST1B_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_ST1B_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_ST1B_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST1H_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1H_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 16
  match VL with
  | 128 => (execute_ST1H_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_ST1H_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_ST1H_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_ST1H_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_ST1H_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1W_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 32
  match VL with
  | 128 => (execute_ST1W_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_ST1W_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_ST1W_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_ST1W_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_ST1W_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1D_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 64
  match VL with
  | 128 => (execute_ST1D_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_ST1D_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_ST1D_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_ST1D_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_ST1D_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_STNT1B_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1B_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 8
  match VL with
  | 128 => (execute_STNT1B_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_STNT1B_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_STNT1B_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_STNT1B_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_STNT1B_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_STNT1H_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1H_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 16
  match VL with
  | 128 => (execute_STNT1H_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_STNT1H_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_STNT1H_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_STNT1H_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_STNT1H_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1W_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 32
  match VL with
  | 128 => (execute_STNT1W_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_STNT1W_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_STNT1W_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_STNT1W_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_STNT1W_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_MZx_P_BR_2x8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1D_MZx_P_BR_2x8 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 64
  match VL with
  | 128 => (execute_STNT1D_MZx_P_BR_2x8 128 esize g m n nreg t tstride)
  | 256 => (execute_STNT1D_MZx_P_BR_2x8 256 esize g m n nreg t tstride)
  | 512 => (execute_STNT1D_MZx_P_BR_2x8 512 esize g m n nreg t tstride)
  | 1024 => (execute_STNT1D_MZx_P_BR_2x8 1024 esize g m n nreg t tstride)
  | 2048 => (execute_STNT1D_MZx_P_BR_2x8 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_STNT1B_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1B_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 8
  match VL with
  | 128 => (execute_STNT1B_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_STNT1B_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_STNT1B_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_STNT1B_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_STNT1B_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_STNT1H_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1H_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 16
  match VL with
  | 128 => (execute_STNT1H_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_STNT1H_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_STNT1H_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_STNT1H_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_STNT1H_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1W_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 32
  match VL with
  | 128 => (execute_STNT1W_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_STNT1W_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_STNT1W_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_STNT1W_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_STNT1W_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t__arg : Nat, tstride
  : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_MZx_P_BR_4x4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (n == 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1D_MZx_P_BR_4x4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 64
  match VL with
  | 128 => (execute_STNT1D_MZx_P_BR_4x4 128 esize g m n nreg t tstride)
  | 256 => (execute_STNT1D_MZx_P_BR_4x4 256 esize g m n nreg t tstride)
  | 512 => (execute_STNT1D_MZx_P_BR_4x4 512 esize g m n nreg t tstride)
  | 1024 => (execute_STNT1D_MZx_P_BR_4x4 1024 esize g m n nreg t tstride)
  | 2048 => (execute_STNT1D_MZx_P_BR_4x4 2048 esize g m n nreg t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1B_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1B_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_LD1B_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_LD1B_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LD1B_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LD1B_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1H_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1H_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_LD1H_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_LD1H_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LD1H_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LD1H_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1W_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1W_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_LD1W_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_LD1W_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LD1W_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LD1W_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1D_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1D_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_LD1D_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_LD1D_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LD1D_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LD1D_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNT1B_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1B_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1B_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_LDNT1B_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_LDNT1B_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LDNT1B_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LDNT1B_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNT1H_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1H_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1H_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_LDNT1H_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_LDNT1H_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LDNT1H_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LDNT1H_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1W_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1W_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_LDNT1W_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_LDNT1W_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LDNT1W_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LDNT1W_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1D_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1D_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_LDNT1D_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_LDNT1D_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LDNT1D_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LDNT1D_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1B_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1B_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_LD1B_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_LD1B_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LD1B_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LD1B_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1H_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1H_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_LD1H_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_LD1H_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LD1H_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LD1H_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1W_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1W_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_LD1W_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_LD1W_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LD1W_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LD1W_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LD1D_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1D_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_LD1D_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_LD1D_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LD1D_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LD1D_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNT1B_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1B_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1B_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_LDNT1B_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_LDNT1B_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LDNT1B_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LDNT1B_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNT1H_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1H_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1H_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_LDNT1H_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_LDNT1H_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LDNT1H_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LDNT1H_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1W_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1W_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_LDNT1W_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_LDNT1W_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LDNT1W_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LDNT1W_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let t ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars_2 := t
    for r in [loop_r_lower:loop_r_upper:1]i do
      let t := loop_vars_2
      loop_vars_2 ← do
        (Z_set t VL (GetElem?.getElem! values_name r))
        (pure (t +i tstride))
    (pure loop_vars_2) ) : SailM Int )
  (pure ())

def decode_LDNT1D_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1D_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_LDNT1D_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_LDNT1D_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_LDNT1D_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_LDNT1D_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST1B_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1B_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1B_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_ST1B_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_ST1B_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_ST1B_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_ST1B_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST1H_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1H_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1H_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_ST1H_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_ST1H_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_ST1H_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_ST1H_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1W_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1W_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_ST1W_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_ST1W_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_ST1W_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_ST1W_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1D_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1D_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_ST1D_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_ST1D_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_ST1D_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_ST1D_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST1B_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1B_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1B_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_ST1B_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_ST1B_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_ST1B_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_ST1B_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST1H_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1H_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1H_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_ST1H_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_ST1H_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_ST1H_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_ST1H_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1W_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1W_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_ST1W_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_ST1W_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_ST1W_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_ST1W_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ST1D_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1D_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_ST1D_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_ST1D_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_ST1D_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_ST1D_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_STNT1B_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1B_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1B_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_STNT1B_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_STNT1B_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_STNT1B_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_STNT1B_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_STNT1H_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1H_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1H_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_STNT1H_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_STNT1H_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_STNT1H_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_STNT1H_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1W_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1W_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_STNT1W_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_STNT1W_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_STNT1W_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_STNT1W_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 8 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_MZx_P_BI_2x8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1D_MZx_P_BI_2x8 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let tstride := 8
  let t := (BitVec.toNat ((T ++ (0b0 : (BitVec 1))) ++ Zt))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1D_MZx_P_BI_2x8 128 esize g n nreg offset t tstride)
  | 256 => (execute_STNT1D_MZx_P_BI_2x8 256 esize g n nreg offset t tstride)
  | 512 => (execute_STNT1D_MZx_P_BI_2x8 512 esize g n nreg offset t tstride)
  | 1024 => (execute_STNT1D_MZx_P_BI_2x8 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_STNT1D_MZx_P_BI_2x8 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_STNT1B_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1B_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1B_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_STNT1B_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_STNT1B_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_STNT1B_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_STNT1B_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_STNT1H_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1H_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1H_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_STNT1H_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_STNT1H_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_STNT1H_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_STNT1H_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1W_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1W_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_STNT1W_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_STNT1W_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_STNT1W_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_STNT1W_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t__arg :
  Nat, tstride : Nat, tstride = 4 ∧
  0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_MZx_P_BI_4x4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t__arg : Nat) (tstride : Nat) : SailM Unit := do
  let t : Int := t__arg
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (! (← (AnyActiveElement mask esize)))
    then
      (do
        bif ((n == 31) && (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (n == 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (n == 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (src, t) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (src, t)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (src, t) := loop_vars
      loop_vars ← do
        let src ← (Z_read t VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        let t : Int := (t +i tstride)
        (pure (src, t))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_STNT1D_MZx_P_BI_4x4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (T : (BitVec 1)) (N : (BitVec 1)) (Zt : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let tstride := 4
  let t := (BitVec.toNat ((T ++ (0b00 : (BitVec 2))) ++ Zt))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1D_MZx_P_BI_4x4 128 esize g n nreg offset t tstride)
  | 256 => (execute_STNT1D_MZx_P_BI_4x4 256 esize g n nreg offset t tstride)
  | 512 => (execute_STNT1D_MZx_P_BI_4x4 512 esize g n nreg offset t tstride)
  | 1024 => (execute_STNT1D_MZx_P_BI_4x4 1024 esize g n nreg offset t tstride)
  | 2048 => (execute_STNT1D_MZx_P_BI_4x4 2048 esize g n nreg offset t tstride)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FADD_ZA_ZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (← (FPAdd_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FADD_ZA_ZW_2x2 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_FADD_ZA_ZW_2x2 128 esize m nreg offset v)
  | 256 => (execute_FADD_ZA_ZW_2x2 256 esize m nreg offset v)
  | 512 => (execute_FADD_ZA_ZW_2x2 512 esize m nreg offset v)
  | 1024 => (execute_FADD_ZA_ZW_2x2 1024 esize m nreg offset v)
  | 2048 => (execute_FADD_ZA_ZW_2x2 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FSUB_ZA_ZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (← (FPSub_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FSUB_ZA_ZW_2x2 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_FSUB_ZA_ZW_2x2 128 esize m nreg offset v)
  | 256 => (execute_FSUB_ZA_ZW_2x2 256 esize m nreg offset v)
  | 512 => (execute_FSUB_ZA_ZW_2x2 512 esize m nreg offset v)
  | 1024 => (execute_FSUB_ZA_ZW_2x2 1024 esize m nreg offset v)
  | 2048 => (execute_FSUB_ZA_ZW_2x2 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FADD_ZA_ZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (← (FPAdd_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FADD_ZA_ZW_4x4 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_FADD_ZA_ZW_4x4 128 esize m nreg offset v)
  | 256 => (execute_FADD_ZA_ZW_4x4 256 esize m nreg offset v)
  | 512 => (execute_FADD_ZA_ZW_4x4 512 esize m nreg offset v)
  | 1024 => (execute_FADD_ZA_ZW_4x4 1024 esize m nreg offset v)
  | 2048 => (execute_FADD_ZA_ZW_4x4 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FSUB_ZA_ZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (← (FPSub_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FSUB_ZA_ZW_4x4 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_FSUB_ZA_ZW_4x4 128 esize m nreg offset v)
  | 256 => (execute_FSUB_ZA_ZW_4x4 256 esize m nreg offset v)
  | 512 => (execute_FSUB_ZA_ZW_4x4 512 esize m nreg offset v)
  | 1024 => (execute_FSUB_ZA_ZW_4x4 1024 esize m nreg offset v)
  | 2048 => (execute_FSUB_ZA_ZW_4x4 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZW_2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_FMLA_ZA_ZZW_2x2 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZW_2x2 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZW_2x2 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZW_2x2 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZW_2x2 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZW_2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_FMLS_ZA_ZZW_2x2 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZW_2x2 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZW_2x2 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZW_2x2 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZW_2x2 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZV_2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_FMLA_ZA_ZZV_2x1 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZV_2x1 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZV_2x1 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZV_2x1 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZV_2x1 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZV_2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_FMLS_ZA_ZZV_2x1 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZV_2x1 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZV_2x1 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZV_2x1 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZV_2x1 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZW_4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_FMLA_ZA_ZZW_4x4 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZW_4x4 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZW_4x4 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZW_4x4 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZW_4x4 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZW_4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_FMLS_ZA_ZZW_4x4 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZW_4x4 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZW_4x4 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZW_4x4 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZW_4x4 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZV_4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_FMLA_ZA_ZZV_4x1 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZV_4x1 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZV_4x1 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZV_4x1 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZV_4x1 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZV_4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_FMLS_ZA_ZZV_4x1 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZV_4x1 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZV_4x1 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZV_4x1 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZV_4x1 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_FMLA_ZA_ZZi_S2xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZi_S2xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZi_S2xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZi_S2xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZi_S2xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_FMLS_ZA_ZZi_S2xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZi_S2xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZi_S2xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZi_S2xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZi_S2xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZi_D2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZi_D2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i1 : (BitVec 1)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i1)
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_FMLA_ZA_ZZi_D2xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZi_D2xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZi_D2xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZi_D2xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZi_D2xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZi_D2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZi_D2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i1 : (BitVec 1)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i1)
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_FMLS_ZA_ZZi_D2xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZi_D2xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZi_D2xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZi_D2xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZi_D2xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_FMLA_ZA_ZZi_S4xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZi_S4xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZi_S4xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZi_S4xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZi_S4xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_FMLS_ZA_ZZi_S4xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZi_S4xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZi_S4xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZi_S4xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZi_S4xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZi_D4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZi_D4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i1 : (BitVec 1)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i1)
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_FMLA_ZA_ZZi_D4xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZi_D4xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZi_D4xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZi_D4xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZi_D4xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZi_D4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZi_D4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i1 : (BitVec 1)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEF64F64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i1)
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_FMLS_ZA_ZZi_D4xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZi_D4xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZi_D4xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZi_D4xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZi_D4xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFDOT_ZA_ZZW_2x2 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) :
                SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFDOT_ZA_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_BFDOT_ZA_ZZW_2x2 128 m n nreg offset v)
  | 256 => (execute_BFDOT_ZA_ZZW_2x2 256 m n nreg offset v)
  | 512 => (execute_BFDOT_ZA_ZZW_2x2 512 m n nreg offset v)
  | 1024 => (execute_BFDOT_ZA_ZZW_2x2 1024 m n nreg offset v)
  | 2048 => (execute_BFDOT_ZA_ZZW_2x2 2048 m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFDOT_ZA_ZZV_2x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) :
                SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFDOT_ZA_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_BFDOT_ZA_ZZV_2x1 128 m n nreg offset v)
  | 256 => (execute_BFDOT_ZA_ZZV_2x1 256 m n nreg offset v)
  | 512 => (execute_BFDOT_ZA_ZZV_2x1 512 m n nreg offset v)
  | 1024 => (execute_BFDOT_ZA_ZZV_2x1 1024 m n nreg offset v)
  | 2048 => (execute_BFDOT_ZA_ZZV_2x1 2048 m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FDOT_ZA_ZZW_2x2 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (FPDotAdd_ZA sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) )
                : SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FDOT_ZA_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_FDOT_ZA_ZZW_2x2 128 m n nreg offset v)
  | 256 => (execute_FDOT_ZA_ZZW_2x2 256 m n nreg offset v)
  | 512 => (execute_FDOT_ZA_ZZW_2x2 512 m n nreg offset v)
  | 1024 => (execute_FDOT_ZA_ZZW_2x2 1024 m n nreg offset v)
  | 2048 => (execute_FDOT_ZA_ZZW_2x2 2048 m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FDOT_ZA_ZZV_2x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (FPDotAdd_ZA sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) )
                : SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FDOT_ZA_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_FDOT_ZA_ZZV_2x1 128 m n nreg offset v)
  | 256 => (execute_FDOT_ZA_ZZV_2x1 256 m n nreg offset v)
  | 512 => (execute_FDOT_ZA_ZZV_2x1 512 m n nreg offset v)
  | 1024 => (execute_FDOT_ZA_ZZV_2x1 1024 m n nreg offset v)
  | 2048 => (execute_FDOT_ZA_ZZV_2x1 2048 m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFDOT_ZA_ZZW_4x4 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) :
                SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFDOT_ZA_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_BFDOT_ZA_ZZW_4x4 128 m n nreg offset v)
  | 256 => (execute_BFDOT_ZA_ZZW_4x4 256 m n nreg offset v)
  | 512 => (execute_BFDOT_ZA_ZZW_4x4 512 m n nreg offset v)
  | 1024 => (execute_BFDOT_ZA_ZZW_4x4 1024 m n nreg offset v)
  | 2048 => (execute_BFDOT_ZA_ZZW_4x4 2048 m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFDOT_ZA_ZZV_4x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) :
                SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFDOT_ZA_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_BFDOT_ZA_ZZV_4x1 128 m n nreg offset v)
  | 256 => (execute_BFDOT_ZA_ZZV_4x1 256 m n nreg offset v)
  | 512 => (execute_BFDOT_ZA_ZZV_4x1 512 m n nreg offset v)
  | 1024 => (execute_BFDOT_ZA_ZZV_4x1 1024 m n nreg offset v)
  | 2048 => (execute_BFDOT_ZA_ZZV_4x1 2048 m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FDOT_ZA_ZZW_4x4 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (FPDotAdd_ZA sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) )
                : SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FDOT_ZA_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_FDOT_ZA_ZZW_4x4 128 m n nreg offset v)
  | 256 => (execute_FDOT_ZA_ZZW_4x4 256 m n nreg offset v)
  | 512 => (execute_FDOT_ZA_ZZW_4x4 512 m n nreg offset v)
  | 1024 => (execute_FDOT_ZA_ZZW_4x4 1024 m n nreg offset v)
  | 2048 => (execute_FDOT_ZA_ZZW_4x4 2048 m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FDOT_ZA_ZZV_4x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (FPDotAdd_ZA sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) )
                : SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FDOT_ZA_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_FDOT_ZA_ZZV_4x1 128 m n nreg offset v)
  | 256 => (execute_FDOT_ZA_ZZV_4x1 256 m n nreg offset v)
  | 512 => (execute_FDOT_ZA_ZZV_4x1 512 m n nreg offset v)
  | 1024 => (execute_FDOT_ZA_ZZV_4x1 1024 m n nreg offset v)
  | 2048 => (execute_FDOT_ZA_ZZV_4x1 2048 m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ is_VL(VL) -/
def execute_BFDOT_ZA_ZZi_2xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let elt2_a ← (( do (Elem_read operand2 ((2 *i s) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i s) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) :
                SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFDOT_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 2
  match VL with
  | 128 => (execute_BFDOT_ZA_ZZi_2xi 128 index m n nreg offset v)
  | 256 => (execute_BFDOT_ZA_ZZi_2xi 256 index m n nreg offset v)
  | 512 => (execute_BFDOT_ZA_ZZi_2xi 512 index m n nreg offset v)
  | 1024 => (execute_BFDOT_ZA_ZZi_2xi 1024 index m n nreg offset v)
  | 2048 => (execute_BFDOT_ZA_ZZi_2xi 2048 index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ is_VL(VL) -/
def execute_BFDOT_ZA_ZZi_4xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let elt2_a ← (( do (Elem_read operand2 ((2 *i s) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i s) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) :
                SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFDOT_ZA_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 4
  match VL with
  | 128 => (execute_BFDOT_ZA_ZZi_4xi 128 index m n nreg offset v)
  | 256 => (execute_BFDOT_ZA_ZZi_4xi 256 index m n nreg offset v)
  | 512 => (execute_BFDOT_ZA_ZZi_4xi 512 index m n nreg offset v)
  | 1024 => (execute_BFDOT_ZA_ZZi_4xi 1024 index m n nreg offset v)
  | 2048 => (execute_BFDOT_ZA_ZZi_4xi 2048 index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ is_VL(VL) -/
def execute_FDOT_ZA_ZZi_2xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let elt2_a ← (( do (Elem_read operand2 ((2 *i s) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i s) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (FPDotAdd_ZA sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) )
                : SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FDOT_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 2
  match VL with
  | 128 => (execute_FDOT_ZA_ZZi_2xi 128 index m n nreg offset v)
  | 256 => (execute_FDOT_ZA_ZZi_2xi 256 index m n nreg offset v)
  | 512 => (execute_FDOT_ZA_ZZi_2xi 512 index m n nreg offset v)
  | 1024 => (execute_FDOT_ZA_ZZi_2xi 1024 index m n nreg offset v)
  | 2048 => (execute_FDOT_ZA_ZZi_2xi 2048 index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ is_VL(VL) -/
def execute_FDOT_ZA_ZZi_4xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let elt2_a ← (( do (Elem_read operand2 ((2 *i s) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i s) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (FPDotAdd_ZA sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) )
                : SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FDOT_ZA_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 4
  match VL with
  | 128 => (execute_FDOT_ZA_ZZi_4xi 128 index m n nreg offset v)
  | 256 => (execute_FDOT_ZA_ZZi_4xi 256 index m n nreg offset v)
  | 512 => (execute_FDOT_ZA_ZZi_4xi 512 index m n nreg offset v)
  | 1024 => (execute_FDOT_ZA_ZZi_4xi 1024 index m n nreg offset v)
  | 2048 => (execute_FDOT_ZA_ZZi_4xi 2048 index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ is_VL(VL) -/
def execute_BFVDOT_ZA_ZZi_2xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name 2)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1a ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        let operand1b ← (( do (Z_read (n +i 1) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let elt1_a ← (( do (Elem_read operand1a ((2 *i e) +i r) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1b ((2 *i e) +i r) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i s) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i s) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) :
                SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFVDOT_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_BFVDOT_ZA_ZZi_2xi 128 index m n offset v)
  | 256 => (execute_BFVDOT_ZA_ZZi_2xi 256 index m n offset v)
  | 512 => (execute_BFVDOT_ZA_ZZi_2xi 512 index m n offset v)
  | 1024 => (execute_BFVDOT_ZA_ZZi_2xi 1024 index m n offset v)
  | 2048 => (execute_BFVDOT_ZA_ZZi_2xi 2048 index m n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ is_VL(VL) -/
def execute_FVDOT_ZA_ZZi_2xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name 2)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1a ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        let operand1b ← (( do (Z_read (n +i 1) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let elt1_a ← (( do (Elem_read operand1a ((2 *i e) +i r) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1b ((2 *i e) +i r) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i s) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i s) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
              let sum ← (( do (FPDotAdd_ZA sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) )
                : SailM (BitVec 32) )
              (Elem_set result e 32 sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FVDOT_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_FVDOT_ZA_ZZi_2xi 128 index m n offset v)
  | 256 => (execute_FVDOT_ZA_ZZi_2xi 256 index m n offset v)
  | 512 => (execute_FVDOT_ZA_ZZi_2xi 512 index m n offset v)
  | 1024 => (execute_FVDOT_ZA_ZZi_2xi 1024 index m n offset v)
  | 2048 => (execute_FVDOT_ZA_ZZi_2xi 2048 index m n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧ nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLAL_ZA_ZZV_1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLAL_ZA_ZZV_1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := false
  let nreg := 1
  match VL with
  | 128 => (execute_BFMLAL_ZA_ZZV_1 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLAL_ZA_ZZV_1 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLAL_ZA_ZZV_1 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLAL_ZA_ZZV_1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLAL_ZA_ZZV_1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLAL_ZA_ZZW_2x2 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLAL_ZA_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLAL_ZA_ZZW_2x2 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLAL_ZA_ZZW_2x2 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLAL_ZA_ZZW_2x2 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLAL_ZA_ZZW_2x2 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLAL_ZA_ZZW_2x2 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLAL_ZA_ZZV_2x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLAL_ZA_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLAL_ZA_ZZV_2x1 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLAL_ZA_ZZV_2x1 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLAL_ZA_ZZV_2x1 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLAL_ZA_ZZV_2x1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLAL_ZA_ZZV_2x1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLAL_ZA_ZZW_4x4 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLAL_ZA_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLAL_ZA_ZZW_4x4 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLAL_ZA_ZZW_4x4 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLAL_ZA_ZZW_4x4 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLAL_ZA_ZZW_4x4 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLAL_ZA_ZZW_4x4 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLAL_ZA_ZZV_4x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLAL_ZA_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLAL_ZA_ZZV_4x1 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLAL_ZA_ZZV_4x1 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLAL_ZA_ZZV_4x1 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLAL_ZA_ZZV_4x1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLAL_ZA_ZZV_4x1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧ nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLSL_ZA_ZZV_1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLSL_ZA_ZZV_1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := true
  let nreg := 1
  match VL with
  | 128 => (execute_BFMLSL_ZA_ZZV_1 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLSL_ZA_ZZV_1 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLSL_ZA_ZZV_1 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLSL_ZA_ZZV_1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLSL_ZA_ZZV_1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLSL_ZA_ZZW_2x2 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLSL_ZA_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLSL_ZA_ZZW_2x2 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLSL_ZA_ZZW_2x2 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLSL_ZA_ZZW_2x2 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLSL_ZA_ZZW_2x2 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLSL_ZA_ZZW_2x2 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLSL_ZA_ZZV_2x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLSL_ZA_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLSL_ZA_ZZV_2x1 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLSL_ZA_ZZV_2x1 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLSL_ZA_ZZV_2x1 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLSL_ZA_ZZV_2x1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLSL_ZA_ZZV_2x1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLSL_ZA_ZZW_4x4 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLSL_ZA_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLSL_ZA_ZZW_4x4 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLSL_ZA_ZZW_4x4 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLSL_ZA_ZZW_4x4 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLSL_ZA_ZZW_4x4 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLSL_ZA_ZZW_4x4 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLSL_ZA_ZZV_4x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLSL_ZA_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLSL_ZA_ZZV_4x1 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLSL_ZA_ZZV_4x1 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLSL_ZA_ZZV_4x1 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLSL_ZA_ZZV_4x1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLSL_ZA_ZZV_4x1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_BFMLAL_ZA_ZZi_1 (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLAL_ZA_ZZi_1 (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := false
  let nreg := 1
  match VL with
  | 128 => (execute_BFMLAL_ZA_ZZi_1 128 index m n nreg offset sub_op v)
  | 256 => (execute_BFMLAL_ZA_ZZi_1 256 index m n nreg offset sub_op v)
  | 512 => (execute_BFMLAL_ZA_ZZi_1 512 index m n nreg offset sub_op v)
  | 1024 => (execute_BFMLAL_ZA_ZZi_1 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_BFMLAL_ZA_ZZi_1 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_BFMLAL_ZA_ZZi_2xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLAL_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLAL_ZA_ZZi_2xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_BFMLAL_ZA_ZZi_2xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_BFMLAL_ZA_ZZi_2xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_BFMLAL_ZA_ZZi_2xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_BFMLAL_ZA_ZZi_2xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_BFMLAL_ZA_ZZi_4xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLAL_ZA_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLAL_ZA_ZZi_4xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_BFMLAL_ZA_ZZi_4xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_BFMLAL_ZA_ZZi_4xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_BFMLAL_ZA_ZZi_4xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_BFMLAL_ZA_ZZi_4xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_BFMLSL_ZA_ZZi_1 (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLSL_ZA_ZZi_1 (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := true
  let nreg := 1
  match VL with
  | 128 => (execute_BFMLSL_ZA_ZZi_1 128 index m n nreg offset sub_op v)
  | 256 => (execute_BFMLSL_ZA_ZZi_1 256 index m n nreg offset sub_op v)
  | 512 => (execute_BFMLSL_ZA_ZZi_1 512 index m n nreg offset sub_op v)
  | 1024 => (execute_BFMLSL_ZA_ZZi_1 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_BFMLSL_ZA_ZZi_1 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_BFMLSL_ZA_ZZi_2xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLSL_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLSL_ZA_ZZi_2xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_BFMLSL_ZA_ZZi_2xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_BFMLSL_ZA_ZZi_2xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_BFMLSL_ZA_ZZi_2xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_BFMLSL_ZA_ZZi_2xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_BFMLSL_ZA_ZZi_4xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (BFNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (BFMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLSL_ZA_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLSL_ZA_ZZi_4xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_BFMLSL_ZA_ZZi_4xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_BFMLSL_ZA_ZZi_4xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_BFMLSL_ZA_ZZi_4xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_BFMLSL_ZA_ZZi_4xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧ nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FMLAL_ZA_ZZV_1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLAL_ZA_ZZV_1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := false
  let nreg := 1
  match VL with
  | 128 => (execute_FMLAL_ZA_ZZV_1 128 m n nreg offset sub_op v)
  | 256 => (execute_FMLAL_ZA_ZZV_1 256 m n nreg offset sub_op v)
  | 512 => (execute_FMLAL_ZA_ZZV_1 512 m n nreg offset sub_op v)
  | 1024 => (execute_FMLAL_ZA_ZZV_1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_FMLAL_ZA_ZZV_1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FMLAL_ZA_ZZW_2x2 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLAL_ZA_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_FMLAL_ZA_ZZW_2x2 128 m n nreg offset sub_op v)
  | 256 => (execute_FMLAL_ZA_ZZW_2x2 256 m n nreg offset sub_op v)
  | 512 => (execute_FMLAL_ZA_ZZW_2x2 512 m n nreg offset sub_op v)
  | 1024 => (execute_FMLAL_ZA_ZZW_2x2 1024 m n nreg offset sub_op v)
  | 2048 => (execute_FMLAL_ZA_ZZW_2x2 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FMLAL_ZA_ZZV_2x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLAL_ZA_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_FMLAL_ZA_ZZV_2x1 128 m n nreg offset sub_op v)
  | 256 => (execute_FMLAL_ZA_ZZV_2x1 256 m n nreg offset sub_op v)
  | 512 => (execute_FMLAL_ZA_ZZV_2x1 512 m n nreg offset sub_op v)
  | 1024 => (execute_FMLAL_ZA_ZZV_2x1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_FMLAL_ZA_ZZV_2x1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FMLAL_ZA_ZZW_4x4 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLAL_ZA_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_FMLAL_ZA_ZZW_4x4 128 m n nreg offset sub_op v)
  | 256 => (execute_FMLAL_ZA_ZZW_4x4 256 m n nreg offset sub_op v)
  | 512 => (execute_FMLAL_ZA_ZZW_4x4 512 m n nreg offset sub_op v)
  | 1024 => (execute_FMLAL_ZA_ZZW_4x4 1024 m n nreg offset sub_op v)
  | 2048 => (execute_FMLAL_ZA_ZZW_4x4 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FMLAL_ZA_ZZV_4x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLAL_ZA_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_FMLAL_ZA_ZZV_4x1 128 m n nreg offset sub_op v)
  | 256 => (execute_FMLAL_ZA_ZZV_4x1 256 m n nreg offset sub_op v)
  | 512 => (execute_FMLAL_ZA_ZZV_4x1 512 m n nreg offset sub_op v)
  | 1024 => (execute_FMLAL_ZA_ZZV_4x1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_FMLAL_ZA_ZZV_4x1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_FMLAL_ZA_ZZi_1 (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLAL_ZA_ZZi_1 (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := false
  let nreg := 1
  match VL with
  | 128 => (execute_FMLAL_ZA_ZZi_1 128 index m n nreg offset sub_op v)
  | 256 => (execute_FMLAL_ZA_ZZi_1 256 index m n nreg offset sub_op v)
  | 512 => (execute_FMLAL_ZA_ZZi_1 512 index m n nreg offset sub_op v)
  | 1024 => (execute_FMLAL_ZA_ZZi_1 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_FMLAL_ZA_ZZi_1 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_FMLAL_ZA_ZZi_2xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLAL_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_FMLAL_ZA_ZZi_2xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_FMLAL_ZA_ZZi_2xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_FMLAL_ZA_ZZi_2xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_FMLAL_ZA_ZZi_2xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_FMLAL_ZA_ZZi_2xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_FMLAL_ZA_ZZi_4xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLAL_ZA_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_FMLAL_ZA_ZZi_4xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_FMLAL_ZA_ZZi_4xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_FMLAL_ZA_ZZi_4xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_FMLAL_ZA_ZZi_4xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_FMLAL_ZA_ZZi_4xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧ nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FMLSL_ZA_ZZV_1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLSL_ZA_ZZV_1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := true
  let nreg := 1
  match VL with
  | 128 => (execute_FMLSL_ZA_ZZV_1 128 m n nreg offset sub_op v)
  | 256 => (execute_FMLSL_ZA_ZZV_1 256 m n nreg offset sub_op v)
  | 512 => (execute_FMLSL_ZA_ZZV_1 512 m n nreg offset sub_op v)
  | 1024 => (execute_FMLSL_ZA_ZZV_1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_FMLSL_ZA_ZZV_1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FMLSL_ZA_ZZW_2x2 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLSL_ZA_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_FMLSL_ZA_ZZW_2x2 128 m n nreg offset sub_op v)
  | 256 => (execute_FMLSL_ZA_ZZW_2x2 256 m n nreg offset sub_op v)
  | 512 => (execute_FMLSL_ZA_ZZW_2x2 512 m n nreg offset sub_op v)
  | 1024 => (execute_FMLSL_ZA_ZZW_2x2 1024 m n nreg offset sub_op v)
  | 2048 => (execute_FMLSL_ZA_ZZW_2x2 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FMLSL_ZA_ZZV_2x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLSL_ZA_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_FMLSL_ZA_ZZV_2x1 128 m n nreg offset sub_op v)
  | 256 => (execute_FMLSL_ZA_ZZV_2x1 256 m n nreg offset sub_op v)
  | 512 => (execute_FMLSL_ZA_ZZV_2x1 512 m n nreg offset sub_op v)
  | 1024 => (execute_FMLSL_ZA_ZZV_2x1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_FMLSL_ZA_ZZV_2x1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FMLSL_ZA_ZZW_4x4 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLSL_ZA_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_FMLSL_ZA_ZZW_4x4 128 m n nreg offset sub_op v)
  | 256 => (execute_FMLSL_ZA_ZZW_4x4 256 m n nreg offset sub_op v)
  | 512 => (execute_FMLSL_ZA_ZZW_4x4 512 m n nreg offset sub_op v)
  | 1024 => (execute_FMLSL_ZA_ZZW_4x4 1024 m n nreg offset sub_op v)
  | 2048 => (execute_FMLSL_ZA_ZZW_4x4 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_FMLSL_ZA_ZZV_4x1 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLSL_ZA_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_FMLSL_ZA_ZZV_4x1 128 m n nreg offset sub_op v)
  | 256 => (execute_FMLSL_ZA_ZZV_4x1 256 m n nreg offset sub_op v)
  | 512 => (execute_FMLSL_ZA_ZZV_4x1 512 m n nreg offset sub_op v)
  | 1024 => (execute_FMLSL_ZA_ZZV_4x1 1024 m n nreg offset sub_op v)
  | 2048 => (execute_FMLSL_ZA_ZZV_4x1 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_FMLSL_ZA_ZZi_1 (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLSL_ZA_ZZi_1 (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := true
  let nreg := 1
  match VL with
  | 128 => (execute_FMLSL_ZA_ZZi_1 128 index m n nreg offset sub_op v)
  | 256 => (execute_FMLSL_ZA_ZZi_1 256 index m n nreg offset sub_op v)
  | 512 => (execute_FMLSL_ZA_ZZi_1 512 index m n nreg offset sub_op v)
  | 1024 => (execute_FMLSL_ZA_ZZi_1 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_FMLSL_ZA_ZZi_1 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_FMLSL_ZA_ZZi_2xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLSL_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_FMLSL_ZA_ZZi_2xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_FMLSL_ZA_ZZi_2xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_FMLSL_ZA_ZZi_2xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_FMLSL_ZA_ZZi_2xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_FMLSL_ZA_ZZi_2xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_FMLSL_ZA_ZZi_4xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 32)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← (( do (Elem_read operand1 ((2 *i e) +i i) 16) ) : SailM
                      (BitVec 16) )
                    let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
                    let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
                    let element1 ← (( do
                      bif sub_op
                      then
                        (do
                          (FPNeg element1))
                      else (pure element1) ) : SailM (BitVec 16) )
                    (Elem_set result e 32
                      (← (FPMulAddH_ZA element3 element1 element2 (← (FPCR_read ())))))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLSL_ZA_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_FMLSL_ZA_ZZi_4xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_FMLSL_ZA_ZZi_4xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_FMLSL_ZA_ZZi_4xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_FMLSL_ZA_ZZi_4xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_FMLSL_ZA_ZZi_4xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAX_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:16715.53-16715.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMax element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMAX_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_FMAX_MZ_ZZW_2x2 128 dn esize m nreg)
  | 256 => (execute_FMAX_MZ_ZZW_2x2 256 dn esize m nreg)
  | 512 => (execute_FMAX_MZ_ZZW_2x2 512 dn esize m nreg)
  | 1024 => (execute_FMAX_MZ_ZZW_2x2 1024 dn esize m nreg)
  | 2048 => (execute_FMAX_MZ_ZZW_2x2 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAX_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:16778.53-16778.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMax element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMAX_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_FMAX_MZ_ZZV_2x1 128 dn esize m nreg)
  | 256 => (execute_FMAX_MZ_ZZV_2x1 256 dn esize m nreg)
  | 512 => (execute_FMAX_MZ_ZZV_2x1 512 dn esize m nreg)
  | 1024 => (execute_FMAX_MZ_ZZV_2x1 1024 dn esize m nreg)
  | 2048 => (execute_FMAX_MZ_ZZV_2x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMIN_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:16841.53-16841.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMin element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMIN_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_FMIN_MZ_ZZW_2x2 128 dn esize m nreg)
  | 256 => (execute_FMIN_MZ_ZZW_2x2 256 dn esize m nreg)
  | 512 => (execute_FMIN_MZ_ZZW_2x2 512 dn esize m nreg)
  | 1024 => (execute_FMIN_MZ_ZZW_2x2 1024 dn esize m nreg)
  | 2048 => (execute_FMIN_MZ_ZZW_2x2 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMIN_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:16904.53-16904.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMin element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMIN_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_FMIN_MZ_ZZV_2x1 128 dn esize m nreg)
  | 256 => (execute_FMIN_MZ_ZZV_2x1 256 dn esize m nreg)
  | 512 => (execute_FMIN_MZ_ZZV_2x1 512 dn esize m nreg)
  | 1024 => (execute_FMIN_MZ_ZZV_2x1 1024 dn esize m nreg)
  | 2048 => (execute_FMIN_MZ_ZZV_2x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAX_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:16967.53-16967.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMax element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMAX_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_FMAX_MZ_ZZW_4x4 128 dn esize m nreg)
  | 256 => (execute_FMAX_MZ_ZZW_4x4 256 dn esize m nreg)
  | 512 => (execute_FMAX_MZ_ZZW_4x4 512 dn esize m nreg)
  | 1024 => (execute_FMAX_MZ_ZZW_4x4 1024 dn esize m nreg)
  | 2048 => (execute_FMAX_MZ_ZZW_4x4 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAX_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17030.53-17030.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMax element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMAX_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_FMAX_MZ_ZZV_4x1 128 dn esize m nreg)
  | 256 => (execute_FMAX_MZ_ZZV_4x1 256 dn esize m nreg)
  | 512 => (execute_FMAX_MZ_ZZV_4x1 512 dn esize m nreg)
  | 1024 => (execute_FMAX_MZ_ZZV_4x1 1024 dn esize m nreg)
  | 2048 => (execute_FMAX_MZ_ZZV_4x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMIN_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17093.53-17093.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMin element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMIN_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_FMIN_MZ_ZZW_4x4 128 dn esize m nreg)
  | 256 => (execute_FMIN_MZ_ZZW_4x4 256 dn esize m nreg)
  | 512 => (execute_FMIN_MZ_ZZW_4x4 512 dn esize m nreg)
  | 1024 => (execute_FMIN_MZ_ZZW_4x4 1024 dn esize m nreg)
  | 2048 => (execute_FMIN_MZ_ZZW_4x4 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMIN_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17156.53-17156.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMin element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMIN_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_FMIN_MZ_ZZV_4x1 128 dn esize m nreg)
  | 256 => (execute_FMIN_MZ_ZZV_4x1 256 dn esize m nreg)
  | 512 => (execute_FMIN_MZ_ZZV_4x1 512 dn esize m nreg)
  | 1024 => (execute_FMIN_MZ_ZZV_4x1 1024 dn esize m nreg)
  | 2048 => (execute_FMIN_MZ_ZZV_4x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXNM_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17219.53-17219.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMaxNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMAXNM_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_FMAXNM_MZ_ZZW_2x2 128 dn esize m nreg)
  | 256 => (execute_FMAXNM_MZ_ZZW_2x2 256 dn esize m nreg)
  | 512 => (execute_FMAXNM_MZ_ZZW_2x2 512 dn esize m nreg)
  | 1024 => (execute_FMAXNM_MZ_ZZW_2x2 1024 dn esize m nreg)
  | 2048 => (execute_FMAXNM_MZ_ZZW_2x2 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXNM_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17282.53-17282.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMaxNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMAXNM_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_FMAXNM_MZ_ZZV_2x1 128 dn esize m nreg)
  | 256 => (execute_FMAXNM_MZ_ZZV_2x1 256 dn esize m nreg)
  | 512 => (execute_FMAXNM_MZ_ZZV_2x1 512 dn esize m nreg)
  | 1024 => (execute_FMAXNM_MZ_ZZV_2x1 1024 dn esize m nreg)
  | 2048 => (execute_FMAXNM_MZ_ZZV_2x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMINNM_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17345.53-17345.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMinNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMINNM_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_FMINNM_MZ_ZZW_2x2 128 dn esize m nreg)
  | 256 => (execute_FMINNM_MZ_ZZW_2x2 256 dn esize m nreg)
  | 512 => (execute_FMINNM_MZ_ZZW_2x2 512 dn esize m nreg)
  | 1024 => (execute_FMINNM_MZ_ZZW_2x2 1024 dn esize m nreg)
  | 2048 => (execute_FMINNM_MZ_ZZW_2x2 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMINNM_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17408.53-17408.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMinNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMINNM_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_FMINNM_MZ_ZZV_2x1 128 dn esize m nreg)
  | 256 => (execute_FMINNM_MZ_ZZV_2x1 256 dn esize m nreg)
  | 512 => (execute_FMINNM_MZ_ZZV_2x1 512 dn esize m nreg)
  | 1024 => (execute_FMINNM_MZ_ZZV_2x1 1024 dn esize m nreg)
  | 2048 => (execute_FMINNM_MZ_ZZV_2x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXNM_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17471.53-17471.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMaxNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMAXNM_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_FMAXNM_MZ_ZZW_4x4 128 dn esize m nreg)
  | 256 => (execute_FMAXNM_MZ_ZZW_4x4 256 dn esize m nreg)
  | 512 => (execute_FMAXNM_MZ_ZZW_4x4 512 dn esize m nreg)
  | 1024 => (execute_FMAXNM_MZ_ZZW_4x4 1024 dn esize m nreg)
  | 2048 => (execute_FMAXNM_MZ_ZZW_4x4 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXNM_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17534.53-17534.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMaxNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMAXNM_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_FMAXNM_MZ_ZZV_4x1 128 dn esize m nreg)
  | 256 => (execute_FMAXNM_MZ_ZZV_4x1 256 dn esize m nreg)
  | 512 => (execute_FMAXNM_MZ_ZZV_4x1 512 dn esize m nreg)
  | 1024 => (execute_FMAXNM_MZ_ZZV_4x1 1024 dn esize m nreg)
  | 2048 => (execute_FMAXNM_MZ_ZZV_4x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMINNM_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17597.53-17597.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMinNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMINNM_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_FMINNM_MZ_ZZW_4x4 128 dn esize m nreg)
  | 256 => (execute_FMINNM_MZ_ZZW_4x4 256 dn esize m nreg)
  | 512 => (execute_FMINNM_MZ_ZZW_4x4 512 dn esize m nreg)
  | 1024 => (execute_FMINNM_MZ_ZZW_4x4 1024 dn esize m nreg)
  | 2048 => (execute_FMINNM_MZ_ZZW_4x4 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMINNM_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17660.53-17660.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMinNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FMINNM_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_FMINNM_MZ_ZZV_4x1 128 dn esize m nreg)
  | 256 => (execute_FMINNM_MZ_ZZV_4x1 256 dn esize m nreg)
  | 512 => (execute_FMINNM_MZ_ZZV_4x1 512 dn esize m nreg)
  | 1024 => (execute_FMINNM_MZ_ZZV_4x1 1024 dn esize m nreg)
  | 2048 => (execute_FMINNM_MZ_ZZV_4x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCLAMP_MZ_ZZ_2 (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do (Z_read (d +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17725.53-17725.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMinNum (← (FPMaxNum element1 element3 (← (FPCR_read ())))) element2
                        (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FCLAMP_MZ_ZZ_2 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_FCLAMP_MZ_ZZ_2 128 d esize m n nreg)
  | 256 => (execute_FCLAMP_MZ_ZZ_2 256 d esize m n nreg)
  | 512 => (execute_FCLAMP_MZ_ZZ_2 512 d esize m n nreg)
  | 1024 => (execute_FCLAMP_MZ_ZZ_2 1024 d esize m n nreg)
  | 2048 => (execute_FCLAMP_MZ_ZZ_2 2048 d esize m n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCLAMP_MZ_ZZ_4 (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do (Z_read (d +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64_sme.sail:17792.53-17792.54"
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (FPMinNum (← (FPMaxNum element1 element3 (← (FPCR_read ())))) element2
                        (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FCLAMP_MZ_ZZ_4 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_FCLAMP_MZ_ZZ_4 128 d esize m n nreg)
  | 256 => (execute_FCLAMP_MZ_ZZ_4 256 d esize m n nreg)
  | 512 => (execute_FCLAMP_MZ_ZZ_4 512 d esize m n nreg)
  | 1024 => (execute_FCLAMP_MZ_ZZ_4 1024 d esize m n nreg)
  | 2048 => (execute_FCLAMP_MZ_ZZ_4 2048 d esize m n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFCVT_Z_MZ2__ (VL : Nat) (d : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let operand1 ← (( do (Z_read (n +i 0) VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read (n +i 1) VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 32) ) : SailM (BitVec 32) )
        let element2 ← (( do (Elem_read operand2 e 32) ) : SailM (BitVec 32) )
        let res1 ← (( do (FPConvertBF__1 element1 (← (FPCR_read ()))) ) : SailM (BitVec 16) )
        let res2 ← (( do (FPConvertBF__1 element2 (← (FPCR_read ()))) ) : SailM (BitVec 16) )
        let result ← (Elem_set result e 16 res1)
        (Elem_set result (elements +i e) 16 res2)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BFCVT_Z_MZ2__ (Zn : (BitVec 4)) (N : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BFCVT_Z_MZ2__ 128 d n)
  | 256 => (execute_BFCVT_Z_MZ2__ 256 d n)
  | 512 => (execute_BFCVT_Z_MZ2__ 512 d n)
  | 1024 => (execute_BFCVT_Z_MZ2__ 1024 d n)
  | 2048 => (execute_BFCVT_Z_MZ2__ 2048 d n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVT_Z_MZ2__ (VL : Nat) (d : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let operand1 ← (( do (Z_read (n +i 0) VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read (n +i 1) VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 32) ) : SailM (BitVec 32) )
        let element2 ← (( do (Elem_read operand2 e 32) ) : SailM (BitVec 32) )
        let res1 ← (( do (FPConvertSVE__1 element1 (← (FPCR_read ())) 16) ) : SailM (BitVec 16)
          )
        let res2 ← (( do (FPConvertSVE__1 element2 (← (FPCR_read ())) 16) ) : SailM (BitVec 16)
          )
        let result ← (Elem_set result e 16 res1)
        (Elem_set result (elements +i e) 16 res2)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVT_Z_MZ2__ (Zn : (BitVec 4)) (N : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FCVT_Z_MZ2__ 128 d n)
  | 256 => (execute_FCVT_Z_MZ2__ 256 d n)
  | 512 => (execute_FCVT_Z_MZ2__ 512 d n)
  | 1024 => (execute_FCVT_Z_MZ2__ 1024 d n)
  | 2048 => (execute_FCVT_Z_MZ2__ 2048 d n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFCVTN_Z_MZ2__ (VL : Nat) (d : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let operand1 ← (( do (Z_read (n +i 0) VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read (n +i 1) VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 32) ) : SailM (BitVec 32) )
        let element2 ← (( do (Elem_read operand2 e 32) ) : SailM (BitVec 32) )
        let res1 ← (( do (FPConvertBF__1 element1 (← (FPCR_read ()))) ) : SailM (BitVec 16) )
        let res2 ← (( do (FPConvertBF__1 element2 (← (FPCR_read ()))) ) : SailM (BitVec 16) )
        let result ← (Elem_set result ((2 *i e) +i 0) 16 res1)
        (Elem_set result ((2 *i e) +i 1) 16 res2)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BFCVTN_Z_MZ2__ (Zn : (BitVec 4)) (N : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BFCVTN_Z_MZ2__ 128 d n)
  | 256 => (execute_BFCVTN_Z_MZ2__ 256 d n)
  | 512 => (execute_BFCVTN_Z_MZ2__ 512 d n)
  | 1024 => (execute_BFCVTN_Z_MZ2__ 1024 d n)
  | 2048 => (execute_BFCVTN_Z_MZ2__ 2048 d n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTN_Z_MZ2__ (VL : Nat) (d : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let operand1 ← (( do (Z_read (n +i 0) VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read (n +i 1) VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 32) ) : SailM (BitVec 32) )
        let element2 ← (( do (Elem_read operand2 e 32) ) : SailM (BitVec 32) )
        let res1 ← (( do (FPConvertSVE__1 element1 (← (FPCR_read ())) 16) ) : SailM (BitVec 16)
          )
        let res2 ← (( do (FPConvertSVE__1 element2 (← (FPCR_read ())) 16) ) : SailM (BitVec 16)
          )
        let result ← (Elem_set result ((2 *i e) +i 0) 16 res1)
        (Elem_set result ((2 *i e) +i 1) 16 res2)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTN_Z_MZ2__ (Zn : (BitVec 4)) (N : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FCVTN_Z_MZ2__ 128 d n)
  | 256 => (execute_FCVTN_Z_MZ2__ 256 d n)
  | 512 => (execute_FCVTN_Z_MZ2__ 512 d n)
  | 1024 => (execute_FCVTN_Z_MZ2__ 1024 d n)
  | 2048 => (execute_FCVTN_Z_MZ2__ 2048 d n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZU_MZ_Z_2 (VL : Nat) (d : Nat) (n : Nat) (nreg : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPToFixed element 0 is_unsigned (← (FPCR_read ())) rounding 32))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FCVTZU_MZ_Z_2 (Zn : (BitVec 4)) (U : (BitVec 1)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let is_unsigned : Bool := true
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZU_MZ_Z_2 128 d n nreg rounding is_unsigned)
  | 256 => (execute_FCVTZU_MZ_Z_2 256 d n nreg rounding is_unsigned)
  | 512 => (execute_FCVTZU_MZ_Z_2 512 d n nreg rounding is_unsigned)
  | 1024 => (execute_FCVTZU_MZ_Z_2 1024 d n nreg rounding is_unsigned)
  | 2048 => (execute_FCVTZU_MZ_Z_2 2048 d n nreg rounding is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZU_MZ_Z_4 (VL : Nat) (d : Nat) (n : Nat) (nreg : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPToFixed element 0 is_unsigned (← (FPCR_read ())) rounding 32))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FCVTZU_MZ_Z_4 (Zn : (BitVec 3)) (U : (BitVec 1)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let is_unsigned : Bool := true
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZU_MZ_Z_4 128 d n nreg rounding is_unsigned)
  | 256 => (execute_FCVTZU_MZ_Z_4 256 d n nreg rounding is_unsigned)
  | 512 => (execute_FCVTZU_MZ_Z_4 512 d n nreg rounding is_unsigned)
  | 1024 => (execute_FCVTZU_MZ_Z_4 1024 d n nreg rounding is_unsigned)
  | 2048 => (execute_FCVTZU_MZ_Z_4 2048 d n nreg rounding is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZS_MZ_Z_2 (VL : Nat) (d : Nat) (n : Nat) (nreg : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPToFixed element 0 is_unsigned (← (FPCR_read ())) rounding 32))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FCVTZS_MZ_Z_2 (Zn : (BitVec 4)) (U : (BitVec 1)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let is_unsigned : Bool := false
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZS_MZ_Z_2 128 d n nreg rounding is_unsigned)
  | 256 => (execute_FCVTZS_MZ_Z_2 256 d n nreg rounding is_unsigned)
  | 512 => (execute_FCVTZS_MZ_Z_2 512 d n nreg rounding is_unsigned)
  | 1024 => (execute_FCVTZS_MZ_Z_2 1024 d n nreg rounding is_unsigned)
  | 2048 => (execute_FCVTZS_MZ_Z_2 2048 d n nreg rounding is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZS_MZ_Z_4 (VL : Nat) (d : Nat) (n : Nat) (nreg : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPToFixed element 0 is_unsigned (← (FPCR_read ())) rounding 32))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FCVTZS_MZ_Z_4 (Zn : (BitVec 3)) (U : (BitVec 1)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let is_unsigned : Bool := false
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZS_MZ_Z_4 128 d n nreg rounding is_unsigned)
  | 256 => (execute_FCVTZS_MZ_Z_4 256 d n nreg rounding is_unsigned)
  | 512 => (execute_FCVTZS_MZ_Z_4 512 d n nreg rounding is_unsigned)
  | 1024 => (execute_FCVTZS_MZ_Z_4 1024 d n nreg rounding is_unsigned)
  | 2048 => (execute_FCVTZS_MZ_Z_4 2048 d n nreg rounding is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCVTF_MZ_Z_2 (VL : Nat) (d : Nat) (n : Nat) (nreg : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FixedToFP element 0 is_unsigned (← (FPCR_read ())) rounding 32))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UCVTF_MZ_Z_2 (Zn : (BitVec 4)) (U : (BitVec 1)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let is_unsigned : Bool := true
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_UCVTF_MZ_Z_2 128 d n nreg rounding is_unsigned)
  | 256 => (execute_UCVTF_MZ_Z_2 256 d n nreg rounding is_unsigned)
  | 512 => (execute_UCVTF_MZ_Z_2 512 d n nreg rounding is_unsigned)
  | 1024 => (execute_UCVTF_MZ_Z_2 1024 d n nreg rounding is_unsigned)
  | 2048 => (execute_UCVTF_MZ_Z_2 2048 d n nreg rounding is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCVTF_MZ_Z_4 (VL : Nat) (d : Nat) (n : Nat) (nreg : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FixedToFP element 0 is_unsigned (← (FPCR_read ())) rounding 32))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UCVTF_MZ_Z_4 (Zn : (BitVec 3)) (U : (BitVec 1)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let is_unsigned : Bool := true
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_UCVTF_MZ_Z_4 128 d n nreg rounding is_unsigned)
  | 256 => (execute_UCVTF_MZ_Z_4 256 d n nreg rounding is_unsigned)
  | 512 => (execute_UCVTF_MZ_Z_4 512 d n nreg rounding is_unsigned)
  | 1024 => (execute_UCVTF_MZ_Z_4 1024 d n nreg rounding is_unsigned)
  | 2048 => (execute_UCVTF_MZ_Z_4 2048 d n nreg rounding is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCVTF_MZ_Z_2 (VL : Nat) (d : Nat) (n : Nat) (nreg : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FixedToFP element 0 is_unsigned (← (FPCR_read ())) rounding 32))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SCVTF_MZ_Z_2 (Zn : (BitVec 4)) (U : (BitVec 1)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let is_unsigned : Bool := false
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_SCVTF_MZ_Z_2 128 d n nreg rounding is_unsigned)
  | 256 => (execute_SCVTF_MZ_Z_2 256 d n nreg rounding is_unsigned)
  | 512 => (execute_SCVTF_MZ_Z_2 512 d n nreg rounding is_unsigned)
  | 1024 => (execute_SCVTF_MZ_Z_2 1024 d n nreg rounding is_unsigned)
  | 2048 => (execute_SCVTF_MZ_Z_2 2048 d n nreg rounding is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCVTF_MZ_Z_4 (VL : Nat) (d : Nat) (n : Nat) (nreg : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FixedToFP element 0 is_unsigned (← (FPCR_read ())) rounding 32))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SCVTF_MZ_Z_4 (Zn : (BitVec 3)) (U : (BitVec 1)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let is_unsigned : Bool := false
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_SCVTF_MZ_Z_4 128 d n nreg rounding is_unsigned)
  | 256 => (execute_SCVTF_MZ_Z_4 256 d n nreg rounding is_unsigned)
  | 512 => (execute_SCVTF_MZ_Z_4 512 d n nreg rounding is_unsigned)
  | 1024 => (execute_SCVTF_MZ_Z_4 1024 d n nreg rounding is_unsigned)
  | 2048 => (execute_SCVTF_MZ_Z_4 2048 d n nreg rounding is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_exact : Bool, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTA_MZ_Z_2 (VL : Nat) (d : Nat) (exact : Bool) (n : Nat) (nreg : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FRINTA_MZ_Z_2 (size : (BitVec 2)) (Zn : (BitVec 4)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_TIEAWAY
  match VL with
  | 128 => (execute_FRINTA_MZ_Z_2 128 d exact n nreg rounding)
  | 256 => (execute_FRINTA_MZ_Z_2 256 d exact n nreg rounding)
  | 512 => (execute_FRINTA_MZ_Z_2 512 d exact n nreg rounding)
  | 1024 => (execute_FRINTA_MZ_Z_2 1024 d exact n nreg rounding)
  | 2048 => (execute_FRINTA_MZ_Z_2 2048 d exact n nreg rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_exact : Bool, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTM_MZ_Z_2 (VL : Nat) (d : Nat) (exact : Bool) (n : Nat) (nreg : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FRINTM_MZ_Z_2 (size : (BitVec 2)) (Zn : (BitVec 4)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_NEGINF
  match VL with
  | 128 => (execute_FRINTM_MZ_Z_2 128 d exact n nreg rounding)
  | 256 => (execute_FRINTM_MZ_Z_2 256 d exact n nreg rounding)
  | 512 => (execute_FRINTM_MZ_Z_2 512 d exact n nreg rounding)
  | 1024 => (execute_FRINTM_MZ_Z_2 1024 d exact n nreg rounding)
  | 2048 => (execute_FRINTM_MZ_Z_2 2048 d exact n nreg rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_exact : Bool, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTN_MZ_Z_2 (VL : Nat) (d : Nat) (exact : Bool) (n : Nat) (nreg : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FRINTN_MZ_Z_2 (size : (BitVec 2)) (Zn : (BitVec 4)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_TIEEVEN
  match VL with
  | 128 => (execute_FRINTN_MZ_Z_2 128 d exact n nreg rounding)
  | 256 => (execute_FRINTN_MZ_Z_2 256 d exact n nreg rounding)
  | 512 => (execute_FRINTN_MZ_Z_2 512 d exact n nreg rounding)
  | 1024 => (execute_FRINTN_MZ_Z_2 1024 d exact n nreg rounding)
  | 2048 => (execute_FRINTN_MZ_Z_2 2048 d exact n nreg rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_exact : Bool, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTP_MZ_Z_2 (VL : Nat) (d : Nat) (exact : Bool) (n : Nat) (nreg : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FRINTP_MZ_Z_2 (size : (BitVec 2)) (Zn : (BitVec 4)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_POSINF
  match VL with
  | 128 => (execute_FRINTP_MZ_Z_2 128 d exact n nreg rounding)
  | 256 => (execute_FRINTP_MZ_Z_2 256 d exact n nreg rounding)
  | 512 => (execute_FRINTP_MZ_Z_2 512 d exact n nreg rounding)
  | 1024 => (execute_FRINTP_MZ_Z_2 1024 d exact n nreg rounding)
  | 2048 => (execute_FRINTP_MZ_Z_2 2048 d exact n nreg rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_exact : Bool, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTA_MZ_Z_4 (VL : Nat) (d : Nat) (exact : Bool) (n : Nat) (nreg : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FRINTA_MZ_Z_4 (size : (BitVec 2)) (Zn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_TIEAWAY
  match VL with
  | 128 => (execute_FRINTA_MZ_Z_4 128 d exact n nreg rounding)
  | 256 => (execute_FRINTA_MZ_Z_4 256 d exact n nreg rounding)
  | 512 => (execute_FRINTA_MZ_Z_4 512 d exact n nreg rounding)
  | 1024 => (execute_FRINTA_MZ_Z_4 1024 d exact n nreg rounding)
  | 2048 => (execute_FRINTA_MZ_Z_4 2048 d exact n nreg rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_exact : Bool, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTM_MZ_Z_4 (VL : Nat) (d : Nat) (exact : Bool) (n : Nat) (nreg : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FRINTM_MZ_Z_4 (size : (BitVec 2)) (Zn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_NEGINF
  match VL with
  | 128 => (execute_FRINTM_MZ_Z_4 128 d exact n nreg rounding)
  | 256 => (execute_FRINTM_MZ_Z_4 256 d exact n nreg rounding)
  | 512 => (execute_FRINTM_MZ_Z_4 512 d exact n nreg rounding)
  | 1024 => (execute_FRINTM_MZ_Z_4 1024 d exact n nreg rounding)
  | 2048 => (execute_FRINTM_MZ_Z_4 2048 d exact n nreg rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_exact : Bool, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTN_MZ_Z_4 (VL : Nat) (d : Nat) (exact : Bool) (n : Nat) (nreg : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FRINTN_MZ_Z_4 (size : (BitVec 2)) (Zn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_TIEEVEN
  match VL with
  | 128 => (execute_FRINTN_MZ_Z_4 128 d exact n nreg rounding)
  | 256 => (execute_FRINTN_MZ_Z_4 256 d exact n nreg rounding)
  | 512 => (execute_FRINTN_MZ_Z_4 512 d exact n nreg rounding)
  | 1024 => (execute_FRINTN_MZ_Z_4 1024 d exact n nreg rounding)
  | 2048 => (execute_FRINTN_MZ_Z_4 2048 d exact n nreg rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_exact : Bool, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTP_MZ_Z_4 (VL : Nat) (d : Nat) (exact : Bool) (n : Nat) (nreg : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 32)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 32
                    (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_FRINTP_MZ_Z_4 (size : (BitVec 2)) (Zn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_POSINF
  match VL with
  | 128 => (execute_FRINTP_MZ_Z_4 128 d exact n nreg rounding)
  | 256 => (execute_FRINTP_MZ_Z_4 256 d exact n nreg rounding)
  | 512 => (execute_FRINTP_MZ_Z_4 512 d exact n nreg rounding)
  | 1024 => (execute_FRINTP_MZ_Z_4 1024 d exact n nreg rounding)
  | 2048 => (execute_FRINTP_MZ_Z_4 2048 d exact n nreg rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_ADD_ZA_ZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 + element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ADD_ZA_ZW_2x2 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_ADD_ZA_ZW_2x2 128 esize m nreg offset v)
  | 256 => (execute_ADD_ZA_ZW_2x2 256 esize m nreg offset v)
  | 512 => (execute_ADD_ZA_ZW_2x2 512 esize m nreg offset v)
  | 1024 => (execute_ADD_ZA_ZW_2x2 1024 esize m nreg offset v)
  | 2048 => (execute_ADD_ZA_ZW_2x2 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SUB_ZA_ZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 - element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUB_ZA_ZW_2x2 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_SUB_ZA_ZW_2x2 128 esize m nreg offset v)
  | 256 => (execute_SUB_ZA_ZW_2x2 256 esize m nreg offset v)
  | 512 => (execute_SUB_ZA_ZW_2x2 512 esize m nreg offset v)
  | 1024 => (execute_SUB_ZA_ZW_2x2 1024 esize m nreg offset v)
  | 2048 => (execute_SUB_ZA_ZW_2x2 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_ADD_ZA_ZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 + element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ADD_ZA_ZW_4x4 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_ADD_ZA_ZW_4x4 128 esize m nreg offset v)
  | 256 => (execute_ADD_ZA_ZW_4x4 256 esize m nreg offset v)
  | 512 => (execute_ADD_ZA_ZW_4x4 512 esize m nreg offset v)
  | 1024 => (execute_ADD_ZA_ZW_4x4 1024 esize m nreg offset v)
  | 2048 => (execute_ADD_ZA_ZW_4x4 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SUB_ZA_ZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 - element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUB_ZA_ZW_4x4 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_SUB_ZA_ZW_4x4 128 esize m nreg offset v)
  | 256 => (execute_SUB_ZA_ZW_4x4 256 esize m nreg offset v)
  | 512 => (execute_SUB_ZA_ZW_4x4 512 esize m nreg offset v)
  | 1024 => (execute_SUB_ZA_ZW_4x4 1024 esize m nreg offset v)
  | 2048 => (execute_SUB_ZA_ZW_4x4 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_ADD_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 + element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ADD_ZA_ZZW_2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_ADD_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_ADD_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_ADD_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_ADD_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_ADD_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SUB_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 - element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUB_ZA_ZZW_2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_SUB_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_SUB_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_SUB_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_SUB_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_SUB_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_ADD_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 + element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ADD_ZA_ZZV_2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_ADD_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_ADD_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_ADD_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_ADD_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_ADD_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SUB_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 - element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUB_ZA_ZZV_2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_SUB_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_SUB_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_SUB_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_SUB_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SUB_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_ADD_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 + element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ADD_ZA_ZZW_4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_ADD_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_ADD_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_ADD_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_ADD_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_ADD_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SUB_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 - element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUB_ZA_ZZW_4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_SUB_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_SUB_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_SUB_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_SUB_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_SUB_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_ADD_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 + element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_ADD_ZA_ZZV_4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_ADD_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_ADD_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_ADD_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_ADD_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_ADD_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SUB_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (element1 - element2))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUB_ZA_ZZV_4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_SUB_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_SUB_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_SUB_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_SUB_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SUB_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UDOT_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA_ZZW_2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_UDOT_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_UDOT_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_UDOT_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_UDOT_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_UDOT_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SDOT_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA_ZZW_2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_SDOT_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_SDOT_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_SDOT_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_SDOT_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_SDOT_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USDOT_ZA_ZZW_S2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USDOT_ZA_ZZW_S2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_USDOT_ZA_ZZW_S2x2 128 esize m n nreg offset v)
  | 256 => (execute_USDOT_ZA_ZZW_S2x2 256 esize m n nreg offset v)
  | 512 => (execute_USDOT_ZA_ZZW_S2x2 512 esize m n nreg offset v)
  | 1024 => (execute_USDOT_ZA_ZZW_S2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_USDOT_ZA_ZZW_S2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UDOT_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA_ZZV_2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_UDOT_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_UDOT_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_UDOT_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_UDOT_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UDOT_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SDOT_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA_ZZV_2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_SDOT_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_SDOT_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_SDOT_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_SDOT_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SDOT_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USDOT_ZA_ZZV_S2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USDOT_ZA_ZZV_S2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_USDOT_ZA_ZZV_S2x1 128 esize m n nreg offset v)
  | 256 => (execute_USDOT_ZA_ZZV_S2x1 256 esize m n nreg offset v)
  | 512 => (execute_USDOT_ZA_ZZV_S2x1 512 esize m n nreg offset v)
  | 1024 => (execute_USDOT_ZA_ZZV_S2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_USDOT_ZA_ZZV_S2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SUDOT_ZA_ZZV_S2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUDOT_ZA_ZZV_S2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_SUDOT_ZA_ZZV_S2x1 128 esize m n nreg offset v)
  | 256 => (execute_SUDOT_ZA_ZZV_S2x1 256 esize m n nreg offset v)
  | 512 => (execute_SUDOT_ZA_ZZV_S2x1 512 esize m n nreg offset v)
  | 1024 => (execute_SUDOT_ZA_ZZV_S2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SUDOT_ZA_ZZV_S2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UDOT_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA_ZZW_4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_UDOT_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_UDOT_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_UDOT_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_UDOT_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_UDOT_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SDOT_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA_ZZW_4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_SDOT_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_SDOT_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_SDOT_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_SDOT_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_SDOT_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USDOT_ZA_ZZW_S4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USDOT_ZA_ZZW_S4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_USDOT_ZA_ZZW_S4x4 128 esize m n nreg offset v)
  | 256 => (execute_USDOT_ZA_ZZW_S4x4 256 esize m n nreg offset v)
  | 512 => (execute_USDOT_ZA_ZZW_S4x4 512 esize m n nreg offset v)
  | 1024 => (execute_USDOT_ZA_ZZW_S4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_USDOT_ZA_ZZW_S4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UDOT_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA_ZZV_4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_UDOT_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_UDOT_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_UDOT_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_UDOT_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UDOT_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SDOT_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA_ZZV_4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_SDOT_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_SDOT_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_SDOT_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_SDOT_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SDOT_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USDOT_ZA_ZZV_S4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USDOT_ZA_ZZV_S4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_USDOT_ZA_ZZV_S4x1 128 esize m n nreg offset v)
  | 256 => (execute_USDOT_ZA_ZZV_S4x1 256 esize m n nreg offset v)
  | 512 => (execute_USDOT_ZA_ZZV_S4x1 512 esize m n nreg offset v)
  | 1024 => (execute_USDOT_ZA_ZZV_S4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_USDOT_ZA_ZZV_S4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SUDOT_ZA_ZZV_S4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUDOT_ZA_ZZV_S4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_SUDOT_ZA_ZZV_S4x1 128 esize m n nreg offset v)
  | 256 => (execute_SUDOT_ZA_ZZV_S4x1 256 esize m n nreg offset v)
  | 512 => (execute_SUDOT_ZA_ZZV_S4x1 512 esize m n nreg offset v)
  | 1024 => (execute_SUDOT_ZA_ZZV_S4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SUDOT_ZA_ZZV_S4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UDOT_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 2
  match VL with
  | 128 => (execute_UDOT_ZA_ZZi_S2xi 128 esize index m n nreg offset v)
  | 256 => (execute_UDOT_ZA_ZZi_S2xi 256 esize index m n nreg offset v)
  | 512 => (execute_UDOT_ZA_ZZi_S2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UDOT_ZA_ZZi_S2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UDOT_ZA_ZZi_S2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SDOT_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 2
  match VL with
  | 128 => (execute_SDOT_ZA_ZZi_S2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SDOT_ZA_ZZi_S2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SDOT_ZA_ZZi_S2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SDOT_ZA_ZZi_S2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SDOT_ZA_ZZi_S2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USDOT_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USDOT_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 2
  match VL with
  | 128 => (execute_USDOT_ZA_ZZi_S2xi 128 esize index m n nreg offset v)
  | 256 => (execute_USDOT_ZA_ZZi_S2xi 256 esize index m n nreg offset v)
  | 512 => (execute_USDOT_ZA_ZZi_S2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_USDOT_ZA_ZZi_S2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_USDOT_ZA_ZZi_S2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SUDOT_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUDOT_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 2
  match VL with
  | 128 => (execute_SUDOT_ZA_ZZi_S2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SUDOT_ZA_ZZi_S2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SUDOT_ZA_ZZi_S2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SUDOT_ZA_ZZi_S2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SUDOT_ZA_ZZi_S2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_UDOT_ZA_ZZi_D2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA_ZZi_D2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i1 : (BitVec 1)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i1)
  let nreg := 2
  match VL with
  | 128 => (execute_UDOT_ZA_ZZi_D2xi 128 esize index m n nreg offset v)
  | 256 => (execute_UDOT_ZA_ZZi_D2xi 256 esize index m n nreg offset v)
  | 512 => (execute_UDOT_ZA_ZZi_D2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UDOT_ZA_ZZi_D2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UDOT_ZA_ZZi_D2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_SDOT_ZA_ZZi_D2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA_ZZi_D2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i1 : (BitVec 1)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i1)
  let nreg := 2
  match VL with
  | 128 => (execute_SDOT_ZA_ZZi_D2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SDOT_ZA_ZZi_D2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SDOT_ZA_ZZi_D2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SDOT_ZA_ZZi_D2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SDOT_ZA_ZZi_D2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UDOT_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 4
  match VL with
  | 128 => (execute_UDOT_ZA_ZZi_S4xi 128 esize index m n nreg offset v)
  | 256 => (execute_UDOT_ZA_ZZi_S4xi 256 esize index m n nreg offset v)
  | 512 => (execute_UDOT_ZA_ZZi_S4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UDOT_ZA_ZZi_S4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UDOT_ZA_ZZi_S4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SDOT_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 4
  match VL with
  | 128 => (execute_SDOT_ZA_ZZi_S4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SDOT_ZA_ZZi_S4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SDOT_ZA_ZZi_S4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SDOT_ZA_ZZi_S4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SDOT_ZA_ZZi_S4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USDOT_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USDOT_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 4
  match VL with
  | 128 => (execute_USDOT_ZA_ZZi_S4xi 128 esize index m n nreg offset v)
  | 256 => (execute_USDOT_ZA_ZZi_S4xi 256 esize index m n nreg offset v)
  | 512 => (execute_USDOT_ZA_ZZi_S4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_USDOT_ZA_ZZi_S4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_USDOT_ZA_ZZi_S4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SUDOT_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUDOT_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 4
  match VL with
  | 128 => (execute_SUDOT_ZA_ZZi_S4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SUDOT_ZA_ZZi_S4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SUDOT_ZA_ZZi_S4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SUDOT_ZA_ZZi_S4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SUDOT_ZA_ZZi_S4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_UDOT_ZA_ZZi_D4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA_ZZi_D4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i1 : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i1)
  let nreg := 4
  match VL with
  | 128 => (execute_UDOT_ZA_ZZi_D4xi 128 esize index m n nreg offset v)
  | 256 => (execute_UDOT_ZA_ZZi_D4xi 256 esize index m n nreg offset v)
  | 512 => (execute_UDOT_ZA_ZZi_D4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UDOT_ZA_ZZi_D4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UDOT_ZA_ZZi_D4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_SDOT_ZA_ZZi_D4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA_ZZi_D4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i1 : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i1)
  let nreg := 4
  match VL with
  | 128 => (execute_SDOT_ZA_ZZi_D4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SDOT_ZA_ZZi_D4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SDOT_ZA_ZZi_D4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SDOT_ZA_ZZi_D4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SDOT_ZA_ZZi_D4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UVDOT_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name 4)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let operand1 ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i r) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UVDOT_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_UVDOT_ZA_ZZi_S4xi 128 esize index m n offset v)
  | 256 => (execute_UVDOT_ZA_ZZi_S4xi 256 esize index m n offset v)
  | 512 => (execute_UVDOT_ZA_ZZi_S4xi 512 esize index m n offset v)
  | 1024 => (execute_UVDOT_ZA_ZZi_S4xi 1024 esize index m n offset v)
  | 2048 => (execute_UVDOT_ZA_ZZi_S4xi 2048 esize index m n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SVDOT_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name 4)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let operand1 ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i r) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SVDOT_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_SVDOT_ZA_ZZi_S4xi 128 esize index m n offset v)
  | 256 => (execute_SVDOT_ZA_ZZi_S4xi 256 esize index m n offset v)
  | 512 => (execute_SVDOT_ZA_ZZi_S4xi 512 esize index m n offset v)
  | 1024 => (execute_SVDOT_ZA_ZZi_S4xi 1024 esize index m n offset v)
  | 2048 => (execute_SVDOT_ZA_ZZi_S4xi 2048 esize index m n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USVDOT_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name 4)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let operand1 ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i r) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USVDOT_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_USVDOT_ZA_ZZi_S4xi 128 esize index m n offset v)
  | 256 => (execute_USVDOT_ZA_ZZi_S4xi 256 esize index m n offset v)
  | 512 => (execute_USVDOT_ZA_ZZi_S4xi 512 esize index m n offset v)
  | 1024 => (execute_USVDOT_ZA_ZZi_S4xi 1024 esize index m n offset v)
  | 2048 => (execute_USVDOT_ZA_ZZi_S4xi 2048 esize index m n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SUVDOT_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name 4)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let operand1 ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i r) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUVDOT_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_SUVDOT_ZA_ZZi_S4xi 128 esize index m n offset v)
  | 256 => (execute_SUVDOT_ZA_ZZi_S4xi 256 esize index m n offset v)
  | 512 => (execute_SUVDOT_ZA_ZZi_S4xi 512 esize index m n offset v)
  | 1024 => (execute_SUVDOT_ZA_ZZi_S4xi 1024 esize index m n offset v)
  | 2048 => (execute_SUVDOT_ZA_ZZi_S4xi 2048 esize index m n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_UVDOT_ZA_ZZi_D4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name 4)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let operand1 ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i r) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UVDOT_ZA_ZZi_D4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i1 : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i1)
  match VL with
  | 128 => (execute_UVDOT_ZA_ZZi_D4xi 128 esize index m n offset v)
  | 256 => (execute_UVDOT_ZA_ZZi_D4xi 256 esize index m n offset v)
  | 512 => (execute_UVDOT_ZA_ZZi_D4xi 512 esize index m n offset v)
  | 1024 => (execute_UVDOT_ZA_ZZi_D4xi 1024 esize index m n offset v)
  | 2048 => (execute_UVDOT_ZA_ZZi_D4xi 2048 esize index m n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_SVDOT_ZA_ZZi_D4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name 4)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let operand1 ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i r) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SVDOT_ZA_ZZi_D4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i1 : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 64
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i1)
  match VL with
  | 128 => (execute_SVDOT_ZA_ZZi_D4xi 128 esize index m n offset v)
  | 256 => (execute_SVDOT_ZA_ZZi_D4xi 256 esize index m n offset v)
  | 512 => (execute_SVDOT_ZA_ZZi_D4xi 512 esize index m n offset v)
  | 1024 => (execute_SVDOT_ZA_ZZi_D4xi 1024 esize index m n offset v)
  | 2048 => (execute_SVDOT_ZA_ZZi_D4xi 2048 esize index m n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UDOT_ZA32_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA32_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_UDOT_ZA32_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_UDOT_ZA32_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_UDOT_ZA32_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_UDOT_ZA32_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_UDOT_ZA32_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SDOT_ZA32_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA32_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_SDOT_ZA32_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_SDOT_ZA32_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_SDOT_ZA32_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_SDOT_ZA32_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_SDOT_ZA32_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UDOT_ZA32_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA32_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_UDOT_ZA32_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_UDOT_ZA32_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_UDOT_ZA32_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_UDOT_ZA32_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UDOT_ZA32_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SDOT_ZA32_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA32_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_SDOT_ZA32_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_SDOT_ZA32_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_SDOT_ZA32_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_SDOT_ZA32_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SDOT_ZA32_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UDOT_ZA32_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA32_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_UDOT_ZA32_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_UDOT_ZA32_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_UDOT_ZA32_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_UDOT_ZA32_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_UDOT_ZA32_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SDOT_ZA32_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA32_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_SDOT_ZA32_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_SDOT_ZA32_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_SDOT_ZA32_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_SDOT_ZA32_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_SDOT_ZA32_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UDOT_ZA32_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA32_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_UDOT_ZA32_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_UDOT_ZA32_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_UDOT_ZA32_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_UDOT_ZA32_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UDOT_ZA32_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SDOT_ZA32_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA32_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_SDOT_ZA32_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_SDOT_ZA32_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_SDOT_ZA32_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_SDOT_ZA32_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SDOT_ZA32_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UDOT_ZA32_ZZi_2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i s) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA32_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 2
  match VL with
  | 128 => (execute_UDOT_ZA32_ZZi_2xi 128 esize index m n nreg offset v)
  | 256 => (execute_UDOT_ZA32_ZZi_2xi 256 esize index m n nreg offset v)
  | 512 => (execute_UDOT_ZA32_ZZi_2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UDOT_ZA32_ZZi_2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UDOT_ZA32_ZZi_2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SDOT_ZA32_ZZi_2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i s) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA32_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 2
  match VL with
  | 128 => (execute_SDOT_ZA32_ZZi_2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SDOT_ZA32_ZZi_2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SDOT_ZA32_ZZi_2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SDOT_ZA32_ZZi_2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SDOT_ZA32_ZZi_2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UDOT_ZA32_ZZi_4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i s) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UDOT_ZA32_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 4
  match VL with
  | 128 => (execute_UDOT_ZA32_ZZi_4xi 128 esize index m n nreg offset v)
  | 256 => (execute_UDOT_ZA32_ZZi_4xi 256 esize index m n nreg offset v)
  | 512 => (execute_UDOT_ZA32_ZZi_4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UDOT_ZA32_ZZi_4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UDOT_ZA32_ZZi_4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SDOT_ZA32_ZZi_4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i s) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SDOT_ZA32_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  let nreg := 4
  match VL with
  | 128 => (execute_SDOT_ZA32_ZZi_4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SDOT_ZA32_ZZi_4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SDOT_ZA32_ZZi_4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SDOT_ZA32_ZZi_4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SDOT_ZA32_ZZi_4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UVDOT_ZA32_ZZi_2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name 2)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let operand1 ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i r) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i s) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UVDOT_ZA32_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_UVDOT_ZA32_ZZi_2xi 128 esize index m n offset v)
  | 256 => (execute_UVDOT_ZA32_ZZi_2xi 256 esize index m n offset v)
  | 512 => (execute_UVDOT_ZA32_ZZi_2xi 512 esize index m n offset v)
  | 1024 => (execute_UVDOT_ZA32_ZZi_2xi 1024 esize index m n offset v)
  | 2048 => (execute_UVDOT_ZA32_ZZi_2xi 2048 esize index m n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SVDOT_ZA32_ZZi_2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name 2)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let sum ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let sum ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 1
                let mut loop_vars_2 := sum
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let sum := loop_vars_2
                  loop_vars_2 ← do
                    let operand1 ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i r) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i s) +i i) (Int.ediv esize 2)))))
                    (pure (BitVec.addInt sum (element1 *i element2)))
                (pure loop_vars_2) ) : SailM (BitVec esize) )
              (Elem_set result e esize sum)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SVDOT_ZA32_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i2 : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 32
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_SVDOT_ZA32_ZZi_2xi 128 esize index m n offset v)
  | 256 => (execute_SVDOT_ZA32_ZZi_2xi 256 esize index m n offset v)
  | 512 => (execute_SVDOT_ZA32_ZZi_2xi 512 esize index m n offset v)
  | 1024 => (execute_SVDOT_ZA32_ZZi_2xi 1024 esize index m n offset v)
  | 2048 => (execute_SVDOT_ZA32_ZZi_2xi 2048 esize index m n offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZV_1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZV_1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let nreg := 1
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZV_1 128 esize m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZV_1 256 esize m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZV_1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZV_1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZV_1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZV_1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZV_1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let nreg := 1
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZV_1 128 esize m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZV_1 256 esize m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZV_1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZV_1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZV_1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZV_1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZV_1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let nreg := 1
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZV_1 128 esize m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZV_1 256 esize m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZV_1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZV_1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZV_1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZV_1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZV_1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let nreg := 1
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZV_1 128 esize m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZV_1 256 esize m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZV_1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZV_1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZV_1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USMLALL_ZA_ZZV_S (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USMLALL_ZA_ZZV_S (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let nreg := 1
  match VL with
  | 128 => (execute_USMLALL_ZA_ZZV_S 128 esize m n nreg offset v)
  | 256 => (execute_USMLALL_ZA_ZZV_S 256 esize m n nreg offset v)
  | 512 => (execute_USMLALL_ZA_ZZV_S 512 esize m n nreg offset v)
  | 1024 => (execute_USMLALL_ZA_ZZV_S 1024 esize m n nreg offset v)
  | 2048 => (execute_USMLALL_ZA_ZZV_S 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZW_2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZW_2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZW_2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZW_2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USMLALL_ZA_ZZW_S2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USMLALL_ZA_ZZW_S2x2 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_USMLALL_ZA_ZZW_S2x2 128 esize m n nreg offset v)
  | 256 => (execute_USMLALL_ZA_ZZW_S2x2 256 esize m n nreg offset v)
  | 512 => (execute_USMLALL_ZA_ZZW_S2x2 512 esize m n nreg offset v)
  | 1024 => (execute_USMLALL_ZA_ZZW_S2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_USMLALL_ZA_ZZW_S2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZV_2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZV_2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZV_2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZV_2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USMLALL_ZA_ZZV_S2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USMLALL_ZA_ZZV_S2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_USMLALL_ZA_ZZV_S2x1 128 esize m n nreg offset v)
  | 256 => (execute_USMLALL_ZA_ZZV_S2x1 256 esize m n nreg offset v)
  | 512 => (execute_USMLALL_ZA_ZZV_S2x1 512 esize m n nreg offset v)
  | 1024 => (execute_USMLALL_ZA_ZZV_S2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_USMLALL_ZA_ZZV_S2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SUMLALL_ZA_ZZV_S2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUMLALL_ZA_ZZV_S2x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 2
  match VL with
  | 128 => (execute_SUMLALL_ZA_ZZV_S2x1 128 esize m n nreg offset v)
  | 256 => (execute_SUMLALL_ZA_ZZV_S2x1 256 esize m n nreg offset v)
  | 512 => (execute_SUMLALL_ZA_ZZV_S2x1 512 esize m n nreg offset v)
  | 1024 => (execute_SUMLALL_ZA_ZZV_S2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SUMLALL_ZA_ZZV_S2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZW_4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZW_4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZW_4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZW_4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USMLALL_ZA_ZZW_S4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USMLALL_ZA_ZZW_S4x4 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_USMLALL_ZA_ZZW_S4x4 128 esize m n nreg offset v)
  | 256 => (execute_USMLALL_ZA_ZZW_S4x4 256 esize m n nreg offset v)
  | 512 => (execute_USMLALL_ZA_ZZW_S4x4 512 esize m n nreg offset v)
  | 1024 => (execute_USMLALL_ZA_ZZW_S4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_USMLALL_ZA_ZZW_S4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZV_4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZV_4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZV_4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZV_4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sz == (0b1 : (BitVec 1))) && (! (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USMLALL_ZA_ZZV_S4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USMLALL_ZA_ZZV_S4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_USMLALL_ZA_ZZV_S4x1 128 esize m n nreg offset v)
  | 256 => (execute_USMLALL_ZA_ZZV_S4x1 256 esize m n nreg offset v)
  | 512 => (execute_USMLALL_ZA_ZZV_S4x1 512 esize m n nreg offset v)
  | 1024 => (execute_USMLALL_ZA_ZZV_S4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_USMLALL_ZA_ZZV_S4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SUMLALL_ZA_ZZV_S4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUMLALL_ZA_ZZV_S4x1 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_SUMLALL_ZA_ZZV_S4x1 128 esize m n nreg offset v)
  | 256 => (execute_SUMLALL_ZA_ZZV_S4x1 256 esize m n nreg offset v)
  | 512 => (execute_SUMLALL_ZA_ZZV_S4x1 512 esize m n nreg offset v)
  | 1024 => (execute_SUMLALL_ZA_ZZV_S4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SUMLALL_ZA_ZZV_S4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZi_S (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZi_S (Zm : (BitVec 4)) (i4h : (BitVec 1)) (Rv : (BitVec 2)) (i4l : (BitVec 3)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 1
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZi_S 128 esize index m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZi_S 256 esize index m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZi_S 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZi_S 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZi_S 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZi_S (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZi_S (Zm : (BitVec 4)) (i4h : (BitVec 1)) (Rv : (BitVec 2)) (i4l : (BitVec 3)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 1
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZi_S 128 esize index m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZi_S 256 esize index m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZi_S 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZi_S 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZi_S 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZi_S (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZi_S (Zm : (BitVec 4)) (i4h : (BitVec 1)) (Rv : (BitVec 2)) (i4l : (BitVec 3)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 1
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZi_S 128 esize index m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZi_S 256 esize index m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZi_S 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZi_S 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZi_S 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZi_S (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZi_S (Zm : (BitVec 4)) (i4h : (BitVec 1)) (Rv : (BitVec 2)) (i4l : (BitVec 3)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 1
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZi_S 128 esize index m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZi_S 256 esize index m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZi_S 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZi_S 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZi_S 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USMLALL_ZA_ZZi_S (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USMLALL_ZA_ZZi_S (Zm : (BitVec 4)) (i4h : (BitVec 1)) (Rv : (BitVec 2)) (i4l : (BitVec 3)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 1
  match VL with
  | 128 => (execute_USMLALL_ZA_ZZi_S 128 esize index m n nreg offset v)
  | 256 => (execute_USMLALL_ZA_ZZi_S 256 esize index m n nreg offset v)
  | 512 => (execute_USMLALL_ZA_ZZi_S 512 esize index m n nreg offset v)
  | 1024 => (execute_USMLALL_ZA_ZZi_S 1024 esize index m n nreg offset v)
  | 2048 => (execute_USMLALL_ZA_ZZi_S 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SUMLALL_ZA_ZZi_S (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUMLALL_ZA_ZZi_S (Zm : (BitVec 4)) (i4h : (BitVec 1)) (Rv : (BitVec 2)) (i4l : (BitVec 3)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 1
  match VL with
  | 128 => (execute_SUMLALL_ZA_ZZi_S 128 esize index m n nreg offset v)
  | 256 => (execute_SUMLALL_ZA_ZZi_S 256 esize index m n nreg offset v)
  | 512 => (execute_SUMLALL_ZA_ZZi_S 512 esize index m n nreg offset v)
  | 1024 => (execute_SUMLALL_ZA_ZZi_S 1024 esize index m n nreg offset v)
  | 2048 => (execute_SUMLALL_ZA_ZZi_S 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZi_D (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZi_D (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 1
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZi_D 128 esize index m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZi_D 256 esize index m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZi_D 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZi_D 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZi_D 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZi_D (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZi_D (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 1
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZi_D 128 esize index m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZi_D 256 esize index m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZi_D 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZi_D 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZi_D 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZi_D (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZi_D (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 1
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZi_D 128 esize index m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZi_D 256 esize index m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZi_D 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZi_D 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZi_D 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZi_D (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZi_D (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 1
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZi_D 128 esize index m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZi_D 256 esize index m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZi_D 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZi_D 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZi_D 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZi_S2xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZi_S2xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZi_S2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZi_S2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZi_S2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZi_S2xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZi_S2xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZi_S2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZi_S2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZi_S2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZi_S2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZi_S2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZi_S2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZi_S2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZi_S2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZi_S2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZi_S2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZi_S2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZi_S2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZi_S2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USMLALL_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USMLALL_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 2
  match VL with
  | 128 => (execute_USMLALL_ZA_ZZi_S2xi 128 esize index m n nreg offset v)
  | 256 => (execute_USMLALL_ZA_ZZi_S2xi 256 esize index m n nreg offset v)
  | 512 => (execute_USMLALL_ZA_ZZi_S2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_USMLALL_ZA_ZZi_S2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_USMLALL_ZA_ZZi_S2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SUMLALL_ZA_ZZi_S2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUMLALL_ZA_ZZi_S2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 2
  match VL with
  | 128 => (execute_SUMLALL_ZA_ZZi_S2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SUMLALL_ZA_ZZi_S2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SUMLALL_ZA_ZZi_S2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SUMLALL_ZA_ZZi_S2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SUMLALL_ZA_ZZi_S2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZi_D2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZi_D2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 1)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZi_D2xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZi_D2xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZi_D2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZi_D2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZi_D2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZi_D2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZi_D2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 1)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZi_D2xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZi_D2xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZi_D2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZi_D2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZi_D2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZi_D2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZi_D2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 1)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZi_D2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZi_D2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZi_D2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZi_D2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZi_D2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZi_D2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZi_D2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 1)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZi_D2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZi_D2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZi_D2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZi_D2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZi_D2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZi_S4xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZi_S4xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZi_S4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZi_S4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZi_S4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZi_S4xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZi_S4xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZi_S4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZi_S4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZi_S4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZi_S4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZi_S4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZi_S4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZi_S4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZi_S4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZi_S4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZi_S4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZi_S4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZi_S4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZi_S4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_USMLALL_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_USMLALL_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 4
  match VL with
  | 128 => (execute_USMLALL_ZA_ZZi_S4xi 128 esize index m n nreg offset v)
  | 256 => (execute_USMLALL_ZA_ZZi_S4xi 256 esize index m n nreg offset v)
  | 512 => (execute_USMLALL_ZA_ZZi_S4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_USMLALL_ZA_ZZi_S4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_USMLALL_ZA_ZZi_S4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ index ∧ index ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SUMLALL_ZA_ZZi_S4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SUMLALL_ZA_ZZi_S4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i4h : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i4l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i4h ++ i4l))
  let nreg := 4
  match VL with
  | 128 => (execute_SUMLALL_ZA_ZZi_S4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SUMLALL_ZA_ZZi_S4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SUMLALL_ZA_ZZi_S4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SUMLALL_ZA_ZZi_S4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SUMLALL_ZA_ZZi_S4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_UMLALL_ZA_ZZi_D4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLALL_ZA_ZZi_D4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLALL_ZA_ZZi_D4xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLALL_ZA_ZZi_D4xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLALL_ZA_ZZi_D4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLALL_ZA_ZZi_D4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLALL_ZA_ZZi_D4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_UMLSLL_ZA_ZZi_D4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSLL_ZA_ZZi_D4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLSLL_ZA_ZZi_D4xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLSLL_ZA_ZZi_D4xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLSLL_ZA_ZZi_D4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLSLL_ZA_ZZi_D4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLSLL_ZA_ZZi_D4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_SMLALL_ZA_ZZi_D4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLALL_ZA_ZZi_D4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLALL_ZA_ZZi_D4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLALL_ZA_ZZi_D4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLALL_ZA_ZZi_D4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLALL_ZA_ZZi_D4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLALL_ZA_ZZi_D4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_SMLSLL_ZA_ZZi_D4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 4))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((4 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 4)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSLL_ZA_ZZi_D4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! ((← (HaveSME2 ())) && (← (HaveSMEI16I64 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLSLL_ZA_ZZi_D4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLSLL_ZA_ZZi_D4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLSLL_ZA_ZZi_D4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLSLL_ZA_ZZi_D4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLSLL_ZA_ZZi_D4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLAL_ZA_ZZV_1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLAL_ZA_ZZV_1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let nreg := 1
  match VL with
  | 128 => (execute_UMLAL_ZA_ZZV_1 128 esize m n nreg offset v)
  | 256 => (execute_UMLAL_ZA_ZZV_1 256 esize m n nreg offset v)
  | 512 => (execute_UMLAL_ZA_ZZV_1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLAL_ZA_ZZV_1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLAL_ZA_ZZV_1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSL_ZA_ZZV_1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSL_ZA_ZZV_1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let nreg := 1
  match VL with
  | 128 => (execute_UMLSL_ZA_ZZV_1 128 esize m n nreg offset v)
  | 256 => (execute_UMLSL_ZA_ZZV_1 256 esize m n nreg offset v)
  | 512 => (execute_UMLSL_ZA_ZZV_1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLSL_ZA_ZZV_1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLSL_ZA_ZZV_1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLAL_ZA_ZZV_1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLAL_ZA_ZZV_1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let nreg := 1
  match VL with
  | 128 => (execute_SMLAL_ZA_ZZV_1 128 esize m n nreg offset v)
  | 256 => (execute_SMLAL_ZA_ZZV_1 256 esize m n nreg offset v)
  | 512 => (execute_SMLAL_ZA_ZZV_1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLAL_ZA_ZZV_1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLAL_ZA_ZZV_1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSL_ZA_ZZV_1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSL_ZA_ZZV_1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let nreg := 1
  match VL with
  | 128 => (execute_SMLSL_ZA_ZZV_1 128 esize m n nreg offset v)
  | 256 => (execute_SMLSL_ZA_ZZV_1 256 esize m n nreg offset v)
  | 512 => (execute_SMLSL_ZA_ZZV_1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLSL_ZA_ZZV_1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLSL_ZA_ZZV_1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLAL_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLAL_ZA_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLAL_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_UMLAL_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_UMLAL_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_UMLAL_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLAL_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSL_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSL_ZA_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLSL_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_UMLSL_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_UMLSL_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_UMLSL_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLSL_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLAL_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLAL_ZA_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLAL_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_SMLAL_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_SMLAL_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_SMLAL_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLAL_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSL_ZA_ZZW_2x2 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSL_ZA_ZZW_2x2 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLSL_ZA_ZZW_2x2 128 esize m n nreg offset v)
  | 256 => (execute_SMLSL_ZA_ZZW_2x2 256 esize m n nreg offset v)
  | 512 => (execute_SMLSL_ZA_ZZW_2x2 512 esize m n nreg offset v)
  | 1024 => (execute_SMLSL_ZA_ZZW_2x2 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLSL_ZA_ZZW_2x2 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLAL_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLAL_ZA_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLAL_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_UMLAL_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_UMLAL_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLAL_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLAL_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSL_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSL_ZA_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLSL_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_UMLSL_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_UMLSL_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLSL_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLSL_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLAL_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLAL_ZA_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLAL_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_SMLAL_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_SMLAL_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLAL_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLAL_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSL_ZA_ZZV_2x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSL_ZA_ZZV_2x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLSL_ZA_ZZV_2x1 128 esize m n nreg offset v)
  | 256 => (execute_SMLSL_ZA_ZZV_2x1 256 esize m n nreg offset v)
  | 512 => (execute_SMLSL_ZA_ZZV_2x1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLSL_ZA_ZZV_2x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLSL_ZA_ZZV_2x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLAL_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLAL_ZA_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLAL_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_UMLAL_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_UMLAL_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_UMLAL_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLAL_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSL_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSL_ZA_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLSL_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_UMLSL_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_UMLSL_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_UMLSL_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLSL_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLAL_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLAL_ZA_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLAL_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_SMLAL_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_SMLAL_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_SMLAL_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLAL_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSL_ZA_ZZW_4x4 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSL_ZA_ZZW_4x4 (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLSL_ZA_ZZW_4x4 128 esize m n nreg offset v)
  | 256 => (execute_SMLSL_ZA_ZZW_4x4 256 esize m n nreg offset v)
  | 512 => (execute_SMLSL_ZA_ZZW_4x4 512 esize m n nreg offset v)
  | 1024 => (execute_SMLSL_ZA_ZZW_4x4 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLSL_ZA_ZZW_4x4 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLAL_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLAL_ZA_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLAL_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_UMLAL_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_UMLAL_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLAL_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLAL_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSL_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSL_ZA_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLSL_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_UMLSL_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_UMLSL_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_UMLSL_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_UMLSL_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLAL_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLAL_ZA_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLAL_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_SMLAL_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_SMLAL_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLAL_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLAL_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSL_ZA_ZZV_4x1 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSL_ZA_ZZV_4x1 (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLSL_ZA_ZZV_4x1 128 esize m n nreg offset v)
  | 256 => (execute_SMLSL_ZA_ZZV_4x1 256 esize m n nreg offset v)
  | 512 => (execute_SMLSL_ZA_ZZV_4x1 512 esize m n nreg offset v)
  | 1024 => (execute_SMLSL_ZA_ZZV_4x1 1024 esize m n nreg offset v)
  | 2048 => (execute_SMLSL_ZA_ZZV_4x1 2048 esize m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLAL_ZA_ZZi_1 (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLAL_ZA_ZZi_1 (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 1
  match VL with
  | 128 => (execute_UMLAL_ZA_ZZi_1 128 esize index m n nreg offset v)
  | 256 => (execute_UMLAL_ZA_ZZi_1 256 esize index m n nreg offset v)
  | 512 => (execute_UMLAL_ZA_ZZi_1 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLAL_ZA_ZZi_1 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLAL_ZA_ZZi_1 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSL_ZA_ZZi_1 (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSL_ZA_ZZi_1 (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 1
  match VL with
  | 128 => (execute_UMLSL_ZA_ZZi_1 128 esize index m n nreg offset v)
  | 256 => (execute_UMLSL_ZA_ZZi_1 256 esize index m n nreg offset v)
  | 512 => (execute_UMLSL_ZA_ZZi_1 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLSL_ZA_ZZi_1 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLSL_ZA_ZZi_1 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLAL_ZA_ZZi_1 (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLAL_ZA_ZZi_1 (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 1
  match VL with
  | 128 => (execute_SMLAL_ZA_ZZi_1 128 esize index m n nreg offset v)
  | 256 => (execute_SMLAL_ZA_ZZi_1 256 esize index m n nreg offset v)
  | 512 => (execute_SMLAL_ZA_ZZi_1 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLAL_ZA_ZZi_1 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLAL_ZA_ZZi_1 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧
  nreg = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSL_ZA_ZZi_1 (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSL_ZA_ZZi_1 (Zm : (BitVec 4)) (i3h : (BitVec 1)) (Rv : (BitVec 2)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (U : (BitVec 1)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 1
  match VL with
  | 128 => (execute_SMLSL_ZA_ZZi_1 128 esize index m n nreg offset v)
  | 256 => (execute_SMLSL_ZA_ZZi_1 256 esize index m n nreg offset v)
  | 512 => (execute_SMLSL_ZA_ZZi_1 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLSL_ZA_ZZi_1 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLSL_ZA_ZZi_1 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLAL_ZA_ZZi_2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLAL_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLAL_ZA_ZZi_2xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLAL_ZA_ZZi_2xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLAL_ZA_ZZi_2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLAL_ZA_ZZi_2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLAL_ZA_ZZi_2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSL_ZA_ZZi_2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSL_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 2
  match VL with
  | 128 => (execute_UMLSL_ZA_ZZi_2xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLSL_ZA_ZZi_2xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLSL_ZA_ZZi_2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLSL_ZA_ZZi_2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLSL_ZA_ZZi_2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLAL_ZA_ZZi_2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLAL_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLAL_ZA_ZZi_2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLAL_ZA_ZZi_2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLAL_ZA_ZZi_2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLAL_ZA_ZZi_2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLAL_ZA_ZZi_2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSL_ZA_ZZi_2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSL_ZA_ZZi_2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 2
  match VL with
  | 128 => (execute_SMLSL_ZA_ZZi_2xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLSL_ZA_ZZi_2xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLSL_ZA_ZZi_2xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLSL_ZA_ZZi_2xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLSL_ZA_ZZi_2xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLAL_ZA_ZZi_4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLAL_ZA_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLAL_ZA_ZZi_4xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLAL_ZA_ZZi_4xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLAL_ZA_ZZi_4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLAL_ZA_ZZi_4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLAL_ZA_ZZi_4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_UMLSL_ZA_ZZi_4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toNat (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_UMLSL_ZA_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 4
  match VL with
  | 128 => (execute_UMLSL_ZA_ZZi_4xi 128 esize index m n nreg offset v)
  | 256 => (execute_UMLSL_ZA_ZZi_4xi 256 esize index m n nreg offset v)
  | 512 => (execute_UMLSL_ZA_ZZi_4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_UMLSL_ZA_ZZi_4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_UMLSL_ZA_ZZi_4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLAL_ZA_ZZi_4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLAL_ZA_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLAL_ZA_ZZi_4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLAL_ZA_ZZi_4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLAL_ZA_ZZi_4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLAL_ZA_ZZi_4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLAL_ZA_ZZi_4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, v
  : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_SMLSL_ZA_ZZi_4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let vec : Int := (vec -i (fmod_int vec 2))
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let vec := vec
        let result ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := result
          for i in [loop_i_lower:loop_i_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let operand3 ← (( do (ZAvector_read (vec +i i) VL) ) : SailM (BitVec VL) )
              let result ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements -i 1)
                let mut loop_vars_2 := result
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let result := loop_vars_2
                  loop_vars_2 ← do
                    let segmentbase := (e -i (Nat.div e eltspersegment))
                    let s := ((2 *i segmentbase) +i index)
                    let element1 ← do
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
                    let element2 ← do
                      (pure (BitVec.toInt (← (Elem_read operand2 s (Int.ediv esize 2)))))
                    let product : (BitVec esize) :=
                      (integer_subrange (element1 *i element2) (esize -i 1) 0)
                    (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product))
                (pure loop_vars_2) ) : SailM (BitVec VL) )
              (ZAvector_set (vec +i i) VL result)
              (pure result)
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (pure ())
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_SMLSL_ZA_ZZi_4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (U : (BitVec 1)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let index := (BitVec.toNat (i3h ++ i3l))
  let nreg := 4
  match VL with
  | 128 => (execute_SMLSL_ZA_ZZi_4xi 128 esize index m n nreg offset v)
  | 256 => (execute_SMLSL_ZA_ZZi_4xi 256 esize index m n nreg offset v)
  | 512 => (execute_SMLSL_ZA_ZZi_4xi 512 esize index m n nreg offset v)
  | 1024 => (execute_SMLSL_ZA_ZZi_4xi 1024 esize index m n nreg offset v)
  | 2048 => (execute_SMLSL_ZA_ZZi_4xi 2048 esize index m n nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMAX_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Max.max element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UMAX_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMAX_MZ_ZZW_2x2 128 dn esize m nreg is_unsigned)
  | 256 => (execute_UMAX_MZ_ZZW_2x2 256 dn esize m nreg is_unsigned)
  | 512 => (execute_UMAX_MZ_ZZW_2x2 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_UMAX_MZ_ZZW_2x2 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_UMAX_MZ_ZZW_2x2 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMAX_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Max.max element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SMAX_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMAX_MZ_ZZW_2x2 128 dn esize m nreg is_unsigned)
  | 256 => (execute_SMAX_MZ_ZZW_2x2 256 dn esize m nreg is_unsigned)
  | 512 => (execute_SMAX_MZ_ZZW_2x2 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_SMAX_MZ_ZZW_2x2 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_SMAX_MZ_ZZW_2x2 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMAX_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Max.max element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UMAX_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMAX_MZ_ZZV_2x1 128 dn esize m nreg is_unsigned)
  | 256 => (execute_UMAX_MZ_ZZV_2x1 256 dn esize m nreg is_unsigned)
  | 512 => (execute_UMAX_MZ_ZZV_2x1 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_UMAX_MZ_ZZV_2x1 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_UMAX_MZ_ZZV_2x1 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMAX_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Max.max element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SMAX_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMAX_MZ_ZZV_2x1 128 dn esize m nreg is_unsigned)
  | 256 => (execute_SMAX_MZ_ZZV_2x1 256 dn esize m nreg is_unsigned)
  | 512 => (execute_SMAX_MZ_ZZV_2x1 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_SMAX_MZ_ZZV_2x1 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_SMAX_MZ_ZZV_2x1 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMAX_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Max.max element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UMAX_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMAX_MZ_ZZW_4x4 128 dn esize m nreg is_unsigned)
  | 256 => (execute_UMAX_MZ_ZZW_4x4 256 dn esize m nreg is_unsigned)
  | 512 => (execute_UMAX_MZ_ZZW_4x4 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_UMAX_MZ_ZZW_4x4 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_UMAX_MZ_ZZW_4x4 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMAX_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Max.max element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SMAX_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMAX_MZ_ZZW_4x4 128 dn esize m nreg is_unsigned)
  | 256 => (execute_SMAX_MZ_ZZW_4x4 256 dn esize m nreg is_unsigned)
  | 512 => (execute_SMAX_MZ_ZZW_4x4 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_SMAX_MZ_ZZW_4x4 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_SMAX_MZ_ZZW_4x4 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMAX_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Max.max element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UMAX_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMAX_MZ_ZZV_4x1 128 dn esize m nreg is_unsigned)
  | 256 => (execute_UMAX_MZ_ZZV_4x1 256 dn esize m nreg is_unsigned)
  | 512 => (execute_UMAX_MZ_ZZV_4x1 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_UMAX_MZ_ZZV_4x1 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_UMAX_MZ_ZZV_4x1 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMAX_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Max.max element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SMAX_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMAX_MZ_ZZV_4x1 128 dn esize m nreg is_unsigned)
  | 256 => (execute_SMAX_MZ_ZZV_4x1 256 dn esize m nreg is_unsigned)
  | 512 => (execute_SMAX_MZ_ZZV_4x1 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_SMAX_MZ_ZZV_4x1 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_SMAX_MZ_ZZV_4x1 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMIN_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Min.min element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UMIN_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMIN_MZ_ZZW_2x2 128 dn esize m nreg is_unsigned)
  | 256 => (execute_UMIN_MZ_ZZW_2x2 256 dn esize m nreg is_unsigned)
  | 512 => (execute_UMIN_MZ_ZZW_2x2 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_UMIN_MZ_ZZW_2x2 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_UMIN_MZ_ZZW_2x2 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMIN_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Min.min element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SMIN_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMIN_MZ_ZZW_2x2 128 dn esize m nreg is_unsigned)
  | 256 => (execute_SMIN_MZ_ZZW_2x2 256 dn esize m nreg is_unsigned)
  | 512 => (execute_SMIN_MZ_ZZW_2x2 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_SMIN_MZ_ZZW_2x2 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_SMIN_MZ_ZZW_2x2 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMIN_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Min.min element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UMIN_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMIN_MZ_ZZV_2x1 128 dn esize m nreg is_unsigned)
  | 256 => (execute_UMIN_MZ_ZZV_2x1 256 dn esize m nreg is_unsigned)
  | 512 => (execute_UMIN_MZ_ZZV_2x1 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_UMIN_MZ_ZZV_2x1 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_UMIN_MZ_ZZV_2x1 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMIN_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Min.min element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SMIN_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMIN_MZ_ZZV_2x1 128 dn esize m nreg is_unsigned)
  | 256 => (execute_SMIN_MZ_ZZV_2x1 256 dn esize m nreg is_unsigned)
  | 512 => (execute_SMIN_MZ_ZZV_2x1 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_SMIN_MZ_ZZV_2x1 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_SMIN_MZ_ZZV_2x1 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMIN_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Min.min element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UMIN_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMIN_MZ_ZZW_4x4 128 dn esize m nreg is_unsigned)
  | 256 => (execute_UMIN_MZ_ZZW_4x4 256 dn esize m nreg is_unsigned)
  | 512 => (execute_UMIN_MZ_ZZW_4x4 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_UMIN_MZ_ZZW_4x4 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_UMIN_MZ_ZZW_4x4 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMIN_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Min.min element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SMIN_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMIN_MZ_ZZW_4x4 128 dn esize m nreg is_unsigned)
  | 256 => (execute_SMIN_MZ_ZZW_4x4 256 dn esize m nreg is_unsigned)
  | 512 => (execute_SMIN_MZ_ZZW_4x4 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_SMIN_MZ_ZZW_4x4 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_SMIN_MZ_ZZW_4x4 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMIN_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Min.min element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UMIN_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMIN_MZ_ZZV_4x1 128 dn esize m nreg is_unsigned)
  | 256 => (execute_UMIN_MZ_ZZV_4x1 256 dn esize m nreg is_unsigned)
  | 512 => (execute_UMIN_MZ_ZZV_4x1 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_UMIN_MZ_ZZV_4x1 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_UMIN_MZ_ZZV_4x1 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, nreg : Nat, nreg
  = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMIN_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let res := (Min.min element1 element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SMIN_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMIN_MZ_ZZV_4x1 128 dn esize m nreg is_unsigned)
  | 256 => (execute_SMIN_MZ_ZZV_4x1 256 dn esize m nreg is_unsigned)
  | 512 => (execute_SMIN_MZ_ZZV_4x1 512 dn esize m nreg is_unsigned)
  | 1024 => (execute_SMIN_MZ_ZZV_4x1 1024 dn esize m nreg is_unsigned)
  | 2048 => (execute_SMIN_MZ_ZZV_4x1 2048 dn esize m nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_URSHL_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_URSHL_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_URSHL_MZ_ZZW_2x2 128 dn esize m nreg)
  | 256 => (execute_URSHL_MZ_ZZW_2x2 256 dn esize m nreg)
  | 512 => (execute_URSHL_MZ_ZZW_2x2 512 dn esize m nreg)
  | 1024 => (execute_URSHL_MZ_ZZW_2x2 1024 dn esize m nreg)
  | 2048 => (execute_URSHL_MZ_ZZW_2x2 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SRSHL_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SRSHL_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_SRSHL_MZ_ZZW_2x2 128 dn esize m nreg)
  | 256 => (execute_SRSHL_MZ_ZZW_2x2 256 dn esize m nreg)
  | 512 => (execute_SRSHL_MZ_ZZW_2x2 512 dn esize m nreg)
  | 1024 => (execute_SRSHL_MZ_ZZW_2x2 1024 dn esize m nreg)
  | 2048 => (execute_SRSHL_MZ_ZZW_2x2 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_URSHL_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_URSHL_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_URSHL_MZ_ZZV_2x1 128 dn esize m nreg)
  | 256 => (execute_URSHL_MZ_ZZV_2x1 256 dn esize m nreg)
  | 512 => (execute_URSHL_MZ_ZZV_2x1 512 dn esize m nreg)
  | 1024 => (execute_URSHL_MZ_ZZV_2x1 1024 dn esize m nreg)
  | 2048 => (execute_URSHL_MZ_ZZV_2x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SRSHL_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SRSHL_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_SRSHL_MZ_ZZV_2x1 128 dn esize m nreg)
  | 256 => (execute_SRSHL_MZ_ZZV_2x1 256 dn esize m nreg)
  | 512 => (execute_SRSHL_MZ_ZZV_2x1 512 dn esize m nreg)
  | 1024 => (execute_SRSHL_MZ_ZZV_2x1 1024 dn esize m nreg)
  | 2048 => (execute_SRSHL_MZ_ZZV_2x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_URSHL_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_URSHL_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_URSHL_MZ_ZZW_4x4 128 dn esize m nreg)
  | 256 => (execute_URSHL_MZ_ZZW_4x4 256 dn esize m nreg)
  | 512 => (execute_URSHL_MZ_ZZW_4x4 512 dn esize m nreg)
  | 1024 => (execute_URSHL_MZ_ZZW_4x4 1024 dn esize m nreg)
  | 2048 => (execute_URSHL_MZ_ZZW_4x4 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SRSHL_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SRSHL_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_SRSHL_MZ_ZZW_4x4 128 dn esize m nreg)
  | 256 => (execute_SRSHL_MZ_ZZW_4x4 256 dn esize m nreg)
  | 512 => (execute_SRSHL_MZ_ZZW_4x4 512 dn esize m nreg)
  | 1024 => (execute_SRSHL_MZ_ZZW_4x4 1024 dn esize m nreg)
  | 2048 => (execute_SRSHL_MZ_ZZW_4x4 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_URSHL_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_URSHL_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_URSHL_MZ_ZZV_4x1 128 dn esize m nreg)
  | 256 => (execute_URSHL_MZ_ZZV_4x1 256 dn esize m nreg)
  | 512 => (execute_URSHL_MZ_ZZV_4x1 512 dn esize m nreg)
  | 1024 => (execute_URSHL_MZ_ZZV_4x1 1024 dn esize m nreg)
  | 2048 => (execute_URSHL_MZ_ZZV_4x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SRSHL_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SRSHL_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_SRSHL_MZ_ZZV_4x1 128 dn esize m nreg)
  | 256 => (execute_SRSHL_MZ_ZZV_4x1 256 dn esize m nreg)
  | 512 => (execute_SRSHL_MZ_ZZV_4x1 512 dn esize m nreg)
  | 1024 => (execute_SRSHL_MZ_ZZV_4x1 1024 dn esize m nreg)
  | 2048 => (execute_SRSHL_MZ_ZZV_4x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULH_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
            let res := ((2 *i element1) *i element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (SignedSat (Int.shiftr res esize) esize))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SQDMULH_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_SQDMULH_MZ_ZZW_2x2 128 dn esize m nreg)
  | 256 => (execute_SQDMULH_MZ_ZZW_2x2 256 dn esize m nreg)
  | 512 => (execute_SQDMULH_MZ_ZZW_2x2 512 dn esize m nreg)
  | 1024 => (execute_SQDMULH_MZ_ZZW_2x2 1024 dn esize m nreg)
  | 2048 => (execute_SQDMULH_MZ_ZZW_2x2 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULH_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
            let res := ((2 *i element1) *i element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (SignedSat (Int.shiftr res esize) esize))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SQDMULH_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_SQDMULH_MZ_ZZV_2x1 128 dn esize m nreg)
  | 256 => (execute_SQDMULH_MZ_ZZV_2x1 256 dn esize m nreg)
  | 512 => (execute_SQDMULH_MZ_ZZV_2x1 512 dn esize m nreg)
  | 1024 => (execute_SQDMULH_MZ_ZZV_2x1 1024 dn esize m nreg)
  | 2048 => (execute_SQDMULH_MZ_ZZV_2x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULH_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
            let res := ((2 *i element1) *i element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (SignedSat (Int.shiftr res esize) esize))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SQDMULH_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_SQDMULH_MZ_ZZW_4x4 128 dn esize m nreg)
  | 256 => (execute_SQDMULH_MZ_ZZW_4x4 256 dn esize m nreg)
  | 512 => (execute_SQDMULH_MZ_ZZW_4x4 512 dn esize m nreg)
  | 1024 => (execute_SQDMULH_MZ_ZZW_4x4 1024 dn esize m nreg)
  | 2048 => (execute_SQDMULH_MZ_ZZW_4x4 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULH_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
            let res := ((2 *i element1) *i element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (← (SignedSat (Int.shiftr res esize) esize))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SQDMULH_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_SQDMULH_MZ_ZZV_4x1 128 dn esize m nreg)
  | 256 => (execute_SQDMULH_MZ_ZZV_4x1 256 dn esize m nreg)
  | 512 => (execute_SQDMULH_MZ_ZZV_4x1 512 dn esize m nreg)
  | 1024 => (execute_SQDMULH_MZ_ZZV_4x1 1024 dn esize m nreg)
  | 2048 => (execute_SQDMULH_MZ_ZZV_4x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ADD_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize (element1 + element2)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_ADD_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_ADD_MZ_ZZV_2x1 128 dn esize m nreg)
  | 256 => (execute_ADD_MZ_ZZV_2x1 256 dn esize m nreg)
  | 512 => (execute_ADD_MZ_ZZV_2x1 512 dn esize m nreg)
  | 1024 => (execute_ADD_MZ_ZZV_2x1 1024 dn esize m nreg)
  | 2048 => (execute_ADD_MZ_ZZV_2x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ADD_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize (element1 + element2)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_ADD_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_ADD_MZ_ZZV_4x1 128 dn esize m nreg)
  | 256 => (execute_ADD_MZ_ZZV_4x1 256 dn esize m nreg)
  | 512 => (execute_ADD_MZ_ZZV_4x1 512 dn esize m nreg)
  | 1024 => (execute_ADD_MZ_ZZV_4x1 1024 dn esize m nreg)
  | 2048 => (execute_ADD_MZ_ZZV_4x1 2048 dn esize m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCLAMP_MZ_ZZ_2 (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do (Z_read (d +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
            let element3 ← do (pure (BitVec.toNat (← (Elem_read operand3 e esize))))
            let res := (Min.min (Max.max element1 element3) element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UCLAMP_MZ_ZZ_2 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_UCLAMP_MZ_ZZ_2 128 d esize m n nreg)
  | 256 => (execute_UCLAMP_MZ_ZZ_2 256 d esize m n nreg)
  | 512 => (execute_UCLAMP_MZ_ZZ_2 512 d esize m n nreg)
  | 1024 => (execute_UCLAMP_MZ_ZZ_2 1024 d esize m n nreg)
  | 2048 => (execute_UCLAMP_MZ_ZZ_2 2048 d esize m n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCLAMP_MZ_ZZ_2 (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do (Z_read (d +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
            let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
            let res := (Min.min (Max.max element1 element3) element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SCLAMP_MZ_ZZ_2 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_SCLAMP_MZ_ZZ_2 128 d esize m n nreg)
  | 256 => (execute_SCLAMP_MZ_ZZ_2 256 d esize m n nreg)
  | 512 => (execute_SCLAMP_MZ_ZZ_2 512 d esize m n nreg)
  | 1024 => (execute_SCLAMP_MZ_ZZ_2 1024 d esize m n nreg)
  | 2048 => (execute_SCLAMP_MZ_ZZ_2 2048 d esize m n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCLAMP_MZ_ZZ_4 (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do (Z_read (d +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
            let element3 ← do (pure (BitVec.toNat (← (Elem_read operand3 e esize))))
            let res := (Min.min (Max.max element1 element3) element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_UCLAMP_MZ_ZZ_4 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_UCLAMP_MZ_ZZ_4 128 d esize m n nreg)
  | 256 => (execute_UCLAMP_MZ_ZZ_4 256 d esize m n nreg)
  | 512 => (execute_UCLAMP_MZ_ZZ_4 512 d esize m n nreg)
  | 1024 => (execute_UCLAMP_MZ_ZZ_4 1024 d esize m n nreg)
  | 2048 => (execute_UCLAMP_MZ_ZZ_4 2048 d esize m n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCLAMP_MZ_ZZ_4 (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do (Z_read (d +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
            let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
            let res := (Min.min (Max.max element1 element3) element2)
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e esize
                    (integer_subrange res (esize -i 1) 0)))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SCLAMP_MZ_ZZ_4 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_SCLAMP_MZ_ZZ_4 128 d esize m n nreg)
  | 256 => (execute_SCLAMP_MZ_ZZ_4 256 d esize m n nreg)
  | 512 => (execute_SCLAMP_MZ_ZZ_4 512 d esize m n nreg)
  | 1024 => (execute_SCLAMP_MZ_ZZ_4 1024 d esize m n nreg)
  | 2048 => (execute_SCLAMP_MZ_ZZ_4 2048 d esize m n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg
  = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UUNPK_MZ_Z_2 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let hsize := (Int.ediv esize 2)
  let sreg := (Int.ediv nreg 2)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (sreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_i_lower := 0
        let loop_i_upper := 1
        let mut loop_vars_1 := results
        for i in [loop_i_lower:loop_i_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let loop_e_lower := 0
            let loop_e_upper := (elements -i 1)
            let mut loop_vars_2 := results
            for e in [loop_e_lower:loop_e_upper:1]i do
              let results := loop_vars_2
              loop_vars_2 ← do
                let element ← (( do (Elem_read operand ((i *i elements) +i e) hsize) ) : SailM
                  (BitVec hsize) )
                (pure (vectorUpdate results ((2 *i r) +i i)
                    (← (Elem_set (GetElem?.getElem! results ((2 *i r) +i i)) e esize
                        (← (Extend element esize is_unsigned))))))
            (pure loop_vars_2)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_3 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_3
    loop_vars_3 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_3)

def decode_UUNPK_MZ_Z_2 (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UUNPK_MZ_Z_2 128 d esize n nreg is_unsigned)
  | 256 => (execute_UUNPK_MZ_Z_2 256 d esize n nreg is_unsigned)
  | 512 => (execute_UUNPK_MZ_Z_2 512 d esize n nreg is_unsigned)
  | 1024 => (execute_UUNPK_MZ_Z_2 1024 d esize n nreg is_unsigned)
  | 2048 => (execute_UUNPK_MZ_Z_2 2048 d esize n nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg
  = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SUNPK_MZ_Z_2 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let hsize := (Int.ediv esize 2)
  let sreg := (Int.ediv nreg 2)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (sreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_i_lower := 0
        let loop_i_upper := 1
        let mut loop_vars_1 := results
        for i in [loop_i_lower:loop_i_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let loop_e_lower := 0
            let loop_e_upper := (elements -i 1)
            let mut loop_vars_2 := results
            for e in [loop_e_lower:loop_e_upper:1]i do
              let results := loop_vars_2
              loop_vars_2 ← do
                let element ← (( do (Elem_read operand ((i *i elements) +i e) hsize) ) : SailM
                  (BitVec hsize) )
                (pure (vectorUpdate results ((2 *i r) +i i)
                    (← (Elem_set (GetElem?.getElem! results ((2 *i r) +i i)) e esize
                        (← (Extend element esize is_unsigned))))))
            (pure loop_vars_2)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_3 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_3
    loop_vars_3 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_3)

def decode_SUNPK_MZ_Z_2 (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SUNPK_MZ_Z_2 128 d esize n nreg is_unsigned)
  | 256 => (execute_SUNPK_MZ_Z_2 256 d esize n nreg is_unsigned)
  | 512 => (execute_SUNPK_MZ_Z_2 512 d esize n nreg is_unsigned)
  | 1024 => (execute_SUNPK_MZ_Z_2 1024 d esize n nreg is_unsigned)
  | 2048 => (execute_SUNPK_MZ_Z_2 2048 d esize n nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg
  = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UUNPK_MZ_Z_4 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let hsize := (Int.ediv esize 2)
  let sreg := (Int.ediv nreg 2)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (sreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_i_lower := 0
        let loop_i_upper := 1
        let mut loop_vars_1 := results
        for i in [loop_i_lower:loop_i_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let loop_e_lower := 0
            let loop_e_upper := (elements -i 1)
            let mut loop_vars_2 := results
            for e in [loop_e_lower:loop_e_upper:1]i do
              let results := loop_vars_2
              loop_vars_2 ← do
                let element ← (( do (Elem_read operand ((i *i elements) +i e) hsize) ) : SailM
                  (BitVec hsize) )
                (pure (vectorUpdate results ((2 *i r) +i i)
                    (← (Elem_set (GetElem?.getElem! results ((2 *i r) +i i)) e esize
                        (← (Extend element esize is_unsigned))))))
            (pure loop_vars_2)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_3 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_3
    loop_vars_3 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_3)

def decode_UUNPK_MZ_Z_4 (size : (BitVec 2)) (Zn : (BitVec 4)) (Zd : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UUNPK_MZ_Z_4 128 d esize n nreg is_unsigned)
  | 256 => (execute_UUNPK_MZ_Z_4 256 d esize n nreg is_unsigned)
  | 512 => (execute_UUNPK_MZ_Z_4 512 d esize n nreg is_unsigned)
  | 1024 => (execute_UUNPK_MZ_Z_4 1024 d esize n nreg is_unsigned)
  | 2048 => (execute_UUNPK_MZ_Z_4 2048 d esize n nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, n : Nat, nreg : Nat, nreg
  = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SUNPK_MZ_Z_4 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let hsize := (Int.ediv esize 2)
  let sreg := (Int.ediv nreg 2)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (sreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_i_lower := 0
        let loop_i_upper := 1
        let mut loop_vars_1 := results
        for i in [loop_i_lower:loop_i_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let loop_e_lower := 0
            let loop_e_upper := (elements -i 1)
            let mut loop_vars_2 := results
            for e in [loop_e_lower:loop_e_upper:1]i do
              let results := loop_vars_2
              loop_vars_2 ← do
                let element ← (( do (Elem_read operand ((i *i elements) +i e) hsize) ) : SailM
                  (BitVec hsize) )
                (pure (vectorUpdate results ((2 *i r) +i i)
                    (← (Elem_set (GetElem?.getElem! results ((2 *i r) +i i)) e esize
                        (← (Extend element esize is_unsigned))))))
            (pure loop_vars_2)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_3 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_3
    loop_vars_3 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_3)

def decode_SUNPK_MZ_Z_4 (size : (BitVec 2)) (Zn : (BitVec 4)) (Zd : (BitVec 3)) (U : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SUNPK_MZ_Z_4 128 d esize n nreg is_unsigned)
  | 256 => (execute_SUNPK_MZ_Z_4 256 d esize n nreg is_unsigned)
  | 512 => (execute_SUNPK_MZ_Z_4 512 d esize n nreg is_unsigned)
  | 1024 => (execute_SUNPK_MZ_Z_4 1024 d esize n nreg is_unsigned)
  | 2048 => (execute_SUNPK_MZ_Z_4 2048 d esize n nreg is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHR_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((r *i elements) +i e) esize (← (SignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHR_Z_MZ2__ (imm4 : (BitVec 4)) (Zn : (BitVec 4)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  let shift := (esize -i (BitVec.toNat imm4))
  match VL with
  | 128 => (execute_SQRSHR_Z_MZ2__ 128 d esize n shift)
  | 256 => (execute_SQRSHR_Z_MZ2__ 256 d esize n shift)
  | 512 => (execute_SQRSHR_Z_MZ2__ 512 d esize n shift)
  | 1024 => (execute_SQRSHR_Z_MZ2__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHR_Z_MZ2__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQRSHR_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toNat element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((r *i elements) +i e) esize (← (UnsignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQRSHR_Z_MZ2__ (imm4 : (BitVec 4)) (Zn : (BitVec 4)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  let shift := (esize -i (BitVec.toNat imm4))
  match VL with
  | 128 => (execute_UQRSHR_Z_MZ2__ 128 d esize n shift)
  | 256 => (execute_UQRSHR_Z_MZ2__ 256 d esize n shift)
  | 512 => (execute_UQRSHR_Z_MZ2__ 512 d esize n shift)
  | 1024 => (execute_UQRSHR_Z_MZ2__ 1024 d esize n shift)
  | 2048 => (execute_UQRSHR_Z_MZ2__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHRU_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((r *i elements) +i e) esize (← (UnsignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHRU_Z_MZ2__ (imm4 : (BitVec 4)) (Zn : (BitVec 4)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  let shift := (esize -i (BitVec.toNat imm4))
  match VL with
  | 128 => (execute_SQRSHRU_Z_MZ2__ 128 d esize n shift)
  | 256 => (execute_SQRSHRU_Z_MZ2__ 256 d esize n shift)
  | 512 => (execute_SQRSHRU_Z_MZ2__ 512 d esize n shift)
  | 1024 => (execute_SQRSHRU_Z_MZ2__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHRU_Z_MZ2__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHRN_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 3
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← (( do (Elem_read operand e (4 *i esize)) ) : SailM (BitVec (4 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((4 *i e) +i i) esize (← (SignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHRN_Z_MZ4__ (tsize : (BitVec 2)) (imm5 : (BitVec 5)) (N : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize : Int := 8
  let b__0 := tsize
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (let esize : Int := 16
      (pure ())))
  let esize := esize
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  let shift := ((8 *i esize) -i (BitVec.toNat (tsize ++ imm5)))
  match VL with
  | 128 => (execute_SQRSHRN_Z_MZ4__ 128 d esize n shift)
  | 256 => (execute_SQRSHRN_Z_MZ4__ 256 d esize n shift)
  | 512 => (execute_SQRSHRN_Z_MZ4__ 512 d esize n shift)
  | 1024 => (execute_SQRSHRN_Z_MZ4__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHRN_Z_MZ4__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQRSHRN_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 3
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← (( do (Elem_read operand e (4 *i esize)) ) : SailM (BitVec (4 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toNat element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((4 *i e) +i i) esize (← (UnsignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQRSHRN_Z_MZ4__ (tsize : (BitVec 2)) (imm5 : (BitVec 5)) (N : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize : Int := 8
  let b__0 := tsize
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (let esize : Int := 16
      (pure ())))
  let esize := esize
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  let shift := ((8 *i esize) -i (BitVec.toNat (tsize ++ imm5)))
  match VL with
  | 128 => (execute_UQRSHRN_Z_MZ4__ 128 d esize n shift)
  | 256 => (execute_UQRSHRN_Z_MZ4__ 256 d esize n shift)
  | 512 => (execute_UQRSHRN_Z_MZ4__ 512 d esize n shift)
  | 1024 => (execute_UQRSHRN_Z_MZ4__ 1024 d esize n shift)
  | 2048 => (execute_UQRSHRN_Z_MZ4__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHRUN_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 3
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← (( do (Elem_read operand e (4 *i esize)) ) : SailM (BitVec (4 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((4 *i e) +i i) esize (← (UnsignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHRUN_Z_MZ4__ (tsize : (BitVec 2)) (imm5 : (BitVec 5)) (N : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize : Int := 8
  let b__0 := tsize
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (let esize : Int := 16
      (pure ())))
  let esize := esize
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  let shift := ((8 *i esize) -i (BitVec.toNat (tsize ++ imm5)))
  match VL with
  | 128 => (execute_SQRSHRUN_Z_MZ4__ 128 d esize n shift)
  | 256 => (execute_SQRSHRUN_Z_MZ4__ 256 d esize n shift)
  | 512 => (execute_SQRSHRUN_Z_MZ4__ 512 d esize n shift)
  | 1024 => (execute_SQRSHRUN_Z_MZ4__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHRUN_Z_MZ4__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHR_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e (4 *i esize)) ) : SailM (BitVec (4 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((r *i elements) +i e) esize (← (SignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHR_Z_MZ4__ (tsize : (BitVec 2)) (imm5 : (BitVec 5)) (N : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize : Int := 8
  let b__0 := tsize
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (let esize : Int := 16
      (pure ())))
  let esize := esize
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  let shift := ((8 *i esize) -i (BitVec.toNat (tsize ++ imm5)))
  match VL with
  | 128 => (execute_SQRSHR_Z_MZ4__ 128 d esize n shift)
  | 256 => (execute_SQRSHR_Z_MZ4__ 256 d esize n shift)
  | 512 => (execute_SQRSHR_Z_MZ4__ 512 d esize n shift)
  | 1024 => (execute_SQRSHR_Z_MZ4__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHR_Z_MZ4__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQRSHR_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e (4 *i esize)) ) : SailM (BitVec (4 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toNat element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((r *i elements) +i e) esize (← (UnsignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQRSHR_Z_MZ4__ (tsize : (BitVec 2)) (imm5 : (BitVec 5)) (N : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize : Int := 8
  let b__0 := tsize
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (let esize : Int := 16
      (pure ())))
  let esize := esize
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  let shift := ((8 *i esize) -i (BitVec.toNat (tsize ++ imm5)))
  match VL with
  | 128 => (execute_UQRSHR_Z_MZ4__ 128 d esize n shift)
  | 256 => (execute_UQRSHR_Z_MZ4__ 256 d esize n shift)
  | 512 => (execute_UQRSHR_Z_MZ4__ 512 d esize n shift)
  | 1024 => (execute_UQRSHR_Z_MZ4__ 1024 d esize n shift)
  | 2048 => (execute_UQRSHR_Z_MZ4__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHRU_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← (( do (Elem_read operand e (4 *i esize)) ) : SailM (BitVec (4 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((r *i elements) +i e) esize (← (UnsignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHRU_Z_MZ4__ (tsize : (BitVec 2)) (imm5 : (BitVec 5)) (N : (BitVec 1)) (Zn : (BitVec 3)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize : Int := 8
  let b__0 := tsize
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (let esize : Int := 16
      (pure ())))
  let esize := esize
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  let shift := ((8 *i esize) -i (BitVec.toNat (tsize ++ imm5)))
  match VL with
  | 128 => (execute_SQRSHRU_Z_MZ4__ 128 d esize n shift)
  | 256 => (execute_SQRSHRU_Z_MZ4__ 256 d esize n shift)
  | 512 => (execute_SQRSHRU_Z_MZ4__ 512 d esize n shift)
  | 1024 => (execute_SQRSHRU_Z_MZ4__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHRU_Z_MZ4__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQCVT_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand e (2 *i esize)))))
            (Elem_set result ((r *i elements) +i e) esize (← (SignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQCVT_Z_MZ2__ (Zn : (BitVec 4)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQCVT_Z_MZ2__ 128 d esize n)
  | 256 => (execute_SQCVT_Z_MZ2__ 256 d esize n)
  | 512 => (execute_SQCVT_Z_MZ2__ 512 d esize n)
  | 1024 => (execute_SQCVT_Z_MZ2__ 1024 d esize n)
  | 2048 => (execute_SQCVT_Z_MZ2__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQCVT_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand e (2 *i esize)))))
            (Elem_set result ((r *i elements) +i e) esize (← (UnsignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQCVT_Z_MZ2__ (Zn : (BitVec 4)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UQCVT_Z_MZ2__ 128 d esize n)
  | 256 => (execute_UQCVT_Z_MZ2__ 256 d esize n)
  | 512 => (execute_UQCVT_Z_MZ2__ 512 d esize n)
  | 1024 => (execute_UQCVT_Z_MZ2__ 1024 d esize n)
  | 2048 => (execute_UQCVT_Z_MZ2__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQCVTU_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand e (2 *i esize)))))
            (Elem_set result ((r *i elements) +i e) esize (← (UnsignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQCVTU_Z_MZ2__ (Zn : (BitVec 4)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQCVTU_Z_MZ2__ 128 d esize n)
  | 256 => (execute_SQCVTU_Z_MZ2__ 256 d esize n)
  | 512 => (execute_SQCVTU_Z_MZ2__ 512 d esize n)
  | 1024 => (execute_SQCVTU_Z_MZ2__ 1024 d esize n)
  | 2048 => (execute_SQCVTU_Z_MZ2__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQCVTN_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 3
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← do (pure (BitVec.toInt (← (Elem_read operand e (4 *i esize)))))
            (Elem_set result ((4 *i e) +i i) esize (← (SignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQCVTN_Z_MZ4__ (sz : (BitVec 1)) (Zn : (BitVec 3)) (N : (BitVec 1)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((128 == 128) || (128 == 256)) || (128 == 512)) || (128 == 1024)) || (128 == 2048))))))) "src/instrs64_sme.sail:34431.103-34431.104"
      (execute_SQCVTN_Z_MZ4__ 128 d esize n))
  | 256 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((256 == 128) || (256 == 256)) || (256 == 512)) || (256 == 1024)) || (256 == 2048))))))) "src/instrs64_sme.sail:34435.103-34435.104"
      (execute_SQCVTN_Z_MZ4__ 256 d esize n))
  | 512 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((512 == 128) || (512 == 256)) || (512 == 512)) || (512 == 1024)) || (512 == 2048))))))) "src/instrs64_sme.sail:34439.103-34439.104"
      (execute_SQCVTN_Z_MZ4__ 512 d esize n))
  | 1024 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((1024 == 128) || (1024 == 256)) || (1024 == 512)) || (1024 == 1024)) || (1024 == 2048))))))) "src/instrs64_sme.sail:34443.104-34443.105"
      (execute_SQCVTN_Z_MZ4__ 1024 d esize n))
  | 2048 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((2048 == 128) || (2048 == 256)) || (2048 == 512)) || (2048 == 1024)) || (2048 == 2048))))))) "src/instrs64_sme.sail:34447.104-34447.105"
      (execute_SQCVTN_Z_MZ4__ 2048 d esize n))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQCVTN_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 3
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← do (pure (BitVec.toNat (← (Elem_read operand e (4 *i esize)))))
            (Elem_set result ((4 *i e) +i i) esize (← (UnsignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQCVTN_Z_MZ4__ (sz : (BitVec 1)) (Zn : (BitVec 3)) (N : (BitVec 1)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((128 == 128) || (128 == 256)) || (128 == 512)) || (128 == 1024)) || (128 == 2048))))))) "src/instrs64_sme.sail:34495.103-34495.104"
      (execute_UQCVTN_Z_MZ4__ 128 d esize n))
  | 256 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((256 == 128) || (256 == 256)) || (256 == 512)) || (256 == 1024)) || (256 == 2048))))))) "src/instrs64_sme.sail:34499.103-34499.104"
      (execute_UQCVTN_Z_MZ4__ 256 d esize n))
  | 512 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((512 == 128) || (512 == 256)) || (512 == 512)) || (512 == 1024)) || (512 == 2048))))))) "src/instrs64_sme.sail:34503.103-34503.104"
      (execute_UQCVTN_Z_MZ4__ 512 d esize n))
  | 1024 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((1024 == 128) || (1024 == 256)) || (1024 == 512)) || (1024 == 1024)) || (1024 == 2048))))))) "src/instrs64_sme.sail:34507.104-34507.105"
      (execute_UQCVTN_Z_MZ4__ 1024 d esize n))
  | 2048 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((2048 == 128) || (2048 == 256)) || (2048 == 512)) || (2048 == 1024)) || (2048 == 2048))))))) "src/instrs64_sme.sail:34511.104-34511.105"
      (execute_UQCVTN_Z_MZ4__ 2048 d esize n))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQCVTUN_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 3
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← do (pure (BitVec.toInt (← (Elem_read operand e (4 *i esize)))))
            (Elem_set result ((4 *i e) +i i) esize (← (UnsignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQCVTUN_Z_MZ4__ (sz : (BitVec 1)) (Zn : (BitVec 3)) (N : (BitVec 1)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((128 == 128) || (128 == 256)) || (128 == 512)) || (128 == 1024)) || (128 == 2048))))))) "src/instrs64_sme.sail:34559.103-34559.104"
      (execute_SQCVTUN_Z_MZ4__ 128 d esize n))
  | 256 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((256 == 128) || (256 == 256)) || (256 == 512)) || (256 == 1024)) || (256 == 2048))))))) "src/instrs64_sme.sail:34563.103-34563.104"
      (execute_SQCVTUN_Z_MZ4__ 256 d esize n))
  | 512 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((512 == 128) || (512 == 256)) || (512 == 512)) || (512 == 1024)) || (512 == 2048))))))) "src/instrs64_sme.sail:34567.103-34567.104"
      (execute_SQCVTUN_Z_MZ4__ 512 d esize n))
  | 1024 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((1024 == 128) || (1024 == 256)) || (1024 == 512)) || (1024 == 1024)) || (1024 == 2048))))))) "src/instrs64_sme.sail:34571.104-34571.105"
      (execute_SQCVTUN_Z_MZ4__ 1024 d esize n))
  | 2048 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((2048 == 128) || (2048 == 256)) || (2048 == 512)) || (2048 == 1024)) || (2048 == 2048))))))) "src/instrs64_sme.sail:34575.104-34575.105"
      (execute_SQCVTUN_Z_MZ4__ 2048 d esize n))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQCVT_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand e (4 *i esize)))))
            (Elem_set result ((r *i elements) +i e) esize (← (SignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQCVT_Z_MZ4__ (sz : (BitVec 1)) (Zn : (BitVec 3)) (N : (BitVec 1)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((128 == 128) || (128 == 256)) || (128 == 512)) || (128 == 1024)) || (128 == 2048))))))) "src/instrs64_sme.sail:34623.103-34623.104"
      (execute_SQCVT_Z_MZ4__ 128 d esize n))
  | 256 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((256 == 128) || (256 == 256)) || (256 == 512)) || (256 == 1024)) || (256 == 2048))))))) "src/instrs64_sme.sail:34627.103-34627.104"
      (execute_SQCVT_Z_MZ4__ 256 d esize n))
  | 512 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((512 == 128) || (512 == 256)) || (512 == 512)) || (512 == 1024)) || (512 == 2048))))))) "src/instrs64_sme.sail:34631.103-34631.104"
      (execute_SQCVT_Z_MZ4__ 512 d esize n))
  | 1024 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((1024 == 128) || (1024 == 256)) || (1024 == 512)) || (1024 == 1024)) || (1024 == 2048))))))) "src/instrs64_sme.sail:34635.104-34635.105"
      (execute_SQCVT_Z_MZ4__ 1024 d esize n))
  | 2048 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((2048 == 128) || (2048 == 256)) || (2048 == 512)) || (2048 == 1024)) || (2048 == 2048))))))) "src/instrs64_sme.sail:34639.104-34639.105"
      (execute_SQCVT_Z_MZ4__ 2048 d esize n))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQCVT_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand e (4 *i esize)))))
            (Elem_set result ((r *i elements) +i e) esize (← (UnsignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQCVT_Z_MZ4__ (sz : (BitVec 1)) (Zn : (BitVec 3)) (N : (BitVec 1)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((128 == 128) || (128 == 256)) || (128 == 512)) || (128 == 1024)) || (128 == 2048))))))) "src/instrs64_sme.sail:34687.103-34687.104"
      (execute_UQCVT_Z_MZ4__ 128 d esize n))
  | 256 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((256 == 128) || (256 == 256)) || (256 == 512)) || (256 == 1024)) || (256 == 2048))))))) "src/instrs64_sme.sail:34691.103-34691.104"
      (execute_UQCVT_Z_MZ4__ 256 d esize n))
  | 512 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((512 == 128) || (512 == 256)) || (512 == 512)) || (512 == 1024)) || (512 == 2048))))))) "src/instrs64_sme.sail:34695.103-34695.104"
      (execute_UQCVT_Z_MZ4__ 512 d esize n))
  | 1024 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((1024 == 128) || (1024 == 256)) || (1024 == 512)) || (1024 == 1024)) || (1024 == 2048))))))) "src/instrs64_sme.sail:34699.104-34699.105"
      (execute_UQCVT_Z_MZ4__ 1024 d esize n))
  | 2048 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((2048 == 128) || (2048 == 256)) || (2048 == 512)) || (2048 == 1024)) || (2048 == 2048))))))) "src/instrs64_sme.sail:34703.104-34703.105"
      (execute_UQCVT_Z_MZ4__ 2048 d esize n))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQCVTU_Z_MZ4__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (4 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand e (4 *i esize)))))
            (Elem_set result ((r *i elements) +i e) esize (← (UnsignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQCVTU_Z_MZ4__ (sz : (BitVec 1)) (Zn : (BitVec 3)) (N : (BitVec 1)) (U : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat sz))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((128 == 128) || (128 == 256)) || (128 == 512)) || (128 == 1024)) || (128 == 2048))))))) "src/instrs64_sme.sail:34751.103-34751.104"
      (execute_SQCVTU_Z_MZ4__ 128 d esize n))
  | 256 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((256 == 128) || (256 == 256)) || (256 == 512)) || (256 == 1024)) || (256 == 2048))))))) "src/instrs64_sme.sail:34755.103-34755.104"
      (execute_SQCVTU_Z_MZ4__ 256 d esize n))
  | 512 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((512 == 128) || (512 == 256)) || (512 == 512)) || (512 == 1024)) || (512 == 2048))))))) "src/instrs64_sme.sail:34759.103-34759.104"
      (execute_SQCVTU_Z_MZ4__ 512 d esize n))
  | 1024 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((1024 == 128) || (1024 == 256)) || (1024 == 512)) || (1024 == 1024)) || (1024 == 2048))))))) "src/instrs64_sme.sail:34763.104-34763.105"
      (execute_SQCVTU_Z_MZ4__ 1024 d esize n))
  | 2048 => (do
      assert ((0 ≤b n) && ((n ≤b 31) && (((esize == 8) || (esize == 16)) && ((0 ≤b d) && ((d ≤b 31) && (((((2048 == 128) || (2048 == 256)) || (2048 == 512)) || (2048 == 1024)) || (2048 == 2048))))))) "src/instrs64_sme.sail:34767.104-34767.105"
      (execute_SQCVTU_Z_MZ4__ 2048 d esize n))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ZIP_MZ_ZZ_2 (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand0 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand1 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let base := (r *i pairs)
        let result ← (( do
          let loop_p_lower := 0
          let loop_p_upper := (pairs -i 1)
          let mut loop_vars_1 := result
          for p in [loop_p_lower:loop_p_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let result ←
                (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand0 (base +i p) esize)))
              (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand1 (base +i p) esize)))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set (d +i r) VL result)
        (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ZIP_MZ_ZZ_2 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  match VL with
  | 128 => (execute_ZIP_MZ_ZZ_2 128 d esize m n)
  | 256 => (execute_ZIP_MZ_ZZ_2 256 d esize m n)
  | 512 => (execute_ZIP_MZ_ZZ_2 512 d esize m n)
  | 1024 => (execute_ZIP_MZ_ZZ_2 1024 d esize m n)
  | 2048 => (execute_ZIP_MZ_ZZ_2 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UZP_MZ_ZZ_2 (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let result0 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result1 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result0, result1) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := (result0, result1)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result0, result1) := loop_vars
      loop_vars ← do
        let base := (r *i pairs)
        let operand ← (( do
          bif (r == 0)
          then (Z_read n VL)
          else (Z_read m VL) ) : SailM (BitVec VL) )
        let (result0, result1) ← (( do
          let loop_p_lower := 0
          let loop_p_upper := (pairs -i 1)
          let mut loop_vars_1 := (result0, result1)
          for p in [loop_p_lower:loop_p_upper:1]i do
            let (result0, result1) := loop_vars_1
            loop_vars_1 ← do
              let result0 ←
                (Elem_set result0 (base +i p) esize (← (Elem_read operand ((2 *i p) +i 0) esize)))
              let result1 ←
                (Elem_set result1 (base +i p) esize (← (Elem_read operand ((2 *i p) +i 1) esize)))
              (pure (result0, result1))
          (pure loop_vars_1) ) : SailM ((BitVec VL) × (BitVec VL)) )
        (pure (result0, result1))
    (pure loop_vars) ) : SailM ((BitVec VL) × (BitVec VL)) )
  (Z_set (d +i 0) VL result0)
  (Z_set (d +i 1) VL result1)

def decode_UZP_MZ_ZZ_2 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  match VL with
  | 128 => (execute_UZP_MZ_ZZ_2 128 d esize m n)
  | 256 => (execute_UZP_MZ_ZZ_2 256 d esize m n)
  | 512 => (execute_UZP_MZ_ZZ_2 512 d esize m n)
  | 1024 => (execute_UZP_MZ_ZZ_2 1024 d esize m n)
  | 2048 => (execute_UZP_MZ_ZZ_2 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ZIP_MZ_ZZ_2Q (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 2))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pairs := (Int.ediv VL (esize *i 2))
  let operand0 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand1 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let base := (r *i pairs)
        let result ← (( do
          let loop_p_lower := 0
          let loop_p_upper := (pairs -i 1)
          let mut loop_vars_1 := result
          for p in [loop_p_lower:loop_p_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let result ←
                (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand0 (base +i p) esize)))
              (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand1 (base +i p) esize)))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set (d +i r) VL result)
        (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ZIP_MZ_ZZ_2Q (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  match VL with
  | 128 => (execute_ZIP_MZ_ZZ_2Q 128 d esize m n)
  | 256 => (execute_ZIP_MZ_ZZ_2Q 256 d esize m n)
  | 512 => (execute_ZIP_MZ_ZZ_2Q 512 d esize m n)
  | 1024 => (execute_ZIP_MZ_ZZ_2Q 1024 d esize m n)
  | 2048 => (execute_ZIP_MZ_ZZ_2Q 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UZP_MZ_ZZ_2Q (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 2))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pairs := (Int.ediv VL (esize *i 2))
  let result0 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result1 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result0, result1) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 1
    let mut loop_vars := (result0, result1)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result0, result1) := loop_vars
      loop_vars ← do
        let base := (r *i pairs)
        let operand ← (( do
          bif (r == 0)
          then (Z_read n VL)
          else (Z_read m VL) ) : SailM (BitVec VL) )
        let (result0, result1) ← (( do
          let loop_p_lower := 0
          let loop_p_upper := (pairs -i 1)
          let mut loop_vars_1 := (result0, result1)
          for p in [loop_p_lower:loop_p_upper:1]i do
            let (result0, result1) := loop_vars_1
            loop_vars_1 ← do
              let result0 ←
                (Elem_set result0 (base +i p) esize (← (Elem_read operand ((2 *i p) +i 0) esize)))
              let result1 ←
                (Elem_set result1 (base +i p) esize (← (Elem_read operand ((2 *i p) +i 1) esize)))
              (pure (result0, result1))
          (pure loop_vars_1) ) : SailM ((BitVec VL) × (BitVec VL)) )
        (pure (result0, result1))
    (pure loop_vars) ) : SailM ((BitVec VL) × (BitVec VL)) )
  (Z_set (d +i 0) VL result0)
  (Z_set (d +i 1) VL result1)

def decode_UZP_MZ_ZZ_2Q (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  match VL with
  | 128 => (execute_UZP_MZ_ZZ_2Q 128 d esize m n)
  | 256 => (execute_UZP_MZ_ZZ_2Q 256 d esize m n)
  | 512 => (execute_UZP_MZ_ZZ_2Q 512 d esize m n)
  | 1024 => (execute_UZP_MZ_ZZ_2Q 1024 d esize m n)
  | 2048 => (execute_UZP_MZ_ZZ_2Q 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ZIP_MZ_Z_4 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 4))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let quads := (Int.ediv VL (esize *i 4))
  let operand0 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand1 ← (( do (Z_read (n +i 1) VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read (n +i 2) VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read (n +i 3) VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let base := (r *i quads)
        let result ← (( do
          let loop_q_lower := 0
          let loop_q_upper := (quads -i 1)
          let mut loop_vars_1 := result
          for q in [loop_q_lower:loop_q_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let result ←
                (Elem_set result ((4 *i q) +i 0) esize (← (Elem_read operand0 (base +i q) esize)))
              let result ←
                (Elem_set result ((4 *i q) +i 1) esize (← (Elem_read operand1 (base +i q) esize)))
              let result ←
                (Elem_set result ((4 *i q) +i 2) esize (← (Elem_read operand2 (base +i q) esize)))
              (Elem_set result ((4 *i q) +i 3) esize (← (Elem_read operand3 (base +i q) esize)))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set (d +i r) VL result)
        (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ZIP_MZ_Z_4 (size : (BitVec 2)) (Zn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  match VL with
  | 128 => (execute_ZIP_MZ_Z_4 128 d esize n)
  | 256 => (execute_ZIP_MZ_Z_4 256 d esize n)
  | 512 => (execute_ZIP_MZ_Z_4 512 d esize n)
  | 1024 => (execute_ZIP_MZ_Z_4 1024 d esize n)
  | 2048 => (execute_ZIP_MZ_Z_4 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UZP_MZ_Z_4 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 4))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let quads := (Int.ediv VL (esize *i 4))
  let result0 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result1 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result2 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result3 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result0, result1, result2, result3) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := (result0, result1, result2, result3)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result0, result1, result2, result3) := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let base := (r *i quads)
        let (result0, result1, result2, result3) ← (( do
          let loop_q_lower := 0
          let loop_q_upper := (quads -i 1)
          let mut loop_vars_1 := (result0, result1, result2, result3)
          for q in [loop_q_lower:loop_q_upper:1]i do
            let (result0, result1, result2, result3) := loop_vars_1
            loop_vars_1 ← do
              let result0 ←
                (Elem_set result0 (base +i q) esize (← (Elem_read operand ((4 *i q) +i 0) esize)))
              let result1 ←
                (Elem_set result1 (base +i q) esize (← (Elem_read operand ((4 *i q) +i 1) esize)))
              let result2 ←
                (Elem_set result2 (base +i q) esize (← (Elem_read operand ((4 *i q) +i 2) esize)))
              let result3 ←
                (Elem_set result3 (base +i q) esize (← (Elem_read operand ((4 *i q) +i 3) esize)))
              (pure (result0, result1, result2, result3))
          (pure loop_vars_1) ) : SailM ((BitVec VL) × (BitVec VL) × (BitVec VL) × (BitVec VL)) )
        (pure (result0, result1, result2, result3))
    (pure loop_vars) ) : SailM ((BitVec VL) × (BitVec VL) × (BitVec VL) × (BitVec VL)) )
  (Z_set (d +i 0) VL result0)
  (Z_set (d +i 1) VL result1)
  (Z_set (d +i 2) VL result2)
  (Z_set (d +i 3) VL result3)

def decode_UZP_MZ_Z_4 (size : (BitVec 2)) (Zn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  match VL with
  | 128 => (execute_UZP_MZ_Z_4 128 d esize n)
  | 256 => (execute_UZP_MZ_Z_4 256 d esize n)
  | 512 => (execute_UZP_MZ_Z_4 512 d esize n)
  | 1024 => (execute_UZP_MZ_Z_4 1024 d esize n)
  | 2048 => (execute_UZP_MZ_Z_4 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ZIP_MZ_Z_4Q (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 4))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let quads := (Int.ediv VL (esize *i 4))
  let operand0 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand1 ← (( do (Z_read (n +i 1) VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read (n +i 2) VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read (n +i 3) VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let base := (r *i quads)
        let result ← (( do
          let loop_q_lower := 0
          let loop_q_upper := (quads -i 1)
          let mut loop_vars_1 := result
          for q in [loop_q_lower:loop_q_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let result ←
                (Elem_set result ((4 *i q) +i 0) esize (← (Elem_read operand0 (base +i q) esize)))
              let result ←
                (Elem_set result ((4 *i q) +i 1) esize (← (Elem_read operand1 (base +i q) esize)))
              let result ←
                (Elem_set result ((4 *i q) +i 2) esize (← (Elem_read operand2 (base +i q) esize)))
              (Elem_set result ((4 *i q) +i 3) esize (← (Elem_read operand3 (base +i q) esize)))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set (d +i r) VL result)
        (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ZIP_MZ_Z_4Q (Zn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  match VL with
  | 128 => (execute_ZIP_MZ_Z_4Q 128 d esize n)
  | 256 => (execute_ZIP_MZ_Z_4Q 256 d esize n)
  | 512 => (execute_ZIP_MZ_Z_4Q 512 d esize n)
  | 1024 => (execute_ZIP_MZ_Z_4Q 1024 d esize n)
  | 2048 => (execute_ZIP_MZ_Z_4Q 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UZP_MZ_Z_4Q (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 4))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let quads := (Int.ediv VL (esize *i 4))
  let result0 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result1 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result2 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result3 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result0, result1, result2, result3) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := 3
    let mut loop_vars := (result0, result1, result2, result3)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result0, result1, result2, result3) := loop_vars
      loop_vars ← do
        let operand ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let base := (r *i quads)
        let (result0, result1, result2, result3) ← (( do
          let loop_q_lower := 0
          let loop_q_upper := (quads -i 1)
          let mut loop_vars_1 := (result0, result1, result2, result3)
          for q in [loop_q_lower:loop_q_upper:1]i do
            let (result0, result1, result2, result3) := loop_vars_1
            loop_vars_1 ← do
              let result0 ←
                (Elem_set result0 (base +i q) esize (← (Elem_read operand ((4 *i q) +i 0) esize)))
              let result1 ←
                (Elem_set result1 (base +i q) esize (← (Elem_read operand ((4 *i q) +i 1) esize)))
              let result2 ←
                (Elem_set result2 (base +i q) esize (← (Elem_read operand ((4 *i q) +i 2) esize)))
              let result3 ←
                (Elem_set result3 (base +i q) esize (← (Elem_read operand ((4 *i q) +i 3) esize)))
              (pure (result0, result1, result2, result3))
          (pure loop_vars_1) ) : SailM ((BitVec VL) × (BitVec VL) × (BitVec VL) × (BitVec VL)) )
        (pure (result0, result1, result2, result3))
    (pure loop_vars) ) : SailM ((BitVec VL) × (BitVec VL) × (BitVec VL) × (BitVec VL)) )
  (Z_set (d +i 0) VL result0)
  (Z_set (d +i 1) VL result1)
  (Z_set (d +i 2) VL result2)
  (Z_set (d +i 3) VL result3)

def decode_UZP_MZ_Z_4Q (Zn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  match VL with
  | 128 => (execute_UZP_MZ_Z_4Q 128 d esize n)
  | 256 => (execute_UZP_MZ_Z_4Q 256 d esize n)
  | 512 => (execute_UZP_MZ_Z_4Q 512 d esize n)
  | 1024 => (execute_UZP_MZ_Z_4Q 1024 d esize n)
  | 2048 => (execute_UZP_MZ_Z_4Q 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, nreg =
  2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  0 ≤ g ∧ g ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SEL_MZ_P_ZZ_2 (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                (pure (vectorUpdate results r
                    (← (Elem_set (GetElem?.getElem! results r) e esize
                        (← (Elem_read operand1 e esize)))))))
            else
              (do
                (pure (vectorUpdate results r
                    (← (Elem_set (GetElem?.getElem! results r) e esize
                        (← (Elem_read operand2 e esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SEL_MZ_P_ZZ_2 (size : (BitVec 2)) (Zm : (BitVec 4)) (PNg : (BitVec 3)) (Zn : (BitVec 4)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  match VL with
  | 128 => (execute_SEL_MZ_P_ZZ_2 128 d esize g m n nreg)
  | 256 => (execute_SEL_MZ_P_ZZ_2 256 d esize g m n nreg)
  | 512 => (execute_SEL_MZ_P_ZZ_2 512 d esize g m n nreg)
  | 1024 => (execute_SEL_MZ_P_ZZ_2 1024 d esize g m n nreg)
  | 2048 => (execute_SEL_MZ_P_ZZ_2 2048 d esize g m n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, nreg =
  4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  0 ≤ g ∧ g ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SEL_MZ_P_ZZ_4 (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                (pure (vectorUpdate results r
                    (← (Elem_set (GetElem?.getElem! results r) e esize
                        (← (Elem_read operand1 e esize)))))))
            else
              (do
                (pure (vectorUpdate results r
                    (← (Elem_set (GetElem?.getElem! results r) e esize
                        (← (Elem_read operand2 e esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_SEL_MZ_P_ZZ_4 (size : (BitVec 2)) (Zm : (BitVec 3)) (PNg : (BitVec 3)) (Zn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  match VL with
  | 128 => (execute_SEL_MZ_P_ZZ_4 128 d esize g m n nreg)
  | 256 => (execute_SEL_MZ_P_ZZ_4 256 d esize g m n nreg)
  | 512 => (execute_SEL_MZ_P_ZZ_4 512 d esize g m n nreg)
  | 1024 => (execute_SEL_MZ_P_ZZ_4 1024 d esize g m n nreg)
  | 2048 => (execute_SEL_MZ_P_ZZ_4 2048 d esize g m n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_BMOPA_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 row esize) ) : SailM (BitVec esize) )
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element2 ← (( do (Elem_read operand2 col esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                     mask2 col esize)))
            then
              (do
                let res : Int := (BitCount (Complement.complement (element1 ^^^ element2)))
                let res : Int :=
                  bif sub_op
                  then (Neg.neg res)
                  else res
                let res := res
                (Elem_set result ((row *i dim) +i col) esize (BitVec.addInt element3 res)))
            else
              (do
                (Elem_set result ((row *i dim) +i col) esize element3))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_BMOPA_ZA_PP_ZZ_32 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  match VL with
  | 128 => (execute_BMOPA_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n sub_op)
  | 256 => (execute_BMOPA_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n sub_op)
  | 512 => (execute_BMOPA_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n sub_op)
  | 1024 => (execute_BMOPA_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op)
  | 2048 => (execute_BMOPA_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_BMOPS_ZA_PP_ZZ_32 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 row esize) ) : SailM (BitVec esize) )
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element2 ← (( do (Elem_read operand2 col esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                     mask2 col esize)))
            then
              (do
                let res : Int := (BitCount (Complement.complement (element1 ^^^ element2)))
                let res : Int :=
                  bif sub_op
                  then (Neg.neg res)
                  else res
                let res := res
                (Elem_set result ((row *i dim) +i col) esize (BitVec.addInt element3 res)))
            else
              (do
                (Elem_set result ((row *i dim) +i col) esize element3))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_BMOPS_ZA_PP_ZZ_32 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  match VL with
  | 128 => (execute_BMOPS_ZA_PP_ZZ_32 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n sub_op)
  | 256 => (execute_BMOPS_ZA_PP_ZZ_32 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n sub_op)
  | 512 => (execute_BMOPS_ZA_PP_ZZ_32 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n sub_op)
  | 1024 => (execute_BMOPS_ZA_PP_ZZ_32 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op)
  | 2048 => (execute_BMOPS_ZA_PP_ZZ_32 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, k_is_unsigned
  : Bool, m : Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_SMOPA_ZA32_PP_ZZ_16 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 1
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((2 *i row) +i k) (Int.ediv esize 2))) && (← (ActivePredicateElement
                               mask2 ((2 *i col) +i k) (Int.ediv esize 2))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((2 *i row) +i k) (Int.ediv esize 2)))
                                    is_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((2 *i col) +i k) (Int.ediv esize 2)))
                                    is_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_SMOPA_ZA32_PP_ZZ_16 (u0 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMOPA_ZA32_PP_ZZ_16 128
      (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 256 => (execute_SMOPA_ZA32_PP_ZZ_16 256
      (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 512 => (execute_SMOPA_ZA32_PP_ZZ_16 512
      (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 1024 => (execute_SMOPA_ZA32_PP_ZZ_16 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op
      is_unsigned)
  | 2048 => (execute_SMOPA_ZA32_PP_ZZ_16 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, k_is_unsigned
  : Bool, m : Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_UMOPA_ZA32_PP_ZZ_16 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 1
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((2 *i row) +i k) (Int.ediv esize 2))) && (← (ActivePredicateElement
                               mask2 ((2 *i col) +i k) (Int.ediv esize 2))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((2 *i row) +i k) (Int.ediv esize 2)))
                                    is_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((2 *i col) +i k) (Int.ediv esize 2)))
                                    is_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_UMOPA_ZA32_PP_ZZ_16 (u0 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMOPA_ZA32_PP_ZZ_16 128
      (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 256 => (execute_UMOPA_ZA32_PP_ZZ_16 256
      (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 512 => (execute_UMOPA_ZA32_PP_ZZ_16 512
      (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 1024 => (execute_UMOPA_ZA32_PP_ZZ_16 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op
      is_unsigned)
  | 2048 => (execute_UMOPA_ZA32_PP_ZZ_16 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, k_is_unsigned
  : Bool, m : Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_SMOPS_ZA32_PP_ZZ_16 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 1
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((2 *i row) +i k) (Int.ediv esize 2))) && (← (ActivePredicateElement
                               mask2 ((2 *i col) +i k) (Int.ediv esize 2))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((2 *i row) +i k) (Int.ediv esize 2)))
                                    is_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((2 *i col) +i k) (Int.ediv esize 2)))
                                    is_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_SMOPS_ZA32_PP_ZZ_16 (u0 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMOPS_ZA32_PP_ZZ_16 128
      (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 256 => (execute_SMOPS_ZA32_PP_ZZ_16 256
      (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 512 => (execute_SMOPS_ZA32_PP_ZZ_16 512
      (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 1024 => (execute_SMOPS_ZA32_PP_ZZ_16 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op
      is_unsigned)
  | 2048 => (execute_SMOPS_ZA32_PP_ZZ_16 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, k_is_unsigned
  : Bool, m : Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 32 ∧
  da ∈ {0, 1, 2, 3} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_UMOPS_ZA32_PP_ZZ_16 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let prod ← (( do (undefined_int ()) ) : SailM Int )
  let (prod, result) ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := (prod, result)
    for row in [loop_row_lower:loop_row_upper:1]i do
      let (prod, result) := loop_vars
      loop_vars ← do
        let (prod, result) ← (( do
          let loop_col_lower := 0
          let loop_col_upper := (dim -i 1)
          let mut loop_vars_1 := (prod, result)
          for col in [loop_col_lower:loop_col_upper:1]i do
            let (prod, result) := loop_vars_1
            loop_vars_1 ← do
              let sum ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
                (BitVec esize) )
              let (prod, sum) ← (( do
                let loop_k_lower := 0
                let loop_k_upper := 1
                let mut loop_vars_2 := (prod, sum)
                for k in [loop_k_lower:loop_k_upper:1]i do
                  let (prod, sum) := loop_vars_2
                  loop_vars_2 ← do
                    let (prod, sum) ← (( do
                      bif ((← (ActivePredicateElement mask1 ((2 *i row) +i k) (Int.ediv esize 2))) && (← (ActivePredicateElement
                               mask2 ((2 *i col) +i k) (Int.ediv esize 2))))
                      then
                        (do
                          let prod ←
                            (pure ((← (asl_Int
                                    (← (Elem_read operand1 ((2 *i row) +i k) (Int.ediv esize 2)))
                                    is_unsigned)) *i (← (asl_Int
                                    (← (Elem_read operand2 ((2 *i col) +i k) (Int.ediv esize 2)))
                                    is_unsigned))))
                          let prod : Int :=
                            bif sub_op
                            then (Neg.neg prod)
                            else prod
                          let sum : (BitVec esize) := (BitVec.addInt sum prod)
                          (pure (prod, sum)))
                      else (pure (prod, sum)) ) : SailM (Int × (BitVec esize)) )
                    (pure (prod, sum))
                (pure loop_vars_2) ) : SailM (Int × (BitVec esize)) )
              let result ← (Elem_set result ((row *i dim) +i col) esize sum)
              (pure (prod, result))
          (pure loop_vars_1) ) : SailM (Int × (BitVec dim_dim_esize)) )
        (pure (prod, result))
    (pure loop_vars) ) : SailM (Int × (BitVec dim_dim_esize)) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_UMOPS_ZA32_PP_ZZ_16 (u0 : (BitVec 1)) (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMOPS_ZA32_PP_ZZ_16 128
      (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 256 => (execute_UMOPS_ZA32_PP_ZZ_16 256
      (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 512 => (execute_UMOPS_ZA32_PP_ZZ_16 512
      (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize) a b da esize m n sub_op is_unsigned)
  | 1024 => (execute_UMOPS_ZA32_PP_ZZ_16 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op
      is_unsigned)
  | 2048 => (execute_UMOPS_ZA32_PP_ZZ_16 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, isize : Nat, n : Nat, nreg : Nat, nreg
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  isize = 2 ∧
  0 ≤ imm ∧ imm ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_LUTI2_Z_ZTZ__ (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (isize : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  (CheckSMEZT0Enabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let segments := (Int.ediv esize (isize *i nreg))
  let segment := (Nat.div imm segments)
  let indexes ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let base := (((segment *i nreg) +i r) *i elements)
      let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
      let result ← (( do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let index ← do (pure (BitVec.toNat (← (Elem_read indexes (base +i e) isize))))
            assert ((esize -i 1) <b 32) "src/instrs64_sme.sail:35958.46-35958.47"
            (Elem_set result e esize
              (Sail.BitVec.extractLsb (← (Elem_read table index 32)) (esize -i 1) 0))
        (pure loop_vars_1) ) : SailM (BitVec VL) )
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_LUTI2_Z_ZTZ__ (i4 : (BitVec 4)) (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let isize := 2
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let imm := (BitVec.toNat i4)
  let nreg := 1
  match VL with
  | 128 => (execute_LUTI2_Z_ZTZ__ 128 d esize imm isize n nreg)
  | 256 => (execute_LUTI2_Z_ZTZ__ 256 d esize imm isize n nreg)
  | 512 => (execute_LUTI2_Z_ZTZ__ 512 d esize imm isize n nreg)
  | 1024 => (execute_LUTI2_Z_ZTZ__ 1024 d esize imm isize n nreg)
  | 2048 => (execute_LUTI2_Z_ZTZ__ 2048 d esize imm isize n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, isize : Nat, n : Nat, nreg : Nat, nreg
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  isize = 4 ∧
  imm ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_LUTI4_Z_ZTZ__ (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (isize : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  (CheckSMEZT0Enabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let segments := (Int.ediv esize (isize *i nreg))
  let segment := (Nat.div imm segments)
  let indexes ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let base := (((segment *i nreg) +i r) *i elements)
      let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
      let result ← (( do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let index ← do (pure (BitVec.toNat (← (Elem_read indexes (base +i e) isize))))
            assert ((esize -i 1) <b 32) "src/instrs64_sme.sail:36028.46-36028.47"
            (Elem_set result e esize
              (Sail.BitVec.extractLsb (← (Elem_read table index 32)) (esize -i 1) 0))
        (pure loop_vars_1) ) : SailM (BitVec VL) )
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_LUTI4_Z_ZTZ__ (i3 : (BitVec 3)) (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let isize := 4
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let imm := (BitVec.toNat i3)
  let nreg := 1
  match VL with
  | 128 => (execute_LUTI4_Z_ZTZ__ 128 d esize imm isize n nreg)
  | 256 => (execute_LUTI4_Z_ZTZ__ 256 d esize imm isize n nreg)
  | 512 => (execute_LUTI4_Z_ZTZ__ 512 d esize imm isize n nreg)
  | 1024 => (execute_LUTI4_Z_ZTZ__ 1024 d esize imm isize n nreg)
  | 2048 => (execute_LUTI4_Z_ZTZ__ 2048 d esize imm isize n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d__arg : Nat, dstride : Nat, esize : Nat, imm : Nat, isize : Nat, n
  : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  isize = 2 ∧
  imm ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ dstride = 1 ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ is_VL(VL) -/
def execute_LUTI2_MZ2_ZTZ_1 (VL : Nat) (d__arg : Nat) (dstride : Nat) (esize : Nat) (imm : Nat) (isize : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckStreamingSVEEnabled ())
  (CheckSMEZT0Enabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let segments := (Int.ediv esize (isize *i nreg))
  let segment := (Nat.div imm segments)
  let indexes ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let d ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := d
    for r in [loop_r_lower:loop_r_upper:1]i do
      let d := loop_vars
      loop_vars ← do
        let base := (((segment *i nreg) +i r) *i elements)
        let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let index ← do (pure (BitVec.toNat (← (Elem_read indexes (base +i e) isize))))
              assert ((esize -i 1) <b 32) "src/instrs64_sme.sail:36099.46-36099.47"
              (Elem_set result e esize
                (Sail.BitVec.extractLsb (← (Elem_read table index 32)) (esize -i 1) 0))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set d VL result)
        (pure (d +i dstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_LUTI2_MZ2_ZTZ_1 (i3 : (BitVec 3)) (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let isize := 2
  let n := (BitVec.toNat Zn)
  let dstride := 1
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let imm := (BitVec.toNat i3)
  let nreg := 2
  match VL with
  | 128 => (execute_LUTI2_MZ2_ZTZ_1 128 d dstride esize imm isize n nreg)
  | 256 => (execute_LUTI2_MZ2_ZTZ_1 256 d dstride esize imm isize n nreg)
  | 512 => (execute_LUTI2_MZ2_ZTZ_1 512 d dstride esize imm isize n nreg)
  | 1024 => (execute_LUTI2_MZ2_ZTZ_1 1024 d dstride esize imm isize n nreg)
  | 2048 => (execute_LUTI2_MZ2_ZTZ_1 2048 d dstride esize imm isize n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d__arg : Nat, dstride : Nat, esize : Nat, imm : Nat, isize : Nat, n
  : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  isize = 4 ∧
  imm ∈ {0, 1, 2, 3} ∧
  esize ∈ {8, 16, 32, 64} ∧ dstride = 1 ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ is_VL(VL) -/
def execute_LUTI4_MZ2_ZTZ_1 (VL : Nat) (d__arg : Nat) (dstride : Nat) (esize : Nat) (imm : Nat) (isize : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckStreamingSVEEnabled ())
  (CheckSMEZT0Enabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let segments := (Int.ediv esize (isize *i nreg))
  let segment := (Nat.div imm segments)
  let indexes ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let d ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := d
    for r in [loop_r_lower:loop_r_upper:1]i do
      let d := loop_vars
      loop_vars ← do
        let base := (((segment *i nreg) +i r) *i elements)
        let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let index ← do (pure (BitVec.toNat (← (Elem_read indexes (base +i e) isize))))
              assert ((esize -i 1) <b 32) "src/instrs64_sme.sail:36172.46-36172.47"
              (Elem_set result e esize
                (Sail.BitVec.extractLsb (← (Elem_read table index 32)) (esize -i 1) 0))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set d VL result)
        (pure (d +i dstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_LUTI4_MZ2_ZTZ_1 (i2 : (BitVec 2)) (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let isize := 4
  let n := (BitVec.toNat Zn)
  let dstride := 1
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let imm := (BitVec.toNat i2)
  let nreg := 2
  match VL with
  | 128 => (execute_LUTI4_MZ2_ZTZ_1 128 d dstride esize imm isize n nreg)
  | 256 => (execute_LUTI4_MZ2_ZTZ_1 256 d dstride esize imm isize n nreg)
  | 512 => (execute_LUTI4_MZ2_ZTZ_1 512 d dstride esize imm isize n nreg)
  | 1024 => (execute_LUTI4_MZ2_ZTZ_1 1024 d dstride esize imm isize n nreg)
  | 2048 => (execute_LUTI4_MZ2_ZTZ_1 2048 d dstride esize imm isize n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d__arg : Nat, dstride : Nat, esize : Nat, imm : Nat, isize : Nat, n
  : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  isize = 2 ∧
  imm ∈ {0, 1, 2, 3} ∧
  esize ∈ {8, 16, 32, 64} ∧ dstride = 1 ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ is_VL(VL) -/
def execute_LUTI2_MZ4_ZTZ_1 (VL : Nat) (d__arg : Nat) (dstride : Nat) (esize : Nat) (imm : Nat) (isize : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckStreamingSVEEnabled ())
  (CheckSMEZT0Enabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let segments := (Int.ediv esize (isize *i nreg))
  let segment := (Nat.div imm segments)
  let indexes ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let d ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := d
    for r in [loop_r_lower:loop_r_upper:1]i do
      let d := loop_vars
      loop_vars ← do
        let base := (((segment *i nreg) +i r) *i elements)
        let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let index ← do (pure (BitVec.toNat (← (Elem_read indexes (base +i e) isize))))
              assert ((esize -i 1) <b 32) "src/instrs64_sme.sail:36245.46-36245.47"
              (Elem_set result e esize
                (Sail.BitVec.extractLsb (← (Elem_read table index 32)) (esize -i 1) 0))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set d VL result)
        (pure (d +i dstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_LUTI2_MZ4_ZTZ_1 (i2 : (BitVec 2)) (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let isize := 2
  let n := (BitVec.toNat Zn)
  let dstride := 1
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let imm := (BitVec.toNat i2)
  let nreg := 4
  match VL with
  | 128 => (execute_LUTI2_MZ4_ZTZ_1 128 d dstride esize imm isize n nreg)
  | 256 => (execute_LUTI2_MZ4_ZTZ_1 256 d dstride esize imm isize n nreg)
  | 512 => (execute_LUTI2_MZ4_ZTZ_1 512 d dstride esize imm isize n nreg)
  | 1024 => (execute_LUTI2_MZ4_ZTZ_1 1024 d dstride esize imm isize n nreg)
  | 2048 => (execute_LUTI2_MZ4_ZTZ_1 2048 d dstride esize imm isize n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d__arg : Nat, dstride : Nat, esize : Nat, imm : Nat, isize : Nat, n
  : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  isize = 4 ∧
  imm ∈ {0, 1} ∧
  esize ∈ {8, 16, 32, 64} ∧ dstride = 1 ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ is_VL(VL) -/
def execute_LUTI4_MZ4_ZTZ_1 (VL : Nat) (d__arg : Nat) (dstride : Nat) (esize : Nat) (imm : Nat) (isize : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckStreamingSVEEnabled ())
  (CheckSMEZT0Enabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let segments := (Int.ediv esize (isize *i nreg))
  let segment := (fmod_int imm segments)
  let indexes ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let d ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := d
    for r in [loop_r_lower:loop_r_upper:1]i do
      let d := loop_vars
      loop_vars ← do
        let base := (((segment *i nreg) +i r) *i elements)
        let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let index ← do (pure (BitVec.toNat (← (Elem_read indexes (base +i e) isize))))
              assert ((esize -i 1) <b 32) "src/instrs64_sme.sail:36318.46-36318.47"
              (Elem_set result e esize
                (Sail.BitVec.extractLsb (← (Elem_read table index 32)) (esize -i 1) 0))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set d VL result)
        (pure (d +i dstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_LUTI4_MZ4_ZTZ_1 (i1 : (BitVec 1)) (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((size == (0b00 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let isize := 4
  let n := (BitVec.toNat Zn)
  let dstride := 1
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let imm := (BitVec.toNat i1)
  let nreg := 4
  match VL with
  | 128 => (execute_LUTI4_MZ4_ZTZ_1 128 d dstride esize imm isize n nreg)
  | 256 => (execute_LUTI4_MZ4_ZTZ_1 256 d dstride esize imm isize n nreg)
  | 512 => (execute_LUTI4_MZ4_ZTZ_1 512 d dstride esize imm isize n nreg)
  | 1024 => (execute_LUTI4_MZ4_ZTZ_1 1024 d dstride esize imm isize n nreg)
  | 2048 => (execute_LUTI4_MZ4_ZTZ_1 2048 d dstride esize imm isize n nreg)
  | _ => (pure ())

/-- Type quantifiers: n : Nat, 0 ≤ n ∧ n ≤ 31 -/
def execute_LDR_ZT_BR__ (n : Nat) : SailM Unit := do
  (CheckSMEEnabled ())
  (CheckSMEZT0Enabled ())
  let elements := (Int.ediv 512 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 512) ) : SailM (BitVec 512) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSME MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  bif ((← (HaveTME ())) && ((← readReg TSTATE).depth >b 0))
  then (FailTransaction TMFailure_ERR false)
  else (pure ())
  let base ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let aligned : Bool := (IsAligned__1 base 16)
  bif ((! aligned) && (← (AlignmentEnforced ())))
  then (AArch64_Abort base (← (AlignmentFault accdesc)))
  else (pure ())
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e 8 (← (AArch64_MemSingle_read (BitVec.addInt base e) 1 accdesc aligned)))
    (pure loop_vars) ) : SailM (BitVec 512) )
  (ZT0_set 512 result)

def decode_LDR_ZT_BR__ (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  (execute_LDR_ZT_BR__ n)

/-- Type quantifiers: n : Nat, 0 ≤ n ∧ n ≤ 31 -/
def execute_STR_ZT_BR__ (n : Nat) : SailM Unit := do
  (CheckSMEEnabled ())
  (CheckSMEZT0Enabled ())
  let elements := (Int.ediv 512 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (n != 31)
  let accdesc ← (( do (CreateAccDescSME MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  bif ((← (HaveTME ())) && ((← readReg TSTATE).depth >b 0))
  then (FailTransaction TMFailure_ERR false)
  else (pure ())
  let base ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let aligned : Bool := (IsAligned__1 base 16)
  bif ((! aligned) && (← (AlignmentEnforced ())))
  then (AArch64_Abort base (← (AlignmentFault accdesc)))
  else (pure ())
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      (AArch64_MemSingle_set (BitVec.addInt base e) 1 accdesc aligned (← (Elem_read table e 8)))
  (pure loop_vars)

def decode_STR_ZT_BR__ (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  (execute_STR_ZT_BR__ n)

def execute_ZERO_ZT_I__ (_ : Unit) : SailM Unit := do
  (CheckSMEEnabled ())
  (CheckSMEZT0Enabled ())
  bif ((← (HaveTME ())) && ((← readReg TSTATE).depth >b 0))
  then (FailTransaction TMFailure_ERR false)
  else (pure ())
  (ZT0_set 512 (Zeros (n := 512)))

def decode_ZERO_ZT_I__ (_ : Unit) : SailM Unit := do
  bif (! (← (HaveSME2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_ZERO_ZT_I__ ())

/-- Type quantifiers: offset : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} -/
def execute_MOVT_R_ZT__ (offset : Nat) (t : Nat) : SailM Unit := do
  (CheckSMEEnabled ())
  (CheckSMEZT0Enabled ())
  let operand ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  (X_set t 64 (← (Elem_read operand offset 64)))

def decode_MOVT_R_ZT__ (off3 : (BitVec 3)) (Rt : (BitVec 5)) : SailM Unit := do
  bif ((! (← (HaveSME2 ()))) || (! (← (Halted ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let offset := (BitVec.toNat off3)
  (execute_MOVT_R_ZT__ offset t)

/-- Type quantifiers: offset : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} -/
def execute_MOVT_ZT_R__ (offset : Nat) (t : Nat) : SailM Unit := do
  (CheckSMEEnabled ())
  (CheckSMEZT0Enabled ())
  let result ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let result ← (Elem_set result offset 64 (← (X_read t 64)))
  (ZT0_set 512 result)

def decode_MOVT_ZT_R__ (off3 : (BitVec 3)) (Rt : (BitVec 5)) : SailM Unit := do
  bif ((! (← (HaveSME2 ()))) || (! (← (Halted ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let offset := (BitVec.toNat off3)
  (execute_MOVT_ZT_R__ offset t)

/-- Type quantifiers: SVL : Nat, d : Nat, imm : Int, 0 ≤ d ∧ d ≤ 31 ∧ is_VL(SVL) -/
def execute_RDSVL_R_I__ (SVL : Nat) (d : Nat) (imm : Int) : SailM Unit := do
  (CheckSMEEnabled ())
  let SVL := SVL
  let len := (imm *i (Int.ediv SVL 8))
  (X_set d 64 (integer_subrange len 63 0))

def decode_RDSVL_R_I__ (imm6 : (BitVec 6)) (Rd : (BitVec 5)) : SailM Unit := do
  let SVL ← do (CurrentSVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let imm := (BitVec.toInt imm6)
  match SVL with
  | 128 => (execute_RDSVL_R_I__ 128 d imm)
  | 256 => (execute_RDSVL_R_I__ 256 d imm)
  | 512 => (execute_RDSVL_R_I__ 512 d imm)
  | 1024 => (execute_RDSVL_R_I__ 1024 d imm)
  | 2048 => (execute_RDSVL_R_I__ 2048 d imm)
  | _ => (pure ())

/-- Type quantifiers: SVL : Nat, d : Nat, imm : Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(SVL) -/
def execute_ADDSPL_R_RI__ (SVL : Nat) (d : Nat) (imm : Int) (n : Nat) : SailM Unit := do
  (CheckSMEEnabled ())
  let SVL := SVL
  let len := (imm *i (Int.ediv SVL 64))
  let operand1 ← (( do
    bif (n == 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let result : (BitVec 64) := (BitVec.addInt operand1 len)
  bif (d == 31)
  then (SP_set result)
  else (X_set d 64 result)

def decode_ADDSPL_R_RI__ (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rd : (BitVec 5)) : SailM Unit := do
  let SVL ← do (CurrentSVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  let imm := (BitVec.toInt imm6)
  match SVL with
  | 128 => (execute_ADDSPL_R_RI__ 128 d imm n)
  | 256 => (execute_ADDSPL_R_RI__ 256 d imm n)
  | 512 => (execute_ADDSPL_R_RI__ 512 d imm n)
  | 1024 => (execute_ADDSPL_R_RI__ 1024 d imm n)
  | 2048 => (execute_ADDSPL_R_RI__ 2048 d imm n)
  | _ => (pure ())

/-- Type quantifiers: SVL : Nat, d : Nat, imm : Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(SVL) -/
def execute_ADDSVL_R_RI__ (SVL : Nat) (d : Nat) (imm : Int) (n : Nat) : SailM Unit := do
  (CheckSMEEnabled ())
  let SVL := SVL
  let len := (imm *i (Int.ediv SVL 8))
  let operand1 ← (( do
    bif (n == 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let result : (BitVec 64) := (BitVec.addInt operand1 len)
  bif (d == 31)
  then (SP_set result)
  else (X_set d 64 result)

def decode_ADDSVL_R_RI__ (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rd : (BitVec 5)) : SailM Unit := do
  let SVL ← do (CurrentSVL_read ())
  bif (! (← (HaveSME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  let imm := (BitVec.toInt imm6)
  match SVL with
  | 128 => (execute_ADDSVL_R_RI__ 128 d imm n)
  | 256 => (execute_ADDSVL_R_RI__ 256 d imm n)
  | 512 => (execute_ADDSVL_R_RI__ 512 d imm n)
  | 1024 => (execute_ADDSVL_R_RI__ 1024 d imm n)
  | 2048 => (execute_ADDSVL_R_RI__ 2048 d imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, ngrp : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧ offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ ngrp = 2 ∧ is_VL(VL) -/
def execute_ZERO_ZA1_RI_2 (VL : Nat) (ngrp : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name ngrp)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (ngrp -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let vec := vec
        (ZAvector_set vec VL (Zeros (n := VL)))
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_ZERO_ZA1_RI_2 (Rv : (BitVec 2)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat off3)
  let ngrp := 2
  match VL with
  | 128 => (execute_ZERO_ZA1_RI_2 128 ngrp offset v)
  | 256 => (execute_ZERO_ZA1_RI_2 256 ngrp offset v)
  | 512 => (execute_ZERO_ZA1_RI_2 512 ngrp offset v)
  | 1024 => (execute_ZERO_ZA1_RI_2 1024 ngrp offset v)
  | 2048 => (execute_ZERO_ZA1_RI_2 2048 ngrp offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, ngrp : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧ offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ ngrp = 4 ∧ is_VL(VL) -/
def execute_ZERO_ZA1_RI_4 (VL : Nat) (ngrp : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name ngrp)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (ngrp -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let vec := vec
        (ZAvector_set vec VL (Zeros (n := VL)))
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_ZERO_ZA1_RI_4 (Rv : (BitVec 2)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat off3)
  let ngrp := 4
  match VL with
  | 128 => (execute_ZERO_ZA1_RI_4 128 ngrp offset v)
  | 256 => (execute_ZERO_ZA1_RI_4 256 ngrp offset v)
  | 512 => (execute_ZERO_ZA1_RI_4 512 ngrp offset v)
  | 1024 => (execute_ZERO_ZA1_RI_4 1024 ngrp offset v)
  | 2048 => (execute_ZERO_ZA1_RI_4 2048 ngrp offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, ngrp : Nat, nvec : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧ 0 ≤ offset ∧ offset ≤ 15 ∧ nvec = 2 ∧ ngrp = 1 ∧ is_VL(VL) -/
def execute_ZERO_ZA2_RI_1 (VL : Nat) (ngrp : Nat) (nvec : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name ngrp)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec : Int := (vec -i (fmod_int vec nvec))
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (ngrp -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let vec := vec
        sorry -- E_for foreach (i from 0 to sub_atom(nvec, 1) by 1 order inc) { ZAvector_set(add_atom(vec, i), VL, Zeros(VL)) not translatable yet.
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_ZERO_ZA2_RI_1 (Rv : (BitVec 2)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let ngrp := 1
  let nvec := 2
  match VL with
  | 128 => (execute_ZERO_ZA2_RI_1 128 ngrp nvec offset v)
  | 256 => (execute_ZERO_ZA2_RI_1 256 ngrp nvec offset v)
  | 512 => (execute_ZERO_ZA2_RI_1 512 ngrp nvec offset v)
  | 1024 => (execute_ZERO_ZA2_RI_1 1024 ngrp nvec offset v)
  | 2048 => (execute_ZERO_ZA2_RI_1 2048 ngrp nvec offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, ngrp : Nat, nvec : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧ offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nvec = 2 ∧ ngrp = 2 ∧ is_VL(VL) -/
def execute_ZERO_ZA2_RI_2 (VL : Nat) (ngrp : Nat) (nvec : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name ngrp)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec : Int := (vec -i (fmod_int vec nvec))
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (ngrp -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let vec := vec
        sorry -- E_for foreach (i from 0 to sub_atom(nvec, 1) by 1 order inc) { ZAvector_set(add_atom(vec, i), VL, Zeros(VL)) not translatable yet.
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_ZERO_ZA2_RI_2 (Rv : (BitVec 2)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let ngrp := 2
  let nvec := 2
  match VL with
  | 128 => (execute_ZERO_ZA2_RI_2 128 ngrp nvec offset v)
  | 256 => (execute_ZERO_ZA2_RI_2 256 ngrp nvec offset v)
  | 512 => (execute_ZERO_ZA2_RI_2 512 ngrp nvec offset v)
  | 1024 => (execute_ZERO_ZA2_RI_2 1024 ngrp nvec offset v)
  | 2048 => (execute_ZERO_ZA2_RI_2 2048 ngrp nvec offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, ngrp : Nat, nvec : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧ offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nvec = 2 ∧ ngrp = 4 ∧ is_VL(VL) -/
def execute_ZERO_ZA2_RI_4 (VL : Nat) (ngrp : Nat) (nvec : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name ngrp)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec : Int := (vec -i (fmod_int vec nvec))
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (ngrp -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let vec := vec
        sorry -- E_for foreach (i from 0 to sub_atom(nvec, 1) by 1 order inc) { ZAvector_set(add_atom(vec, i), VL, Zeros(VL)) not translatable yet.
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_ZERO_ZA2_RI_4 (Rv : (BitVec 2)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let ngrp := 4
  let nvec := 2
  match VL with
  | 128 => (execute_ZERO_ZA2_RI_4 128 ngrp nvec offset v)
  | 256 => (execute_ZERO_ZA2_RI_4 256 ngrp nvec offset v)
  | 512 => (execute_ZERO_ZA2_RI_4 512 ngrp nvec offset v)
  | 1024 => (execute_ZERO_ZA2_RI_4 1024 ngrp nvec offset v)
  | 2048 => (execute_ZERO_ZA2_RI_4 2048 ngrp nvec offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, ngrp : Nat, nvec : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧ 0 ≤ offset ∧ offset ≤ 15 ∧ nvec = 4 ∧ ngrp = 1 ∧ is_VL(VL) -/
def execute_ZERO_ZA4_RI_1 (VL : Nat) (ngrp : Nat) (nvec : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name ngrp)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec : Int := (vec -i (fmod_int vec nvec))
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (ngrp -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let vec := vec
        sorry -- E_for foreach (i from 0 to sub_atom(nvec, 1) by 1 order inc) { ZAvector_set(add_atom(vec, i), VL, Zeros(VL)) not translatable yet.
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_ZERO_ZA4_RI_1 (Rv : (BitVec 2)) (off2 : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let ngrp := 1
  let nvec := 4
  match VL with
  | 128 => (execute_ZERO_ZA4_RI_1 128 ngrp nvec offset v)
  | 256 => (execute_ZERO_ZA4_RI_1 256 ngrp nvec offset v)
  | 512 => (execute_ZERO_ZA4_RI_1 512 ngrp nvec offset v)
  | 1024 => (execute_ZERO_ZA4_RI_1 1024 ngrp nvec offset v)
  | 2048 => (execute_ZERO_ZA4_RI_1 2048 ngrp nvec offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, ngrp : Nat, nvec : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧ offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nvec = 4 ∧ ngrp = 2 ∧ is_VL(VL) -/
def execute_ZERO_ZA4_RI_2 (VL : Nat) (ngrp : Nat) (nvec : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name ngrp)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec : Int := (vec -i (fmod_int vec nvec))
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (ngrp -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let vec := vec
        sorry -- E_for foreach (i from 0 to sub_atom(nvec, 1) by 1 order inc) { ZAvector_set(add_atom(vec, i), VL, Zeros(VL)) not translatable yet.
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_ZERO_ZA4_RI_2 (Rv : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let ngrp := 2
  let nvec := 4
  match VL with
  | 128 => (execute_ZERO_ZA4_RI_2 128 ngrp nvec offset v)
  | 256 => (execute_ZERO_ZA4_RI_2 256 ngrp nvec offset v)
  | 512 => (execute_ZERO_ZA4_RI_2 512 ngrp nvec offset v)
  | 1024 => (execute_ZERO_ZA4_RI_2 1024 ngrp nvec offset v)
  | 2048 => (execute_ZERO_ZA4_RI_2 2048 ngrp nvec offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, ngrp : Nat, nvec : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧ offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nvec = 4 ∧ ngrp = 4 ∧ is_VL(VL) -/
def execute_ZERO_ZA4_RI_4 (VL : Nat) (ngrp : Nat) (nvec : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name ngrp)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec : Int := (vec -i (fmod_int vec nvec))
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (ngrp -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let vec := vec
        sorry -- E_for foreach (i from 0 to sub_atom(nvec, 1) by 1 order inc) { ZAvector_set(add_atom(vec, i), VL, Zeros(VL)) not translatable yet.
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_ZERO_ZA4_RI_4 (Rv : (BitVec 2)) (o1 : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let ngrp := 4
  let nvec := 4
  match VL with
  | 128 => (execute_ZERO_ZA4_RI_4 128 ngrp nvec offset v)
  | 256 => (execute_ZERO_ZA4_RI_4 256 ngrp nvec offset v)
  | 512 => (execute_ZERO_ZA4_RI_4 512 ngrp nvec offset v)
  | 1024 => (execute_ZERO_ZA4_RI_4 1024 ngrp nvec offset v)
  | 2048 => (execute_ZERO_ZA4_RI_4 2048 ngrp nvec offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d__arg : Nat, dstride : Nat, esize : Nat, imm : Nat, isize : Nat, n
  : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  isize = 2 ∧
  imm ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ dstride = 8 ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ is_VL(VL) -/
def execute_LUTI2_MZ2_ZTZ_8 (VL : Nat) (d__arg : Nat) (dstride : Nat) (esize : Nat) (imm : Nat) (isize : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckStreamingSVEEnabled ())
  (CheckSMEZT0Enabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let segments := (Int.ediv esize (isize *i nreg))
  let segment := (Nat.div imm segments)
  let indexes ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let d ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := d
    for r in [loop_r_lower:loop_r_upper:1]i do
      let d := loop_vars
      loop_vars ← do
        let base := (((segment *i nreg) +i r) *i elements)
        let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let index ← do (pure (BitVec.toNat (← (Elem_read indexes (base +i e) isize))))
              assert ((esize -i 1) <b 32) "src/instrs64_sme.sail:37205.46-37205.47"
              (Elem_set result e esize
                (Sail.BitVec.extractLsb (← (Elem_read table index 32)) (esize -i 1) 0))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set d VL result)
        (pure (d +i dstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_LUTI2_MZ2_ZTZ_8 (i3 : (BitVec 3)) (size : (BitVec 2)) (Zn : (BitVec 5)) (D : (BitVec 1)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((size == (0b10 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let isize := 2
  let n := (BitVec.toNat Zn)
  let dstride := 8
  let d := (BitVec.toNat ((D ++ (0b0 : (BitVec 1))) ++ Zd))
  let imm := (BitVec.toNat i3)
  let nreg := 2
  match VL with
  | 128 => (execute_LUTI2_MZ2_ZTZ_8 128 d dstride esize imm isize n nreg)
  | 256 => (execute_LUTI2_MZ2_ZTZ_8 256 d dstride esize imm isize n nreg)
  | 512 => (execute_LUTI2_MZ2_ZTZ_8 512 d dstride esize imm isize n nreg)
  | 1024 => (execute_LUTI2_MZ2_ZTZ_8 1024 d dstride esize imm isize n nreg)
  | 2048 => (execute_LUTI2_MZ2_ZTZ_8 2048 d dstride esize imm isize n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d__arg : Nat, dstride : Nat, esize : Nat, imm : Nat, isize : Nat, n
  : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  isize = 4 ∧
  imm ∈ {0, 1, 2, 3} ∧
  esize ∈ {8, 16, 32, 64} ∧ dstride = 8 ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ is_VL(VL) -/
def execute_LUTI4_MZ2_ZTZ_8 (VL : Nat) (d__arg : Nat) (dstride : Nat) (esize : Nat) (imm : Nat) (isize : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckStreamingSVEEnabled ())
  (CheckSMEZT0Enabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let segments := (Int.ediv esize (isize *i nreg))
  let segment := (Nat.div imm segments)
  let indexes ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let d ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := d
    for r in [loop_r_lower:loop_r_upper:1]i do
      let d := loop_vars
      loop_vars ← do
        let base := (((segment *i nreg) +i r) *i elements)
        let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let index ← do (pure (BitVec.toNat (← (Elem_read indexes (base +i e) isize))))
              assert ((esize -i 1) <b 32) "src/instrs64_sme.sail:37279.46-37279.47"
              (Elem_set result e esize
                (Sail.BitVec.extractLsb (← (Elem_read table index 32)) (esize -i 1) 0))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set d VL result)
        (pure (d +i dstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_LUTI4_MZ2_ZTZ_8 (i2 : (BitVec 2)) (size : (BitVec 2)) (Zn : (BitVec 5)) (D : (BitVec 1)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((size == (0b10 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let isize := 4
  let n := (BitVec.toNat Zn)
  let dstride := 8
  let d := (BitVec.toNat ((D ++ (0b0 : (BitVec 1))) ++ Zd))
  let imm := (BitVec.toNat i2)
  let nreg := 2
  match VL with
  | 128 => (execute_LUTI4_MZ2_ZTZ_8 128 d dstride esize imm isize n nreg)
  | 256 => (execute_LUTI4_MZ2_ZTZ_8 256 d dstride esize imm isize n nreg)
  | 512 => (execute_LUTI4_MZ2_ZTZ_8 512 d dstride esize imm isize n nreg)
  | 1024 => (execute_LUTI4_MZ2_ZTZ_8 1024 d dstride esize imm isize n nreg)
  | 2048 => (execute_LUTI4_MZ2_ZTZ_8 2048 d dstride esize imm isize n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d__arg : Nat, dstride : Nat, esize : Nat, imm : Nat, isize : Nat, n
  : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  isize = 2 ∧
  imm ∈ {0, 1, 2, 3} ∧
  esize ∈ {8, 16, 32, 64} ∧ dstride = 4 ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ is_VL(VL) -/
def execute_LUTI2_MZ4_ZTZ_4 (VL : Nat) (d__arg : Nat) (dstride : Nat) (esize : Nat) (imm : Nat) (isize : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckStreamingSVEEnabled ())
  (CheckSMEZT0Enabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let segments := (Int.ediv esize (isize *i nreg))
  let segment := (Nat.div imm segments)
  let indexes ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let d ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := d
    for r in [loop_r_lower:loop_r_upper:1]i do
      let d := loop_vars
      loop_vars ← do
        let base := (((segment *i nreg) +i r) *i elements)
        let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let index ← do (pure (BitVec.toNat (← (Elem_read indexes (base +i e) isize))))
              assert ((esize -i 1) <b 32) "src/instrs64_sme.sail:37353.46-37353.47"
              (Elem_set result e esize
                (Sail.BitVec.extractLsb (← (Elem_read table index 32)) (esize -i 1) 0))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set d VL result)
        (pure (d +i dstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_LUTI2_MZ4_ZTZ_4 (i2 : (BitVec 2)) (size : (BitVec 2)) (Zn : (BitVec 5)) (D : (BitVec 1)) (Zd : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((size == (0b10 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let isize := 2
  let n := (BitVec.toNat Zn)
  let dstride := 4
  let d := (BitVec.toNat ((D ++ (0b00 : (BitVec 2))) ++ Zd))
  let imm := (BitVec.toNat i2)
  let nreg := 4
  match VL with
  | 128 => (execute_LUTI2_MZ4_ZTZ_4 128 d dstride esize imm isize n nreg)
  | 256 => (execute_LUTI2_MZ4_ZTZ_4 256 d dstride esize imm isize n nreg)
  | 512 => (execute_LUTI2_MZ4_ZTZ_4 512 d dstride esize imm isize n nreg)
  | 1024 => (execute_LUTI2_MZ4_ZTZ_4 1024 d dstride esize imm isize n nreg)
  | 2048 => (execute_LUTI2_MZ4_ZTZ_4 2048 d dstride esize imm isize n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d__arg : Nat, dstride : Nat, esize : Nat, imm : Nat, isize : Nat, n
  : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  isize = 4 ∧
  imm ∈ {0, 1} ∧
  esize ∈ {8, 16, 32, 64} ∧ dstride = 4 ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ is_VL(VL) -/
def execute_LUTI4_MZ4_ZTZ_4 (VL : Nat) (d__arg : Nat) (dstride : Nat) (esize : Nat) (imm : Nat) (isize : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckStreamingSVEEnabled ())
  (CheckSMEZT0Enabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let segments := (Int.ediv esize (isize *i nreg))
  let segment := (fmod_int imm segments)
  let indexes ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let table ← (( do (ZT0_read 512) ) : SailM (BitVec 512) )
  let d ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := d
    for r in [loop_r_lower:loop_r_upper:1]i do
      let d := loop_vars
      loop_vars ← do
        let base := (((segment *i nreg) +i r) *i elements)
        let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let index ← do (pure (BitVec.toNat (← (Elem_read indexes (base +i e) isize))))
              assert ((esize -i 1) <b 32) "src/instrs64_sme.sail:37427.46-37427.47"
              (Elem_set result e esize
                (Sail.BitVec.extractLsb (← (Elem_read table index 32)) (esize -i 1) 0))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        (Z_set d VL result)
        (pure (d +i dstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_LUTI4_MZ4_ZTZ_4 (i1 : (BitVec 1)) (size : (BitVec 2)) (Zn : (BitVec 5)) (D : (BitVec 1)) (Zd : (BitVec 2)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size != (0b01 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let isize := 4
  let n := (BitVec.toNat Zn)
  let dstride := 4
  let d := (BitVec.toNat ((D ++ (0b00 : (BitVec 2))) ++ Zd))
  let imm := (BitVec.toNat i1)
  let nreg := 4
  match VL with
  | 128 => (execute_LUTI4_MZ4_ZTZ_4 128 d dstride esize imm isize n nreg)
  | 256 => (execute_LUTI4_MZ4_ZTZ_4 256 d dstride esize imm isize n nreg)
  | 512 => (execute_LUTI4_MZ4_ZTZ_4 512 d dstride esize imm isize n nreg)
  | 1024 => (execute_LUTI4_MZ4_ZTZ_4 1024 d dstride esize imm isize n nreg)
  | 2048 => (execute_LUTI4_MZ4_ZTZ_4 2048 d dstride esize imm isize n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, offset : Nat, s : Nat, k_vertical :
  Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧ offset ≤ 15 ∧ n = 0 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_Z_RZA_B (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let operand ← (( do (ZAslice_read n esize vertical slice_name VL) ) : SailM (BitVec VL) )
  (ZAslice_set n esize vertical slice_name VL (Zeros (n := VL)))
  (Z_set d VL operand)

def decode_MOVAZ_Z_RZA_B (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (off4 : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := 0
  let offset := (BitVec.toNat off4)
  let esize := 8
  let d := (BitVec.toNat Zd)
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_Z_RZA_B 128 d esize n offset s vertical)
  | 256 => (execute_MOVAZ_Z_RZA_B 256 d esize n offset s vertical)
  | 512 => (execute_MOVAZ_Z_RZA_B 512 d esize n offset s vertical)
  | 1024 => (execute_MOVAZ_Z_RZA_B 1024 d esize n offset s vertical)
  | 2048 => (execute_MOVAZ_Z_RZA_B 2048 d esize n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, offset : Nat, s : Nat, k_vertical :
  Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  n ∈ {0, 1} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_Z_RZA_H (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let operand ← (( do (ZAslice_read n esize vertical slice_name VL) ) : SailM (BitVec VL) )
  (ZAslice_set n esize vertical slice_name VL (Zeros (n := VL)))
  (Z_set d VL operand)

def decode_MOVAZ_Z_RZA_H (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 1)) (off3 : (BitVec 3)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat off3)
  let esize := 16
  let d := (BitVec.toNat Zd)
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_Z_RZA_H 128 d esize n offset s vertical)
  | 256 => (execute_MOVAZ_Z_RZA_H 256 d esize n offset s vertical)
  | 512 => (execute_MOVAZ_Z_RZA_H 512 d esize n offset s vertical)
  | 1024 => (execute_MOVAZ_Z_RZA_H 1024 d esize n offset s vertical)
  | 2048 => (execute_MOVAZ_Z_RZA_H 2048 d esize n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, offset : Nat, s : Nat, k_vertical :
  Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3} ∧
  n ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_Z_RZA_W (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let operand ← (( do (ZAslice_read n esize vertical slice_name VL) ) : SailM (BitVec VL) )
  (ZAslice_set n esize vertical slice_name VL (Zeros (n := VL)))
  (Z_set d VL operand)

def decode_MOVAZ_Z_RZA_W (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 2)) (off2 : (BitVec 2)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat off2)
  let esize := 32
  let d := (BitVec.toNat Zd)
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_Z_RZA_W 128 d esize n offset s vertical)
  | 256 => (execute_MOVAZ_Z_RZA_W 256 d esize n offset s vertical)
  | 512 => (execute_MOVAZ_Z_RZA_W 512 d esize n offset s vertical)
  | 1024 => (execute_MOVAZ_Z_RZA_W 1024 d esize n offset s vertical)
  | 2048 => (execute_MOVAZ_Z_RZA_W 2048 d esize n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, offset : Nat, s : Nat, k_vertical :
  Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1} ∧
  n ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_Z_RZA_D (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let operand ← (( do (ZAslice_read n esize vertical slice_name VL) ) : SailM (BitVec VL) )
  (ZAslice_set n esize vertical slice_name VL (Zeros (n := VL)))
  (Z_set d VL operand)

def decode_MOVAZ_Z_RZA_D (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 3)) (o1 : (BitVec 1)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat o1)
  let esize := 64
  let d := (BitVec.toNat Zd)
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_Z_RZA_D 128 d esize n offset s vertical)
  | 256 => (execute_MOVAZ_Z_RZA_D 256 d esize n offset s vertical)
  | 512 => (execute_MOVAZ_Z_RZA_D 512 d esize n offset s vertical)
  | 1024 => (execute_MOVAZ_Z_RZA_D 1024 d esize n offset s vertical)
  | 2048 => (execute_MOVAZ_Z_RZA_D 2048 d esize n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, offset : Nat, s : Nat, k_vertical :
  Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧ 0 ≤ n ∧ n ≤ 15 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_Z_RZA_Q (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name := (Nat.div ((BitVec.toNat index) +i offset) dim)
  let operand ← (( do (ZAslice_read n esize vertical slice_name VL) ) : SailM (BitVec VL) )
  (ZAslice_set n esize vertical slice_name VL (Zeros (n := VL)))
  (Z_set d VL operand)

def decode_MOVAZ_Z_RZA_Q (size : (BitVec 2)) (Q : (BitVec 1)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let n := (BitVec.toNat ZAn)
  let offset := 0
  let esize := 128
  let d := (BitVec.toNat Zd)
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_Z_RZA_Q 128 d esize n offset s vertical)
  | 256 => (execute_MOVAZ_Z_RZA_Q 256 d esize n offset s vertical)
  | 512 => (execute_MOVAZ_Z_RZA_Q 512 d esize n offset s vertical)
  | 1024 => (execute_MOVAZ_Z_RZA_Q 1024 d esize n offset s vertical)
  | 2048 => (execute_MOVAZ_Z_RZA_Q 2048 d esize n offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧ nreg = 2 ∧ n = 0 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_MZ2_ZA_B1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (ZAslice_set n esize vertical (slice_name +i r) VL (Zeros (n := VL)))
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVAZ_MZ2_ZA_B1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (off3 : (BitVec 3)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 8
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let n := 0
  let offset := (BitVec.toNat (off3 ++ (0b0 : (BitVec 1))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_MZ2_ZA_B1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVAZ_MZ2_ZA_B1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVAZ_MZ2_ZA_B1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVAZ_MZ2_ZA_B1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVAZ_MZ2_ZA_B1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ n ∈ {0, 1} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_MZ2_ZA_H1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (ZAslice_set n esize vertical (slice_name +i r) VL (Zeros (n := VL)))
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVAZ_MZ2_ZA_H1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 1)) (off2 : (BitVec 2)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 16
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat (off2 ++ (0b0 : (BitVec 1))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_MZ2_ZA_H1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVAZ_MZ2_ZA_H1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVAZ_MZ2_ZA_H1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVAZ_MZ2_ZA_H1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVAZ_MZ2_ZA_H1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3} ∧
  nreg = 2 ∧ n ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_MZ2_ZA_W1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (ZAslice_set n esize vertical (slice_name +i r) VL (Zeros (n := VL)))
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVAZ_MZ2_ZA_W1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 2)) (o1 : (BitVec 1)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 32
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat (o1 ++ (0b0 : (BitVec 1))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_MZ2_ZA_W1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVAZ_MZ2_ZA_W1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVAZ_MZ2_ZA_W1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVAZ_MZ2_ZA_W1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVAZ_MZ2_ZA_W1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  nreg = 2 ∧ n ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_MZ2_ZA_D1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (ZAslice_set n esize vertical (slice_name +i r) VL (Zeros (n := VL)))
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVAZ_MZ2_ZA_D1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 3)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 2
  let esize := 64
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let n := (BitVec.toNat ZAn)
  let offset := 0
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_MZ2_ZA_D1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVAZ_MZ2_ZA_D1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVAZ_MZ2_ZA_D1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVAZ_MZ2_ZA_D1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVAZ_MZ2_ZA_D1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 15 ∧ nreg = 4 ∧ n = 0 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_MZ4_ZA_B1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (ZAslice_set n esize vertical (slice_name +i r) VL (Zeros (n := VL)))
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVAZ_MZ4_ZA_B1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (off2 : (BitVec 2)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 8
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let n := 0
  let offset := (BitVec.toNat (off2 ++ (0b00 : (BitVec 2))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_MZ4_ZA_B1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVAZ_MZ4_ZA_B1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVAZ_MZ4_ZA_B1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVAZ_MZ4_ZA_B1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVAZ_MZ4_ZA_B1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ n ∈ {0, 1} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_MZ4_ZA_H1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (ZAslice_set n esize vertical (slice_name +i r) VL (Zeros (n := VL)))
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVAZ_MZ4_ZA_H1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 1)) (o1 : (BitVec 1)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 16
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let n := (BitVec.toNat ZAn)
  let offset := (BitVec.toNat (o1 ++ (0b00 : (BitVec 2))))
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_MZ4_ZA_H1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVAZ_MZ4_ZA_H1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVAZ_MZ4_ZA_H1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVAZ_MZ4_ZA_H1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVAZ_MZ4_ZA_H1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  nreg = 4 ∧ n ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_MZ4_ZA_W1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (ZAslice_set n esize vertical (slice_name +i r) VL (Zeros (n := VL)))
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVAZ_MZ4_ZA_W1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 2)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 32
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let n := (BitVec.toNat ZAn)
  let offset := 0
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_MZ4_ZA_W1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVAZ_MZ4_ZA_W1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVAZ_MZ4_ZA_W1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVAZ_MZ4_ZA_W1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVAZ_MZ4_ZA_W1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, nreg : Nat, offset : Nat, s : Nat, k_vertical
  : Bool, 0 ≤ s ∧
  s ≤ 31 ∧
  offset = 0 ∧
  nreg = 4 ∧ n ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_MZ4_ZA_D1 (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (s : Nat) (vertical : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  bif (((nreg == 4) && (esize == 64)) && (VL == 128))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let slices := (Int.ediv VL esize)
  let index ← (( do (X_read s 32) ) : SailM (BitVec 32) )
  let slice_name :=
    (fmod_int (((BitVec.toNat index) -i (Nat.div (BitVec.toNat index) nreg)) +i offset) slices)
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let result ← (( do (ZAslice_read n esize vertical (slice_name +i r) VL) ) : SailM
        (BitVec VL) )
      (ZAslice_set n esize vertical (slice_name +i r) VL (Zeros (n := VL)))
      (Z_set (d +i r) VL result)
  (pure loop_vars)

def decode_MOVAZ_MZ4_ZA_D1 (size : (BitVec 2)) (V : (BitVec 1)) (Rs : (BitVec 2)) (ZAn : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let s := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rs))
  let nreg := 4
  let esize := 64
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let n := (BitVec.toNat ZAn)
  let offset := 0
  let vertical : Bool := (V == (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVAZ_MZ4_ZA_D1 128 d esize n nreg offset s vertical)
  | 256 => (execute_MOVAZ_MZ4_ZA_D1 256 d esize n nreg offset s vertical)
  | 512 => (execute_MOVAZ_MZ4_ZA_D1 512 d esize n nreg offset s vertical)
  | 1024 => (execute_MOVAZ_MZ4_ZA_D1 1024 d esize n nreg offset s vertical)
  | 2048 => (execute_MOVAZ_MZ4_ZA_D1 2048 d esize n nreg offset s vertical)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nreg = 2 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_MZ_ZA2_1 (VL : Nat) (d : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let result ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL (Zeros (n := VL)))
        (Z_set (d +i r) VL result)
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_MOVAZ_MZ_ZA2_1 (Rv : (BitVec 2)) (off3 : (BitVec 3)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat off3)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_MOVAZ_MZ_ZA2_1 128 d nreg offset v)
  | 256 => (execute_MOVAZ_MZ_ZA2_1 256 d nreg offset v)
  | 512 => (execute_MOVAZ_MZ_ZA2_1 512 d nreg offset v)
  | 1024 => (execute_MOVAZ_MZ_ZA2_1 1024 d nreg offset v)
  | 2048 => (execute_MOVAZ_MZ_ZA2_1 2048 d nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nreg = 4 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVAZ_MZ_ZA4_1 (VL : Nat) (d : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let vec ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := vec
    for r in [loop_r_lower:loop_r_upper:1]i do
      let vec := loop_vars
      loop_vars ← do
        let result ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL (Zeros (n := VL)))
        (Z_set (d +i r) VL result)
        (pure (vec +i vstride))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_MOVAZ_MZ_ZA4_1 (Rv : (BitVec 2)) (off3 : (BitVec 3)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSME2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let offset := (BitVec.toNat off3)
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_MOVAZ_MZ_ZA4_1 128 d nreg offset v)
  | 256 => (execute_MOVAZ_MZ_ZA4_1 256 d nreg offset v)
  | 512 => (execute_MOVAZ_MZ_ZA4_1 512 d nreg offset v)
  | 1024 => (execute_MOVAZ_MZ_ZA4_1 1024 d nreg offset v)
  | 2048 => (execute_MOVAZ_MZ_ZA4_1 2048 d nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 16 ∧
  da ∈ {0, 1} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_FMOPA_ZA_PP_ZZ_16 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 row esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 col esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                     mask2 col esize)))
            then
              (do
                let element1 ← (( do
                  bif sub_op
                  then
                    (do
                      (FPNeg element1))
                  else (pure element1) ) : SailM (BitVec esize) )
                (Elem_set result ((row *i dim) +i col) esize
                  (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ()))))))
            else
              (do
                (Elem_set result ((row *i dim) +i col) esize element3))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_FMOPA_ZA_PP_ZZ_16 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  match VL with
  | 128 => (execute_FMOPA_ZA_PP_ZZ_16 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n sub_op)
  | 256 => (execute_FMOPA_ZA_PP_ZZ_16 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n sub_op)
  | 512 => (execute_FMOPA_ZA_PP_ZZ_16 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n sub_op)
  | 1024 => (execute_FMOPA_ZA_PP_ZZ_16 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op)
  | 2048 => (execute_FMOPA_ZA_PP_ZZ_16 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_esize : Nat, esize : Nat, m :
  Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize = 16 ∧
  da ∈ {0, 1} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  is_VL(VL) ∧ dim_dim_esize = (VL / esize * (VL / esize * esize)) -/
def execute_FMOPS_ZA_PP_ZZ_16 (VL : Nat) (dim_dim_esize : Nat) (a : Nat) (b : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL esize)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da esize dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do (undefined_bitvector dim_dim_esize) ) : SailM (BitVec dim_dim_esize) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 row esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 col esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 ((row *i dim) +i col) esize) ) : SailM
              (BitVec esize) )
            bif ((← (ActivePredicateElement mask1 row esize)) && (← (ActivePredicateElement
                     mask2 col esize)))
            then
              (do
                let element1 ← (( do
                  bif sub_op
                  then
                    (do
                      (FPNeg element1))
                  else (pure element1) ) : SailM (BitVec esize) )
                (Elem_set result ((row *i dim) +i col) esize
                  (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ()))))))
            else
              (do
                (Elem_set result ((row *i dim) +i col) esize element3))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_esize) )
  (ZAtile_set VL da esize dim_dim_esize result)

def decode_FMOPS_ZA_PP_ZZ_16 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  match VL with
  | 128 => (execute_FMOPS_ZA_PP_ZZ_16 128 (((Int.ediv 128 esize) *i (Int.ediv 128 esize)) *i esize)
      a b da esize m n sub_op)
  | 256 => (execute_FMOPS_ZA_PP_ZZ_16 256 (((Int.ediv 256 esize) *i (Int.ediv 256 esize)) *i esize)
      a b da esize m n sub_op)
  | 512 => (execute_FMOPS_ZA_PP_ZZ_16 512 (((Int.ediv 512 esize) *i (Int.ediv 512 esize)) *i esize)
      a b da esize m n sub_op)
  | 1024 => (execute_FMOPS_ZA_PP_ZZ_16 1024
      (((Int.ediv 1024 esize) *i (Int.ediv 1024 esize)) *i esize) a b da esize m n sub_op)
  | 2048 => (execute_FMOPS_ZA_PP_ZZ_16 2048
      (((Int.ediv 2048 esize) *i (Int.ediv 2048 esize)) *i esize) a b da esize m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_16 : Nat, m : Nat, n : Nat, k_sub_op
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  da ∈ {0, 1} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) ∧ dim_dim_16 = (VL / 16 * (VL / 16 * 16)) -/
def execute_BFMOPA_ZA_PP_ZZ_16 (VL : Nat) (dim_dim_16 : Nat) (a : Nat) (b : Nat) (da : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL 16)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da 16 dim_dim_16) ) : SailM (BitVec dim_dim_16) )
  let result ← (( do (undefined_bitvector dim_dim_16) ) : SailM (BitVec dim_dim_16) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 row 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 col 16) ) : SailM (BitVec 16) )
            let element3 ← (( do (Elem_read operand3 ((row *i dim) +i col) 16) ) : SailM
              (BitVec 16) )
            bif ((← (ActivePredicateElement mask1 row 16)) && (← (ActivePredicateElement mask2
                     col 16)))
            then
              (do
                let element1 ← (( do
                  bif sub_op
                  then
                    (do
                      (BFNeg element1))
                  else (pure element1) ) : SailM (BitVec 16) )
                (Elem_set result ((row *i dim) +i col) 16
                  (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ()))))))
            else
              (do
                (Elem_set result ((row *i dim) +i col) 16 element3))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_16) )
  (ZAtile_set VL da 16 dim_dim_16 result)

def decode_BFMOPA_ZA_PP_ZZ_16 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := false
  match VL with
  | 128 => (execute_BFMOPA_ZA_PP_ZZ_16 128 (((Int.ediv 128 16) *i (Int.ediv 128 16)) *i 16) a b da m
      n sub_op)
  | 256 => (execute_BFMOPA_ZA_PP_ZZ_16 256 (((Int.ediv 256 16) *i (Int.ediv 256 16)) *i 16) a b da m
      n sub_op)
  | 512 => (execute_BFMOPA_ZA_PP_ZZ_16 512 (((Int.ediv 512 16) *i (Int.ediv 512 16)) *i 16) a b da m
      n sub_op)
  | 1024 => (execute_BFMOPA_ZA_PP_ZZ_16 1024 (((Int.ediv 1024 16) *i (Int.ediv 1024 16)) *i 16) a b
      da m n sub_op)
  | 2048 => (execute_BFMOPA_ZA_PP_ZZ_16 2048 (((Int.ediv 2048 16) *i (Int.ediv 2048 16)) *i 16) a b
      da m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, b : Nat, da : Nat, dim_dim_16 : Nat, m : Nat, n : Nat, k_sub_op
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  da ∈ {0, 1} ∧
  b ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  a ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) ∧ dim_dim_16 = (VL / 16 * (VL / 16 * 16)) -/
def execute_BFMOPS_ZA_PP_ZZ_16 (VL : Nat) (dim_dim_16 : Nat) (a : Nat) (b : Nat) (da : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dim := (Int.ediv VL 16)
  let mask1 ← (( do (P_read a PL) ) : SailM (BitVec PL) )
  let mask2 ← (( do (P_read b PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (ZAtile_read VL da 16 dim_dim_16) ) : SailM (BitVec dim_dim_16) )
  let result ← (( do (undefined_bitvector dim_dim_16) ) : SailM (BitVec dim_dim_16) )
  let result ← (( do
    let loop_row_lower := 0
    let loop_row_upper := (dim -i 1)
    let mut loop_vars := result
    for row in [loop_row_lower:loop_row_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_col_lower := 0
        let loop_col_upper := (dim -i 1)
        let mut loop_vars_1 := result
        for col in [loop_col_lower:loop_col_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 row 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 col 16) ) : SailM (BitVec 16) )
            let element3 ← (( do (Elem_read operand3 ((row *i dim) +i col) 16) ) : SailM
              (BitVec 16) )
            bif ((← (ActivePredicateElement mask1 row 16)) && (← (ActivePredicateElement mask2
                     col 16)))
            then
              (do
                let element1 ← (( do
                  bif sub_op
                  then
                    (do
                      (BFNeg element1))
                  else (pure element1) ) : SailM (BitVec 16) )
                (Elem_set result ((row *i dim) +i col) 16
                  (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ()))))))
            else
              (do
                (Elem_set result ((row *i dim) +i col) 16 element3))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec dim_dim_16) )
  (ZAtile_set VL da 16 dim_dim_16 result)

def decode_BFMOPS_ZA_PP_ZZ_16 (Zm : (BitVec 5)) (Pm : (BitVec 3)) (Pn : (BitVec 3)) (Zn : (BitVec 5)) (S : (BitVec 1)) (ZAda : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let a := (BitVec.toNat Pn)
  let b := (BitVec.toNat Pm)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat ZAda)
  let sub_op : Bool := true
  match VL with
  | 128 => (execute_BFMOPS_ZA_PP_ZZ_16 128 (((Int.ediv 128 16) *i (Int.ediv 128 16)) *i 16) a b da m
      n sub_op)
  | 256 => (execute_BFMOPS_ZA_PP_ZZ_16 256 (((Int.ediv 256 16) *i (Int.ediv 256 16)) *i 16) a b da m
      n sub_op)
  | 512 => (execute_BFMOPS_ZA_PP_ZZ_16 512 (((Int.ediv 512 16) *i (Int.ediv 512 16)) *i 16) a b da m
      n sub_op)
  | 1024 => (execute_BFMOPS_ZA_PP_ZZ_16 1024 (((Int.ediv 1024 16) *i (Int.ediv 1024 16)) *i 16) a b
      da m n sub_op)
  | 2048 => (execute_BFMOPS_ZA_PP_ZZ_16 2048 (((Int.ediv 2048 16) *i (Int.ediv 2048 16)) *i 16) a b
      da m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FADD_ZA_ZW_2x2_16 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (← (FPAdd_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FADD_ZA_ZW_2x2_16 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_FADD_ZA_ZW_2x2_16 128 esize m nreg offset v)
  | 256 => (execute_FADD_ZA_ZW_2x2_16 256 esize m nreg offset v)
  | 512 => (execute_FADD_ZA_ZW_2x2_16 512 esize m nreg offset v)
  | 1024 => (execute_FADD_ZA_ZW_2x2_16 1024 esize m nreg offset v)
  | 2048 => (execute_FADD_ZA_ZW_2x2_16 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FSUB_ZA_ZW_2x2_16 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (← (FPSub_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FSUB_ZA_ZW_2x2_16 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_FSUB_ZA_ZW_2x2_16 128 esize m nreg offset v)
  | 256 => (execute_FSUB_ZA_ZW_2x2_16 256 esize m nreg offset v)
  | 512 => (execute_FSUB_ZA_ZW_2x2_16 512 esize m nreg offset v)
  | 1024 => (execute_FSUB_ZA_ZW_2x2_16 1024 esize m nreg offset v)
  | 2048 => (execute_FSUB_ZA_ZW_2x2_16 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nreg = 2 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFADD_ZA_ZW_2x2_16 (VL : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              (Elem_set result e 16 (← (BFAdd_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFADD_ZA_ZW_2x2_16 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_BFADD_ZA_ZW_2x2_16 128 m nreg offset v)
  | 256 => (execute_BFADD_ZA_ZW_2x2_16 256 m nreg offset v)
  | 512 => (execute_BFADD_ZA_ZW_2x2_16 512 m nreg offset v)
  | 1024 => (execute_BFADD_ZA_ZW_2x2_16 1024 m nreg offset v)
  | 2048 => (execute_BFADD_ZA_ZW_2x2_16 2048 m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nreg = 2 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFSUB_ZA_ZW_2x2_16 (VL : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              (Elem_set result e 16 (← (BFSub_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFSUB_ZA_ZW_2x2_16 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let nreg := 2
  match VL with
  | 128 => (execute_BFSUB_ZA_ZW_2x2_16 128 m nreg offset v)
  | 256 => (execute_BFSUB_ZA_ZW_2x2_16 256 m nreg offset v)
  | 512 => (execute_BFSUB_ZA_ZW_2x2_16 512 m nreg offset v)
  | 1024 => (execute_BFSUB_ZA_ZW_2x2_16 1024 m nreg offset v)
  | 2048 => (execute_BFSUB_ZA_ZW_2x2_16 2048 m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FADD_ZA_ZW_4x4_16 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (← (FPAdd_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FADD_ZA_ZW_4x4_16 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_FADD_ZA_ZW_4x4_16 128 esize m nreg offset v)
  | 256 => (execute_FADD_ZA_ZW_4x4_16 256 esize m nreg offset v)
  | 512 => (execute_FADD_ZA_ZW_4x4_16 512 esize m nreg offset v)
  | 1024 => (execute_FADD_ZA_ZW_4x4_16 1024 esize m nreg offset v)
  | 2048 => (execute_FADD_ZA_ZW_4x4_16 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FSUB_ZA_ZW_4x4_16 (VL : Nat) (esize : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              (Elem_set result e esize (← (FPSub_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FSUB_ZA_ZW_4x4_16 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_FSUB_ZA_ZW_4x4_16 128 esize m nreg offset v)
  | 256 => (execute_FSUB_ZA_ZW_4x4_16 256 esize m nreg offset v)
  | 512 => (execute_FSUB_ZA_ZW_4x4_16 512 esize m nreg offset v)
  | 1024 => (execute_FSUB_ZA_ZW_4x4_16 1024 esize m nreg offset v)
  | 2048 => (execute_FSUB_ZA_ZW_4x4_16 2048 esize m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nreg = 4 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFADD_ZA_ZW_4x4_16 (VL : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              (Elem_set result e 16 (← (BFAdd_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFADD_ZA_ZW_4x4_16 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_BFADD_ZA_ZW_4x4_16 128 m nreg offset v)
  | 256 => (execute_BFADD_ZA_ZW_4x4_16 256 m nreg offset v)
  | 512 => (execute_BFADD_ZA_ZW_4x4_16 512 m nreg offset v)
  | 1024 => (execute_BFADD_ZA_ZW_4x4_16 1024 m nreg offset v)
  | 2048 => (execute_BFADD_ZA_ZW_4x4_16 2048 m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, nreg : Nat, offset : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ nreg = 4 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFSUB_ZA_ZW_4x4_16 (VL : Nat) (m : Nat) (nreg : Nat) (offset : Nat) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              (Elem_set result e 16 (← (BFSub_ZA element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFSUB_ZA_ZW_4x4_16 (sz : (BitVec 1)) (Rv : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let nreg := 4
  match VL with
  | 128 => (execute_BFSUB_ZA_ZW_4x4_16 128 m nreg offset v)
  | 256 => (execute_BFSUB_ZA_ZW_4x4_16 256 m nreg offset v)
  | 512 => (execute_BFSUB_ZA_ZW_4x4_16 512 m nreg offset v)
  | 1024 => (execute_BFSUB_ZA_ZW_4x4_16 1024 m nreg offset v)
  | 2048 => (execute_BFSUB_ZA_ZW_4x4_16 2048 m nreg offset v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZW_2x2_16 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZW_2x2_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_FMLA_ZA_ZZW_2x2_16 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZW_2x2_16 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZW_2x2_16 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZW_2x2_16 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZW_2x2_16 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZW_2x2_16 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZW_2x2_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_FMLS_ZA_ZZW_2x2_16 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZW_2x2_16 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZW_2x2_16 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZW_2x2_16 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZW_2x2_16 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLA_ZA_ZZW_2x2_16 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLA_ZA_ZZW_2x2_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLA_ZA_ZZW_2x2_16 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLA_ZA_ZZW_2x2_16 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLA_ZA_ZZW_2x2_16 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLA_ZA_ZZW_2x2_16 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLA_ZA_ZZW_2x2_16 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLS_ZA_ZZW_2x2_16 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLS_ZA_ZZW_2x2_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLS_ZA_ZZW_2x2_16 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLS_ZA_ZZW_2x2_16 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLS_ZA_ZZW_2x2_16 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLS_ZA_ZZW_2x2_16 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLS_ZA_ZZW_2x2_16 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZV_2x1_16 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZV_2x1_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_FMLA_ZA_ZZV_2x1_16 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZV_2x1_16 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZV_2x1_16 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZV_2x1_16 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZV_2x1_16 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZV_2x1_16 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZV_2x1_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_FMLS_ZA_ZZV_2x1_16 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZV_2x1_16 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZV_2x1_16 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZV_2x1_16 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZV_2x1_16 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLA_ZA_ZZV_2x1_16 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLA_ZA_ZZV_2x1_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLA_ZA_ZZV_2x1_16 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLA_ZA_ZZV_2x1_16 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLA_ZA_ZZV_2x1_16 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLA_ZA_ZZV_2x1_16 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLA_ZA_ZZV_2x1_16 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLS_ZA_ZZV_2x1_16 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLS_ZA_ZZV_2x1_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLS_ZA_ZZV_2x1_16 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLS_ZA_ZZV_2x1_16 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLS_ZA_ZZV_2x1_16 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLS_ZA_ZZV_2x1_16 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLS_ZA_ZZV_2x1_16 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZW_4x4_16 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZW_4x4_16 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_FMLA_ZA_ZZW_4x4_16 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZW_4x4_16 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZW_4x4_16 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZW_4x4_16 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZW_4x4_16 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZW_4x4_16 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZW_4x4_16 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_FMLS_ZA_ZZW_4x4_16 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZW_4x4_16 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZW_4x4_16 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZW_4x4_16 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZW_4x4_16 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLA_ZA_ZZW_4x4_16 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLA_ZA_ZZW_4x4_16 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLA_ZA_ZZW_4x4_16 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLA_ZA_ZZW_4x4_16 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLA_ZA_ZZW_4x4_16 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLA_ZA_ZZW_4x4_16 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLA_ZA_ZZW_4x4_16 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLS_ZA_ZZW_4x4_16 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLS_ZA_ZZW_4x4_16 (sz : (BitVec 1)) (Zm : (BitVec 3)) (Rv : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLS_ZA_ZZW_4x4_16 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLS_ZA_ZZW_4x4_16 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLS_ZA_ZZW_4x4_16 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLS_ZA_ZZW_4x4_16 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLS_ZA_ZZW_4x4_16 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZV_4x1_16 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZV_4x1_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_FMLA_ZA_ZZV_4x1_16 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZV_4x1_16 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZV_4x1_16 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZV_4x1_16 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZV_4x1_16 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZV_4x1_16 (VL : Nat) (esize : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZV_4x1_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_FMLS_ZA_ZZV_4x1_16 128 esize m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZV_4x1_16 256 esize m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZV_4x1_16 512 esize m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZV_4x1_16 1024 esize m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZV_4x1_16 2048 esize m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLA_ZA_ZZV_4x1_16 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLA_ZA_ZZV_4x1_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLA_ZA_ZZV_4x1_16 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLA_ZA_ZZV_4x1_16 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLA_ZA_ZZV_4x1_16 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLA_ZA_ZZV_4x1_16 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLA_ZA_ZZV_4x1_16 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op : Bool, v : Nat, 0
  ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLS_ZA_ZZV_4x1_16 (VL : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (Nat.div (n +i r) 32) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLS_ZA_ZZV_4x1_16 (sz : (BitVec 1)) (Zm : (BitVec 4)) (Rv : (BitVec 2)) (Zn : (BitVec 5)) (S : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLS_ZA_ZZV_4x1_16 128 m n nreg offset sub_op v)
  | 256 => (execute_BFMLS_ZA_ZZV_4x1_16 256 m n nreg offset sub_op v)
  | 512 => (execute_BFMLS_ZA_ZZV_4x1_16 512 m n nreg offset sub_op v)
  | 1024 => (execute_BFMLS_ZA_ZZV_4x1_16 1024 m n nreg offset sub_op v)
  | 2048 => (execute_BFMLS_ZA_ZZV_4x1_16 2048 m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZi_H2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZi_H2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_FMLA_ZA_ZZi_H2xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZi_H2xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZi_H2xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZi_H2xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZi_H2xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZi_H2xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZi_H2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_FMLS_ZA_ZZi_H2xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZi_H2xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZi_H2xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZi_H2xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZi_H2xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_BFMLA_ZA_ZZi_H2xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 16)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLA_ZA_ZZi_H2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := false
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLA_ZA_ZZi_H2xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_BFMLA_ZA_ZZi_H2xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_BFMLA_ZA_ZZi_H2xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_BFMLA_ZA_ZZi_H2xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_BFMLA_ZA_ZZi_H2xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_BFMLS_ZA_ZZi_H2xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 16)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLS_ZA_ZZi_H2xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 4)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := true
  let nreg := 2
  match VL with
  | 128 => (execute_BFMLS_ZA_ZZi_H2xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_BFMLS_ZA_ZZi_H2xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_BFMLS_ZA_ZZi_H2xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_BFMLS_ZA_ZZi_H2xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_BFMLS_ZA_ZZi_H2xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLA_ZA_ZZi_H4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLA_ZA_ZZi_H4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_FMLA_ZA_ZZi_H4xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLA_ZA_ZZi_H4xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLA_ZA_ZZi_H4xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLA_ZA_ZZi_H4xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLA_ZA_ZZi_H4xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op
  : Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_FMLS_ZA_ZZi_H4xi (VL : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 esize)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec esize) )
              (Elem_set result e esize
                (← (FPMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_FMLS_ZA_ZZi_H4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_FMLS_ZA_ZZi_H4xi 128 esize index m n nreg offset sub_op v)
  | 256 => (execute_FMLS_ZA_ZZi_H4xi 256 esize index m n nreg offset sub_op v)
  | 512 => (execute_FMLS_ZA_ZZi_H4xi 512 esize index m n nreg offset sub_op v)
  | 1024 => (execute_FMLS_ZA_ZZi_H4xi 1024 esize index m n nreg offset sub_op v)
  | 2048 => (execute_FMLS_ZA_ZZi_H4xi 2048 esize index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_BFMLA_ZA_ZZi_H4xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 16)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLA_ZA_ZZi_H4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := false
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLA_ZA_ZZi_H4xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_BFMLA_ZA_ZZi_H4xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_BFMLA_ZA_ZZi_H4xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_BFMLA_ZA_ZZi_H4xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_BFMLA_ZA_ZZi_H4xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, index : Nat, m : Nat, n : Nat, nreg : Nat, offset : Nat, k_sub_op :
  Bool, v : Nat, 0 ≤ v ∧
  v ≤ 31 ∧
  offset ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_BFMLS_ZA_ZZi_H4xi (VL : Nat) (index : Nat) (m : Nat) (n : Nat) (nreg : Nat) (offset : Nat) (sub_op : Bool) (v : Nat) : SailM Unit := do
  (CheckStreamingSVEAndZAEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let vectors_name := (Int.ediv VL 8)
  let vstride := (Int.ediv vectors_name nreg)
  let eltspersegment := (Int.ediv 128 16)
  let vbase ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let vec : Int := (Nat.div ((BitVec.toNat vbase) +i offset) vstride)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result, vec) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := (result, vec)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, vec) := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (n +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do
          let vec := vec
          (ZAvector_read vec VL) ) : SailM (BitVec VL) )
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
              let segmentbase := (e -i (Nat.div e eltspersegment))
              let s := (segmentbase +i index)
              let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
              let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (BFNeg element1))
                else (pure element1) ) : SailM (BitVec 16) )
              (Elem_set result e 16
                (← (BFMulAdd_ZA element3 element1 element2 (← (FPCR_read ())))))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let vec := vec
        (ZAvector_set vec VL result)
        let vec : Int := (vec +i vstride)
        (pure (result, vec))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (pure ())

def decode_BFMLS_ZA_ZZi_H4xi (Zm : (BitVec 4)) (Rv : (BitVec 2)) (i3h : (BitVec 2)) (Zn : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (off3 : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let v := (BitVec.toNat ((0b010 : (BitVec 3)) ++ Rv))
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let offset := (BitVec.toNat off3)
  let index := (BitVec.toNat (i3h ++ i3l))
  let sub_op : Bool := true
  let nreg := 4
  match VL with
  | 128 => (execute_BFMLS_ZA_ZZi_H4xi 128 index m n nreg offset sub_op v)
  | 256 => (execute_BFMLS_ZA_ZZi_H4xi 256 index m n nreg offset sub_op v)
  | 512 => (execute_BFMLS_ZA_ZZi_H4xi 512 index m n nreg offset sub_op v)
  | 1024 => (execute_BFMLS_ZA_ZZi_H4xi 1024 index m n nreg offset sub_op v)
  | 2048 => (execute_BFMLS_ZA_ZZi_H4xi 2048 index m n nreg offset sub_op v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMAX_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMax element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMAX_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_BFMAX_MZ_ZZW_2x2 128 dn m nreg)
  | 256 => (execute_BFMAX_MZ_ZZW_2x2 256 dn m nreg)
  | 512 => (execute_BFMAX_MZ_ZZW_2x2 512 dn m nreg)
  | 1024 => (execute_BFMAX_MZ_ZZW_2x2 1024 dn m nreg)
  | 2048 => (execute_BFMAX_MZ_ZZW_2x2 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMAX_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMax element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMAX_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_BFMAX_MZ_ZZV_2x1 128 dn m nreg)
  | 256 => (execute_BFMAX_MZ_ZZV_2x1 256 dn m nreg)
  | 512 => (execute_BFMAX_MZ_ZZV_2x1 512 dn m nreg)
  | 1024 => (execute_BFMAX_MZ_ZZV_2x1 1024 dn m nreg)
  | 2048 => (execute_BFMAX_MZ_ZZV_2x1 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMIN_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMin element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMIN_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_BFMIN_MZ_ZZW_2x2 128 dn m nreg)
  | 256 => (execute_BFMIN_MZ_ZZW_2x2 256 dn m nreg)
  | 512 => (execute_BFMIN_MZ_ZZW_2x2 512 dn m nreg)
  | 1024 => (execute_BFMIN_MZ_ZZW_2x2 1024 dn m nreg)
  | 2048 => (execute_BFMIN_MZ_ZZW_2x2 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMIN_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMin element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMIN_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_BFMIN_MZ_ZZV_2x1 128 dn m nreg)
  | 256 => (execute_BFMIN_MZ_ZZV_2x1 256 dn m nreg)
  | 512 => (execute_BFMIN_MZ_ZZV_2x1 512 dn m nreg)
  | 1024 => (execute_BFMIN_MZ_ZZV_2x1 1024 dn m nreg)
  | 2048 => (execute_BFMIN_MZ_ZZV_2x1 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMAX_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMax element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMAX_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_BFMAX_MZ_ZZW_4x4 128 dn m nreg)
  | 256 => (execute_BFMAX_MZ_ZZW_4x4 256 dn m nreg)
  | 512 => (execute_BFMAX_MZ_ZZW_4x4 512 dn m nreg)
  | 1024 => (execute_BFMAX_MZ_ZZW_4x4 1024 dn m nreg)
  | 2048 => (execute_BFMAX_MZ_ZZW_4x4 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMAX_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMax element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMAX_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_BFMAX_MZ_ZZV_4x1 128 dn m nreg)
  | 256 => (execute_BFMAX_MZ_ZZV_4x1 256 dn m nreg)
  | 512 => (execute_BFMAX_MZ_ZZV_4x1 512 dn m nreg)
  | 1024 => (execute_BFMAX_MZ_ZZV_4x1 1024 dn m nreg)
  | 2048 => (execute_BFMAX_MZ_ZZV_4x1 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMIN_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMin element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMIN_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_BFMIN_MZ_ZZW_4x4 128 dn m nreg)
  | 256 => (execute_BFMIN_MZ_ZZW_4x4 256 dn m nreg)
  | 512 => (execute_BFMIN_MZ_ZZW_4x4 512 dn m nreg)
  | 1024 => (execute_BFMIN_MZ_ZZW_4x4 1024 dn m nreg)
  | 2048 => (execute_BFMIN_MZ_ZZW_4x4 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMIN_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMin element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMIN_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_BFMIN_MZ_ZZV_4x1 128 dn m nreg)
  | 256 => (execute_BFMIN_MZ_ZZV_4x1 256 dn m nreg)
  | 512 => (execute_BFMIN_MZ_ZZV_4x1 512 dn m nreg)
  | 1024 => (execute_BFMIN_MZ_ZZV_4x1 1024 dn m nreg)
  | 2048 => (execute_BFMIN_MZ_ZZV_4x1 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMAXNM_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMaxNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMAXNM_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_BFMAXNM_MZ_ZZW_2x2 128 dn m nreg)
  | 256 => (execute_BFMAXNM_MZ_ZZW_2x2 256 dn m nreg)
  | 512 => (execute_BFMAXNM_MZ_ZZW_2x2 512 dn m nreg)
  | 1024 => (execute_BFMAXNM_MZ_ZZW_2x2 1024 dn m nreg)
  | 2048 => (execute_BFMAXNM_MZ_ZZW_2x2 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMAXNM_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMaxNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMAXNM_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_BFMAXNM_MZ_ZZV_2x1 128 dn m nreg)
  | 256 => (execute_BFMAXNM_MZ_ZZV_2x1 256 dn m nreg)
  | 512 => (execute_BFMAXNM_MZ_ZZV_2x1 512 dn m nreg)
  | 1024 => (execute_BFMAXNM_MZ_ZZV_2x1 1024 dn m nreg)
  | 2048 => (execute_BFMAXNM_MZ_ZZV_2x1 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMINNM_MZ_ZZW_2x2 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMinNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMINNM_MZ_ZZW_2x2 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat (Zm ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_BFMINNM_MZ_ZZW_2x2 128 dn m nreg)
  | 256 => (execute_BFMINNM_MZ_ZZW_2x2 256 dn m nreg)
  | 512 => (execute_BFMINNM_MZ_ZZW_2x2 512 dn m nreg)
  | 1024 => (execute_BFMINNM_MZ_ZZW_2x2 1024 dn m nreg)
  | 2048 => (execute_BFMINNM_MZ_ZZW_2x2 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMINNM_MZ_ZZV_2x1 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMinNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMINNM_MZ_ZZV_2x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b0 : (BitVec 1))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 2
  match VL with
  | 128 => (execute_BFMINNM_MZ_ZZV_2x1 128 dn m nreg)
  | 256 => (execute_BFMINNM_MZ_ZZV_2x1 256 dn m nreg)
  | 512 => (execute_BFMINNM_MZ_ZZV_2x1 512 dn m nreg)
  | 1024 => (execute_BFMINNM_MZ_ZZV_2x1 1024 dn m nreg)
  | 2048 => (execute_BFMINNM_MZ_ZZV_2x1 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMAXNM_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMaxNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMAXNM_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_BFMAXNM_MZ_ZZW_4x4 128 dn m nreg)
  | 256 => (execute_BFMAXNM_MZ_ZZW_4x4 256 dn m nreg)
  | 512 => (execute_BFMAXNM_MZ_ZZW_4x4 512 dn m nreg)
  | 1024 => (execute_BFMAXNM_MZ_ZZW_4x4 1024 dn m nreg)
  | 2048 => (execute_BFMAXNM_MZ_ZZW_4x4 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMAXNM_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMaxNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMAXNM_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_BFMAXNM_MZ_ZZV_4x1 128 dn m nreg)
  | 256 => (execute_BFMAXNM_MZ_ZZV_4x1 256 dn m nreg)
  | 512 => (execute_BFMAXNM_MZ_ZZV_4x1 512 dn m nreg)
  | 1024 => (execute_BFMAXNM_MZ_ZZV_4x1 1024 dn m nreg)
  | 2048 => (execute_BFMAXNM_MZ_ZZV_4x1 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMINNM_MZ_ZZW_4x4 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read (m +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMinNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMINNM_MZ_ZZW_4x4 (size : (BitVec 2)) (Zm : (BitVec 3)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat (Zm ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_BFMINNM_MZ_ZZW_4x4 128 dn m nreg)
  | 256 => (execute_BFMINNM_MZ_ZZW_4x4 256 dn m nreg)
  | 512 => (execute_BFMINNM_MZ_ZZW_4x4 512 dn m nreg)
  | 1024 => (execute_BFMINNM_MZ_ZZW_4x4 1024 dn m nreg)
  | 2048 => (execute_BFMINNM_MZ_ZZW_4x4 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMINNM_MZ_ZZV_4x1 (VL : Nat) (dn : Nat) (m : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read (dn +i r) VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMinNum element1 element2 (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (dn +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFMINNM_MZ_ZZV_4x1 (size : (BitVec 2)) (Zm : (BitVec 4)) (Zdn : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat (Zdn ++ (0b00 : (BitVec 2))))
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Zm))
  let nreg := 4
  match VL with
  | 128 => (execute_BFMINNM_MZ_ZZV_4x1 128 dn m nreg)
  | 256 => (execute_BFMINNM_MZ_ZZV_4x1 256 dn m nreg)
  | 512 => (execute_BFMINNM_MZ_ZZV_4x1 512 dn m nreg)
  | 1024 => (execute_BFMINNM_MZ_ZZV_4x1 1024 dn m nreg)
  | 2048 => (execute_BFMINNM_MZ_ZZV_4x1 2048 dn m nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVT_MZ2_Z__ (VL : Nat) (d : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector (2 *i VL)) ) : SailM (BitVec (2 * VL)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e 16) ) : SailM (BitVec 16) )
        let res ← (( do (FPConvertSVE__1 element (← (FPCR_read ())) 32) ) : SailM (BitVec 32) )
        (Elem_set result e 32 res)
    (pure loop_vars) ) : SailM (BitVec (2 * VL)) )
  (Z_set (d +i 0) VL (Sail.BitVec.extractLsb result (VL -i 1) 0))
  (Z_set (d +i 1) VL (Sail.BitVec.extractLsb result ((2 *i VL) -i 1) VL))

def decode_FCVT_MZ2_Z__ (Zn : (BitVec 5)) (Zd : (BitVec 4)) (L : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  match VL with
  | 128 => (execute_FCVT_MZ2_Z__ 128 d n)
  | 256 => (execute_FCVT_MZ2_Z__ 256 d n)
  | 512 => (execute_FCVT_MZ2_Z__ 512 d n)
  | 1024 => (execute_FCVT_MZ2_Z__ 1024 d n)
  | 2048 => (execute_FCVT_MZ2_Z__ 2048 d n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTL_MZ2_Z__ (VL : Nat) (d : Nat) (n : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL 32)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result0 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result1 ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (result0, result1) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (result0, result1)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (result0, result1) := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand ((2 *i p) +i 0) 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand ((2 *i p) +i 1) 16) ) : SailM (BitVec 16) )
        let res1 ← (( do (FPConvertSVE__1 element1 (← (FPCR_read ())) 32) ) : SailM (BitVec 32)
          )
        let res2 ← (( do (FPConvertSVE__1 element2 (← (FPCR_read ())) 32) ) : SailM (BitVec 32)
          )
        let result0 ← (Elem_set result0 p 32 res1)
        let result1 ← (Elem_set result1 p 32 res2)
        (pure (result0, result1))
    (pure loop_vars) ) : SailM ((BitVec VL) × (BitVec VL)) )
  (Z_set (d +i 0) VL result0)
  (Z_set (d +i 1) VL result1)

def decode_FCVTL_MZ2_Z__ (Zn : (BitVec 5)) (Zd : (BitVec 4)) (L : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEF16F16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  match VL with
  | 128 => (execute_FCVTL_MZ2_Z__ 128 d n)
  | 256 => (execute_FCVTL_MZ2_Z__ 256 d n)
  | 512 => (execute_FCVTL_MZ2_Z__ 512 d n)
  | 1024 => (execute_FCVTL_MZ2_Z__ 1024 d n)
  | 2048 => (execute_FCVTL_MZ2_Z__ 2048 d n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, nreg : Nat, nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFCLAMP_MZ_ZZ_2 (VL : Nat) (d : Nat) (m : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do (Z_read (d +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMinNum (← (BFMaxNum element1 element3 (← (FPCR_read ())))) element2
                        (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFCLAMP_MZ_ZZ_2 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b0 : (BitVec 1))))
  let nreg := 2
  match VL with
  | 128 => (execute_BFCLAMP_MZ_ZZ_2 128 d m n nreg)
  | 256 => (execute_BFCLAMP_MZ_ZZ_2 256 d m n nreg)
  | 512 => (execute_BFCLAMP_MZ_ZZ_2 512 d m n nreg)
  | 1024 => (execute_BFCLAMP_MZ_ZZ_2 1024 d m n nreg)
  | 2048 => (execute_BFCLAMP_MZ_ZZ_2 2048 d m n nreg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, nreg : Nat, nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFCLAMP_MZ_ZZ_4 (VL : Nat) (d : Nat) (m : Nat) (n : Nat) (nreg : Nat) : SailM Unit := do
  (CheckStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let results ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let results ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := results
    for r in [loop_r_lower:loop_r_upper:1]i do
      let results := loop_vars
      loop_vars ← do
        let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
        let operand3 ← (( do (Z_read (d +i r) VL) ) : SailM (BitVec VL) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := results
        for e in [loop_e_lower:loop_e_upper:1]i do
          let results := loop_vars_1
          loop_vars_1 ← do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
            (pure (vectorUpdate results r
                (← (Elem_set (GetElem?.getElem! results r) e 16
                    (← (BFMinNum (← (BFMaxNum element1 element3 (← (FPCR_read ())))) element2
                        (← (FPCR_read ()))))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (d +i r) VL (GetElem?.getElem! results r))
  (pure loop_vars_2)

def decode_BFCLAMP_MZ_ZZ_4 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveSMEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat (Zd ++ (0b00 : (BitVec 2))))
  let nreg := 4
  match VL with
  | 128 => (execute_BFCLAMP_MZ_ZZ_4 128 d m n nreg)
  | 256 => (execute_BFCLAMP_MZ_ZZ_4 256 d m n nreg)
  | 512 => (execute_BFCLAMP_MZ_ZZ_4 512 d m n nreg)
  | 1024 => (execute_BFCLAMP_MZ_ZZ_4 1024 d m n nreg)
  | 2048 => (execute_BFCLAMP_MZ_ZZ_4 2048 d m n nreg)
  | _ => (pure ())

