import Armv9.Instrs32

set_option maxHeartbeats 1_000_000_000
set_option maxRecDepth 1_000_000
set_option linter.unusedVariables false
set_option match.ignoreUnusedAlts true

open Sail

noncomputable section

namespace Armv9.Functions

open signal
open option
open exception
open arm_acc_type
open __InstrEnc
open WFxType
open VFPNegMul
open VCGTtype
open VCGEType
open VBitOps
open VBitOp
open VARange
open Unpredictable
open TranslationStage
open TimeStamp
open TMFailure
open TLBIOp
open TLBIMemAttr
open TLBILevel
open TGx
open SystemHintOp
open Signal
open ShiftType
open Shareability
open SecurityState
open SVECmp
open SRType
open SMEExceptionType
open SDFType
open RestrictType
open Register
open Regime
open ReduceOp
open PrivilegeLevel
open PrefetchHint
open PSTATEField
open PGSe
open PASpace
open PARTIDspaceType
open OpType
open MoveWideOp
open MemType
open MemTagType
open MemOp
open MemAtomicOp
open MOPSStage
open MBReqTypes
open MBReqDomain
open LogicalOp
open InterruptID
open InstrSet
open ImmediateOp
open GPCF
open GCSInstruction
open Feature
open Fault
open FPUnaryOp
open FPType
open FPRounding
open FPMaxMinOp
open FPExc
open FPConvOp
open ExtendType
open ExceptionalOccurrenceTargetState
open Exception
open ErrorState
open DeviceType
open DescriptorType
open DSBAlias
open CrossTriggerIn
open CountOp
open Constraint
open CompareOp
open CacheType
open CachePASpace
open CacheOpScope
open CacheOp
open BranchType
open Barrier
open ArchVersion
open AccessType
open ATAccess

/-- Type quantifiers: d : Nat, datasize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_unary_abs (d : Nat) (datasize : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let result := (Int.natAbs (BitVec.toInt operand1))
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_abs_aarch64_instrs_integer_arithmetic_unary_abs (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_integer_arithmetic_unary_abs d datasize n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, k_neg : Bool, 0
  ≤ n ∧
  n ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (neg : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (pure (BitVec.toInt (← (Elem_read operand e esize))))
        let element : Int :=
          bif neg
          then (Neg.neg element)
          else (Int.natAbs element)
        let result ← (Elem_set result e esize (integer_subrange element (esize -i 1) 0))
        (pure (element, result))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize)) )
  (V_set d datasize result)

def decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd d datasize elements esize n neg)

def decode_abs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd d datasize elements esize n neg)

def decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd d datasize elements esize n neg)

def decode_neg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_int_sisd d datasize elements esize n neg)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, k_setflags : Bool, k_sub_op : Bool, 0
  ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_add_sub_carry (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) (setflags : Bool) (sub_op : Bool) : SailM Unit := do
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let operand2 : (BitVec datasize) :=
    bif sub_op
    then (Complement.complement operand2)
    else operand2
  let (tup__0, tup__1) ← do (pure (AddWithCarry operand1 operand2 (← readReg PSTATE).C))
  let result : (BitVec datasize) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())
  (X_set d datasize result)

def decode_adc_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_add_sub_carry d datasize m n setflags sub_op)

def decode_adcs_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_add_sub_carry d datasize m n setflags sub_op)

def decode_sbc_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_add_sub_carry d datasize m n setflags sub_op)

def decode_sbcs_aarch64_instrs_integer_arithmetic_add_sub_carry (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_add_sub_carry d datasize m n setflags sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, k_sub_op
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let result ← (( do
          bif sub_op
          then
            (do
              (Elem_set result e esize (element1 - element2)))
          else
            (do
              (Elem_set result e esize (element1 + element2))) ) : SailM (BitVec datasize) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let sub_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd d datasize
    elements esize m n sub_op)

def decode_add_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd d datasize
    elements esize m n sub_op)

def decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let sub_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd d datasize
    elements esize m n sub_op)

def decode_sub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_single_sisd d datasize
    elements esize m n sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_amount :
  Nat, k_sub_op : Bool, 0 ≤ shift_amount ∧
  shift_amount ≤ 63 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_amount : Nat) (shift_type : ShiftType) (sub_op : Bool) : SailM Unit := do
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (ShiftReg m shift_type shift_amount datasize) ) : SailM (BitVec datasize) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let carry_in ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let (carry_in, operand2) : ((BitVec 1) × (BitVec datasize)) :=
    bif sub_op
    then
      (let operand2 : (BitVec datasize) := (Complement.complement operand2)
      let carry_in : (BitVec 1) := (0b1 : (BitVec 1))
      (carry_in, operand2))
    else
      (let carry_in : (BitVec 1) := (0b0 : (BitVec 1))
      (carry_in, operand2))
  let _ : Unit :=
    let (tup__0, tup__1) :=
      ((AddWithCarry operand1 operand2 carry_in) : ((BitVec datasize) × (BitVec 4)))
    let result : (BitVec datasize) := tup__0
    let nzcv : (BitVec 4) := tup__1
    ()
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())
  (X_set d datasize result)

def decode_add_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (shift : (BitVec 2)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  bif (shift == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  (execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg d datasize m n setflags shift_amount
    shift_type sub_op)

def decode_adds_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (shift : (BitVec 2)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  bif (shift == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  (execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg d datasize m n setflags shift_amount
    shift_type sub_op)

def decode_sub_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (shift : (BitVec 2)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  bif (shift == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  (execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg d datasize m n setflags shift_amount
    shift_type sub_op)

def decode_subs_addsub_shift_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (shift : (BitVec 2)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  bif (shift == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  (execute_aarch64_instrs_integer_arithmetic_add_sub_shiftedreg d datasize m n setflags shift_amount
    shift_type sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, n : Nat, k_setflags : Bool, k_sub_op : Bool, 0 ≤ n
  ∧ n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_add_sub_immediate (d : Nat) (datasize : Nat) (imm : (BitVec datasize)) (n : Nat) (setflags : Bool) (sub_op : Bool) : SailM Unit := do
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand1 ← (( do
    bif (n == 31)
    then (pure (Sail.BitVec.extractLsb (← (SP_read ())) (datasize -i 1) 0))
    else (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 : (BitVec datasize) := imm
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let carry_in ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let (carry_in, operand2) : ((BitVec 1) × (BitVec datasize)) :=
    bif sub_op
    then
      (let operand2 : (BitVec datasize) := (Complement.complement operand2)
      let carry_in : (BitVec 1) := (0b1 : (BitVec 1))
      (carry_in, operand2))
    else
      (let carry_in : (BitVec 1) := (0b0 : (BitVec 1))
      (carry_in, operand2))
  let _ : Unit :=
    let (tup__0, tup__1) :=
      ((AddWithCarry operand1 operand2 carry_in) : ((BitVec datasize) × (BitVec 4)))
    let result : (BitVec datasize) := tup__0
    let nzcv : (BitVec 4) := tup__1
    ()
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())
  bif ((d == 31) && (! setflags))
  then (SP_set (Sail.BitVec.zeroExtend result 64))
  else (X_set d datasize result)

def decode_add_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (sh : (BitVec 1)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  let imm ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let _ : Unit :=
    let b__0 := sh
    bif (b__0 == (0b0 : (BitVec 1)))
    then
      (let imm : (BitVec datasize) := (Sail.BitVec.zeroExtend imm12 datasize)
      ())
    else
      (let imm : (BitVec datasize) := (Sail.BitVec.zeroExtend (imm12 ++ (Zeros (n := 12))) datasize)
      ())
  let imm := imm
  (execute_aarch64_instrs_integer_arithmetic_add_sub_immediate d datasize imm n setflags sub_op)

def decode_adds_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (sh : (BitVec 1)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  let imm ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let _ : Unit :=
    let b__0 := sh
    bif (b__0 == (0b0 : (BitVec 1)))
    then
      (let imm : (BitVec datasize) := (Sail.BitVec.zeroExtend imm12 datasize)
      ())
    else
      (let imm : (BitVec datasize) := (Sail.BitVec.zeroExtend (imm12 ++ (Zeros (n := 12))) datasize)
      ())
  let imm := imm
  (execute_aarch64_instrs_integer_arithmetic_add_sub_immediate d datasize imm n setflags sub_op)

def decode_sub_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (sh : (BitVec 1)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  let imm ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let _ : Unit :=
    let b__0 := sh
    bif (b__0 == (0b0 : (BitVec 1)))
    then
      (let imm : (BitVec datasize) := (Sail.BitVec.zeroExtend imm12 datasize)
      ())
    else
      (let imm : (BitVec datasize) := (Sail.BitVec.zeroExtend (imm12 ++ (Zeros (n := 12))) datasize)
      ())
  let imm := imm
  (execute_aarch64_instrs_integer_arithmetic_add_sub_immediate d datasize imm n setflags sub_op)

def decode_subs_addsub_imm_aarch64_instrs_integer_arithmetic_add_sub_immediate (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (sh : (BitVec 1)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  let imm ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let _ : Unit :=
    let b__0 := sh
    bif (b__0 == (0b0 : (BitVec 1)))
    then
      (let imm : (BitVec datasize) := (Sail.BitVec.zeroExtend imm12 datasize)
      ())
    else
      (let imm : (BitVec datasize) := (Sail.BitVec.zeroExtend (imm12 ++ (Zeros (n := 12))) datasize)
      ())
  let imm := imm
  (execute_aarch64_instrs_integer_arithmetic_add_sub_immediate d datasize imm n setflags sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, k_setflags : Bool, shift : Nat, k_sub_op
  : Bool, shift ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (d : Nat) (datasize : Nat) (extend_type : ExtendType) (m : Nat) (n : Nat) (setflags : Bool) (shift : Nat) (sub_op : Bool) : SailM Unit := do
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand1 ← (( do
    bif (n == 31)
    then (pure (Sail.BitVec.extractLsb (← (SP_read ())) (datasize -i 1) 0))
    else (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (ExtendReg m extend_type shift datasize) ) : SailM (BitVec datasize) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let carry_in ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let (carry_in, operand2) : ((BitVec 1) × (BitVec datasize)) :=
    bif sub_op
    then
      (let operand2 : (BitVec datasize) := (Complement.complement operand2)
      let carry_in : (BitVec 1) := (0b1 : (BitVec 1))
      (carry_in, operand2))
    else
      (let carry_in : (BitVec 1) := (0b0 : (BitVec 1))
      (carry_in, operand2))
  let _ : Unit :=
    let (tup__0, tup__1) :=
      ((AddWithCarry operand1 operand2 carry_in) : ((BitVec datasize) × (BitVec 4)))
    let result : (BitVec datasize) := tup__0
    let nzcv : (BitVec 4) := tup__1
    ()
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())
  bif ((d == 31) && (! setflags))
  then (SP_set (Sail.BitVec.zeroExtend result 64))
  else (X_set d datasize result)

def decode_add_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm3 : (BitVec 3)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift := (BitVec.toNat imm3)
  bif (shift >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg d datasize extend_type m n setflags
    shift sub_op)

def decode_adds_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm3 : (BitVec 3)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift := (BitVec.toNat imm3)
  bif (shift >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg d datasize extend_type m n setflags
    shift sub_op)

def decode_sub_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm3 : (BitVec 3)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift := (BitVec.toNat imm3)
  bif (shift >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg d datasize extend_type m n setflags
    shift sub_op)

def decode_subs_addsub_ext_aarch64_instrs_integer_arithmetic_add_sub_extendedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm3 : (BitVec 3)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (S : (BitVec 1)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let setflags : Bool := (S == (0b1 : (BitVec 1)))
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift := (BitVec.toNat imm3)
  bif (shift >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_integer_arithmetic_add_sub_extendedreg d datasize extend_type m n setflags
    shift sub_op)

/-- Type quantifiers: k_ADD : Bool, d : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcaddtag (ADD : Bool) (d : Nat) (n : Nat) (offset : (BitVec 64)) (tag_offset : (BitVec 4)) : SailM Unit := do
  let operand1 ← (( do
    bif (n == 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let start_tag : (BitVec 4) := (AArch64_AllocationTagFromAddress operand1)
  let exclude ← (( do (pure (_get_GCR_EL1_Type_Exclude (← readReg GCR_EL1))) ) : SailM
    (BitVec 16) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let rtag ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let rtag ← (( do
    bif (← (AArch64_AllocationTagAccessIsEnabled (← readReg PSTATE).EL))
    then (pure (AArch64_ChooseNonExcludedTag start_tag tag_offset exclude))
    else (pure (0x0 : (BitVec 4))) ) : SailM (BitVec 4) )
  let result : (BitVec 64) :=
    bif ADD
    then
      (let (__tup_0, _) := (AddWithCarry operand1 offset (0b0 : (BitVec 1)))
      __tup_0)
    else
      (let (__tup_0, _) := (AddWithCarry operand1 (Complement.complement offset) (0b1 : (BitVec 1)))
      __tup_0)
  let result ← (( do (AArch64_AddressWithAllocationTag result rtag) ) : SailM (BitVec 64) )
  bif (d == 31)
  then (SP_set result)
  else (X_set d 64 result)

def decode_addg_aarch64_instrs_integer_tags_mcaddtag (Xd : (BitVec 5)) (Xn : (BitVec 5)) (uimm4 : (BitVec 4)) (op3 : (BitVec 2)) (uimm6 : (BitVec 6)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Xd)
  let n := (BitVec.toNat Xn)
  let tag_offset : (BitVec 4) := uimm4
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend uimm6 64) <<< LOG2_TAG_GRANULE)
  let ADD : Bool := true
  (execute_aarch64_instrs_integer_tags_mcaddtag ADD d n offset tag_offset)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, part :
  Nat, k_round : Bool, k_sub_op : Bool, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) (round : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let operand2 ← (( do (V_read m (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let sum ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result, sum) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result, sum)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result, sum) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toNat (← (Elem_read operand1 e (2 *i esize)))))
        let element2 ← (pure (BitVec.toNat (← (Elem_read operand2 e (2 *i esize)))))
        let sum : Int :=
          bif sub_op
          then (element1 -i element2)
          else (element1 +i element2)
        let sum ← (RShr sum esize round)
        let result ← (Elem_set result e esize (integer_subrange sum (esize -i 1) 0))
        (pure (element1, element2, result, sum))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec datasize) × Int) )
  (Vpart_set d part datasize result)

def decode_addhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let round : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow d datasize elements
    esize m n part round sub_op)

def decode_raddhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let round : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow d datasize elements
    esize m n part round sub_op)

def decode_rsubhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let round : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow d datasize elements
    esize m n part round sub_op)

def decode_subhn_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let round : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_narrow d datasize elements
    esize m n part round sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let concat : (BitVec (2 * datasize)) := (operand2 ++ operand1)
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read concat (2 *i e) esize)
        let element2 ← (Elem_read concat ((2 *i e) +i 1) esize)
        let result ← (Elem_set result e esize (element1 + element2))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_addp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_wrapping_pair d datasize elements
    esize m n)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_reduce_add_sisd (d : Nat) (datasize : Nat) (esize : Nat) (n : Nat) (op : ReduceOp) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  assert (datasize ≥b esize) "src/instrs64.sail:1153.42-1153.43"
  (V_set d esize (← (Reduce op operand esize)))

def decode_addp_advsimd_pair_aarch64_instrs_vector_reduce_add_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp := ReduceOp_ADD
  (execute_aarch64_instrs_vector_reduce_add_sisd d datasize esize n op)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_reduce_add_simd (d : Nat) (datasize : Nat) (esize : Nat) (n : Nat) (op : ReduceOp) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  (V_set d esize (← (Reduce op operand esize)))

def decode_addv_advsimd_aarch64_instrs_vector_reduce_add_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b100 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op : ReduceOp := ReduceOp_ADD
  (execute_aarch64_instrs_vector_reduce_add_simd d datasize esize n op)

/-- Type quantifiers: d : Nat, k_page : Bool, 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_address_pc_rel (d : Nat) (imm : (BitVec 64)) (page : Bool) : SailM Unit := do
  let base ← (( do (PC_read ()) ) : SailM (BitVec 64) )
  let base : (BitVec 64) :=
    bif page
    then (Sail.BitVec.updateSubrange base 11 0 (Zeros (n := 12)))
    else base
  (X_set d 64 (base + imm))

def decode_adr_aarch64_instrs_integer_arithmetic_address_pc_rel (Rd : (BitVec 5)) (immhi : (BitVec 19)) (immlo : (BitVec 2)) (op : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let page : Bool := (op == (0b1 : (BitVec 1)))
  let imm ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let imm : (BitVec 64) :=
    bif page
    then (sign_extend ((immhi ++ immlo) ++ (Zeros (n := 12))) 64)
    else (sign_extend (immhi ++ immlo) 64)
  (execute_aarch64_instrs_integer_arithmetic_address_pc_rel d imm page)

def decode_adrp_aarch64_instrs_integer_arithmetic_address_pc_rel (Rd : (BitVec 5)) (immhi : (BitVec 19)) (immlo : (BitVec 2)) (op : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let page : Bool := (op == (0b1 : (BitVec 1)))
  let imm ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let imm : (BitVec 64) :=
    bif page
    then (sign_extend ((immhi ++ immlo) ++ (Zeros (n := 12))) 64)
    else (sign_extend (immhi ++ immlo) 64)
  (execute_aarch64_instrs_integer_arithmetic_address_pc_rel d imm page)

/-- Type quantifiers: d : Nat, k_decrypt : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_aes_round (d : Nat) (decrypt : Bool) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let operand1 ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let operand2 ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let result : (BitVec 128) := (operand1 ^^^ operand2)
  let result ← (( do
    bif decrypt
    then
      (do
        (AESInvSubBytes (AESInvShiftRows result)))
    else
      (do
        (AESSubBytes (AESShiftRows result))) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_aesd_advsimd_aarch64_instrs_vector_crypto_aes_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (D : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HaveAESExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let decrypt : Bool := (D == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_crypto_aes_round d decrypt n)

def decode_aese_advsimd_aarch64_instrs_vector_crypto_aes_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (D : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HaveAESExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let decrypt : Bool := (D == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_crypto_aes_round d decrypt n)

/-- Type quantifiers: d : Nat, k_decrypt : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_aes_mix (d : Nat) (decrypt : Bool) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let operand ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let result ← (( do
    bif decrypt
    then
      (do
        (AESInvMixColumns operand))
    else
      (do
        (AESMixColumns operand)) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_aesimc_advsimd_aarch64_instrs_vector_crypto_aes_mix (Rd : (BitVec 5)) (Rn : (BitVec 5)) (D : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HaveAESExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let decrypt : Bool := (D == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_crypto_aes_mix d decrypt n)

def decode_aesmc_advsimd_aarch64_instrs_vector_crypto_aes_mix (Rd : (BitVec 5)) (Rn : (BitVec 5)) (D : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HaveAESExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let decrypt : Bool := (D == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_crypto_aes_mix d decrypt n)

/-- Type quantifiers: d : Nat, datasize : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_logical_immediate (d : Nat) (datasize : Nat) (imm : (BitVec datasize)) (n : Nat) (op : LogicalOp) (setflags : Bool) : SailM Unit := do
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 : (BitVec datasize) := imm
  let result : (BitVec datasize) :=
    match op with
    | LogicalOp_AND => (operand1 &&& operand2)
    | LogicalOp_ORR => (operand1 ||| operand2)
    | LogicalOp_EOR => (operand1 ^^^ operand2)
  let result := result
  bif setflags
  then
    (do
      let split_vec :=
        (((BitVec.join1 [(BitVec.access result (datasize -i 1))]) ++ (IsZeroBit result)) ++ (0b00 : (BitVec 2)))
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  bif ((d == 31) && (! setflags))
  then (SP_set (Sail.BitVec.zeroExtend result 64))
  else (X_set d datasize result)

def decode_and_log_imm_aarch64_instrs_integer_logical_immediate (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imms : (BitVec 6)) (immr : (BitVec 6)) (N : (BitVec 1)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  let imm ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  bif ((sf == (0b0 : (BitVec 1))) && (N != (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let (__tup_0, _) ← do (DecodeBitMasks N imms immr true datasize)
  let imm : (BitVec datasize) := __tup_0
  (pure ())
  (execute_aarch64_instrs_integer_logical_immediate d datasize imm n op setflags)

def decode_ands_log_imm_aarch64_instrs_integer_logical_immediate (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imms : (BitVec 6)) (immr : (BitVec 6)) (N : (BitVec 1)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  let imm ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  bif ((sf == (0b0 : (BitVec 1))) && (N != (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let (__tup_0, _) ← do (DecodeBitMasks N imms immr true datasize)
  let imm : (BitVec datasize) := __tup_0
  (pure ())
  (execute_aarch64_instrs_integer_logical_immediate d datasize imm n op setflags)

def decode_eor_log_imm_aarch64_instrs_integer_logical_immediate (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imms : (BitVec 6)) (immr : (BitVec 6)) (N : (BitVec 1)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  let imm ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  bif ((sf == (0b0 : (BitVec 1))) && (N != (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let (__tup_0, _) ← do (DecodeBitMasks N imms immr true datasize)
  let imm : (BitVec datasize) := __tup_0
  (pure ())
  (execute_aarch64_instrs_integer_logical_immediate d datasize imm n op setflags)

def decode_orr_log_imm_aarch64_instrs_integer_logical_immediate (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imms : (BitVec 6)) (immr : (BitVec 6)) (N : (BitVec 1)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  let imm ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  bif ((sf == (0b0 : (BitVec 1))) && (N != (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let (__tup_0, _) ← do (DecodeBitMasks N imms immr true datasize)
  let imm : (BitVec datasize) := __tup_0
  (pure ())
  (execute_aarch64_instrs_integer_logical_immediate d datasize imm n op setflags)

/-- Type quantifiers: d : Nat, datasize : Nat, k_invert : Bool, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (d : Nat) (datasize : Nat) (invert : Bool) (m : Nat) (n : Nat) (op : LogicalOp) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand2 : (BitVec datasize) :=
    bif invert
    then (Complement.complement operand2)
    else operand2
  let result : (BitVec datasize) :=
    match op with
    | LogicalOp_AND => (operand1 &&& operand2)
    | LogicalOp_ORR => (operand1 ||| operand2)
    | _ => result
  (V_set d datasize result)

def decode_and_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let invert : Bool := ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
  let op : LogicalOp :=
    bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
    then LogicalOp_ORR
    else LogicalOp_AND
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr d datasize invert m n op)

def decode_bic_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let invert : Bool := ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
  let op : LogicalOp :=
    bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
    then LogicalOp_ORR
    else LogicalOp_AND
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr d datasize invert m n op)

def decode_orn_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let invert : Bool := ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
  let op : LogicalOp :=
    bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
    then LogicalOp_ORR
    else LogicalOp_AND
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr d datasize invert m n op)

def decode_orr_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let invert : Bool := ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
  let op : LogicalOp :=
    bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
    then LogicalOp_ORR
    else LogicalOp_AND
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_and_orr d datasize invert m n op)

/-- Type quantifiers: d : Nat, datasize : Nat, k_invert : Bool, m : Nat, n : Nat, k_setflags : Bool, shift_amount
  : Nat, 0 ≤ shift_amount ∧
  shift_amount ≤ 63 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_logical_shiftedreg (d : Nat) (datasize : Nat) (invert : Bool) (m : Nat) (n : Nat) (op : LogicalOp) (setflags : Bool) (shift_amount : Nat) (shift_type : ShiftType) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (ShiftReg m shift_type shift_amount datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand2 : (BitVec datasize) :=
    bif invert
    then (Complement.complement operand2)
    else operand2
  let result : (BitVec datasize) :=
    match op with
    | LogicalOp_AND => (operand1 &&& operand2)
    | LogicalOp_ORR => (operand1 ||| operand2)
    | LogicalOp_EOR => (operand1 ^^^ operand2)
  let result := result
  bif setflags
  then
    (do
      let split_vec :=
        (((BitVec.join1 [(BitVec.access result (datasize -i 1))]) ++ (IsZeroBit result)) ++ (0b00 : (BitVec 2)))
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (X_set d datasize result)

def decode_and_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (N : (BitVec 1)) (shift : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  let invert : Bool := (N == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_logical_shiftedreg d datasize invert m n op setflags shift_amount
    shift_type)

def decode_ands_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (N : (BitVec 1)) (shift : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  let invert : Bool := (N == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_logical_shiftedreg d datasize invert m n op setflags shift_amount
    shift_type)

def decode_bic_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (N : (BitVec 1)) (shift : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  let invert : Bool := (N == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_logical_shiftedreg d datasize invert m n op setflags shift_amount
    shift_type)

def decode_bics_aarch64_instrs_integer_logical_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (N : (BitVec 1)) (shift : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  let invert : Bool := (N == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_logical_shiftedreg d datasize invert m n op setflags shift_amount
    shift_type)

def decode_eon_aarch64_instrs_integer_logical_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (N : (BitVec 1)) (shift : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  let invert : Bool := (N == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_logical_shiftedreg d datasize invert m n op setflags shift_amount
    shift_type)

def decode_eor_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (N : (BitVec 1)) (shift : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  let invert : Bool := (N == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_logical_shiftedreg d datasize invert m n op setflags shift_amount
    shift_type)

def decode_orn_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (N : (BitVec 1)) (shift : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  let invert : Bool := (N == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_logical_shiftedreg d datasize invert m n op setflags shift_amount
    shift_type)

def decode_orr_log_shift_aarch64_instrs_integer_logical_shiftedreg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) (N : (BitVec 1)) (shift : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let setflags ← (( do (undefined_bool ()) ) : SailM Bool )
  let op ← (( do (undefined_LogicalOp ()) ) : SailM LogicalOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : LogicalOp := LogicalOp_AND
      let setflags : Bool := false
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : LogicalOp := LogicalOp_ORR
        let setflags : Bool := false
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : LogicalOp := LogicalOp_EOR
          let setflags : Bool := false
          ())
        else
          (let op : LogicalOp := LogicalOp_AND
          let setflags : Bool := true
          ())))
  let op := op
  let setflags := setflags
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm6 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let shift_type ← (( do (DecodeShift shift) ) : SailM ShiftType )
  let shift_amount := (BitVec.toNat imm6)
  let invert : Bool := (N == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_logical_shiftedreg d datasize invert m n op setflags shift_amount
    shift_type)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_shift_variable (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) (shift_type : ShiftType) : SailM Unit := do
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (ShiftReg n shift_type (Nat.div (BitVec.toNat operand2) datasize) datasize) )
    : SailM (BitVec datasize) )
  (X_set d datasize result)

def decode_asrv_aarch64_instrs_integer_shift_variable (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let shift_type ← (( do (DecodeShift op2) ) : SailM ShiftType )
  (execute_aarch64_instrs_integer_shift_variable d datasize m n shift_type)

def decode_lslv_aarch64_instrs_integer_shift_variable (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let shift_type ← (( do (DecodeShift op2) ) : SailM ShiftType )
  (execute_aarch64_instrs_integer_shift_variable d datasize m n shift_type)

def decode_lsrv_aarch64_instrs_integer_shift_variable (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let shift_type ← (( do (DecodeShift op2) ) : SailM ShiftType )
  (execute_aarch64_instrs_integer_shift_variable d datasize m n shift_type)

def decode_rorv_aarch64_instrs_integer_shift_variable (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let shift_type ← (( do (DecodeShift op2) ) : SailM ShiftType )
  (execute_aarch64_instrs_integer_shift_variable d datasize m n shift_type)

/-- Type quantifiers: d : Nat, n : Nat, k_source_is_sp : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_pac_autda_dp_1src (d : Nat) (n : Nat) (source_is_sp : Bool) : SailM Unit := do
  let auth_then_branch : Bool := false
  bif (← (HavePACExt ()))
  then
    (do
      bif source_is_sp
      then (X_set d 64 (← (AuthDA (← (X_read d 64)) (← (SP_read ())) auth_then_branch)))
      else (X_set d 64 (← (AuthDA (← (X_read d 64)) (← (X_read n 64)) auth_then_branch))))
  else (pure ())

def decode_autda_aarch64_instrs_integer_pac_autda_dp_1src (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Z : (BitVec 1)) : SailM Unit := do
  let source_is_sp : Bool := false
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HavePACExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let source_is_sp ← (( do
    bif (Z == (0b0 : (BitVec 1)))
    then
      (bif (n == 31)
      then (pure true)
      else (pure source_is_sp))
    else
      (do
        bif (n != 31)
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        (pure source_is_sp)) ) : SailM Bool )
  (execute_aarch64_instrs_integer_pac_autda_dp_1src d n source_is_sp)

/-- Type quantifiers: d : Nat, n : Nat, k_source_is_sp : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_pac_autdb_dp_1src (d : Nat) (n : Nat) (source_is_sp : Bool) : SailM Unit := do
  let auth_then_branch : Bool := false
  bif (← (HavePACExt ()))
  then
    (do
      bif source_is_sp
      then (X_set d 64 (← (AuthDB (← (X_read d 64)) (← (SP_read ())) auth_then_branch)))
      else (X_set d 64 (← (AuthDB (← (X_read d 64)) (← (X_read n 64)) auth_then_branch))))
  else (pure ())

def decode_autdb_aarch64_instrs_integer_pac_autdb_dp_1src (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Z : (BitVec 1)) : SailM Unit := do
  let source_is_sp : Bool := false
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HavePACExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let source_is_sp ← (( do
    bif (Z == (0b0 : (BitVec 1)))
    then
      (bif (n == 31)
      then (pure true)
      else (pure source_is_sp))
    else
      (do
        bif (n != 31)
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        (pure source_is_sp)) ) : SailM Bool )
  (execute_aarch64_instrs_integer_pac_autdb_dp_1src d n source_is_sp)

/-- Type quantifiers: d : Nat, n : Nat, k_source_is_sp : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_pac_autia_dp_1src (d : Nat) (n : Nat) (source_is_sp : Bool) : SailM Unit := do
  let auth_then_branch : Bool := false
  bif (← (HavePACExt ()))
  then
    (do
      bif source_is_sp
      then (X_set d 64 (← (AuthIA (← (X_read d 64)) (← (SP_read ())) auth_then_branch)))
      else (X_set d 64 (← (AuthIA (← (X_read d 64)) (← (X_read n 64)) auth_then_branch))))
  else (pure ())

def decode_autia_aarch64_instrs_integer_pac_autia_dp_1src (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Z : (BitVec 1)) : SailM Unit := do
  let source_is_sp : Bool := false
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HavePACExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let source_is_sp ← (( do
    bif (Z == (0b0 : (BitVec 1)))
    then
      (bif (n == 31)
      then (pure true)
      else (pure source_is_sp))
    else
      (do
        bif (n != 31)
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        (pure source_is_sp)) ) : SailM Bool )
  (execute_aarch64_instrs_integer_pac_autia_dp_1src d n source_is_sp)

def decode_autia_aarch64_instrs_integer_pac_autia_hint (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let d : Int := 17
  let n ← (( do (undefined_int ()) ) : SailM Int )
  let source_is_sp : Bool := false
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0011100 : (BitVec 7)))
  then
    (let d : Int := 30
    let n : Int := 31
    (pure ()))
  else
    (do
      bif (b__0 == (0b0011101 : (BitVec 7)))
      then
        (let d : Int := 30
        let source_is_sp : Bool := true
        (pure ()))
      else
        (do
          bif (b__0 == (0b0001100 : (BitVec 7)))
          then
            (let d : Int := 17
            let n : Int := 16
            (pure ()))
          else
            (do
              bif (b__0 == (0b0001000 : (BitVec 7)))
              then sailThrow ((Error_See "PACIA"))
              else
                (do
                  bif (b__0 == (0b0001010 : (BitVec 7)))
                  then sailThrow ((Error_See "PACIB"))
                  else
                    (do
                      bif (b__0 == (0b0001110 : (BitVec 7)))
                      then sailThrow ((Error_See "AUTIB"))
                      else
                        (do
                          bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001100 : (BitVec 6)))
                          then sailThrow ((Error_See "PACIA"))
                          else
                            (do
                              bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001101 : (BitVec 6)))
                              then sailThrow ((Error_See "PACIB"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001111 : (BitVec 6)))
                                  then sailThrow ((Error_See "AUTIB"))
                                  else
                                    (do
                                      bif (b__0 == (0b0000111 : (BitVec 7)))
                                      then sailThrow ((Error_See "XPACLRI"))
                                      else sailThrow ((Error_See "HINT")))))))))))
  let n := n
  let d := d
  assert ((0 ≤b n) && (n ≤b 31)) "src/instrs64.sail:2471.43-2471.44"
  (execute_aarch64_instrs_integer_pac_autia_dp_1src d n source_is_sp)

/-- Type quantifiers: d : Nat, n : Nat, k_source_is_sp : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_pac_autib_dp_1src (d : Nat) (n : Nat) (source_is_sp : Bool) : SailM Unit := do
  let auth_then_branch : Bool := false
  bif (← (HavePACExt ()))
  then
    (do
      bif source_is_sp
      then (X_set d 64 (← (AuthIB (← (X_read d 64)) (← (SP_read ())) auth_then_branch)))
      else (X_set d 64 (← (AuthIB (← (X_read d 64)) (← (X_read n 64)) auth_then_branch))))
  else (pure ())

def decode_autib_aarch64_instrs_integer_pac_autib_dp_1src (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Z : (BitVec 1)) : SailM Unit := do
  let source_is_sp : Bool := false
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HavePACExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let source_is_sp ← (( do
    bif (Z == (0b0 : (BitVec 1)))
    then
      (bif (n == 31)
      then (pure true)
      else (pure source_is_sp))
    else
      (do
        bif (n != 31)
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        (pure source_is_sp)) ) : SailM Bool )
  (execute_aarch64_instrs_integer_pac_autib_dp_1src d n source_is_sp)

def decode_autib_aarch64_instrs_integer_pac_autib_hint (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let d : Int := 17
  let n ← (( do (undefined_int ()) ) : SailM Int )
  let source_is_sp : Bool := false
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0011110 : (BitVec 7)))
  then
    (let d : Int := 30
    let n : Int := 31
    (pure ()))
  else
    (do
      bif (b__0 == (0b0011111 : (BitVec 7)))
      then
        (let d : Int := 30
        let source_is_sp : Bool := true
        (pure ()))
      else
        (do
          bif (b__0 == (0b0001110 : (BitVec 7)))
          then
            (let d : Int := 17
            let n : Int := 16
            (pure ()))
          else
            (do
              bif (b__0 == (0b0001000 : (BitVec 7)))
              then sailThrow ((Error_See "PACIA"))
              else
                (do
                  bif (b__0 == (0b0001010 : (BitVec 7)))
                  then sailThrow ((Error_See "PACIB"))
                  else
                    (do
                      bif (b__0 == (0b0001100 : (BitVec 7)))
                      then sailThrow ((Error_See "AUTIA"))
                      else
                        (do
                          bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001100 : (BitVec 6)))
                          then sailThrow ((Error_See "PACIA"))
                          else
                            (do
                              bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001101 : (BitVec 6)))
                              then sailThrow ((Error_See "PACIB"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001110 : (BitVec 6)))
                                  then sailThrow ((Error_See "AUTIA"))
                                  else
                                    (do
                                      bif (b__0 == (0b0000111 : (BitVec 7)))
                                      then sailThrow ((Error_See "XPACLRI"))
                                      else sailThrow ((Error_See "HINT")))))))))))
  let n := n
  let d := d
  assert ((0 ≤b n) && (n ≤b 31)) "src/instrs64.sail:2575.43-2575.44"
  (execute_aarch64_instrs_integer_pac_autib_dp_1src d n source_is_sp)

def execute_aarch64_instrs_integer_flags_axflag (_ : Unit) : SailM Unit := do
  let n : (BitVec 1) := (0b0 : (BitVec 1))
  let z ← (( do (pure ((← readReg PSTATE).Z ||| (← readReg PSTATE).V)) ) : SailM (BitVec 1) )
  let c ← (( do (pure ((← readReg PSTATE).C &&& (Complement.complement (← readReg PSTATE).V)))
    ) : SailM (BitVec 1) )
  let v : (BitVec 1) := (0b0 : (BitVec 1))
  writeReg PSTATE { (← readReg PSTATE) with N := n }
  writeReg PSTATE { (← readReg PSTATE) with Z := z }
  writeReg PSTATE { (← readReg PSTATE) with C := c }
  writeReg PSTATE { (← readReg PSTATE) with V := v }

def decode_axflag_aarch64_instrs_integer_flags_axflag (CRm : (BitVec 4)) : SailM Unit := do
  bif (! (← (HaveFlagFormatExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_integer_flags_axflag ())

def execute_aarch64_instrs_branch_unconditional_immediate (branch_type : BranchType) (offset : (BitVec 64)) : SailM Unit := do
  bif (BEq.beq branch_type BranchType_DIRCALL)
  then
    (do
      bif ((← (HaveGCS ())) && (← (GCSPCREnabled (← readReg PSTATE).EL)))
      then (AddGCSRecord (BitVec.addInt (← (PC_read ())) 4))
      else (pure ())
      (X_set 30 64 (BitVec.addInt (← (PC_read ())) 4)))
  else (pure ())
  let branch_conditional : Bool := false
  (BranchTo ((← (PC_read ())) + offset) branch_type branch_conditional)

def decode_b_uncond_aarch64_instrs_branch_unconditional_immediate (imm26 : (BitVec 26)) (op : (BitVec 1)) : SailM Unit := do
  let branch_type : BranchType :=
    bif (op == (0b1 : (BitVec 1)))
    then BranchType_DIRCALL
    else BranchType_DIR
  let offset : (BitVec 64) := (sign_extend (imm26 ++ (0b00 : (BitVec 2))) 64)
  (execute_aarch64_instrs_branch_unconditional_immediate branch_type offset)

def decode_bl_aarch64_instrs_branch_unconditional_immediate (imm26 : (BitVec 26)) (op : (BitVec 1)) : SailM Unit := do
  let branch_type : BranchType :=
    bif (op == (0b1 : (BitVec 1)))
    then BranchType_DIRCALL
    else BranchType_DIR
  let offset : (BitVec 64) := (sign_extend (imm26 ++ (0b00 : (BitVec 2))) 64)
  (execute_aarch64_instrs_branch_unconditional_immediate branch_type offset)

def execute_aarch64_instrs_branch_conditional_cond (condition : (BitVec 4)) (offset : (BitVec 64)) : SailM Unit := do
  let branch_conditional : Bool := true
  bif (← (ConditionHolds condition))
  then (BranchTo ((← (PC_read ())) + offset) BranchType_DIR branch_conditional)
  else (BranchNotTaken BranchType_DIR branch_conditional)

def decode_b_cond_aarch64_instrs_branch_conditional_cond (cond : (BitVec 4)) (imm19 : (BitVec 19)) : SailM Unit := do
  let offset : (BitVec 64) := (sign_extend (imm19 ++ (0b00 : (BitVec 2))) 64)
  let condition : (BitVec 4) := cond
  (execute_aarch64_instrs_branch_conditional_cond condition offset)

def execute_aarch64_instrs_branch_conditional_hinted (condition : (BitVec 4)) (offset : (BitVec 64)) : SailM Unit := do
  let branch_conditional : Bool := true
  bif (← (ConditionHolds condition))
  then (BranchTo ((← (PC_read ())) + offset) BranchType_DIR branch_conditional)
  else (BranchNotTaken BranchType_DIR branch_conditional)

def decode_bc_cond_aarch64_instrs_branch_conditional_hinted (cond : (BitVec 4)) (imm19 : (BitVec 19)) : SailM Unit := do
  bif (! (← (HaveFeatHBC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := (sign_extend (imm19 ++ (0b00 : (BitVec 2))) 64)
  let condition : (BitVec 4) := cond
  (execute_aarch64_instrs_branch_conditional_hinted condition offset)

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha3_bcax (a : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let Va ← (( do (V_read a 128) ) : SailM (BitVec 128) )
  (V_set d 128 (Vn ^^^ (Vm &&& (Complement.complement Va))))

def decode_bcax_advsimd_aarch64_instrs_vector_crypto_sha3_bcax (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSHA3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  (execute_aarch64_instrs_vector_crypto_sha3_bcax a d m n)

/-- Type quantifiers: d : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_cvt_bf16_scalar (d : Nat) (n : Nat) : SailM Unit := do
  (CheckFPEnabled64 ())
  let operand ← (( do (V_read n 32) ) : SailM (BitVec 32) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let result ← (Elem_set result 0 16 (← (FPConvertBF__1 operand fpcr)))
  (V_set d 128 result)

def decode_bfcvt_float_aarch64_instrs_vector_cvt_bf16_scalar (Rd : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveBF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_vector_cvt_bf16_scalar d n)

/-- Type quantifiers: d : Nat, elements : Nat, n : Nat, part : Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧ n ≤ 31 ∧ elements = 4 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_cvt_bf16_vector (d : Nat) (elements : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e 16
          (← (FPConvertBF__1 (← (Elem_read operand e 32)) (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec 64) )
  (Vpart_set d part 64 result)

def decode_bfcvtn_advsimd_aarch64_instrs_vector_cvt_bf16_vector (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveBF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv 64 16)
  (execute_aarch64_instrs_vector_cvt_bf16_vector d elements n part)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Nat, i : Nat, m : Nat, n : Nat, 0 ≤ n
  ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  i ∈ {0, 1, 2, 3} ∧ elements ∈ {2, 4} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_bfdot (d : Nat) (datasize : Nat) (elements : Nat) (i : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let elt2_a ← (( do (Elem_read operand2 ((2 *i i) +i 0) 16) ) : SailM (BitVec 16) )
        let elt2_b ← (( do (Elem_read operand2 ((2 *i i) +i 1) 16) ) : SailM (BitVec 16) )
        let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) : SailM
          (BitVec 32) )
        (Elem_set result e 32 sum)
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_bfdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_bfdot (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveBF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (M ++ Rm))
  let d := (BitVec.toNat Rd)
  let i := (BitVec.toNat (H ++ L))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize 32)
  (execute_aarch64_instrs_vector_arithmetic_binary_element_bfdot d datasize elements i m n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ elements ∈ {2, 4} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_bfdot (d : Nat) (datasize : Nat) (elements : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) : SailM
          (BitVec 32) )
        (Elem_set result e 32 sum)
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_bfdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_bfdot (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveBF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize 32)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_bfdot d datasize elements m n)

/-- Type quantifiers: d : Nat, datasize : Nat, k_extend : Bool, k_inzero : Bool, n : Nat, r : Nat, s
  : Nat, 0 ≤ s ∧
  s ≤ 63 ∧
  0 ≤ r ∧ r ≤ 63 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_bitfield (d : Nat) (datasize : Nat) (extend : Bool) (inzero : Bool) (n : Nat) (r : Nat) (s : Nat) (tmask : (BitVec datasize)) (wmask : (BitVec datasize)) : SailM Unit := do
  let dst ← (( do
    bif inzero
    then (pure (Zeros (n := datasize)))
    else (X_read d datasize) ) : SailM (BitVec datasize) )
  let src ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let bot : (BitVec datasize) :=
    ((dst &&& (Complement.complement wmask)) ||| ((ROR src r) &&& wmask))
  let top ← (( do
    bif extend
    then
      (do
        assert ((0 ≤b s) && (s <b datasize)) "src/instrs64.sail:2923.53-2923.54"
        (pure (BitVec.replicateBits (BitVec.join1 [(BitVec.access src s)]) datasize)))
    else (pure dst) ) : SailM (BitVec datasize) )
  (X_set d datasize ((top &&& (Complement.complement tmask)) ||| (bot &&& tmask)))

def decode_bfm_aarch64_instrs_integer_bitfield (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imms : (BitVec 6)) (immr : (BitVec 6)) (N : (BitVec 1)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let inzero ← (( do (undefined_bool ()) ) : SailM Bool )
  let extend ← (( do (undefined_bool ()) ) : SailM Bool )
  let wmask ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let tmask ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let b__0 := opc
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let inzero : Bool := true
    let extend : Bool := true
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let inzero : Bool := false
        let extend : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let inzero : Bool := true
            let extend : Bool := false
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let extend := extend
  let inzero := inzero
  bif ((sf == (0b1 : (BitVec 1))) && (N != (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sf == (0b0 : (BitVec 1))) && (((N != (0b0 : (BitVec 1))) || ((BitVec.join1 [(BitVec.access
                 immr 5)]) != (0b0 : (BitVec 1)))) || ((BitVec.join1 [(BitVec.access imms 5)]) != (0b0 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let r := (BitVec.toNat immr)
  let s := (BitVec.toNat imms)
  let (tup__0, tup__1) ← do (DecodeBitMasks N imms immr false datasize)
  let wmask : (BitVec datasize) := tup__0
  let tmask : (BitVec datasize) := tup__1
  (pure ())
  (execute_aarch64_instrs_integer_bitfield d datasize extend inzero n r s tmask wmask)

def decode_sbfm_aarch64_instrs_integer_bitfield (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imms : (BitVec 6)) (immr : (BitVec 6)) (N : (BitVec 1)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let inzero ← (( do (undefined_bool ()) ) : SailM Bool )
  let extend ← (( do (undefined_bool ()) ) : SailM Bool )
  let wmask ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let tmask ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let b__0 := opc
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let inzero : Bool := true
    let extend : Bool := true
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let inzero : Bool := false
        let extend : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let inzero : Bool := true
            let extend : Bool := false
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let extend := extend
  let inzero := inzero
  bif ((sf == (0b1 : (BitVec 1))) && (N != (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sf == (0b0 : (BitVec 1))) && (((N != (0b0 : (BitVec 1))) || ((BitVec.join1 [(BitVec.access
                 immr 5)]) != (0b0 : (BitVec 1)))) || ((BitVec.join1 [(BitVec.access imms 5)]) != (0b0 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let r := (BitVec.toNat immr)
  let s := (BitVec.toNat imms)
  let (tup__0, tup__1) ← do (DecodeBitMasks N imms immr false datasize)
  let wmask : (BitVec datasize) := tup__0
  let tmask : (BitVec datasize) := tup__1
  (pure ())
  (execute_aarch64_instrs_integer_bitfield d datasize extend inzero n r s tmask wmask)

def decode_ubfm_aarch64_instrs_integer_bitfield (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imms : (BitVec 6)) (immr : (BitVec 6)) (N : (BitVec 1)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let inzero ← (( do (undefined_bool ()) ) : SailM Bool )
  let extend ← (( do (undefined_bool ()) ) : SailM Bool )
  let wmask ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let tmask ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let b__0 := opc
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let inzero : Bool := true
    let extend : Bool := true
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let inzero : Bool := false
        let extend : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let inzero : Bool := true
            let extend : Bool := false
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let extend := extend
  let inzero := inzero
  bif ((sf == (0b1 : (BitVec 1))) && (N != (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sf == (0b0 : (BitVec 1))) && (((N != (0b0 : (BitVec 1))) || ((BitVec.join1 [(BitVec.access
                 immr 5)]) != (0b0 : (BitVec 1)))) || ((BitVec.join1 [(BitVec.access imms 5)]) != (0b0 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let r := (BitVec.toNat immr)
  let s := (BitVec.toNat imms)
  let (tup__0, tup__1) ← do (DecodeBitMasks N imms immr false datasize)
  let wmask : (BitVec datasize) := tup__0
  let tmask : (BitVec datasize) := tup__1
  (pure ())
  (execute_aarch64_instrs_integer_bitfield d datasize extend inzero n r s tmask wmask)

/-- Type quantifiers: d : Nat, elements : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel ∈
  {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ elements = 4 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_bf16_long (d : Nat) (elements : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let operand1 ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let operand2 ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let operand3 ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let element2 ← (( do (Elem_read operand2 index 16) ) : SailM (BitVec 16) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i sel) 16) ) : SailM (BitVec 16) )
        let addend ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        (Elem_set result e 32 (← (BFMulAddH addend element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_bfmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_bf16_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveBF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Rm))
  let d := (BitVec.toNat Rd)
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let elements := (Int.ediv 128 32)
  let sel := (BitVec.toNat Q)
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_bf16_long d elements index m n
    sel)

/-- Type quantifiers: d : Nat, elements : Nat, m : Nat, n : Nat, sel : Nat, sel ∈ {0, 1} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ elements = 4 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_acc_bf16_long (d : Nat) (elements : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let operand2 ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let operand3 ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i sel) 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i sel) 16) ) : SailM (BitVec 16) )
        let addend ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        (Elem_set result e 32 (← (BFMulAddH addend element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_bfmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_acc_bf16_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveBF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let elements := (Int.ediv 128 32)
  let sel := (BitVec.toNat Q)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_acc_bf16_long d elements m n sel)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_bfmmla (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let op1 ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let op2 ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let acc ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  (V_set d 128 (← (BFMatMulAdd acc op1 op2)))

def decode_bfmmla_advsimd_aarch64_instrs_vector_bfmmla (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveBF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_vector_bfmmla d m n)

/-- Type quantifiers: datasize : Nat, rd : Nat, 0 ≤ rd ∧ rd ≤ 31 ∧ datasize ∈ {64, 128} -/
def execute_aarch64_instrs_vector_logical (datasize : Nat) (imm : (BitVec datasize)) (operation : ImmediateOp) (rd : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    match operation with
    | ImmediateOp_MOVI => (pure imm)
    | ImmediateOp_MVNI => (pure (Complement.complement imm))
    | ImmediateOp_ORR =>
      (do
        let operand ← (( do (V_read rd datasize) ) : SailM (BitVec datasize) )
        (pure (operand ||| imm)))
    | ImmediateOp_BIC =>
      (do
        let operand ← (( do (V_read rd datasize) ) : SailM (BitVec datasize) )
        (pure (operand &&& (Complement.complement imm)))) ) : SailM (BitVec datasize) )
  (V_set rd datasize result)

def decode_bic_advsimd_imm_aarch64_instrs_vector_logical (Rd : (BitVec 5)) (h : (BitVec 1)) (g : (BitVec 1)) (f : (BitVec 1)) (e : (BitVec 1)) (d : (BitVec 1)) (cmode : (BitVec 4)) (c : (BitVec 1)) (b : (BitVec 1)) (a : (BitVec 1)) (op : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let rd := (BitVec.toNat Rd)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let operation ← (( do (undefined_ImmediateOp ()) ) : SailM ImmediateOp )
  let b__0 := (cmode ++ op)
  bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb b__0 1
           0) == (0b00 : (BitVec 2))))
  then
    (let operation : ImmediateOp := ImmediateOp_MOVI
    (pure ()))
  else
    (do
      bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
               b__0 1 0) == (0b01 : (BitVec 2))))
      then
        (let operation : ImmediateOp := ImmediateOp_MVNI
        (pure ()))
      else
        (do
          bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                   b__0 1 0) == (0b10 : (BitVec 2))))
          then
            (let operation : ImmediateOp := ImmediateOp_ORR
            (pure ()))
          else
            (do
              bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                       b__0 1 0) == (0b11 : (BitVec 2))))
              then
                (let operation : ImmediateOp := ImmediateOp_BIC
                (pure ()))
              else
                (do
                  bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                           b__0 1 0) == (0b00 : (BitVec 2))))
                  then
                    (let operation : ImmediateOp := ImmediateOp_MOVI
                    (pure ()))
                  else
                    (do
                      bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                               b__0 1 0) == (0b01 : (BitVec 2))))
                      then
                        (let operation : ImmediateOp := ImmediateOp_MVNI
                        (pure ()))
                      else
                        (do
                          bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                                   b__0 1 0) == (0b10 : (BitVec 2))))
                          then
                            (let operation : ImmediateOp := ImmediateOp_ORR
                            (pure ()))
                          else
                            (do
                              bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                                       b__0 1 0) == (0b11 : (BitVec 2))))
                              then
                                (let operation : ImmediateOp := ImmediateOp_BIC
                                (pure ()))
                              else
                                (do
                                  bif (((Sail.BitVec.extractLsb b__0 4 2) == (0b110 : (BitVec 3))) && ((Sail.BitVec.extractLsb
                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                  then
                                    (let operation : ImmediateOp := ImmediateOp_MOVI
                                    (pure ()))
                                  else
                                    (do
                                      bif (((Sail.BitVec.extractLsb b__0 4 2) == (0b110 : (BitVec 3))) && ((Sail.BitVec.extractLsb
                                               b__0 0 0) == (0b1 : (BitVec 1))))
                                      then
                                        (let operation : ImmediateOp := ImmediateOp_MVNI
                                        (pure ()))
                                      else
                                        (do
                                          bif ((Sail.BitVec.extractLsb b__0 4 1) == (0xE : (BitVec 4)))
                                          then
                                            (let operation : ImmediateOp := ImmediateOp_MOVI
                                            (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b11110 : (BitVec 5)))
                                              then
                                                (let operation : ImmediateOp := ImmediateOp_MOVI
                                                (pure ()))
                                              else
                                                (do
                                                  bif (Q == (0b0 : (BitVec 1)))
                                                  then sailThrow ((Error_Undefined ()))
                                                  else (pure ())
                                                  let operation : ImmediateOp := ImmediateOp_MOVI
                                                  (pure ())))))))))))))
  let operation := operation
  let imm64 ← (( do (AdvSIMDExpandImm op cmode (((((((a ++ b) ++ c) ++ d) ++ e) ++ f) ++ g) ++ h))
    ) : SailM (BitVec 64) )
  let imm : (BitVec datasize) := (BitVec.replicateBits imm64 (Int.ediv datasize 64))
  (execute_aarch64_instrs_vector_logical datasize imm operation rd)

def decode_movi_advsimd_aarch64_instrs_vector_logical (Rd : (BitVec 5)) (h : (BitVec 1)) (g : (BitVec 1)) (f : (BitVec 1)) (e : (BitVec 1)) (d : (BitVec 1)) (cmode : (BitVec 4)) (c : (BitVec 1)) (b : (BitVec 1)) (a : (BitVec 1)) (op : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let rd := (BitVec.toNat Rd)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let operation ← (( do (undefined_ImmediateOp ()) ) : SailM ImmediateOp )
  let b__0 := (cmode ++ op)
  bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb b__0 1
           0) == (0b00 : (BitVec 2))))
  then
    (let operation : ImmediateOp := ImmediateOp_MOVI
    (pure ()))
  else
    (do
      bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
               b__0 1 0) == (0b01 : (BitVec 2))))
      then
        (let operation : ImmediateOp := ImmediateOp_MVNI
        (pure ()))
      else
        (do
          bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                   b__0 1 0) == (0b10 : (BitVec 2))))
          then
            (let operation : ImmediateOp := ImmediateOp_ORR
            (pure ()))
          else
            (do
              bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                       b__0 1 0) == (0b11 : (BitVec 2))))
              then
                (let operation : ImmediateOp := ImmediateOp_BIC
                (pure ()))
              else
                (do
                  bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                           b__0 1 0) == (0b00 : (BitVec 2))))
                  then
                    (let operation : ImmediateOp := ImmediateOp_MOVI
                    (pure ()))
                  else
                    (do
                      bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                               b__0 1 0) == (0b01 : (BitVec 2))))
                      then
                        (let operation : ImmediateOp := ImmediateOp_MVNI
                        (pure ()))
                      else
                        (do
                          bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                                   b__0 1 0) == (0b10 : (BitVec 2))))
                          then
                            (let operation : ImmediateOp := ImmediateOp_ORR
                            (pure ()))
                          else
                            (do
                              bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                                       b__0 1 0) == (0b11 : (BitVec 2))))
                              then
                                (let operation : ImmediateOp := ImmediateOp_BIC
                                (pure ()))
                              else
                                (do
                                  bif (((Sail.BitVec.extractLsb b__0 4 2) == (0b110 : (BitVec 3))) && ((Sail.BitVec.extractLsb
                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                  then
                                    (let operation : ImmediateOp := ImmediateOp_MOVI
                                    (pure ()))
                                  else
                                    (do
                                      bif (((Sail.BitVec.extractLsb b__0 4 2) == (0b110 : (BitVec 3))) && ((Sail.BitVec.extractLsb
                                               b__0 0 0) == (0b1 : (BitVec 1))))
                                      then
                                        (let operation : ImmediateOp := ImmediateOp_MVNI
                                        (pure ()))
                                      else
                                        (do
                                          bif ((Sail.BitVec.extractLsb b__0 4 1) == (0xE : (BitVec 4)))
                                          then
                                            (let operation : ImmediateOp := ImmediateOp_MOVI
                                            (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b11110 : (BitVec 5)))
                                              then
                                                (let operation : ImmediateOp := ImmediateOp_MOVI
                                                (pure ()))
                                              else
                                                (do
                                                  bif (Q == (0b0 : (BitVec 1)))
                                                  then sailThrow ((Error_Undefined ()))
                                                  else (pure ())
                                                  let operation : ImmediateOp := ImmediateOp_MOVI
                                                  (pure ())))))))))))))
  let operation := operation
  let imm64 ← (( do (AdvSIMDExpandImm op cmode (((((((a ++ b) ++ c) ++ d) ++ e) ++ f) ++ g) ++ h))
    ) : SailM (BitVec 64) )
  let imm : (BitVec datasize) := (BitVec.replicateBits imm64 (Int.ediv datasize 64))
  (execute_aarch64_instrs_vector_logical datasize imm operation rd)

def decode_mvni_advsimd_aarch64_instrs_vector_logical (Rd : (BitVec 5)) (h : (BitVec 1)) (g : (BitVec 1)) (f : (BitVec 1)) (e : (BitVec 1)) (d : (BitVec 1)) (cmode : (BitVec 4)) (c : (BitVec 1)) (b : (BitVec 1)) (a : (BitVec 1)) (op : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let rd := (BitVec.toNat Rd)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let operation ← (( do (undefined_ImmediateOp ()) ) : SailM ImmediateOp )
  let b__0 := (cmode ++ op)
  bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb b__0 1
           0) == (0b00 : (BitVec 2))))
  then
    (let operation : ImmediateOp := ImmediateOp_MOVI
    (pure ()))
  else
    (do
      bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
               b__0 1 0) == (0b01 : (BitVec 2))))
      then
        (let operation : ImmediateOp := ImmediateOp_MVNI
        (pure ()))
      else
        (do
          bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                   b__0 1 0) == (0b10 : (BitVec 2))))
          then
            (let operation : ImmediateOp := ImmediateOp_ORR
            (pure ()))
          else
            (do
              bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                       b__0 1 0) == (0b11 : (BitVec 2))))
              then
                (let operation : ImmediateOp := ImmediateOp_BIC
                (pure ()))
              else
                (do
                  bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                           b__0 1 0) == (0b00 : (BitVec 2))))
                  then
                    (let operation : ImmediateOp := ImmediateOp_MOVI
                    (pure ()))
                  else
                    (do
                      bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                               b__0 1 0) == (0b01 : (BitVec 2))))
                      then
                        (let operation : ImmediateOp := ImmediateOp_MVNI
                        (pure ()))
                      else
                        (do
                          bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                                   b__0 1 0) == (0b10 : (BitVec 2))))
                          then
                            (let operation : ImmediateOp := ImmediateOp_ORR
                            (pure ()))
                          else
                            (do
                              bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                                       b__0 1 0) == (0b11 : (BitVec 2))))
                              then
                                (let operation : ImmediateOp := ImmediateOp_BIC
                                (pure ()))
                              else
                                (do
                                  bif (((Sail.BitVec.extractLsb b__0 4 2) == (0b110 : (BitVec 3))) && ((Sail.BitVec.extractLsb
                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                  then
                                    (let operation : ImmediateOp := ImmediateOp_MOVI
                                    (pure ()))
                                  else
                                    (do
                                      bif (((Sail.BitVec.extractLsb b__0 4 2) == (0b110 : (BitVec 3))) && ((Sail.BitVec.extractLsb
                                               b__0 0 0) == (0b1 : (BitVec 1))))
                                      then
                                        (let operation : ImmediateOp := ImmediateOp_MVNI
                                        (pure ()))
                                      else
                                        (do
                                          bif ((Sail.BitVec.extractLsb b__0 4 1) == (0xE : (BitVec 4)))
                                          then
                                            (let operation : ImmediateOp := ImmediateOp_MOVI
                                            (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b11110 : (BitVec 5)))
                                              then
                                                (let operation : ImmediateOp := ImmediateOp_MOVI
                                                (pure ()))
                                              else
                                                (do
                                                  bif (Q == (0b0 : (BitVec 1)))
                                                  then sailThrow ((Error_Undefined ()))
                                                  else (pure ())
                                                  let operation : ImmediateOp := ImmediateOp_MOVI
                                                  (pure ())))))))))))))
  let operation := operation
  let imm64 ← (( do (AdvSIMDExpandImm op cmode (((((((a ++ b) ++ c) ++ d) ++ e) ++ f) ++ g) ++ h))
    ) : SailM (BitVec 64) )
  let imm : (BitVec datasize) := (BitVec.replicateBits imm64 (Int.ediv datasize 64))
  (execute_aarch64_instrs_vector_logical datasize imm operation rd)

def decode_orr_advsimd_imm_aarch64_instrs_vector_logical (Rd : (BitVec 5)) (h : (BitVec 1)) (g : (BitVec 1)) (f : (BitVec 1)) (e : (BitVec 1)) (d : (BitVec 1)) (cmode : (BitVec 4)) (c : (BitVec 1)) (b : (BitVec 1)) (a : (BitVec 1)) (op : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let rd := (BitVec.toNat Rd)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let operation ← (( do (undefined_ImmediateOp ()) ) : SailM ImmediateOp )
  let b__0 := (cmode ++ op)
  bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb b__0 1
           0) == (0b00 : (BitVec 2))))
  then
    (let operation : ImmediateOp := ImmediateOp_MOVI
    (pure ()))
  else
    (do
      bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
               b__0 1 0) == (0b01 : (BitVec 2))))
      then
        (let operation : ImmediateOp := ImmediateOp_MVNI
        (pure ()))
      else
        (do
          bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                   b__0 1 0) == (0b10 : (BitVec 2))))
          then
            (let operation : ImmediateOp := ImmediateOp_ORR
            (pure ()))
          else
            (do
              bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                       b__0 1 0) == (0b11 : (BitVec 2))))
              then
                (let operation : ImmediateOp := ImmediateOp_BIC
                (pure ()))
              else
                (do
                  bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                           b__0 1 0) == (0b00 : (BitVec 2))))
                  then
                    (let operation : ImmediateOp := ImmediateOp_MOVI
                    (pure ()))
                  else
                    (do
                      bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                               b__0 1 0) == (0b01 : (BitVec 2))))
                      then
                        (let operation : ImmediateOp := ImmediateOp_MVNI
                        (pure ()))
                      else
                        (do
                          bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                                   b__0 1 0) == (0b10 : (BitVec 2))))
                          then
                            (let operation : ImmediateOp := ImmediateOp_ORR
                            (pure ()))
                          else
                            (do
                              bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                                       b__0 1 0) == (0b11 : (BitVec 2))))
                              then
                                (let operation : ImmediateOp := ImmediateOp_BIC
                                (pure ()))
                              else
                                (do
                                  bif (((Sail.BitVec.extractLsb b__0 4 2) == (0b110 : (BitVec 3))) && ((Sail.BitVec.extractLsb
                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                  then
                                    (let operation : ImmediateOp := ImmediateOp_MOVI
                                    (pure ()))
                                  else
                                    (do
                                      bif (((Sail.BitVec.extractLsb b__0 4 2) == (0b110 : (BitVec 3))) && ((Sail.BitVec.extractLsb
                                               b__0 0 0) == (0b1 : (BitVec 1))))
                                      then
                                        (let operation : ImmediateOp := ImmediateOp_MVNI
                                        (pure ()))
                                      else
                                        (do
                                          bif ((Sail.BitVec.extractLsb b__0 4 1) == (0xE : (BitVec 4)))
                                          then
                                            (let operation : ImmediateOp := ImmediateOp_MOVI
                                            (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b11110 : (BitVec 5)))
                                              then
                                                (let operation : ImmediateOp := ImmediateOp_MOVI
                                                (pure ()))
                                              else
                                                (do
                                                  bif (Q == (0b0 : (BitVec 1)))
                                                  then sailThrow ((Error_Undefined ()))
                                                  else (pure ())
                                                  let operation : ImmediateOp := ImmediateOp_MOVI
                                                  (pure ())))))))))))))
  let operation := operation
  let imm64 ← (( do (AdvSIMDExpandImm op cmode (((((((a ++ b) ++ c) ++ d) ++ e) ++ f) ++ g) ++ h))
    ) : SailM (BitVec 64) )
  let imm : (BitVec datasize) := (BitVec.replicateBits imm64 (Int.ediv datasize 64))
  (execute_aarch64_instrs_vector_logical datasize imm operation rd)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) (op : VBitOp) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand4 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let (operand1, operand2, operand3) ← (( do
    match op with
    | VBitOp_VEOR =>
      (do
        let operand1 ← (V_read m datasize)
        let operand2 : (BitVec datasize) := (Zeros (n := datasize))
        let operand3 : (BitVec datasize) := (Ones (n := datasize))
        (pure (operand1, operand2, operand3)))
    | VBitOp_VBSL =>
      (do
        let operand1 ← (V_read m datasize)
        let operand2 : (BitVec datasize) := operand1
        let operand3 ← (V_read d datasize)
        (pure (operand1, operand2, operand3)))
    | VBitOp_VBIT =>
      (do
        let operand1 ← (V_read d datasize)
        let operand2 : (BitVec datasize) := operand1
        let operand3 ← (V_read m datasize)
        (pure (operand1, operand2, operand3)))
    | VBitOp_VBIF =>
      (do
        let operand1 ← (V_read d datasize)
        let operand2 : (BitVec datasize) := operand1
        let operand3 ← (pure (Complement.complement (← (V_read m datasize))))
        (pure (operand1, operand2, operand3))) ) : SailM
    ((BitVec datasize) × (BitVec datasize) × (BitVec datasize)) )
  let operand3 := operand3
  let operand2 := operand2
  let operand1 := operand1
  (V_set d datasize (operand1 ^^^ ((operand2 ^^^ operand4) &&& operand3)))

def decode_bif_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (opc2 : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op ← (( do (undefined_VBitOp ()) ) : SailM VBitOp )
  let _ : Unit :=
    let b__0 := opc2
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : VBitOp := VBitOp_VEOR
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : VBitOp := VBitOp_VBSL
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : VBitOp := VBitOp_VBIT
          ())
        else
          (let op : VBitOp := VBitOp_VBIF
          ())))
  let op := op
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor d datasize m n op)

def decode_bit_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (opc2 : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op ← (( do (undefined_VBitOp ()) ) : SailM VBitOp )
  let _ : Unit :=
    let b__0 := opc2
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : VBitOp := VBitOp_VEOR
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : VBitOp := VBitOp_VBSL
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : VBitOp := VBitOp_VBIT
          ())
        else
          (let op : VBitOp := VBitOp_VBIF
          ())))
  let op := op
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor d datasize m n op)

def decode_bsl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (opc2 : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op ← (( do (undefined_VBitOp ()) ) : SailM VBitOp )
  let _ : Unit :=
    let b__0 := opc2
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : VBitOp := VBitOp_VEOR
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : VBitOp := VBitOp_VBSL
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : VBitOp := VBitOp_VBIT
          ())
        else
          (let op : VBitOp := VBitOp_VBIF
          ())))
  let op := op
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor d datasize m n op)

def decode_eor_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (opc2 : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op ← (( do (undefined_VBitOp ()) ) : SailM VBitOp )
  let _ : Unit :=
    let b__0 := opc2
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let op : VBitOp := VBitOp_VEOR
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op : VBitOp := VBitOp_VBSL
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let op : VBitOp := VBitOp_VBIT
          ())
        else
          (let op : VBitOp := VBitOp_VBIF
          ())))
  let op := op
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_logical_bsl_eor d datasize m n op)

/-- Type quantifiers: m : Nat, n : Nat, k_pac : Bool, k_source_is_sp : Bool, k_use_key_a : Bool, 0
  ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 -/
def execute_aarch64_instrs_branch_unconditional_register (branch_type : BranchType) (m : Nat) (n : Nat) (pac : Bool) (source_is_sp : Bool) (use_key_a : Bool) : SailM Unit := do
  let inst_type ← (( do (undefined_GCSInstruction ()) ) : SailM GCSInstruction )
  let target ← (( do (X_read n 64) ) : SailM (BitVec 64) )
  let auth_then_branch : Bool := true
  let target ← (( do
    bif pac
    then
      (do
        let modifier ← (( do
          bif source_is_sp
          then (SP_read ())
          else (X_read m 64) ) : SailM (BitVec 64) )
        bif use_key_a
        then
          (do
            (AuthIA target modifier auth_then_branch))
        else
          (do
            (AuthIB target modifier auth_then_branch)))
    else (pure target) ) : SailM (BitVec 64) )
  let target ← (( do
    bif (((BEq.beq branch_type BranchType_RET) && (← (HaveGCS ()))) && (← (GCSPCREnabled
             (← readReg PSTATE).EL)))
    then
      (do
        let inst_type : GCSInstruction :=
          bif (! pac)
          then GCSInstType_PRET
          else
            (bif use_key_a
            then GCSInstType_PRETAA
            else GCSInstType_PRETAB)
        let target ← (LoadCheckGCSRecord target inst_type)
        (SetCurrentGCSPointer (BitVec.addInt (← (GetCurrentGCSPointer ())) 8))
        (pure target))
    else (pure target) ) : SailM (BitVec 64) )
  bif (BEq.beq branch_type BranchType_INDCALL)
  then
    (do
      bif ((← (HaveGCS ())) && (← (GCSPCREnabled (← readReg PSTATE).EL)))
      then (AddGCSRecord (BitVec.addInt (← (PC_read ())) 4))
      else (pure ())
      (X_set 30 64 (BitVec.addInt (← (PC_read ())) 4)))
  else (pure ())
  match branch_type with
  | BranchType_INDIR =>
    (do
      bif (← readReg InGuardedPage)
      then
        (do
          bif ((n == 16) || (n == 17))
          then writeReg BTypeNext (0b01 : (BitVec 2))
          else writeReg BTypeNext (0b11 : (BitVec 2)))
      else writeReg BTypeNext (0b01 : (BitVec 2)))
  | BranchType_INDCALL => writeReg BTypeNext (0b10 : (BitVec 2))
  | BranchType_RET => writeReg BTypeNext (0b00 : (BitVec 2))
  | _ => (pure ())
  let branch_conditional : Bool := false
  (BranchTo target branch_type branch_conditional)

def decode_blr_aarch64_instrs_branch_unconditional_register (Rm : (BitVec 5)) (Rn : (BitVec 5)) (M : (BitVec 1)) (A : (BitVec 1)) (op : (BitVec 2)) (Z : (BitVec 1)) : SailM Unit := do
  let n : Nat := (BitVec.toNat Rn)
  let branch_type ← (( do (undefined_BranchType ()) ) : SailM BranchType )
  let m := (BitVec.toNat Rm)
  let pac : Bool := (A == (0b1 : (BitVec 1)))
  let use_key_a : Bool := (M == (0b0 : (BitVec 1)))
  let source_is_sp : Bool := ((Z == (0b1 : (BitVec 1))) && (m == 31))
  bif ((! pac) && (m != 0))
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (pac && (! (← (HavePACExt ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ()))
  let b__0 := op
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let branch_type : BranchType := BranchType_INDIR
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let branch_type : BranchType := BranchType_INDCALL
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let branch_type : BranchType := BranchType_RET
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let branch_type := branch_type
  let (n, source_is_sp) ← (( do
    bif pac
    then
      (do
        bif ((Z == (0b0 : (BitVec 1))) && (m != 31))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (n, source_is_sp) ← (( do
          bif (BEq.beq branch_type BranchType_RET)
          then
            (do
              bif (n != 31)
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let n : Nat := 30
              let source_is_sp : Bool := true
              (pure (n, source_is_sp)))
          else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
        (pure (n, source_is_sp)))
    else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
  let n := n
  (execute_aarch64_instrs_branch_unconditional_register branch_type m n pac source_is_sp use_key_a)

def decode_blra_aarch64_instrs_branch_unconditional_register (Rm : (BitVec 5)) (Rn : (BitVec 5)) (M : (BitVec 1)) (A : (BitVec 1)) (op : (BitVec 2)) (Z : (BitVec 1)) : SailM Unit := do
  let n : Nat := (BitVec.toNat Rn)
  let branch_type ← (( do (undefined_BranchType ()) ) : SailM BranchType )
  let m := (BitVec.toNat Rm)
  let pac : Bool := (A == (0b1 : (BitVec 1)))
  let use_key_a : Bool := (M == (0b0 : (BitVec 1)))
  let source_is_sp : Bool := ((Z == (0b1 : (BitVec 1))) && (m == 31))
  bif ((! pac) && (m != 0))
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (pac && (! (← (HavePACExt ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ()))
  let b__0 := op
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let branch_type : BranchType := BranchType_INDIR
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let branch_type : BranchType := BranchType_INDCALL
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let branch_type : BranchType := BranchType_RET
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let branch_type := branch_type
  let (n, source_is_sp) ← (( do
    bif pac
    then
      (do
        bif ((Z == (0b0 : (BitVec 1))) && (m != 31))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (n, source_is_sp) ← (( do
          bif (BEq.beq branch_type BranchType_RET)
          then
            (do
              bif (n != 31)
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let n : Nat := 30
              let source_is_sp : Bool := true
              (pure (n, source_is_sp)))
          else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
        (pure (n, source_is_sp)))
    else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
  let n := n
  (execute_aarch64_instrs_branch_unconditional_register branch_type m n pac source_is_sp use_key_a)

def decode_br_aarch64_instrs_branch_unconditional_register (Rm : (BitVec 5)) (Rn : (BitVec 5)) (M : (BitVec 1)) (A : (BitVec 1)) (op : (BitVec 2)) (Z : (BitVec 1)) : SailM Unit := do
  let n : Nat := (BitVec.toNat Rn)
  let branch_type ← (( do (undefined_BranchType ()) ) : SailM BranchType )
  let m := (BitVec.toNat Rm)
  let pac : Bool := (A == (0b1 : (BitVec 1)))
  let use_key_a : Bool := (M == (0b0 : (BitVec 1)))
  let source_is_sp : Bool := ((Z == (0b1 : (BitVec 1))) && (m == 31))
  bif ((! pac) && (m != 0))
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (pac && (! (← (HavePACExt ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ()))
  let b__0 := op
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let branch_type : BranchType := BranchType_INDIR
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let branch_type : BranchType := BranchType_INDCALL
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let branch_type : BranchType := BranchType_RET
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let branch_type := branch_type
  let (n, source_is_sp) ← (( do
    bif pac
    then
      (do
        bif ((Z == (0b0 : (BitVec 1))) && (m != 31))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (n, source_is_sp) ← (( do
          bif (BEq.beq branch_type BranchType_RET)
          then
            (do
              bif (n != 31)
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let n : Nat := 30
              let source_is_sp : Bool := true
              (pure (n, source_is_sp)))
          else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
        (pure (n, source_is_sp)))
    else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
  let n := n
  (execute_aarch64_instrs_branch_unconditional_register branch_type m n pac source_is_sp use_key_a)

def decode_bra_aarch64_instrs_branch_unconditional_register (Rm : (BitVec 5)) (Rn : (BitVec 5)) (M : (BitVec 1)) (A : (BitVec 1)) (op : (BitVec 2)) (Z : (BitVec 1)) : SailM Unit := do
  let n : Nat := (BitVec.toNat Rn)
  let branch_type ← (( do (undefined_BranchType ()) ) : SailM BranchType )
  let m := (BitVec.toNat Rm)
  let pac : Bool := (A == (0b1 : (BitVec 1)))
  let use_key_a : Bool := (M == (0b0 : (BitVec 1)))
  let source_is_sp : Bool := ((Z == (0b1 : (BitVec 1))) && (m == 31))
  bif ((! pac) && (m != 0))
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (pac && (! (← (HavePACExt ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ()))
  let b__0 := op
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let branch_type : BranchType := BranchType_INDIR
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let branch_type : BranchType := BranchType_INDCALL
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let branch_type : BranchType := BranchType_RET
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let branch_type := branch_type
  let (n, source_is_sp) ← (( do
    bif pac
    then
      (do
        bif ((Z == (0b0 : (BitVec 1))) && (m != 31))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (n, source_is_sp) ← (( do
          bif (BEq.beq branch_type BranchType_RET)
          then
            (do
              bif (n != 31)
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let n : Nat := 30
              let source_is_sp : Bool := true
              (pure (n, source_is_sp)))
          else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
        (pure (n, source_is_sp)))
    else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
  let n := n
  (execute_aarch64_instrs_branch_unconditional_register branch_type m n pac source_is_sp use_key_a)

def decode_ret_aarch64_instrs_branch_unconditional_register (Rm : (BitVec 5)) (Rn : (BitVec 5)) (M : (BitVec 1)) (A : (BitVec 1)) (op : (BitVec 2)) (Z : (BitVec 1)) : SailM Unit := do
  let n : Nat := (BitVec.toNat Rn)
  let branch_type ← (( do (undefined_BranchType ()) ) : SailM BranchType )
  let m := (BitVec.toNat Rm)
  let pac : Bool := (A == (0b1 : (BitVec 1)))
  let use_key_a : Bool := (M == (0b0 : (BitVec 1)))
  let source_is_sp : Bool := ((Z == (0b1 : (BitVec 1))) && (m == 31))
  bif ((! pac) && (m != 0))
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (pac && (! (← (HavePACExt ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ()))
  let b__0 := op
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let branch_type : BranchType := BranchType_INDIR
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let branch_type : BranchType := BranchType_INDCALL
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let branch_type : BranchType := BranchType_RET
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let branch_type := branch_type
  let (n, source_is_sp) ← (( do
    bif pac
    then
      (do
        bif ((Z == (0b0 : (BitVec 1))) && (m != 31))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (n, source_is_sp) ← (( do
          bif (BEq.beq branch_type BranchType_RET)
          then
            (do
              bif (n != 31)
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let n : Nat := 30
              let source_is_sp : Bool := true
              (pure (n, source_is_sp)))
          else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
        (pure (n, source_is_sp)))
    else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
  let n := n
  (execute_aarch64_instrs_branch_unconditional_register branch_type m n pac source_is_sp use_key_a)

def decode_reta_aarch64_instrs_branch_unconditional_register (Rm : (BitVec 5)) (Rn : (BitVec 5)) (M : (BitVec 1)) (A : (BitVec 1)) (op : (BitVec 2)) (Z : (BitVec 1)) : SailM Unit := do
  let n : Nat := (BitVec.toNat Rn)
  let branch_type ← (( do (undefined_BranchType ()) ) : SailM BranchType )
  let m := (BitVec.toNat Rm)
  let pac : Bool := (A == (0b1 : (BitVec 1)))
  let use_key_a : Bool := (M == (0b0 : (BitVec 1)))
  let source_is_sp : Bool := ((Z == (0b1 : (BitVec 1))) && (m == 31))
  bif ((! pac) && (m != 0))
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (pac && (! (← (HavePACExt ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ()))
  let b__0 := op
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let branch_type : BranchType := BranchType_INDIR
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let branch_type : BranchType := BranchType_INDCALL
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let branch_type : BranchType := BranchType_RET
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let branch_type := branch_type
  let (n, source_is_sp) ← (( do
    bif pac
    then
      (do
        bif ((Z == (0b0 : (BitVec 1))) && (m != 31))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (n, source_is_sp) ← (( do
          bif (BEq.beq branch_type BranchType_RET)
          then
            (do
              bif (n != 31)
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let n : Nat := 30
              let source_is_sp : Bool := true
              (pure (n, source_is_sp)))
          else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
        (pure (n, source_is_sp)))
    else (pure (n, source_is_sp)) ) : SailM (Nat × Bool) )
  let n := n
  (execute_aarch64_instrs_branch_unconditional_register branch_type m n pac source_is_sp use_key_a)

def execute_aarch64_instrs_system_exceptions_debug_breakpoint (comment : (BitVec 16)) : SailM Unit := do
  (AArch64_SoftwareBreakpoint comment)

def decode_brk_aarch64_instrs_system_exceptions_debug_breakpoint (imm16 : (BitVec 16)) : SailM Unit := do
  let comment : (BitVec 16) := imm16
  bif (← (HaveBTIExt ()))
  then (SetBTypeCompatible true)
  else (pure ())
  (execute_aarch64_instrs_system_exceptions_debug_breakpoint comment)

def execute_aarch64_instrs_system_hints (op : SystemHintOp) : SailM Unit := do
  match op with
  | SystemHintOp_YIELD => (pure (Hint_Yield ()))
  | SystemHintOp_DGH => (pure (Hint_DGH ()))
  | SystemHintOp_WFE =>
    (do
      let localtimeout := (Int.shiftl 1 64)
      (Hint_WFE localtimeout WFxType_WFE))
  | SystemHintOp_WFI =>
    (do
      let localtimeout := (Int.shiftl 1 64)
      (Hint_WFI localtimeout WFxType_WFI))
  | SystemHintOp_SEV => (pure (SendEvent ()))
  | SystemHintOp_SEVL => (SendEventLocal ())
  | SystemHintOp_ESB =>
    (do
      bif ((← (HaveTME ())) && ((← readReg TSTATE).depth >b 0))
      then (FailTransaction TMFailure_ERR false)
      else (pure ())
      let _ : Unit := (SynchronizeErrors ())
      (AArch64_ESBOperation ())
      bif ((((← readReg PSTATE).EL == EL0) || ((← readReg PSTATE).EL == EL1)) && (← (EL2Enabled
               ())))
      then (AArch64_vESBOperation ())
      else (pure ())
      (TakeUnmaskedSErrorInterrupts ()))
  | SystemHintOp_PSB => (pure (ProfilingSynchronizationBarrier ()))
  | SystemHintOp_TSB => (pure (TraceSynchronizationBarrier ()))
  | SystemHintOp_GCSB => (pure (GCSSynchronizationBarrier ()))
  | SystemHintOp_CHKFEAT => (X_set 16 64 (← (AArch64_ChkFeat (← (X_read 16 64)))))
  | SystemHintOp_CSDB => (pure (ConsumptionOfSpeculativeDataBarrier ()))
  | SystemHintOp_CLRBHB => (pure (Hint_CLRBHB ()))
  | SystemHintOp_BTI => (SetBTypeNext (0b00 : (BitVec 2)))
  | SystemHintOp_NOP => (pure ())
  | _ => (Unreachable ())

def decode_bti_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_chkfeat_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_clrbhb_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_csdb_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_dgh_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_esb_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_gcsb_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_hint_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_nop_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_psb_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_sev_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_sevl_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_tsb_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_wfe_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_wfi_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

def decode_yield_aarch64_instrs_system_hints (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let op ← (( do (undefined_SystemHintOp ()) ) : SailM SystemHintOp )
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0000000 : (BitVec 7)))
  then
    (let op : SystemHintOp := SystemHintOp_NOP
    (pure ()))
  else
    (do
      bif (b__0 == (0b0000001 : (BitVec 7)))
      then
        (let op : SystemHintOp := SystemHintOp_YIELD
        (pure ()))
      else
        (do
          bif (b__0 == (0b0000010 : (BitVec 7)))
          then
            (let op : SystemHintOp := SystemHintOp_WFE
            (pure ()))
          else
            (do
              bif (b__0 == (0b0000011 : (BitVec 7)))
              then
                (let op : SystemHintOp := SystemHintOp_WFI
                (pure ()))
              else
                (do
                  bif (b__0 == (0b0000100 : (BitVec 7)))
                  then
                    (let op : SystemHintOp := SystemHintOp_SEV
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0b0000101 : (BitVec 7)))
                      then
                        (let op : SystemHintOp := SystemHintOp_SEVL
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0b0000110 : (BitVec 7)))
                          then
                            (do
                              bif (! (← (HaveDGHExt ())))
                              then (EndOfInstruction ())
                              else (pure ())
                              let op : SystemHintOp := SystemHintOp_DGH
                              (pure ()))
                          else
                            (do
                              bif (b__0 == (0b0000111 : (BitVec 7)))
                              then sailThrow ((Error_See "XPACLRI"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x1 : (BitVec 4)))
                                  then
                                    (do
                                      let b__9 := op2
                                      bif (b__9 == (0b000 : (BitVec 3)))
                                      then sailThrow ((Error_See "PACIA1716"))
                                      else
                                        (do
                                          bif (b__9 == (0b010 : (BitVec 3)))
                                          then sailThrow ((Error_See "PACIB1716"))
                                          else
                                            (do
                                              bif (b__9 == (0b100 : (BitVec 3)))
                                              then sailThrow ((Error_See "AUTIA1716"))
                                              else
                                                (do
                                                  bif (b__9 == (0b110 : (BitVec 3)))
                                                  then sailThrow ((Error_See "AUTIB1716"))
                                                  else (EndOfInstruction ())))))
                                  else
                                    (do
                                      bif (b__0 == (0b0010000 : (BitVec 7)))
                                      then
                                        (do
                                          bif (! (← (HaveRASExt ())))
                                          then (EndOfInstruction ())
                                          else (pure ())
                                          let op : SystemHintOp := SystemHintOp_ESB
                                          (pure ()))
                                      else
                                        (do
                                          bif (b__0 == (0b0010001 : (BitVec 7)))
                                          then
                                            (do
                                              bif (! (← (HaveStatisticalProfiling ())))
                                              then (EndOfInstruction ())
                                              else (pure ())
                                              let op : SystemHintOp := SystemHintOp_PSB
                                              (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b0010010 : (BitVec 7)))
                                              then
                                                (do
                                                  bif (! (← (HaveSelfHostedTrace ())))
                                                  then (EndOfInstruction ())
                                                  else (pure ())
                                                  let op : SystemHintOp := SystemHintOp_TSB
                                                  (pure ()))
                                              else
                                                (do
                                                  bif (b__0 == (0b0010011 : (BitVec 7)))
                                                  then
                                                    (do
                                                      bif (! (← (IsFeatureImplemented FEAT_GCS)))
                                                      then (EndOfInstruction ())
                                                      else (pure ())
                                                      let op : SystemHintOp := SystemHintOp_GCSB
                                                      (pure ()))
                                                  else
                                                    (do
                                                      bif (b__0 == (0b0010100 : (BitVec 7)))
                                                      then
                                                        (let op : SystemHintOp := SystemHintOp_CSDB
                                                        (pure ()))
                                                      else
                                                        (do
                                                          bif (b__0 == (0b0010110 : (BitVec 7)))
                                                          then
                                                            (do
                                                              bif (! (← (HaveFeatCLRBHB ())))
                                                              then (EndOfInstruction ())
                                                              else (pure ())
                                                              let op : SystemHintOp :=
                                                                SystemHintOp_CLRBHB
                                                              (pure ()))
                                                          else
                                                            (do
                                                              bif ((Sail.BitVec.extractLsb b__0 6 3) == (0x3 : (BitVec 4)))
                                                              then
                                                                (do
                                                                  let b__20 := op2
                                                                  bif (b__20 == (0b000 : (BitVec 3)))
                                                                  then
                                                                    sailThrow ((Error_See "PACIAZ"))
                                                                  else
                                                                    (do
                                                                      bif (b__20 == (0b001 : (BitVec 3)))
                                                                      then
                                                                        sailThrow ((Error_See
                                                                          "PACIASP"))
                                                                      else
                                                                        (do
                                                                          bif (b__20 == (0b010 : (BitVec 3)))
                                                                          then
                                                                            sailThrow ((Error_See
                                                                              "PACIBZ"))
                                                                          else
                                                                            (do
                                                                              bif (b__20 == (0b011 : (BitVec 3)))
                                                                              then
                                                                                sailThrow ((Error_See
                                                                                  "PACIBSP"))
                                                                              else
                                                                                (do
                                                                                  bif (b__20 == (0b100 : (BitVec 3)))
                                                                                  then
                                                                                    sailThrow ((Error_See
                                                                                      "AUTIAZ"))
                                                                                  else
                                                                                    (do
                                                                                      bif (b__20 == (0b101 : (BitVec 3)))
                                                                                      then
                                                                                        sailThrow ((Error_See
                                                                                          "AUTIASP"))
                                                                                      else
                                                                                        (do
                                                                                          bif (b__20 == (0b110 : (BitVec 3)))
                                                                                          then
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBZ"))
                                                                                          else
                                                                                            sailThrow ((Error_See
                                                                                              "AUTIBSP")))))))))
                                                              else
                                                                (do
                                                                  bif (((Sail.BitVec.extractLsb b__0
                                                                           6 3) == (0x4 : (BitVec 4))) && ((Sail.BitVec.extractLsb
                                                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                                                  then
                                                                    (do
                                                                      let op : SystemHintOp :=
                                                                        SystemHintOp_BTI
                                                                      (SetBTypeCompatible
                                                                        (← (BTypeCompatible_BTI
                                                                            (Sail.BitVec.extractLsb
                                                                              op2 2 1)))))
                                                                  else
                                                                    (do
                                                                      bif (b__0 == (0b0101000 : (BitVec 7)))
                                                                      then
                                                                        (do
                                                                          bif (! (← (IsFeatureImplemented
                                                                                   FEAT_CHK)))
                                                                          then (EndOfInstruction ())
                                                                          else (pure ())
                                                                          let op : SystemHintOp :=
                                                                            SystemHintOp_CHKFEAT
                                                                          (pure ()))
                                                                      else (EndOfInstruction ()))))))))))))))))))
  (execute_aarch64_instrs_system_hints op)

/-- Type quantifiers: k_acquire : Bool, datasize : Nat, n : Nat, regsize : Nat, k_release : Bool, s
  : Nat, t : Nat, k_tagchecked : Bool, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ s ∧
  s ≤ 31 ∧ regsize ∈ {32, 64} ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_atomicops_cas_single (acquire : Bool) (datasize : Nat) (n : Nat) (regsize : Nat) (release : Bool) (s : Nat) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescAtomicOp MemAtomicOp_CAS acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let comparevalue ← (( do (X_read s datasize) ) : SailM (BitVec datasize) )
  let newvalue ← (( do (X_read t datasize) ) : SailM (BitVec datasize) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let data ← (( do (MemAtomic address comparevalue newvalue accdesc) ) : SailM (BitVec datasize) )
  assert (regsize ≥b datasize) "src/instrs64.sail:6398.44-6398.45"
  (X_set s regsize (Sail.BitVec.zeroExtend data regsize))
  bif (← readReg SPESampleInFlight)
  then
    (do
      let ar : (BitVec 1) :=
        bif (acquire || release)
        then (0b1 : (BitVec 1))
        else (0b0 : (BitVec 1))
      let excl : (BitVec 1) := (0b0 : (BitVec 1))
      let at' : (BitVec 1) := (0b1 : (BitVec 1))
      let is_load : Bool := true
      (SPESampleExtendedLoadStore ar excl at' is_load))
  else (pure ())

def decode_cas_aarch64_instrs_memory_atomicops_cas_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := (L == (0b1 : (BitVec 1)))
  let release : Bool := (o0 == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_cas_single acquire datasize n regsize release s t
    tagchecked)

def decode_casb_aarch64_instrs_memory_atomicops_cas_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := (L == (0b1 : (BitVec 1)))
  let release : Bool := (o0 == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_cas_single acquire datasize n regsize release s t
    tagchecked)

def decode_cash_aarch64_instrs_memory_atomicops_cas_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := (L == (0b1 : (BitVec 1)))
  let release : Bool := (o0 == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_cas_single acquire datasize n regsize release s t
    tagchecked)

/-- Type quantifiers: k_acquire : Bool, datasize : Nat, n : Nat, k_release : Bool, s : Nat, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {32, 64} -/
def execute_aarch64_instrs_memory_atomicops_cas_pair (acquire : Bool) (datasize : Nat) (n : Nat) (release : Bool) (s : Nat) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let s1 ← (( do (X_read s datasize) ) : SailM (BitVec datasize) )
  let s2 ← (( do (X_read (s +i 1) datasize) ) : SailM (BitVec datasize) )
  let t1 ← (( do (X_read t datasize) ) : SailM (BitVec datasize) )
  let t2 ← (( do (X_read (t +i 1) datasize) ) : SailM (BitVec datasize) )
  let accdesc ← (( do (CreateAccDescAtomicOp MemAtomicOp_CAS acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let comparevalue ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (s1 ++ s2))
    else (pure (s2 ++ s1)) ) : SailM (BitVec (2 * datasize)) )
  let newvalue ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (t1 ++ t2))
    else (pure (t2 ++ t1)) ) : SailM (BitVec (2 * datasize)) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let data ← (( do (MemAtomic address comparevalue newvalue accdesc) ) : SailM
    (BitVec (2 * datasize)) )
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set s datasize (Sail.BitVec.extractLsb data ((2 *i datasize) -i 1) datasize))
      (X_set (s +i 1) datasize (Sail.BitVec.extractLsb data (datasize -i 1) 0)))
  else
    (do
      (X_set s datasize (Sail.BitVec.extractLsb data (datasize -i 1) 0))
      (X_set (s +i 1) datasize (Sail.BitVec.extractLsb data ((2 *i datasize) -i 1) datasize)))
  bif (← readReg SPESampleInFlight)
  then
    (do
      let ar : (BitVec 1) :=
        bif (acquire || release)
        then (0b1 : (BitVec 1))
        else (0b0 : (BitVec 1))
      let excl : (BitVec 1) := (0b0 : (BitVec 1))
      let at' : (BitVec 1) := (0b1 : (BitVec 1))
      let is_load : Bool := true
      (SPESampleExtendedLoadStore ar excl at' is_load))
  else (pure ())

def decode_casp_aarch64_instrs_memory_atomicops_cas_pair (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (sz : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access Rs 0)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access Rt 0)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 32 (BitVec.toNat sz))
  let regsize := datasize
  let acquire : Bool := (L == (0b1 : (BitVec 1)))
  let release : Bool := (o0 == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_cas_pair acquire datasize n release s t tagchecked)

/-- Type quantifiers: datasize : Nat, k_iszero : Bool, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ datasize ∈ {32, 64} -/
def execute_aarch64_instrs_branch_conditional_compare (datasize : Nat) (iszero : Bool) (offset : (BitVec 64)) (t : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read t datasize) ) : SailM (BitVec datasize) )
  let branch_conditional : Bool := true
  bif ((IsZero operand1) == iszero)
  then (BranchTo ((← (PC_read ())) + offset) BranchType_DIR branch_conditional)
  else (BranchNotTaken BranchType_DIR branch_conditional)

def decode_cbnz_aarch64_instrs_branch_conditional_compare (Rt : (BitVec 5)) (imm19 : (BitVec 19)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let iszero : Bool := (op == (0b0 : (BitVec 1)))
  let offset : (BitVec 64) := (sign_extend (imm19 ++ (0b00 : (BitVec 2))) 64)
  (execute_aarch64_instrs_branch_conditional_compare datasize iszero offset t)

def decode_cbz_aarch64_instrs_branch_conditional_compare (Rt : (BitVec 5)) (imm19 : (BitVec 19)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let iszero : Bool := (op == (0b0 : (BitVec 1)))
  let offset : (BitVec 64) := (sign_extend (imm19 ++ (0b00 : (BitVec 2))) 64)
  (execute_aarch64_instrs_branch_conditional_compare datasize iszero offset t)

/-- Type quantifiers: datasize : Nat, m : Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} -/
def execute_aarch64_instrs_integer_conditional_compare_register (condition : (BitVec 4)) (datasize : Nat) (flags__arg : (BitVec 4)) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  let flags : (BitVec 4) := flags__arg
  let taken : Bool := false
  let (flags, taken) ← (( do
    bif (← (ConditionHolds condition))
    then
      (do
        let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
        let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
        let carry_in : (BitVec 1) := (0b0 : (BitVec 1))
        let (carry_in, operand2) : ((BitVec 1) × (BitVec datasize)) :=
          bif sub_op
          then
            (let operand2 : (BitVec datasize) := (Complement.complement operand2)
            let carry_in : (BitVec 1) := (0b1 : (BitVec 1))
            (carry_in, operand2))
          else (carry_in, operand2)
        let _ : Unit :=
          let (_, __tup_1) := (AddWithCarry operand1 operand2 carry_in)
          let flags : (BitVec 4) := __tup_1
          ()
        let taken : Bool := true
        (pure (flags, taken)))
    else (pure (flags, taken)) ) : SailM ((BitVec 4) × Bool) )
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb flags 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb flags 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb flags 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb flags 0 0) }
  bif (← readReg SPESampleInFlight)
  then
    (do
      let conditional : Bool := true
      (SPESampleAddOpOther conditional taken))
  else (pure ())

def decode_ccmn_reg_aarch64_instrs_integer_conditional_compare_register (nzcv : (BitVec 4)) (Rn : (BitVec 5)) (cond : (BitVec 4)) (Rm : (BitVec 5)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let condition : (BitVec 4) := cond
  let flags : (BitVec 4) := nzcv
  (execute_aarch64_instrs_integer_conditional_compare_register condition datasize flags m n sub_op)

def decode_ccmp_reg_aarch64_instrs_integer_conditional_compare_register (nzcv : (BitVec 4)) (Rn : (BitVec 5)) (cond : (BitVec 4)) (Rm : (BitVec 5)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let condition : (BitVec 4) := cond
  let flags : (BitVec 4) := nzcv
  (execute_aarch64_instrs_integer_conditional_compare_register condition datasize flags m n sub_op)

/-- Type quantifiers: datasize : Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {32, 64} -/
def execute_aarch64_instrs_integer_conditional_compare_immediate (condition : (BitVec 4)) (datasize : Nat) (flags__arg : (BitVec 4)) (imm : (BitVec datasize)) (n : Nat) (sub_op : Bool) : SailM Unit := do
  let flags : (BitVec 4) := flags__arg
  let taken : Bool := false
  let (flags, taken) ← (( do
    bif (← (ConditionHolds condition))
    then
      (do
        let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
        let operand2 : (BitVec datasize) := imm
        let carry_in : (BitVec 1) := (0b0 : (BitVec 1))
        let (carry_in, operand2) : ((BitVec 1) × (BitVec datasize)) :=
          bif sub_op
          then
            (let operand2 : (BitVec datasize) := (Complement.complement operand2)
            let carry_in : (BitVec 1) := (0b1 : (BitVec 1))
            (carry_in, operand2))
          else (carry_in, operand2)
        let _ : Unit :=
          let (_, __tup_1) := (AddWithCarry operand1 operand2 carry_in)
          let flags : (BitVec 4) := __tup_1
          ()
        let taken : Bool := true
        (pure (flags, taken)))
    else (pure (flags, taken)) ) : SailM ((BitVec 4) × Bool) )
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb flags 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb flags 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb flags 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb flags 0 0) }
  bif (← readReg SPESampleInFlight)
  then
    (do
      let conditional : Bool := true
      (SPESampleAddOpOther conditional taken))
  else (pure ())

def decode_ccmn_imm_aarch64_instrs_integer_conditional_compare_immediate (nzcv : (BitVec 4)) (Rn : (BitVec 5)) (cond : (BitVec 4)) (imm5 : (BitVec 5)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let condition : (BitVec 4) := cond
  let flags : (BitVec 4) := nzcv
  let imm : (BitVec datasize) := (Sail.BitVec.zeroExtend imm5 datasize)
  (execute_aarch64_instrs_integer_conditional_compare_immediate condition datasize flags imm n
    sub_op)

def decode_ccmp_imm_aarch64_instrs_integer_conditional_compare_immediate (nzcv : (BitVec 4)) (Rn : (BitVec 5)) (cond : (BitVec 4)) (imm5 : (BitVec 5)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  let condition : (BitVec 4) := cond
  let flags : (BitVec 4) := nzcv
  let imm : (BitVec datasize) := (Sail.BitVec.zeroExtend imm5 datasize)
  (execute_aarch64_instrs_integer_conditional_compare_immediate condition datasize flags imm n
    sub_op)

def execute_aarch64_instrs_integer_flags_cfinv (_ : Unit) : SailM Unit := do
  writeReg PSTATE { (← readReg PSTATE) with C := (Complement.complement (← readReg PSTATE).C) }

def decode_cfinv_aarch64_instrs_integer_flags_cfinv (CRm : (BitVec 4)) : SailM Unit := do
  bif (! (← (HaveFlagManipulateExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_integer_flags_cfinv ())

def execute_aarch64_instrs_system_monitors (_ : Unit) : Unit :=
  (ClearExclusiveLocal (ProcessorID ()))

def decode_clrex_aarch64_instrs_system_monitors (CRm : (BitVec 4)) : Unit :=
  (execute_aarch64_instrs_system_monitors ())

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_clsz (countop : CountOp) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let count ← (( do (undefined_int ()) ) : SailM Int )
  let (count, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (count, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (count, result) := loop_vars
      loop_vars ← do
        let count ← (( do
          bif (BEq.beq countop CountOp_CLS)
          then
            (do
              (pure (CountLeadingSignBits (← (Elem_read operand e esize)))))
          else
            (do
              (pure (CountLeadingZeroBits (← (Elem_read operand e esize))))) ) : SailM Int )
        let result ← (Elem_set result e esize (integer_subrange count (esize -i 1) 0))
        (pure (count, result))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize)) )
  (V_set d datasize result)

def decode_cls_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let countop : CountOp :=
    bif (U == (0b1 : (BitVec 1)))
    then CountOp_CLZ
    else CountOp_CLS
  (execute_aarch64_instrs_vector_arithmetic_unary_clsz countop d datasize elements esize n)

def decode_clz_advsimd_aarch64_instrs_vector_arithmetic_unary_clsz (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let countop : CountOp :=
    bif (U == (0b1 : (BitVec 1)))
    then CountOp_CLZ
    else CountOp_CLS
  (execute_aarch64_instrs_vector_arithmetic_unary_clsz countop d datasize elements esize n)

/-- Type quantifiers: d : Nat, datasize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_cnt (d : Nat) (datasize : Nat) (n : Nat) (opcode : CountOp) : SailM Unit := do
  let result ← (( do (undefined_int ()) ) : SailM Int )
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let result : Int :=
    bif (BEq.beq opcode CountOp_CLZ)
    then (CountLeadingZeroBits operand1)
    else (CountLeadingSignBits operand1)
  let result := result
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_cls_int_aarch64_instrs_integer_arithmetic_cnt (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let opcode : CountOp :=
    bif (op == (0b0 : (BitVec 1)))
    then CountOp_CLZ
    else CountOp_CLS
  (execute_aarch64_instrs_integer_arithmetic_cnt d datasize n opcode)

def decode_clz_int_aarch64_instrs_integer_arithmetic_cnt (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let opcode : CountOp :=
    bif (op == (0b0 : (BitVec 1)))
    then CountOp_CLZ
    else CountOp_CLS
  (execute_aarch64_instrs_integer_arithmetic_cnt d datasize n opcode)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (comparison : CompareOp) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element, result, test_passed) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, test_passed)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, test_passed) := loop_vars
      loop_vars ← do
        let element ← (pure (BitVec.toInt (← (Elem_read operand e esize))))
        let test_passed : Bool :=
          match comparison with
          | CompareOp_GT => (element >b 0)
          | CompareOp_GE => (element ≥b 0)
          | CompareOp_EQ => (element == 0)
          | CompareOp_LE => (element ≤b 0)
          | CompareOp_LT => (element <b 0)
        let result ←
          (Elem_set result e esize
            (bif test_passed
            then (Ones (n := esize))
            else (Zeros (n := esize))))
        (pure (element, result, test_passed))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd comparison d datasize elements
    esize n)

def decode_cmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd comparison d datasize elements
    esize n)

def decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd comparison d datasize elements
    esize n)

def decode_cmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd comparison d datasize elements
    esize n)

def decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd comparison d datasize elements
    esize n)

def decode_cmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd comparison d datasize elements
    esize n)

def decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd comparison d datasize elements
    esize n)

def decode_cmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_bulk_sisd comparison d datasize elements
    esize n)

/-- Type quantifiers: k_and_test : Bool, d : Nat, datasize : Nat, elements : Int, esize : Nat, m :
  Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd (and_test : Bool) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element1, element2, result, test_passed) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result, test_passed)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result, test_passed) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let test_passed : Bool :=
          bif and_test
          then (! (IsZero (element1 &&& element2)))
          else (element1 == element2)
        let result ←
          (Elem_set result e esize
            (bif test_passed
            then (Ones (n := esize))
            else (Zeros (n := esize))))
        (pure (element1, element2, result, test_passed))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let and_test : Bool := (U == (0b0 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd and_test d datasize
    elements esize m n)

def decode_cmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let and_test : Bool := (U == (0b0 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd and_test d datasize
    elements esize m n)

def decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let and_test : Bool := (U == (0b0 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd and_test d datasize
    elements esize m n)

def decode_cmtst_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let and_test : Bool := (U == (0b0 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_bitwise_sisd and_test d datasize
    elements esize m n)

/-- Type quantifiers: k_cmp_eq : Bool, d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned
  : Bool, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (cmp_eq : Bool) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element1, element2, result, test_passed) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result, test_passed)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result, test_passed) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let test_passed : Bool :=
          bif cmp_eq
          then (element1 ≥b element2)
          else (element1 >b element2)
        let result ←
          (Elem_set result e esize
            (bif test_passed
            then (Ones (n := esize))
            else (Zeros (n := esize))))
        (pure (element1, element2, result, test_passed))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let cmp_eq : Bool := (eq == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd cmp_eq d datasize elements
    esize m n is_unsigned)

def decode_cmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let cmp_eq : Bool := (eq == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd cmp_eq d datasize elements
    esize m n is_unsigned)

def decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let cmp_eq : Bool := (eq == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd cmp_eq d datasize elements
    esize m n is_unsigned)

def decode_cmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let cmp_eq : Bool := (eq == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd cmp_eq d datasize elements
    esize m n is_unsigned)

def decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let cmp_eq : Bool := (eq == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd cmp_eq d datasize elements
    esize m n is_unsigned)

def decode_cmhi_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let cmp_eq : Bool := (eq == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd cmp_eq d datasize elements
    esize m n is_unsigned)

def decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let cmp_eq : Bool := (eq == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd cmp_eq d datasize elements
    esize m n is_unsigned)

def decode_cmhs_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let cmp_eq : Bool := (eq == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_int_sisd cmp_eq d datasize elements
    esize m n is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd (comparison : CompareOp) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element, result, test_passed) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, test_passed)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, test_passed) := loop_vars
      loop_vars ← do
        let element ← (pure (BitVec.toInt (← (Elem_read operand e esize))))
        let test_passed : Bool :=
          match comparison with
          | CompareOp_GT => (element >b 0)
          | CompareOp_GE => (element ≥b 0)
          | CompareOp_EQ => (element == 0)
          | CompareOp_LE => (element ≤b 0)
          | CompareOp_LT => (element <b 0)
        let result ←
          (Elem_set result e esize
            (bif test_passed
            then (Ones (n := esize))
            else (Zeros (n := esize))))
        (pure (element, result, test_passed))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size != (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let comparison : CompareOp := CompareOp_LT
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd comparison d datasize
    elements esize n)

def decode_cmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison : CompareOp := CompareOp_LT
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_int_lessthan_sisd comparison d datasize
    elements esize n)

/-- Type quantifiers: d : Nat, datasize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_unary_cnt (d : Nat) (datasize : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let result := (BitCount operand1)
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_cnt_aarch64_instrs_integer_arithmetic_unary_cnt (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_integer_arithmetic_unary_cnt d datasize n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize = 8 ∧ elements ∈ {8, 16} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_cnt (d : Nat) (datasize : Nat) (elements : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let count ← (( do (undefined_int ()) ) : SailM Int )
  let (count, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (count, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (count, result) := loop_vars
      loop_vars ← do
        let count ← (pure (BitCount (← (Elem_read operand e esize))))
        let result ← (Elem_set result e esize (integer_subrange count (esize -i 1) 0))
        (pure (count, result))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize)) )
  (V_set d datasize result)

def decode_cnt_advsimd_aarch64_instrs_vector_arithmetic_unary_cnt (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize 8)
  (execute_aarch64_instrs_vector_arithmetic_unary_cnt d datasize elements esize n)

/-- Type quantifiers: d : Nat, n : Nat, s : Nat, 0 ≤ s ∧
  s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_memory_mcpymset_cpy (d : Nat) (n : Nat) (options_name : (BitVec 4)) (s : Nat) (stage : MOPSStage) : SailM Unit := do
  let N ← do (MaxBlockSizeCopiedBytes ())
  let toaddress ← (( do (X_read d 64) ) : SailM (BitVec 64) )
  let fromaddress ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let cpysize ← (( do (X_read n 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do
    (pure ((← readReg PSTATE).N ++ ((← readReg PSTATE).Z ++ ((← readReg PSTATE).C ++ (← readReg PSTATE).V))))
    ) : SailM (BitVec 4) )
  let stagecpysize ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector (8 *i N)) ) : SailM (BitVec (8 * N)) )
  let B ← (( do (undefined_int ()) ) : SailM Int )
  let supports_option_a ← (( do (CPYOptionA ()) ) : SailM Bool )
  let rprivileged ← (( do
    bif ((BitVec.join1 [(BitVec.access options_name 1)]) == (0b1 : (BitVec 1)))
    then (AArch64_IsUnprivAccessPriv ())
    else (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let wprivileged ← (( do
    bif ((BitVec.join1 [(BitVec.access options_name 0)]) == (0b1 : (BitVec 1)))
    then (AArch64_IsUnprivAccessPriv ())
    else (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let rnontemporal : Bool := ((BitVec.join1 [(BitVec.access options_name 3)]) == (0b1 : (BitVec 1)))
  let wnontemporal : Bool := ((BitVec.join1 [(BitVec.access options_name 2)]) == (0b1 : (BitVec 1)))
  let raccdesc ← (( do (CreateAccDescMOPS MemOp_LOAD rprivileged rnontemporal) ) : SailM
    AccessDescriptor )
  let waccdesc ← (( do (CreateAccDescMOPS MemOp_STORE wprivileged wnontemporal) ) : SailM
    AccessDescriptor )
  let (cpysize, fromaddress, nzcv, stagecpysize, toaddress) ← (( do
    bif (BEq.beq stage MOPSStage_Prologue)
    then
      (do
        let cpysize : (BitVec 64) :=
          bif ((Sail.BitVec.extractLsb cpysize 63 55) != (0b000000000 : (BitVec 9)))
          then (0x007FFFFFFFFFFFFF : (BitVec 64))
          else cpysize
        let forward ← (( do (undefined_bool ()) ) : SailM Bool )
        let forward ← (( do
          bif (((BitVec.toNat (Sail.BitVec.extractLsb fromaddress 55 0)) >b (BitVec.toNat
                   (Sail.BitVec.extractLsb toaddress 55 0))) && (((BitVec.toNat
                   (Sail.BitVec.extractLsb fromaddress 55 0)) <b (BitVec.toNat
                   ((Sail.BitVec.extractLsb toaddress 55 0) + (Sail.BitVec.extractLsb cpysize 55 0)))) : Bool))
          then (pure true)
          else
            (do
              bif (((BitVec.toNat (Sail.BitVec.extractLsb fromaddress 55 0)) <b (BitVec.toNat
                       (Sail.BitVec.extractLsb toaddress 55 0))) && (((BitVec.toNat
                       ((Sail.BitVec.extractLsb fromaddress 55 0) + (Sail.BitVec.extractLsb cpysize
                           55 0))) >b (BitVec.toNat (Sail.BitVec.extractLsb toaddress 55 0))) : Bool))
              then (pure false)
              else
                (do
                  (MemCpyDirectionChoice fromaddress toaddress cpysize))) ) : SailM Bool )
        let (cpysize, fromaddress, nzcv, toaddress) : ((BitVec 64) × (BitVec 64) × (BitVec 4) × (BitVec 64)) :=
          bif supports_option_a
          then
            (let nzcv : (BitVec 4) := (0x0 : (BitVec 4))
            let (cpysize, fromaddress, toaddress) : ((BitVec 64) × (BitVec 64) × (BitVec 64)) :=
              bif forward
              then
                (let toaddress : (BitVec 64) := (toaddress + cpysize)
                let fromaddress : (BitVec 64) := (fromaddress + cpysize)
                let cpysize : (BitVec 64) := ((Zeros (n := 64)) - cpysize)
                (cpysize, fromaddress, toaddress))
              else (cpysize, fromaddress, toaddress)
            (cpysize, fromaddress, nzcv, toaddress))
          else
            (let (fromaddress, nzcv, toaddress) : ((BitVec 64) × (BitVec 4) × (BitVec 64)) :=
              bif (! forward)
              then
                (let toaddress : (BitVec 64) := (toaddress + cpysize)
                let fromaddress : (BitVec 64) := (fromaddress + cpysize)
                let nzcv : (BitVec 4) := (0xA : (BitVec 4))
                (fromaddress, nzcv, toaddress))
              else
                (let nzcv : (BitVec 4) := (0x2 : (BitVec 4))
                (fromaddress, nzcv, toaddress))
            (cpysize, fromaddress, nzcv, toaddress))
        let stagecpysize ← (CPYPreSizeChoice toaddress fromaddress cpysize)
        assert (((BitVec.join1 [(BitVec.access stagecpysize 63)]) == (BitVec.join1 [(BitVec.access
                cpysize 63)])) || (stagecpysize == (Zeros (n := 64)))) "src/instrs64.sail:7892.78-7892.79"
        bif ((BitVec.toInt cpysize) >b 0)
        then
          assert ((BitVec.toInt stagecpysize) ≤b (BitVec.toInt cpysize)) "src/instrs64.sail:7894.54-7894.55"
        else
          assert ((BitVec.toInt stagecpysize) ≥b (BitVec.toInt cpysize)) "src/instrs64.sail:7896.54-7896.55"
        (pure (cpysize, fromaddress, nzcv, stagecpysize, toaddress)))
    else
      (do
        let zero_size_exceptions ← (( do (MemCpyZeroSizeCheck ()) ) : SailM Bool )
        bif (zero_size_exceptions || (((BitVec.toInt cpysize) != 0) : Bool))
        then
          (do
            bif supports_option_a
            then
              (do
                bif ((BitVec.join1 [(BitVec.access nzcv 1)]) == (0b1 : (BitVec 1)))
                then
                  (do
                    let wrong_option : Bool := true
                    let from_epilogue : Bool := (BEq.beq stage MOPSStage_Epilogue)
                    (MismatchedMemCpyException supports_option_a d s n wrong_option from_epilogue
                      options_name))
                else (pure ()))
            else
              (do
                bif ((BitVec.join1 [(BitVec.access nzcv 1)]) == (0b0 : (BitVec 1)))
                then
                  (do
                    let wrong_option : Bool := true
                    let from_epilogue : Bool := (BEq.beq stage MOPSStage_Epilogue)
                    (MismatchedMemCpyException supports_option_a d s n wrong_option from_epilogue
                      options_name))
                else (pure ())))
        else (pure ())
        let postsize ← (( do (CPYPostSizeChoice toaddress fromaddress cpysize) ) : SailM
          (BitVec 64) )
        assert (((BitVec.join1 [(BitVec.access postsize 63)]) == (BitVec.join1 [(BitVec.access
                cpysize 63)])) || (((BitVec.toInt postsize) == 0) : Bool)) "src/instrs64.sail:7918.68-7918.69"
        let stagecpysize ← (( do
          bif (BEq.beq stage MOPSStage_Main)
          then
            (do
              let stagecpysize : (BitVec 64) := (cpysize - postsize)
              bif (← (MemCpyParametersIllformedM toaddress fromaddress cpysize))
              then
                (do
                  let wrong_option : Bool := false
                  let from_epilogue : Bool := false
                  (MismatchedMemCpyException supports_option_a d s n wrong_option from_epilogue
                    options_name))
              else (pure ())
              (pure stagecpysize))
          else
            (do
              let stagecpysize : (BitVec 64) := postsize
              bif ((cpysize != postsize) || (← (MemCpyParametersIllformedE toaddress fromaddress
                       cpysize)))
              then
                (do
                  let wrong_option : Bool := false
                  let from_epilogue : Bool := true
                  (MismatchedMemCpyException supports_option_a d s n wrong_option from_epilogue
                    options_name))
              else (pure ())
              (pure stagecpysize)) ) : SailM (BitVec 64) )
        (pure (cpysize, fromaddress, nzcv, stagecpysize, toaddress))) ) : SailM
    ((BitVec 64) × (BitVec 64) × (BitVec 4) × (BitVec 64) × (BitVec 64)) )
  bif (← readReg SPESampleInFlight)
  then (SPESampleMemCopy ())
  else (pure ())
  let (cpysize, fromaddress, toaddress) ← (( do
    bif supports_option_a
    then
      (do
        let (B, cpysize, readdata, stagecpysize) ← (( do
          let mut loop_vars_1 := (B, cpysize, readdata, stagecpysize)
          while (λ (B, cpysize, readdata, stagecpysize) => ((BitVec.toInt stagecpysize) != 0))
            loop_vars_1
            do
            let (B, cpysize, readdata, stagecpysize) := loop_vars_1
            loop_vars_1 ← do
              let B ← (CPYSizeChoice toaddress fromaddress cpysize)
              let B := B
              bif ((BitVec.toInt cpysize) <b 0)
              then
                (do
                  assert (B ≤b ((Neg.neg 1) *i (BitVec.toInt stagecpysize))) "src/instrs64.sail:7946.64-7946.65"
                  assert ((0 ≤b ((B *i 8) -i 1)) && (((B *i 8) -i 1) <b (8 *i N))) "src/instrs64.sail:7947.80-7947.81"
                  let readdata ←
                    (pure (Sail.BitVec.updateSubrange readdata ((B *i 8) -i 1) 0
                        (← (Mem_read (fromaddress + cpysize) B raccdesc))))
                  (Mem_set (toaddress + cpysize) B waccdesc
                    (Sail.BitVec.extractLsb readdata ((B *i 8) -i 1) 0))
                  let cpysize : (BitVec 64) := (BitVec.addInt cpysize B)
                  let stagecpysize : (BitVec 64) := (BitVec.addInt stagecpysize B)
                  (pure ()))
              else
                (do
                  assert (B ≤b (BitVec.toInt stagecpysize)) "src/instrs64.sail:7953.52-7953.53"
                  let cpysize : (BitVec 64) := (BitVec.subInt cpysize B)
                  let stagecpysize : (BitVec 64) := (BitVec.subInt stagecpysize B)
                  assert ((0 ≤b ((B *i 8) -i 1)) && (((B *i 8) -i 1) <b (8 *i N))) "src/instrs64.sail:7956.80-7956.81"
                  let readdata ←
                    (pure (Sail.BitVec.updateSubrange readdata ((B *i 8) -i 1) 0
                        (← (Mem_read (fromaddress + cpysize) B raccdesc))))
                  (Mem_set (toaddress + cpysize) B waccdesc
                    (Sail.BitVec.extractLsb readdata ((B *i 8) -i 1) 0)))
              bif (bne stage MOPSStage_Prologue)
              then (X_set n 64 cpysize)
              else (pure ())
              (pure (B, cpysize, readdata, stagecpysize))
          (pure loop_vars_1) ) : SailM (Int × (BitVec 64) × (BitVec (8 * N)) × (BitVec 64)) )
        (pure (cpysize, fromaddress, toaddress)))
    else
      (do
        let (B, cpysize, fromaddress, readdata, stagecpysize, toaddress) ← (( do
          let mut loop_vars := (B, cpysize, fromaddress, readdata, stagecpysize, toaddress)
          while (λ (B, cpysize, fromaddress, readdata, stagecpysize, toaddress) =>
            ((BitVec.toNat stagecpysize) >b 0))
            loop_vars
            do
            let (B, cpysize, fromaddress, readdata, stagecpysize, toaddress) := loop_vars
            loop_vars ← do
              let B ← (CPYSizeChoice toaddress fromaddress cpysize)
              assert (B ≤b (BitVec.toNat stagecpysize)) "src/instrs64.sail:7969.42-7969.43"
              let B := B
              bif ((BitVec.join1 [(BitVec.access nzcv 3)]) == (0b0 : (BitVec 1)))
              then
                (do
                  assert ((0 ≤b ((B *i 8) -i 1)) && (((B *i 8) -i 1) <b (8 *i N))) "src/instrs64.sail:7973.80-7973.81"
                  let readdata ←
                    (pure (Sail.BitVec.updateSubrange readdata ((B *i 8) -i 1) 0
                        (← (Mem_read fromaddress B raccdesc))))
                  (Mem_set toaddress B waccdesc (Sail.BitVec.extractLsb readdata ((B *i 8) -i 1) 0))
                  let fromaddress : (BitVec 64) := (BitVec.addInt fromaddress B)
                  let toaddress : (BitVec 64) := (BitVec.addInt toaddress B)
                  (pure ()))
              else
                (do
                  assert ((0 ≤b ((B *i 8) -i 1)) && (((B *i 8) -i 1) <b (8 *i N))) "src/instrs64.sail:7979.80-7979.81"
                  let readdata ←
                    (pure (Sail.BitVec.updateSubrange readdata ((B *i 8) -i 1) 0
                        (← (Mem_read (BitVec.subInt fromaddress B) B raccdesc))))
                  (Mem_set (BitVec.subInt toaddress B) B waccdesc
                    (Sail.BitVec.extractLsb readdata ((B *i 8) -i 1) 0))
                  let fromaddress : (BitVec 64) := (BitVec.subInt fromaddress B)
                  let toaddress : (BitVec 64) := (BitVec.subInt toaddress B)
                  (pure ()))
              let cpysize : (BitVec 64) := (BitVec.subInt cpysize B)
              let stagecpysize : (BitVec 64) := (BitVec.subInt stagecpysize B)
              bif (bne stage MOPSStage_Prologue)
              then
                (do
                  (X_set n 64 cpysize)
                  (X_set d 64 toaddress)
                  (X_set s 64 fromaddress))
              else (pure ())
              (pure (B, cpysize, fromaddress, readdata, stagecpysize, toaddress))
          (pure loop_vars) ) : SailM
          (Int × (BitVec 64) × (BitVec 64) × (BitVec (8 * N)) × (BitVec 64) × (BitVec 64)) )
        (pure (cpysize, fromaddress, toaddress))) ) : SailM
    ((BitVec 64) × (BitVec 64) × (BitVec 64)) )
  bif (BEq.beq stage MOPSStage_Prologue)
  then
    (do
      (X_set n 64 cpysize)
      (X_set d 64 toaddress)
      (X_set s 64 fromaddress)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_cpyp_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8037.58-8037.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpypn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8094.58-8094.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpyprn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8151.58-8151.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpyprt_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8208.58-8208.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpyprtn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8265.58-8265.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpyprtrn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8322.58-8322.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpyprtwn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8379.58-8379.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpypt_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8436.58-8436.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpyptn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8493.58-8493.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpyptrn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8550.58-8550.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpyptwn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8607.58-8607.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpypwn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8664.58-8664.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpypwt_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8721.58-8721.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpypwtn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8778.58-8778.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpypwtrn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8835.58-8835.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

def decode_cpypwtwn_aarch64_instrs_memory_mcpymset_cpy (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:8892.58-8892.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpy d n options_name s stage)

/-- Type quantifiers: d : Nat, n : Nat, s : Nat, 0 ≤ s ∧
  s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_memory_mcpymset_cpyf (d : Nat) (n : Nat) (options_name : (BitVec 4)) (s : Nat) (stage : MOPSStage) : SailM Unit := do
  let N ← do (MaxBlockSizeCopiedBytes ())
  let toaddress ← (( do (X_read d 64) ) : SailM (BitVec 64) )
  let fromaddress ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let cpysize ← (( do (X_read n 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do
    (pure ((← readReg PSTATE).N ++ ((← readReg PSTATE).Z ++ ((← readReg PSTATE).C ++ (← readReg PSTATE).V))))
    ) : SailM (BitVec 4) )
  let stagecpysize ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector (8 *i N)) ) : SailM (BitVec (8 * N)) )
  let B ← (( do (undefined_int ()) ) : SailM Int )
  let supports_option_a ← (( do (CPYFOptionA ()) ) : SailM Bool )
  let rprivileged ← (( do
    bif ((BitVec.join1 [(BitVec.access options_name 1)]) == (0b1 : (BitVec 1)))
    then (AArch64_IsUnprivAccessPriv ())
    else (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let wprivileged ← (( do
    bif ((BitVec.join1 [(BitVec.access options_name 0)]) == (0b1 : (BitVec 1)))
    then (AArch64_IsUnprivAccessPriv ())
    else (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let rnontemporal : Bool := ((BitVec.join1 [(BitVec.access options_name 3)]) == (0b1 : (BitVec 1)))
  let wnontemporal : Bool := ((BitVec.join1 [(BitVec.access options_name 2)]) == (0b1 : (BitVec 1)))
  let raccdesc ← (( do (CreateAccDescMOPS MemOp_LOAD rprivileged rnontemporal) ) : SailM
    AccessDescriptor )
  let waccdesc ← (( do (CreateAccDescMOPS MemOp_STORE wprivileged wnontemporal) ) : SailM
    AccessDescriptor )
  let (cpysize, fromaddress, nzcv, stagecpysize, toaddress) ← (( do
    bif (BEq.beq stage MOPSStage_Prologue)
    then
      (do
        let cpysize : (BitVec 64) :=
          bif ((BitVec.join1 [(BitVec.access cpysize 63)]) == (0b1 : (BitVec 1)))
          then (0x7FFFFFFFFFFFFFFF : (BitVec 64))
          else cpysize
        let (cpysize, fromaddress, nzcv, toaddress) : ((BitVec 64) × (BitVec 64) × (BitVec 4) × (BitVec 64)) :=
          bif supports_option_a
          then
            (let nzcv : (BitVec 4) := (0x0 : (BitVec 4))
            let toaddress : (BitVec 64) := (toaddress + cpysize)
            let fromaddress : (BitVec 64) := (fromaddress + cpysize)
            let cpysize : (BitVec 64) := ((Zeros (n := 64)) - cpysize)
            (cpysize, fromaddress, nzcv, toaddress))
          else
            (let nzcv : (BitVec 4) := (0x2 : (BitVec 4))
            (cpysize, fromaddress, nzcv, toaddress))
        let stagecpysize ← (CPYPreSizeChoice toaddress fromaddress cpysize)
        assert (((BitVec.join1 [(BitVec.access stagecpysize 63)]) == (BitVec.join1 [(BitVec.access
                cpysize 63)])) || (stagecpysize == (Zeros (n := 64)))) "src/instrs64.sail:8956.78-8956.79"
        bif ((BitVec.toInt cpysize) >b 0)
        then
          assert ((BitVec.toInt stagecpysize) ≤b (BitVec.toInt cpysize)) "src/instrs64.sail:8958.54-8958.55"
        else
          assert ((BitVec.toInt stagecpysize) ≥b (BitVec.toInt cpysize)) "src/instrs64.sail:8960.54-8960.55"
        (pure (cpysize, fromaddress, nzcv, stagecpysize, toaddress)))
    else
      (do
        let zero_size_exceptions ← (( do (MemCpyZeroSizeCheck ()) ) : SailM Bool )
        bif (zero_size_exceptions || (((BitVec.toInt cpysize) != 0) : Bool))
        then
          (do
            bif supports_option_a
            then
              (do
                bif ((BitVec.join1 [(BitVec.access nzcv 1)]) == (0b1 : (BitVec 1)))
                then
                  (do
                    let wrong_option : Bool := true
                    let from_epilogue : Bool := (BEq.beq stage MOPSStage_Epilogue)
                    (MismatchedMemCpyException supports_option_a d s n wrong_option from_epilogue
                      options_name))
                else (pure ()))
            else
              (do
                bif ((BitVec.join1 [(BitVec.access nzcv 1)]) == (0b0 : (BitVec 1)))
                then
                  (do
                    let wrong_option : Bool := true
                    let from_epilogue : Bool := (BEq.beq stage MOPSStage_Epilogue)
                    (MismatchedMemCpyException supports_option_a d s n wrong_option from_epilogue
                      options_name))
                else (pure ())))
        else (pure ())
        let postsize ← (( do (CPYPostSizeChoice toaddress fromaddress cpysize) ) : SailM
          (BitVec 64) )
        assert (((BitVec.join1 [(BitVec.access postsize 63)]) == (BitVec.join1 [(BitVec.access
                cpysize 63)])) || (((BitVec.toInt postsize) == 0) : Bool)) "src/instrs64.sail:8982.68-8982.69"
        let stagecpysize ← (( do
          bif (BEq.beq stage MOPSStage_Main)
          then
            (do
              let stagecpysize : (BitVec 64) := (cpysize - postsize)
              bif (← (MemCpyParametersIllformedM toaddress fromaddress cpysize))
              then
                (do
                  let wrong_option : Bool := false
                  let from_epilogue : Bool := false
                  (MismatchedMemCpyException supports_option_a d s n wrong_option from_epilogue
                    options_name))
              else (pure ())
              (pure stagecpysize))
          else
            (do
              let stagecpysize : (BitVec 64) := postsize
              bif ((cpysize != postsize) || (← (MemCpyParametersIllformedE toaddress fromaddress
                       cpysize)))
              then
                (do
                  let wrong_option : Bool := false
                  let from_epilogue : Bool := true
                  (MismatchedMemCpyException supports_option_a d s n wrong_option from_epilogue
                    options_name))
              else (pure ())
              (pure stagecpysize)) ) : SailM (BitVec 64) )
        (pure (cpysize, fromaddress, nzcv, stagecpysize, toaddress))) ) : SailM
    ((BitVec 64) × (BitVec 64) × (BitVec 4) × (BitVec 64) × (BitVec 64)) )
  bif (← readReg SPESampleInFlight)
  then (SPESampleMemCopy ())
  else (pure ())
  let (cpysize, fromaddress, toaddress) ← (( do
    bif supports_option_a
    then
      (do
        let (B, cpysize, readdata, stagecpysize) ← (( do
          let mut loop_vars_1 := (B, cpysize, readdata, stagecpysize)
          while (λ (B, cpysize, readdata, stagecpysize) => ((BitVec.toInt stagecpysize) != 0))
            loop_vars_1
            do
            let (B, cpysize, readdata, stagecpysize) := loop_vars_1
            loop_vars_1 ← do
              let B ← (CPYSizeChoice toaddress fromaddress cpysize)
              assert (B ≤b ((Neg.neg 1) *i (BitVec.toInt stagecpysize))) "src/instrs64.sail:9007.54-9007.55"
              let B := B
              assert ((0 ≤b ((B *i 8) -i 1)) && (((B *i 8) -i 1) <b (8 *i N))) "src/instrs64.sail:9010.76-9010.77"
              let readdata ←
                (pure (Sail.BitVec.updateSubrange readdata ((B *i 8) -i 1) 0
                    (← (Mem_read (fromaddress + cpysize) B raccdesc))))
              (pure ())
              let B := B
              assert ((0 ≤b ((B *i 8) -i 1)) && (((B *i 8) -i 1) <b (8 *i N))) "src/instrs64.sail:9015.76-9015.77"
              (Mem_set (toaddress + cpysize) B waccdesc
                (Sail.BitVec.extractLsb readdata ((B *i 8) -i 1) 0))
              let cpysize : (BitVec 64) := (BitVec.addInt cpysize B)
              let stagecpysize : (BitVec 64) := (BitVec.addInt stagecpysize B)
              bif (bne stage MOPSStage_Prologue)
              then (X_set n 64 cpysize)
              else (pure ())
              (pure (B, cpysize, readdata, stagecpysize))
          (pure loop_vars_1) ) : SailM (Int × (BitVec 64) × (BitVec (8 * N)) × (BitVec 64)) )
        (pure (cpysize, fromaddress, toaddress)))
    else
      (do
        let (B, cpysize, fromaddress, readdata, stagecpysize, toaddress) ← (( do
          let mut loop_vars := (B, cpysize, fromaddress, readdata, stagecpysize, toaddress)
          while (λ (B, cpysize, fromaddress, readdata, stagecpysize, toaddress) =>
            ((BitVec.toNat stagecpysize) >b 0))
            loop_vars
            do
            let (B, cpysize, fromaddress, readdata, stagecpysize, toaddress) := loop_vars
            loop_vars ← do
              let B ← (CPYSizeChoice toaddress fromaddress cpysize)
              assert (B ≤b (BitVec.toNat stagecpysize)) "src/instrs64.sail:9028.42-9028.43"
              let B := B
              assert ((0 ≤b ((B *i 8) -i 1)) && (((B *i 8) -i 1) <b (8 *i N))) "src/instrs64.sail:9031.76-9031.77"
              let readdata ←
                (pure (Sail.BitVec.updateSubrange readdata ((B *i 8) -i 1) 0
                    (← (Mem_read fromaddress B raccdesc))))
              (pure ())
              let B := B
              assert ((0 ≤b ((B *i 8) -i 1)) && (((B *i 8) -i 1) <b (8 *i N))) "src/instrs64.sail:9036.76-9036.77"
              (Mem_set toaddress B waccdesc (Sail.BitVec.extractLsb readdata ((B *i 8) -i 1) 0))
              let fromaddress : (BitVec 64) := (BitVec.addInt fromaddress B)
              let toaddress : (BitVec 64) := (BitVec.addInt toaddress B)
              let cpysize : (BitVec 64) := (BitVec.subInt cpysize B)
              let stagecpysize : (BitVec 64) := (BitVec.subInt stagecpysize B)
              bif (bne stage MOPSStage_Prologue)
              then
                (do
                  (X_set n 64 cpysize)
                  (X_set d 64 toaddress)
                  (X_set s 64 fromaddress))
              else (pure ())
              (pure (B, cpysize, fromaddress, readdata, stagecpysize, toaddress))
          (pure loop_vars) ) : SailM
          (Int × (BitVec 64) × (BitVec 64) × (BitVec (8 * N)) × (BitVec 64) × (BitVec 64)) )
        (pure (cpysize, fromaddress, toaddress))) ) : SailM
    ((BitVec 64) × (BitVec 64) × (BitVec 64)) )
  bif (BEq.beq stage MOPSStage_Prologue)
  then
    (do
      (X_set n 64 cpysize)
      (X_set d 64 toaddress)
      (X_set s 64 fromaddress)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_cpyfp_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9092.58-9092.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfpn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9149.58-9149.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfprn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9206.58-9206.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfprt_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9263.58-9263.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfprtn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9320.58-9320.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfprtrn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9377.58-9377.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfprtwn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9434.58-9434.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfpt_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9491.58-9491.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfptn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9548.58-9548.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfptrn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9605.58-9605.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfptwn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9662.58-9662.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfpwn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9719.58-9719.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfpwt_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9776.58-9776.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfpwtn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9833.58-9833.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfpwtrn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9890.58-9890.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

def decode_cpyfpwtwn_aarch64_instrs_memory_mcpymset_cpyf (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (op1 : (BitVec 2)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 4) := op2
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := op1
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_See "Memory Copy and Memory Set"))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif ((((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (s == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:9947.58-9947.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_cpyf d n options_name s stage)

/-- Type quantifiers: k_crc32c : Bool, d : Nat, m : Nat, n : Nat, size : Nat, size ∈
  {8, 16, 32, 64} ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_crc (crc32c : Bool) (d : Nat) (m : Nat) (n : Nat) (size : Nat) : SailM Unit := do
  let acc ← (( do (X_read n 32) ) : SailM (BitVec 32) )
  let val_name ← (( do (X_read m size) ) : SailM (BitVec size) )
  let poly : (BitVec 32) :=
    (integer_subrange
      (bif crc32c
      then (BitVec.toNat (0x1EDC6F41 : (BitVec 32)))
      else (BitVec.toNat (0x04C11DB7 : (BitVec 32)))) 31 0)
  let tempacc ← (( do (pure ((← (BitReverse acc)) ++ (Zeros (n := size)))) ) : SailM
    (BitVec (32 + size)) )
  let tempval ← (( do (pure ((← (BitReverse val_name)) ++ (Zeros (n := 32)))) ) : SailM
    (BitVec (size + 32)) )
  (X_set d 32 (← (BitReverse (← (Poly32Mod2 (tempacc ^^^ tempval) poly)))))

def decode_crc32_aarch64_instrs_integer_crc (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 2)) (C : (BitVec 1)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCRCExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sf == (0b1 : (BitVec 1))) && (sz != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sf == (0b0 : (BitVec 1))) && (sz == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let size := (Int.shiftl 8 (BitVec.toNat sz))
  let crc32c : Bool := (C == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_crc crc32c d m n size)

def decode_crc32c_aarch64_instrs_integer_crc (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 2)) (C : (BitVec 1)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCRCExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sf == (0b1 : (BitVec 1))) && (sz != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sf == (0b0 : (BitVec 1))) && (sz == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let size := (Int.shiftl 8 (BitVec.toNat sz))
  let crc32c : Bool := (C == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_crc crc32c d m n size)

/-- Type quantifiers: d : Nat, datasize : Nat, k_else_inc : Bool, k_else_inv : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_conditional_select (condition : (BitVec 4)) (d : Nat) (datasize : Nat) (else_inc : Bool) (else_inv : Bool) (m : Nat) (n : Nat) : SailM Unit := do
  let taken : Bool := false
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let (result, taken) ← (( do
    bif (← (ConditionHolds condition))
    then
      (do
        let result ← (X_read n datasize)
        let taken : Bool := true
        (pure (result, taken)))
    else
      (do
        let result ← (X_read m datasize)
        let result : (BitVec datasize) :=
          bif else_inv
          then (Complement.complement result)
          else result
        let result : (BitVec datasize) :=
          bif else_inc
          then (BitVec.addInt result 1)
          else result
        (pure (result, taken))) ) : SailM ((BitVec datasize) × Bool) )
  (X_set d datasize result)
  bif (← readReg SPESampleInFlight)
  then
    (do
      let conditional : Bool := true
      (SPESampleAddOpOther conditional taken))
  else (pure ())

def decode_csel_aarch64_instrs_integer_conditional_select (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o2 : (BitVec 1)) (cond : (BitVec 4)) (Rm : (BitVec 5)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let condition : (BitVec 4) := cond
  let else_inv : Bool := (op == (0b1 : (BitVec 1)))
  let else_inc : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_conditional_select condition d datasize else_inc else_inv m n)

def decode_csinc_aarch64_instrs_integer_conditional_select (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o2 : (BitVec 1)) (cond : (BitVec 4)) (Rm : (BitVec 5)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let condition : (BitVec 4) := cond
  let else_inv : Bool := (op == (0b1 : (BitVec 1)))
  let else_inc : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_conditional_select condition d datasize else_inc else_inv m n)

def decode_csinv_aarch64_instrs_integer_conditional_select (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o2 : (BitVec 1)) (cond : (BitVec 4)) (Rm : (BitVec 5)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let condition : (BitVec 4) := cond
  let else_inv : Bool := (op == (0b1 : (BitVec 1)))
  let else_inc : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_conditional_select condition d datasize else_inc else_inv m n)

def decode_csneg_aarch64_instrs_integer_conditional_select (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o2 : (BitVec 1)) (cond : (BitVec 4)) (Rm : (BitVec 5)) (op : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let condition : (BitVec 4) := cond
  let else_inv : Bool := (op == (0b1 : (BitVec 1)))
  let else_inc : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_conditional_select condition d datasize else_inc else_inv m n)

/-- Type quantifiers: d : Nat, datasize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_unary_ctz (d : Nat) (datasize : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let result ← do (pure (CountLeadingZeroBits (← (BitReverse operand1))))
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_ctz_aarch64_instrs_integer_arithmetic_unary_ctz (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_integer_arithmetic_unary_ctz d datasize n)

def execute_aarch64_instrs_system_exceptions_debug_exception (target_level : (BitVec 2)) : SailM Unit := do
  (DCPSInstruction target_level)

def decode_dcps1_aarch64_instrs_system_exceptions_debug_exception (LL : (BitVec 2)) (imm16 : (BitVec 16)) : SailM Unit := do
  let target_level : (BitVec 2) := LL
  bif (LL == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (! (← (Halted ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_system_exceptions_debug_exception target_level)

def decode_dcps2_aarch64_instrs_system_exceptions_debug_exception (LL : (BitVec 2)) (imm16 : (BitVec 16)) : SailM Unit := do
  let target_level : (BitVec 2) := LL
  bif (LL == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (! (← (Halted ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_system_exceptions_debug_exception target_level)

def decode_dcps3_aarch64_instrs_system_exceptions_debug_exception (LL : (BitVec 2)) (imm16 : (BitVec 16)) : SailM Unit := do
  let target_level : (BitVec 2) := LL
  bif (LL == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (! (← (Halted ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_system_exceptions_debug_exception target_level)

def execute_aarch64_instrs_system_barriers_dmb (domain : MBReqDomain) (types : MBReqTypes) : SailM Unit := do
  (DataMemoryBarrier domain types)

def decode_dmb_aarch64_instrs_system_barriers_dmb (opc : (BitVec 2)) (CRm : (BitVec 4)) : SailM Unit := do
  let domain ← (( do (undefined_MBReqDomain ()) ) : SailM MBReqDomain )
  let types ← (( do (undefined_MBReqTypes ()) ) : SailM MBReqTypes )
  let _ : Unit :=
    let b__0 := (Sail.BitVec.extractLsb CRm 3 2)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let domain : MBReqDomain := MBReqDomain_OuterShareable
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let domain : MBReqDomain := MBReqDomain_Nonshareable
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let domain : MBReqDomain := MBReqDomain_InnerShareable
          ())
        else
          (let domain : MBReqDomain := MBReqDomain_FullSystem
          ())))
  let _ : Unit :=
    let b__3 := (Sail.BitVec.extractLsb CRm 1 0)
    bif (b__3 == (0b00 : (BitVec 2)))
    then
      (let types : MBReqTypes := MBReqTypes_All
      let domain : MBReqDomain := MBReqDomain_FullSystem
      ())
    else
      (bif (b__3 == (0b01 : (BitVec 2)))
      then
        (let types : MBReqTypes := MBReqTypes_Reads
        ())
      else
        (bif (b__3 == (0b10 : (BitVec 2)))
        then
          (let types : MBReqTypes := MBReqTypes_Writes
          ())
        else
          (let types : MBReqTypes := MBReqTypes_All
          ())))
  let types := types
  (execute_aarch64_instrs_system_barriers_dmb domain types)

def execute_aarch64_instrs_branch_unconditional_dret (_ : Unit) : SailM Unit := do
  (DRPSInstruction ())

def decode_drps_aarch64_instrs_branch_unconditional_dret (_ : Unit) : SailM Unit := do
  bif ((! (← (Halted ()))) || ((← readReg PSTATE).EL == EL0))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_branch_unconditional_dret ())

/-- Type quantifiers: k_nXS : Bool -/
def execute_aarch64_instrs_system_barriers_dsb (alias' : DSBAlias) (domain : MBReqDomain) (nXS__arg : Bool) (types : MBReqTypes) : SailM Unit := do
  let nXS : Bool := nXS__arg
  match alias' with
  | DSBAlias_SSBB => (pure (SpeculativeStoreBypassBarrierToVA ()))
  | DSBAlias_PSSBB => (pure (SpeculativeStoreBypassBarrierToPA ()))
  | DSBAlias_DSB =>
    (do
      bif ((← (HaveTME ())) && ((← readReg TSTATE).depth >b 0))
      then (FailTransaction TMFailure_ERR false)
      else (pure ())
      let nXS ← (( do
        bif ((! nXS) && (← (HaveFeatXS ())))
        then
          (do
            (pure (((((← readReg PSTATE).EL == EL0) || ((← readReg PSTATE).EL == EL1)) && (← (IsHCRXEL2Enabled
                      ()))) && ((_get_HCRX_EL2_Type_FnXS (← readReg HCRX_EL2)) == (0b1 : (BitVec 1))))))
        else (pure nXS) ) : SailM Bool )
      (DataSynchronizationBarrier domain types nXS))

def decode_dsb_aarch64_instrs_system_barriers_dsb (opc : (BitVec 2)) (CRm : (BitVec 4)) : SailM Unit := do
  let nXS : Bool := false
  let alias' ← (( do (undefined_DSBAlias ()) ) : SailM DSBAlias )
  let _ : Unit :=
    let b__0 := CRm
    bif (b__0 == (0x0 : (BitVec 4)))
    then
      (let alias' : DSBAlias := DSBAlias_SSBB
      ())
    else
      (bif (b__0 == (0x4 : (BitVec 4)))
      then
        (let alias' : DSBAlias := DSBAlias_PSSBB
        ())
      else
        (let alias' : DSBAlias := DSBAlias_DSB
        ()))
  let alias' := alias'
  let domain ← (( do (undefined_MBReqDomain ()) ) : SailM MBReqDomain )
  let _ : Unit :=
    let b__2 := (Sail.BitVec.extractLsb CRm 3 2)
    bif (b__2 == (0b00 : (BitVec 2)))
    then
      (let domain : MBReqDomain := MBReqDomain_OuterShareable
      ())
    else
      (bif (b__2 == (0b01 : (BitVec 2)))
      then
        (let domain : MBReqDomain := MBReqDomain_Nonshareable
        ())
      else
        (bif (b__2 == (0b10 : (BitVec 2)))
        then
          (let domain : MBReqDomain := MBReqDomain_InnerShareable
          ())
        else
          (let domain : MBReqDomain := MBReqDomain_FullSystem
          ())))
  let types ← (( do (undefined_MBReqTypes ()) ) : SailM MBReqTypes )
  let _ : Unit :=
    let b__5 := (Sail.BitVec.extractLsb CRm 1 0)
    bif (b__5 == (0b00 : (BitVec 2)))
    then
      (let types : MBReqTypes := MBReqTypes_All
      let domain : MBReqDomain := MBReqDomain_FullSystem
      ())
    else
      (bif (b__5 == (0b01 : (BitVec 2)))
      then
        (let types : MBReqTypes := MBReqTypes_Reads
        ())
      else
        (bif (b__5 == (0b10 : (BitVec 2)))
        then
          (let types : MBReqTypes := MBReqTypes_Writes
          ())
        else
          (let types : MBReqTypes := MBReqTypes_All
          ())))
  (execute_aarch64_instrs_system_barriers_dsb alias' domain nXS types)

def decode_dsb_aarch64_instrs_system_barriers_dsb_nxs (imm2 : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatXS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let types : MBReqTypes := MBReqTypes_All
  let nXS : Bool := true
  let alias' : DSBAlias := DSBAlias_DSB
  let domain ← (( do (undefined_MBReqDomain ()) ) : SailM MBReqDomain )
  let _ : Unit :=
    let b__0 := imm2
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let domain : MBReqDomain := MBReqDomain_OuterShareable
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let domain : MBReqDomain := MBReqDomain_Nonshareable
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let domain : MBReqDomain := MBReqDomain_InnerShareable
          ())
        else
          (let domain : MBReqDomain := MBReqDomain_FullSystem
          ())))
  let domain := domain
  (execute_aarch64_instrs_system_barriers_dsb alias' domain nXS types)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {8, 16, 32, 64, 128, 256} ∧
  datasize ∈ {8, 16, 32, 64, 128, 256} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Int) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n idxdsize) ) : SailM (BitVec idxdsize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (Elem_read operand index esize) ) : SailM (BitVec esize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do (Elem_set result e esize element)
    (pure loop_vars) ) : SailM (BitVec datasize) )
  assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:10473.56-10473.57"
  (V_set d datasize result)

def decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm5 : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let size := (LowestSetBit imm5)
  bif (size >b 3)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  assert (0 ≤b (size +i 1)) "src/instrs64.sail:10486.37-10486.38"
  let index := (BitVec.toNat (Sail.BitVec.extractLsb imm5 4 (size +i 1)))
  let idxdsize :=
    bif ((BitVec.join1 [(BitVec.access imm5 4)]) == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 size)
  let datasize := esize
  let elements := 1
  assert (((((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) || (esize == 128)) || (esize == 256)) && ((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256))) "src/instrs64.sail:10492.101-10492.102"
  (execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd d datasize elements esize idxdsize
    index n)

def decode_dup_advsimd_elt_aarch64_instrs_vector_transfer_vector_cpy_dup_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm5 : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let size := (LowestSetBit imm5)
  bif (size >b 3)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  assert (0 ≤b (size +i 1)) "src/instrs64.sail:10513.37-10513.38"
  let index := (BitVec.toNat (Sail.BitVec.extractLsb imm5 4 (size +i 1)))
  let idxdsize :=
    bif ((BitVec.join1 [(BitVec.access imm5 4)]) == (0b1 : (BitVec 1)))
    then 128
    else 64
  bif ((size == 3) && (Q == (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 size)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  assert ((((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) || (esize == 128)) || (esize == 256)) "src/instrs64.sail:10522.58-10522.59"
  (execute_aarch64_instrs_vector_transfer_vector_cpy_dup_sisd d datasize elements esize idxdsize
    index n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize ∈ {8, 16, 32, 64, 128, 256} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_integer_dup (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:10541.48-10541.49"
  let element ← (( do (X_read n esize) ) : SailM (BitVec esize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do (Elem_set result e esize element)
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_dup_advsimd_gen_aarch64_instrs_vector_transfer_integer_dup (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm5 : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let size := (LowestSetBit imm5)
  bif (size >b 3)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((size == 3) && (Q == (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 size)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  assert ((((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) || (esize == 128)) || (esize == 256)) "src/instrs64.sail:10565.58-10565.59"
  (execute_aarch64_instrs_vector_transfer_integer_dup d datasize elements esize n)

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha3_eor3 (a : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let Va ← (( do (V_read a 128) ) : SailM (BitVec 128) )
  (V_set d 128 ((Vn ^^^ Vm) ^^^ Va))

def decode_eor3_advsimd_aarch64_instrs_vector_crypto_sha3_eor3 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSHA3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  (execute_aarch64_instrs_vector_crypto_sha3_eor3 a d m n)

/-- Type quantifiers: k_pac : Bool, k_use_key_a : Bool -/
def execute_aarch64_instrs_branch_unconditional_eret (pac : Bool) (use_key_a : Bool) : SailM Unit := do
  (AArch64_CheckForERetTrap pac use_key_a)
  let target ← (( do (ELR_read__1 ()) ) : SailM (BitVec 64) )
  let modifier ← (( do (SP_read ()) ) : SailM (BitVec 64) )
  let auth_then_branch : Bool := true
  let target ← (( do
    bif pac
    then
      (do
        bif use_key_a
        then
          (do
            (AuthIA target modifier auth_then_branch))
        else
          (do
            (AuthIB target modifier auth_then_branch)))
    else (pure target) ) : SailM (BitVec 64) )
  (return_exception (Sail.BitVec.extractLsb target 55 0))
  (AArch64_ExceptionReturn target (← (SPSR_read (N := 64))))

def decode_eret_aarch64_instrs_branch_unconditional_eret (op4 : (BitVec 5)) (Rn : (BitVec 5)) (M : (BitVec 1)) (A : (BitVec 1)) : SailM Unit := do
  bif ((← readReg PSTATE).EL == EL0)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pac : Bool := (A == (0b1 : (BitVec 1)))
  let use_key_a : Bool := (M == (0b0 : (BitVec 1)))
  bif ((! pac) && (op4 != (0b00000 : (BitVec 5))))
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (pac && ((! (← (HavePACExt ()))) || (op4 != (0b11111 : (BitVec 5)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ()))
  bif (Rn != (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_branch_unconditional_eret pac use_key_a)

def decode_ereta_aarch64_instrs_branch_unconditional_eret (op4 : (BitVec 5)) (Rn : (BitVec 5)) (M : (BitVec 1)) (A : (BitVec 1)) : SailM Unit := do
  bif ((← readReg PSTATE).EL == EL0)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pac : Bool := (A == (0b1 : (BitVec 1)))
  let use_key_a : Bool := (M == (0b0 : (BitVec 1)))
  bif ((! pac) && (op4 != (0b00000 : (BitVec 5))))
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (pac && ((! (← (HavePACExt ()))) || (op4 != (0b11111 : (BitVec 5)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ()))
  bif (Rn != (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_branch_unconditional_eret pac use_key_a)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, position : Int, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_vector_extract (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) (position : Int) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let hi ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let lo ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let concat : (BitVec (datasize * 2)) := (hi ++ lo)
  assert ((0 ≤b position) && (((position +i datasize) -i 1) <b (datasize *i 2))) "src/instrs64.sail:10696.83-10696.84"
  (V_set d datasize (Sail.BitVec.extractLsb concat ((position +i datasize) -i 1) position))

def decode_ext_advsimd_aarch64_instrs_vector_transfer_vector_extract (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm4 : (BitVec 4)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((Q == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imm4 3)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let position := (Int.shiftl (BitVec.toNat imm4) 3)
  (execute_aarch64_instrs_vector_transfer_vector_extract d datasize m n position)

/-- Type quantifiers: d : Nat, datasize : Nat, lsb : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ lsb ∧ lsb ≤ 63 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_ins_ext_extract_immediate (d : Nat) (datasize : Nat) (lsb : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let concat : (BitVec (2 * datasize)) := (operand1 ++ operand2)
  assert (((lsb +i datasize) -i 1) <b (2 *i datasize)) "src/instrs64.sail:10732.59-10732.60"
  let result : (BitVec datasize) := (Sail.BitVec.extractLsb concat ((lsb +i datasize) -i 1) lsb)
  (X_set d datasize result)

def decode_extr_aarch64_instrs_integer_ins_ext_extract_immediate (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imms : (BitVec 6)) (Rm : (BitVec 5)) (N : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  bif (N != sf)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access imms 5)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let lsb := (BitVec.toNat imms)
  (execute_aarch64_instrs_integer_ins_ext_extract_immediate d datasize lsb m n)

/-- Type quantifiers: k_abs : Bool, d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n
  : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd (abs : Bool) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let diff ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read n 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (diff, element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (diff, element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (diff, element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let diff ← (FPSub element1 element2 fpcr)
        let result ←
          (Elem_set result e esize
            (← do
              bif abs
              then (FPAbs diff)
              else (pure diff)))
        (pure (diff, element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec 128))
    )
  (V_set d 128 result)

def decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize := esize
  let elements := 1
  let abs : Bool := true
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd abs d datasize elements
    esize m n)

def decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let abs : Bool := true
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd abs d datasize elements
    esize m n)

def decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let abs : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd abs d datasize elements
    esize m n)

def decode_fabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let abs : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_sisd abs d datasize elements
    esize m n)

/-- Type quantifiers: d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_arithmetic_unary (d : Nat) (esize : Nat) (fpop : FPUnaryOp) (n : Nat) : SailM Unit := do
  (CheckFPEnabled64 ())
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((bne fpop FPUnaryOp_MOV) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (integer_subrange 0 127 0)) ) : SailM (BitVec 128) )
  let operand ← (( do (V_read n esize) ) : SailM (BitVec esize) )
  let result ← (( do
    match fpop with
    | FPUnaryOp_MOV =>
      (do
        (Elem_set result 0 esize operand))
    | FPUnaryOp_ABS =>
      (do
        (Elem_set result 0 esize (← (FPAbs operand))))
    | FPUnaryOp_NEG =>
      (do
        (Elem_set result 0 esize (← (FPNeg operand))))
    | FPUnaryOp_SQRT =>
      (do
        (Elem_set result 0 esize (← (FPSqrt operand fpcr)))) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_fabs_float_aarch64_instrs_float_arithmetic_unary (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 2)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let fpop ← (( do (undefined_FPUnaryOp ()) ) : SailM FPUnaryOp )
  let _ : Unit :=
    let b__3 := opc
    bif (b__3 == (0b00 : (BitVec 2)))
    then
      (let fpop : FPUnaryOp := FPUnaryOp_MOV
      ())
    else
      (bif (b__3 == (0b01 : (BitVec 2)))
      then
        (let fpop : FPUnaryOp := FPUnaryOp_ABS
        ())
      else
        (bif (b__3 == (0b10 : (BitVec 2)))
        then
          (let fpop : FPUnaryOp := FPUnaryOp_NEG
          ())
        else
          (let fpop : FPUnaryOp := FPUnaryOp_SQRT
          ())))
  let fpop := fpop
  (execute_aarch64_instrs_float_arithmetic_unary d esize fpop n)

def decode_fmov_float_aarch64_instrs_float_arithmetic_unary (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 2)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let fpop ← (( do (undefined_FPUnaryOp ()) ) : SailM FPUnaryOp )
  let _ : Unit :=
    let b__3 := opc
    bif (b__3 == (0b00 : (BitVec 2)))
    then
      (let fpop : FPUnaryOp := FPUnaryOp_MOV
      ())
    else
      (bif (b__3 == (0b01 : (BitVec 2)))
      then
        (let fpop : FPUnaryOp := FPUnaryOp_ABS
        ())
      else
        (bif (b__3 == (0b10 : (BitVec 2)))
        then
          (let fpop : FPUnaryOp := FPUnaryOp_NEG
          ())
        else
          (let fpop : FPUnaryOp := FPUnaryOp_SQRT
          ())))
  let fpop := fpop
  (execute_aarch64_instrs_float_arithmetic_unary d esize fpop n)

def decode_fneg_float_aarch64_instrs_float_arithmetic_unary (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 2)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let fpop ← (( do (undefined_FPUnaryOp ()) ) : SailM FPUnaryOp )
  let _ : Unit :=
    let b__3 := opc
    bif (b__3 == (0b00 : (BitVec 2)))
    then
      (let fpop : FPUnaryOp := FPUnaryOp_MOV
      ())
    else
      (bif (b__3 == (0b01 : (BitVec 2)))
      then
        (let fpop : FPUnaryOp := FPUnaryOp_ABS
        ())
      else
        (bif (b__3 == (0b10 : (BitVec 2)))
        then
          (let fpop : FPUnaryOp := FPUnaryOp_NEG
          ())
        else
          (let fpop : FPUnaryOp := FPUnaryOp_SQRT
          ())))
  let fpop := fpop
  (execute_aarch64_instrs_float_arithmetic_unary d esize fpop n)

def decode_fsqrt_float_aarch64_instrs_float_arithmetic_unary (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 2)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let fpop ← (( do (undefined_FPUnaryOp ()) ) : SailM FPUnaryOp )
  let _ : Unit :=
    let b__3 := opc
    bif (b__3 == (0b00 : (BitVec 2)))
    then
      (let fpop : FPUnaryOp := FPUnaryOp_MOV
      ())
    else
      (bif (b__3 == (0b01 : (BitVec 2)))
      then
        (let fpop : FPUnaryOp := FPUnaryOp_ABS
        ())
      else
        (bif (b__3 == (0b10 : (BitVec 2)))
        then
          (let fpop : FPUnaryOp := FPUnaryOp_NEG
          ())
        else
          (let fpop : FPUnaryOp := FPUnaryOp_SQRT
          ())))
  let fpop := fpop
  (execute_aarch64_instrs_float_arithmetic_unary d esize fpop n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, k_neg : Bool, 0
  ≤ n ∧ n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (neg : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let element ← (( do
          bif neg
          then
            (do
              (FPNeg element))
          else
            (do
              (FPAbs element)) ) : SailM (BitVec esize) )
        let result ← (Elem_set result e esize element)
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 d datasize elements esize n neg)

def decode_fabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 d datasize elements esize n neg)

def decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 d datasize elements esize n neg)

def decode_fneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_float (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_fp16 d datasize elements esize n neg)

/-- Type quantifiers: k_abs : Bool, d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n
  : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (abs : Bool) (cmp : CompareOp) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read m 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element1, element2, result, test_passed) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result, test_passed)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result, test_passed) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let (element1, element2) ← (( do
          bif abs
          then
            (do
              let element1 ← (FPAbs element1)
              let element2 ← (FPAbs element2)
              (pure (element1, element2)))
          else (pure (element1, element2)) ) : SailM ((BitVec esize) × (BitVec esize)) )
        let test_passed ← (( do
          match cmp with
          | CompareOp_EQ =>
            (do
              (FPCompareEQ element1 element2 fpcr))
          | CompareOp_GE =>
            (do
              (FPCompareGE element1 element2 fpcr))
          | CompareOp_GT =>
            (do
              (FPCompareGT element1 element2 fpcr))
          | _ => (pure test_passed) ) : SailM Bool )
        let result ←
          (Elem_set result e esize
            (bif test_passed
            then (Ones (n := esize))
            else (Zeros (n := esize))))
        (pure (element1, element2, result, test_passed))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec 128) × Bool) )
  (V_set d 128 result)

def decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (E : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize := esize
  let elements := 1
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (E : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (E : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_facge_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (E : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (E : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize := esize
  let elements := 1
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (E : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (E : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_facgt_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (E : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (E : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize := esize
  let elements := 1
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (E : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (E : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmeq_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (E : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (E : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize := esize
  let elements := 1
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (E : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (E : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmge_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (E : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (E : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize := esize
  let elements := 1
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (E : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (E : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

def decode_fcmgt_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (E : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let cmp ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let abs ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ((E ++ U) ++ ac)
  bif (b__0 == (0b000 : (BitVec 3)))
  then
    (let cmp : CompareOp := CompareOp_EQ
    let abs : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let cmp : CompareOp := CompareOp_GE
        let abs : Bool := false
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let cmp : CompareOp := CompareOp_GE
            let abs : Bool := true
            (pure ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (let cmp : CompareOp := CompareOp_GT
                let abs : Bool := false
                (pure ()))
              else
                (do
                  bif (b__0 == (0b111 : (BitVec 3)))
                  then
                    (let cmp : CompareOp := CompareOp_GT
                    let abs : Bool := true
                    (pure ()))
                  else sailThrow ((Error_Undefined ()))))))
  let abs := abs
  let cmp := cmp
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_cmp_fp16_sisd abs cmp d datasize elements
    esize m n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, k_pair
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (pair : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let concat : (BitVec (2 * datasize)) := (operand2 ++ operand1)
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2) ← (( do
          bif pair
          then
            (do
              let element1 ← (Elem_read concat (2 *i e) esize)
              let element2 ← (Elem_read concat ((2 *i e) +i 1) esize)
              (pure (element1, element2)))
          else
            (do
              let element1 ← (Elem_read operand1 e esize)
              let element2 ← (Elem_read operand2 e esize)
              (pure (element1, element2))) ) : SailM ((BitVec esize) × (BitVec esize)) )
        let result ←
          (Elem_set result e esize (← (FPAdd element1 element2 (← (FPCR_read ())))))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 d datasize elements esize m n
    pair)

def decode_fadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 d datasize elements esize m n
    pair)

def decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 d datasize elements esize m n
    pair)

def decode_faddp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp16 d datasize elements esize m n
    pair)

/-- Type quantifiers: d : Nat, esize : Nat, m : Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_arithmetic_add_sub (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckFPEnabled64 ())
  let operand1 ← (( do (V_read n esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (V_read m esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read n 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let result ← (( do
    bif sub_op
    then
      (do
        (Elem_set result 0 esize (← (FPSub operand1 operand2 fpcr))))
    else
      (do
        (Elem_set result 0 esize (← (FPAdd operand1 operand2 fpcr)))) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_fadd_float_aarch64_instrs_float_arithmetic_add_sub (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_float_arithmetic_add_sub d esize m n sub_op)

def decode_fsub_float_aarch64_instrs_float_arithmetic_add_sub (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_float_arithmetic_add_sub d esize m n sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_reduce_fp16_add_sisd (d : Nat) (datasize : Nat) (esize : Nat) (n : Nat) (op : ReduceOp) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  assert (datasize ≥b esize) "src/instrs64.sail:12626.42-12626.43"
  (V_set d esize (← (Reduce op operand esize)))

def decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_add_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp := ReduceOp_FADD
  (execute_aarch64_instrs_vector_reduce_fp16_add_sisd d datasize esize n op)

def decode_faddp_advsimd_pair_aarch64_instrs_vector_reduce_fp_add_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp := ReduceOp_FADD
  (execute_aarch64_instrs_vector_reduce_fp16_add_sisd d datasize esize n op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp_complex (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (rot : (BitVec 1)) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element3 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element3, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((fdiv_int elements 2) -i 1)
    let mut loop_vars := (element1, element3, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element3, result) := loop_vars
      loop_vars ← do
        let b__0 := rot
        bif (b__0 == (0b0 : (BitVec 1)))
        then
          (do
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:12690.55-12690.56"
            let element1 ← (FPNeg (← (Elem_read operand2 ((e *i 2) +i 1) esize)))
            let element3 ← (Elem_read operand2 (e *i 2) esize)
            (pure ()))
        else
          (do
            let element1 ← (Elem_read operand2 ((e *i 2) +i 1) esize)
            assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:12696.55-12696.56"
            let element3 ← (FPNeg (← (Elem_read operand2 (e *i 2) esize)))
            (pure ()))
        assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:12700.49-12700.50"
        let result ←
          (Elem_set result (e *i 2) esize
            (← (FPAdd (← (Elem_read operand1 (e *i 2) esize)) element1 (← (FPCR_read ())))))
        let result ←
          (Elem_set result ((e *i 2) +i 1) esize
            (← (FPAdd (← (Elem_read operand1 ((e *i 2) +i 1) esize)) element3
                (← (FPCR_read ())))))
        (pure (element1, element3, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fcadd_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp_complex (Rd : (BitVec 5)) (Rn : (BitVec 5)) (rot : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFCADDExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((Q == (0b0 : (BitVec 1))) && (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  bif ((! (HaveFP16Ext ())) && (esize == 16))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_fp_complex d datasize elements esize
    m n rot)

/-- Type quantifiers: datasize : Nat, m : Nat, n : Nat, k_signal_all_nans : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {16, 32, 64} -/
def execute_aarch64_instrs_float_compare_cond (condition : (BitVec 4)) (datasize : Nat) (flags__arg : (BitVec 4)) (m : Nat) (n : Nat) (signal_all_nans : Bool) : SailM Unit := do
  let flags : (BitVec 4) := flags__arg
  (CheckFPEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let taken : Bool := false
  let (flags, taken) ← (( do
    bif (← (ConditionHolds condition))
    then
      (do
        let flags ← (FPCompare operand1 operand2 signal_all_nans (← (FPCR_read ())))
        let taken : Bool := true
        (pure (flags, taken)))
    else (pure (flags, taken)) ) : SailM ((BitVec 4) × Bool) )
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb flags 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb flags 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb flags 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb flags 0 0) }
  bif (← readReg SPESampleInFlight)
  then
    (do
      let conditional : Bool := true
      (SPESampleAddOpOther conditional taken))
  else (pure ())

def decode_fccmp_float_aarch64_instrs_float_compare_cond (nzcv : (BitVec 4)) (op : (BitVec 1)) (Rn : (BitVec 5)) (cond : (BitVec 4)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let datasize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let datasize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let datasize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let datasize := datasize
  let signal_all_nans : Bool := (op == (0b1 : (BitVec 1)))
  let condition : (BitVec 4) := cond
  let flags : (BitVec 4) := nzcv
  (execute_aarch64_instrs_float_compare_cond condition datasize flags m n signal_all_nans)

def decode_fccmpe_float_aarch64_instrs_float_compare_cond (nzcv : (BitVec 4)) (op : (BitVec 1)) (Rn : (BitVec 5)) (cond : (BitVec 4)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let datasize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let datasize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let datasize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let datasize := datasize
  let signal_all_nans : Bool := (op == (0b1 : (BitVec 1)))
  let condition : (BitVec 4) := cond
  let flags : (BitVec 4) := nzcv
  (execute_aarch64_instrs_float_compare_cond condition datasize flags m n signal_all_nans)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (comparison : CompareOp) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let zero ← (( do (FPZero (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element, result, test_passed) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, test_passed)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, test_passed) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let test_passed ← (( do
          match comparison with
          | CompareOp_GT =>
            (do
              (FPCompareGT element zero (← (FPCR_read ()))))
          | CompareOp_GE =>
            (do
              (FPCompareGE element zero (← (FPCR_read ()))))
          | CompareOp_EQ =>
            (do
              (FPCompareEQ element zero (← (FPCR_read ()))))
          | CompareOp_LE =>
            (do
              (FPCompareGE zero element (← (FPCR_read ()))))
          | CompareOp_LT =>
            (do
              (FPCompareGT zero element (← (FPCR_read ())))) ) : SailM Bool )
        let result ←
          (Elem_set result e esize
            (bif test_passed
            then (Ones (n := esize))
            else (Zeros (n := esize))))
        (pure (element, result, test_passed))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmeq_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmge_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmgt_advsimd_zero_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

def decode_fcmle_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison ← (( do (undefined_CompareOp ()) ) : SailM CompareOp )
  let _ : Unit :=
    let b__0 := (op ++ U)
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let comparison : CompareOp := CompareOp_GT
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let comparison : CompareOp := CompareOp_GE
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let comparison : CompareOp := CompareOp_EQ
          ())
        else
          (let comparison : CompareOp := CompareOp_LE
          ())))
  let comparison := comparison
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_bulk_sisd comparison d datasize elements
    esize n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_complex (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (rot : (BitVec 2)) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element3 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element4 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let (element1, element2, element3, element4, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((fdiv_int elements 2) -i 1)
    let mut loop_vars := (element1, element2, element3, element4, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, element3, element4, result) := loop_vars
      loop_vars ← do
        let b__0 := rot
        bif (b__0 == (0b00 : (BitVec 2)))
        then
          (do
            let element1 ← (Elem_read operand2 (e *i 2) esize)
            let element2 ← (Elem_read operand1 (e *i 2) esize)
            let element3 ← (Elem_read operand2 ((e *i 2) +i 1) esize)
            let element4 ← (Elem_read operand1 (e *i 2) esize)
            (pure ()))
        else
          (do
            bif (b__0 == (0b01 : (BitVec 2)))
            then
              (do
                assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:13536.55-13536.56"
                let element1 ← (FPNeg (← (Elem_read operand2 ((e *i 2) +i 1) esize)))
                let element2 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                let element3 ← (Elem_read operand2 (e *i 2) esize)
                let element4 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                (pure ()))
            else
              (do
                bif (b__0 == (0b10 : (BitVec 2)))
                then
                  (do
                    assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:13543.55-13543.56"
                    let element1 ← (FPNeg (← (Elem_read operand2 (e *i 2) esize)))
                    let element2 ← (Elem_read operand1 (e *i 2) esize)
                    let element3 ← (FPNeg (← (Elem_read operand2 ((e *i 2) +i 1) esize)))
                    let element4 ← (Elem_read operand1 (e *i 2) esize)
                    (pure ()))
                else
                  (do
                    let element1 ← (Elem_read operand2 ((e *i 2) +i 1) esize)
                    let element2 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                    assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:13552.55-13552.56"
                    let element3 ← (FPNeg (← (Elem_read operand2 (e *i 2) esize)))
                    let element4 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                    (pure ()))))
        assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:13557.49-13557.50"
        let result ←
          (Elem_set result (e *i 2) esize
            (← (FPMulAdd (← (Elem_read operand3 (e *i 2) esize)) element2 element1 fpcr)))
        let result ←
          (Elem_set result ((e *i 2) +i 1) esize
            (← (FPMulAdd (← (Elem_read operand3 ((e *i 2) +i 1) esize)) element4 element3 fpcr)))
        (pure (element1, element2, element3, element4, result))
    (pure loop_vars) ) : SailM
    ((BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fcmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_complex (Rd : (BitVec 5)) (Rn : (BitVec 5)) (rot : (BitVec 2)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFCADDExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((Q == (0b0 : (BitVec 1))) && (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  bif ((! (HaveFP16Ext ())) && (esize == 16))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_complex d datasize elements esize
    m n rot)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, index : Nat, m : Nat, n
  : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3} ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_complex (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (rot : (BitVec 2)) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((fdiv_int elements 2) -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
        let element3 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
        let element4 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
        let b__0 := rot
        bif (b__0 == (0b00 : (BitVec 2)))
        then
          (do
            let element1 ← (Elem_read operand2 (index *i 2) esize)
            let element2 ← (Elem_read operand1 (e *i 2) esize)
            let element3 ← (Elem_read operand2 ((index *i 2) +i 1) esize)
            let element4 ← (Elem_read operand1 (e *i 2) esize)
            (pure ()))
        else
          (do
            bif (b__0 == (0b01 : (BitVec 2)))
            then
              (do
                assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:13623.55-13623.56"
                let element1 ← (FPNeg (← (Elem_read operand2 ((index *i 2) +i 1) esize)))
                let element2 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                let element3 ← (Elem_read operand2 (index *i 2) esize)
                let element4 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                (pure ()))
            else
              (do
                bif (b__0 == (0b10 : (BitVec 2)))
                then
                  (do
                    assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:13630.55-13630.56"
                    let element1 ← (FPNeg (← (Elem_read operand2 (index *i 2) esize)))
                    let element2 ← (Elem_read operand1 (e *i 2) esize)
                    let element3 ← (FPNeg (← (Elem_read operand2 ((index *i 2) +i 1) esize)))
                    let element4 ← (Elem_read operand1 (e *i 2) esize)
                    (pure ()))
                else
                  (do
                    let element1 ← (Elem_read operand2 ((index *i 2) +i 1) esize)
                    let element2 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                    assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:13639.55-13639.56"
                    let element3 ← (FPNeg (← (Elem_read operand2 (index *i 2) esize)))
                    let element4 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                    (pure ()))))
        let element4 := element4
        let element3 := element3
        let element2 := element2
        let element1 := element1
        assert (((esize == 16) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:13648.49-13648.50"
        let result ←
          (Elem_set result (e *i 2) esize
            (← (FPMulAdd (← (Elem_read operand3 (e *i 2) esize)) element2 element1 fpcr)))
        (Elem_set result ((e *i 2) +i 1) esize
          (← (FPMulAdd (← (Elem_read operand3 ((e *i 2) +i 1) esize)) element4 element3 fpcr)))
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_fcmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_complex (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (rot : (BitVec 2)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFCADDExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (M ++ Rm))
  let index ← (( do (undefined_int ()) ) : SailM Int )
  bif ((size == (0b00 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index : Int :=
    bif (size == (0b01 : (BitVec 2)))
    then (BitVec.toNat (H ++ L))
    else index
  let index : Int :=
    bif (size == (0b10 : (BitVec 2)))
    then (BitVec.toNat H)
    else index
  let index := index
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  bif ((! (HaveFP16Ext ())) && (esize == 16))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  bif ((size == (0b10 : (BitVec 2))) && ((L == (0b1 : (BitVec 1))) || (Q == (0b0 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (((size == (0b01 : (BitVec 2))) && (H == (0b1 : (BitVec 1)))) && (Q == (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  assert ((((index == 0) || (index == 1)) || (index == 2)) || (index == 3)) "src/instrs64.sail:13687.45-13687.46"
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_complex d datasize elements esize
    index m n rot)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd (comparison : CompareOp) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let zero ← (( do (FPZero (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element, result, test_passed) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, test_passed)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, test_passed) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let test_passed ← (( do
          match comparison with
          | CompareOp_GT =>
            (do
              (FPCompareGT element zero (← (FPCR_read ()))))
          | CompareOp_GE =>
            (do
              (FPCompareGE element zero (← (FPCR_read ()))))
          | CompareOp_EQ =>
            (do
              (FPCompareEQ element zero (← (FPCR_read ()))))
          | CompareOp_LE =>
            (do
              (FPCompareGE zero element (← (FPCR_read ()))))
          | CompareOp_LT =>
            (do
              (FPCompareGT zero element (← (FPCR_read ())))) ) : SailM Bool )
        let result ←
          (Elem_set result e esize
            (bif test_passed
            then (Ones (n := esize))
            else (Zeros (n := esize))))
        (pure (element, result, test_passed))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let comparison : CompareOp := CompareOp_LT
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd comparison d datasize
    elements esize n)

def decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let comparison : CompareOp := CompareOp_LT
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd comparison d datasize
    elements esize n)

def decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison : CompareOp := CompareOp_LT
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd comparison d datasize
    elements esize n)

def decode_fcmlt_advsimd_aarch64_instrs_vector_arithmetic_unary_cmp_float_lessthan_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let comparison : CompareOp := CompareOp_LT
  (execute_aarch64_instrs_vector_arithmetic_unary_cmp_fp16_lessthan_sisd comparison d datasize
    elements esize n)

/-- Type quantifiers: k_cmp_with_zero : Bool, datasize : Nat, m : Nat, n : Nat, k_signal_all_nans :
  Bool, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {16, 32, 64} -/
def execute_aarch64_instrs_float_compare_uncond (cmp_with_zero : Bool) (datasize : Nat) (m : Nat) (n : Nat) (signal_all_nans : Bool) : SailM Unit := do
  (CheckFPEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do
    bif cmp_with_zero
    then (FPZero (0b0 : (BitVec 1)) datasize)
    else (V_read m datasize) ) : SailM (BitVec datasize) )
  let split_vec ← do (FPCompare operand1 operand2 signal_all_nans (← (FPCR_read ())))
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }

def decode_fcmp_float_aarch64_instrs_float_compare_uncond (opc : (BitVec 2)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let datasize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let datasize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let datasize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let datasize := datasize
  let signal_all_nans : Bool := ((BitVec.join1 [(BitVec.access opc 1)]) == (0b1 : (BitVec 1)))
  let cmp_with_zero : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_float_compare_uncond cmp_with_zero datasize m n signal_all_nans)

def decode_fcmpe_float_aarch64_instrs_float_compare_uncond (opc : (BitVec 2)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let datasize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let datasize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let datasize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let datasize := datasize
  let signal_all_nans : Bool := ((BitVec.join1 [(BitVec.access opc 1)]) == (0b1 : (BitVec 1)))
  let cmp_with_zero : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_float_compare_uncond cmp_with_zero datasize m n signal_all_nans)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_move_fp_select (condition : (BitVec 4)) (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPEnabled64 ())
  let result ← (( do
    bif (← (ConditionHolds condition))
    then (V_read n datasize)
    else (V_read m datasize) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_fcsel_float_aarch64_instrs_float_move_fp_select (Rd : (BitVec 5)) (Rn : (BitVec 5)) (cond : (BitVec 4)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let datasize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let datasize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let datasize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let datasize := datasize
  let condition : (BitVec 4) := cond
  (execute_aarch64_instrs_float_move_fp_select condition d datasize m n)

/-- Type quantifiers: d : Nat, dstsize : Nat, n : Nat, srcsize : Nat, srcsize ∈ {16, 32, 64} ∧
  0 ≤ n ∧ n ≤ 31 ∧ dstsize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_convert_fp (d : Nat) (dstsize : Nat) (n : Nat) (srcsize : Nat) : SailM Unit := do
  (CheckFPEnabled64 ())
  let operand ← (( do (V_read n srcsize) ) : SailM (BitVec srcsize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let result ← (Elem_set result 0 dstsize (← (FPConvert__1 operand fpcr dstsize)))
  (V_set d 128 result)

def decode_fcvt_float_aarch64_instrs_float_convert_fp (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 2)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let srcsize : Int := 16
  let dstsize : Int := 16
  bif (ftype == opc)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let srcsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let srcsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (let srcsize : Int := 16
            (pure ()))))
  let srcsize := srcsize
  let b__3 := opc
  bif (b__3 == (0b00 : (BitVec 2)))
  then
    (let dstsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__3 == (0b01 : (BitVec 2)))
      then
        (let dstsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__3 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (let dstsize : Int := 16
            (pure ()))))
  let dstsize := dstsize
  (execute_aarch64_instrs_float_convert_fp d dstsize n srcsize)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, n
  : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ←
          (Elem_set result e esize (← (FPToFixed element 0 is_unsigned fpcr rounding esize)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let rounding : FPRounding := FPRounding_TIEAWAY
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let rounding : FPRounding := FPRounding_TIEAWAY
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding : FPRounding := FPRounding_TIEAWAY
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtas_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding : FPRounding := FPRounding_TIEAWAY
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let rounding : FPRounding := FPRounding_TIEAWAY
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let rounding : FPRounding := FPRounding_TIEAWAY
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding : FPRounding := FPRounding_TIEAWAY
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtau_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_tieaway_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding : FPRounding := FPRounding_TIEAWAY
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_tieaway_sisd d datasize elements
    esize n rounding is_unsigned)

/-- Type quantifiers: d : Nat, fltsize : Nat, intsize : Nat, k_is_unsigned : Bool, n : Nat, part :
  Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ intsize ∈ {32, 64} ∧ fltsize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_convert_int (d : Nat) (fltsize : Nat) (intsize : Nat) (n : Nat) (op : FPConvOp) (part : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  bif (BEq.beq op FPConvOp_CVT_FtoI_JS)
  then (CheckFPAdvSIMDEnabled64 ())
  else (CheckFPEnabled64 ())
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let fsize :=
    bif ((BEq.beq op FPConvOp_CVT_ItoF) && merge)
    then 128
    else fltsize
  let fltval ← (( do (undefined_bitvector fsize) ) : SailM (BitVec fsize) )
  let intval ← (( do (undefined_bitvector intsize) ) : SailM (BitVec intsize) )
  match op with
  | FPConvOp_CVT_FtoI =>
    (do
      let fltval ← (( do (V_read n fsize) ) : SailM (BitVec fsize) )
      assert ((((fsize == 16) || (fsize == 32)) || (fsize == 64)) && (((intsize == 16) || (intsize == 32)) || (intsize == 64))) "src/instrs64.sail:14270.80-14270.81"
      let intval ← (( do (FPToFixed fltval 0 is_unsigned fpcr rounding intsize) ) : SailM
        (BitVec intsize) )
      (X_set d intsize intval))
  | FPConvOp_CVT_ItoF =>
    (do
      let intval ← (( do (X_read n intsize) ) : SailM (BitVec intsize) )
      let fltval ← ((
        bif merge
        then (V_read d fsize)
        else (pure (Zeros (n := fsize))) ) : SailM (BitVec fsize) )
      assert ((((fltsize == 16) || (fltsize == 32)) || (fltsize == 64)) && (((intsize == 16) || (intsize == 32)) || (intsize == 64))) "src/instrs64.sail:14278.82-14278.83"
      let fltval ←
        (Elem_set fltval 0 fltsize (← (FixedToFP intval 0 is_unsigned fpcr rounding fltsize)))
      (V_set d fsize fltval))
  | FPConvOp_MOV_FtoI =>
    (do
      let fltval ← (( do (Vpart_read n part fsize) ) : SailM (BitVec fsize) )
      assert ((fsize ≥b 0) && (intsize ≥b fsize)) "src/instrs64.sail:14284.63-14284.64"
      let intval : (BitVec intsize) := (Sail.BitVec.zeroExtend fltval intsize)
      (X_set d intsize intval))
  | FPConvOp_MOV_ItoF =>
    (do
      let intval ← (( do (X_read n intsize) ) : SailM (BitVec intsize) )
      assert ((0 ≤b (fsize -i 1)) && ((fsize -i 1) <b intsize)) "src/instrs64.sail:14290.70-14290.71"
      let fltval : (BitVec fsize) := (Sail.BitVec.extractLsb intval (fsize -i 1) 0)
      (Vpart_set d part fsize fltval))
  | FPConvOp_CVT_FtoI_JS =>
    (do
      let z ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let fltval ← (( do (V_read n fsize) ) : SailM (BitVec fsize) )
      assert (fsize == 64) "src/instrs64.sail:14297.41-14297.42"
      assert (intsize == 32) "src/instrs64.sail:14298.43-14298.44"
      let (tup__0, tup__1) ← do (FPToFixedJS fltval fpcr true intsize)
      let intval : (BitVec intsize) := tup__0
      let z : (BitVec 1) := tup__1
      (pure ())
      let split_vec := (((0b0 : (BitVec 1)) ++ z) ++ (0b00 : (BitVec 2)))
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
      (X_set d intsize intval))

def decode_fcvtas_float_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:14400.22-14400.23"

def decode_fcvtau_float_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:14510.22-14510.23"

def decode_fcvtms_float_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:14620.22-14620.23"

def decode_fcvtmu_float_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:14730.22-14730.23"

def decode_fcvtns_float_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:14840.22-14840.23"

def decode_fcvtnu_float_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:14950.22-14950.23"

def decode_fcvtps_float_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:15060.22-15060.23"

def decode_fcvtpu_float_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:15170.22-15170.23"

def decode_fcvtzs_float_int_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:15280.22-15280.23"

def decode_fcvtzu_float_int_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:15390.22-15390.23"

def decode_fjcvtzs_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:15500.22-15500.23"

def decode_fmov_float_gen_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:15610.22-15610.23"

def decode_scvtf_float_int_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:15720.22-15720.23"

def decode_ucvtf_float_int_aarch64_instrs_float_convert_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let part : Int := 0
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (do
              bif (((Sail.BitVec.extractLsb opcode 2 1) ++ rmode) != (0xD : (BitVec 4)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let fltsize : Int := 128
              (pure ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif ((Sail.BitVec.extractLsb b__3 3 2) == (0b00 : (BitVec 2)))
  then
    (do
      let rounding ← (FPDecodeRounding rmode)
      let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
      let op : FPConvOp := FPConvOp_CVT_FtoI
      (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else
        (do
          bif (b__3 == (0x8 : (BitVec 4)))
          then
            (let rounding : FPRounding := FPRounding_TIEAWAY
            let is_unsigned : Bool :=
              ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
            let op : FPConvOp := FPConvOp_CVT_FtoI
            (pure ()))
          else
            (do
              bif (b__3 == (0xC : (BitVec 4)))
              then
                (do
                  bif ((fltsize != 16) && ((fltsize != intsize) : Bool))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let op : FPConvOp :=
                    bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                    then FPConvOp_MOV_ItoF
                    else FPConvOp_MOV_FtoI
                  let part : Int := 0
                  (pure ()))
              else
                (do
                  bif (b__3 == (0xD : (BitVec 4)))
                  then
                    (do
                      bif ((intsize != 64) || ((fltsize != 128) : Bool))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let op : FPConvOp :=
                        bif ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                        then FPConvOp_MOV_ItoF
                        else FPConvOp_MOV_FtoI
                      let part : Int := 1
                      let fltsize : Int := 64
                      (pure ()))
                  else
                    (do
                      bif (b__3 == (0xF : (BitVec 4)))
                      then
                        (do
                          bif (! (← (HaveFJCVTZSExt ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let rounding : FPRounding := FPRounding_ZERO
                          let is_unsigned : Bool :=
                            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
                          let op : FPConvOp := FPConvOp_CVT_FtoI_JS
                          (pure ()))
                      else sailThrow ((Error_Undefined ())))))))
  let op := op
  let part := part
  let fltsize := fltsize
  match fltsize with
  | 16 => (execute_aarch64_instrs_float_convert_int d 16 intsize n op part rounding is_unsigned)
  | 32 => (execute_aarch64_instrs_float_convert_int d 32 intsize n op part rounding is_unsigned)
  | 64 => (execute_aarch64_instrs_float_convert_int d 64 intsize n op part rounding is_unsigned)
  | 128 => (execute_aarch64_instrs_float_convert_int d 128 intsize n op part rounding is_unsigned)
  | _ => assert false "src/instrs64.sail:15830.22-15830.23"

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, part : Nat, part
  ∈ {0, 1} ∧
  0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {16, 32} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_float_widen (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e (2 *i esize)
          (← (FPConvert__1 (← (Elem_read operand e esize)) (← (FPCR_read ())) (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec (2 * datasize)) )
  (V_set d (2 *i datasize) result)

def decode_fcvtl_advsimd_aarch64_instrs_vector_arithmetic_unary_float_widen (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 16 (BitVec.toNat sz))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  assert ((esize == 16) || (esize == 32)) "src/instrs64.sail:15869.41-15869.42"
  (execute_aarch64_instrs_vector_arithmetic_unary_float_widen d datasize elements esize n part)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, n
  : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ←
          (Elem_set result e esize (← (FPToFixed element 0 is_unsigned fpcr rounding esize)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtms_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtmu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtns_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtnu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtps_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtpu_advsimd_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtzs_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

def decode_fcvtzu_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_float_bulk_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding ← (( do (FPDecodeRounding (o1 ++ o2)) ) : SailM FPRounding )
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_float_bulk_sisd d datasize elements
    esize n rounding is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, part : Nat, part
  ∈ {0, 1} ∧
  0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {16, 32} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_float_narrow (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize
          (← (FPConvert__1 (← (Elem_read operand e (2 *i esize))) (← (FPCR_read ())) esize)))
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (Vpart_set d part datasize result)

def decode_fcvtn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_narrow (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 16 (BitVec.toNat sz))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  assert ((esize == 16) || (esize == 32)) "src/instrs64.sail:16763.41-16763.42"
  (execute_aarch64_instrs_vector_arithmetic_unary_float_narrow d datasize elements esize n part)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Nat, esize : Nat, n : Nat, part : Nat, part
  ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ esize = 32 ∧ elements ∈ {1, 2} ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd (d : Nat) (datasize : Nat) (elements : Nat) (esize : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize
          (← (FPConvert (← (Elem_read operand e (2 *i esize))) fpcr FPRounding_ODD esize)))
    (pure loop_vars) ) : SailM (BitVec 128) )
  bif merge
  then (V_set d 128 result)
  else (Vpart_set d part datasize (← (Elem_read result 0 datasize)))

def decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (sz == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let datasize := esize
  let elements := 1
  let part := 0
  (execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd d datasize elements esize n part)

def decode_fcvtxn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_xtn_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (sz == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let datasize := 64
  let elements := 2
  let part := (BitVec.toNat Q)
  (execute_aarch64_instrs_vector_arithmetic_unary_float_xtn_sisd d datasize elements esize n part)

/-- Type quantifiers: d : Nat, fltsize : Nat, fracbits : Nat, intsize : Nat, k_is_unsigned : Bool, n
  : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  intsize ∈ {32, 64} ∧
  1 ≤ fracbits ∧ fracbits ≤ 64 ∧ fltsize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_convert_fix (d : Nat) (fltsize : Nat) (fracbits : Nat) (intsize : Nat) (n : Nat) (op : FPConvOp) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPEnabled64 ())
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let fsize :=
    bif ((BEq.beq op FPConvOp_CVT_ItoF) && merge)
    then 128
    else fltsize
  let fltval ← (( do (undefined_bitvector fsize) ) : SailM (BitVec fsize) )
  let intval ← (( do (undefined_bitvector intsize) ) : SailM (BitVec intsize) )
  match op with
  | FPConvOp_CVT_FtoI =>
    (do
      let fltval ← (( do (V_read n fsize) ) : SailM (BitVec fsize) )
      assert ((((fsize == 16) || (fsize == 32)) || (fsize == 64)) && (((intsize == 16) || (intsize == 32)) || (intsize == 64))) "src/instrs64.sail:16857.80-16857.81"
      let intval ← (( do (FPToFixed fltval fracbits is_unsigned fpcr rounding intsize) ) : SailM
        (BitVec intsize) )
      (X_set d intsize intval))
  | FPConvOp_CVT_ItoF =>
    (do
      let intval ← (( do (X_read n intsize) ) : SailM (BitVec intsize) )
      let fltval ← ((
        bif merge
        then (V_read d fsize)
        else (pure (Zeros (n := fsize))) ) : SailM (BitVec fsize) )
      let fltval ←
        (Elem_set fltval 0 fltsize
          (← (FixedToFP intval fracbits is_unsigned fpcr rounding fltsize)))
      (V_set d fsize fltval))
  | _ => (pure ())

def decode_fcvtzs_float_fix_aarch64_instrs_float_convert_fix (Rd : (BitVec 5)) (Rn : (BitVec 5)) (scale : (BitVec 6)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let fltsize := fltsize
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access scale 5)]) == (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let fracbits := (64 -i (BitVec.toNat scale))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif (b__3 == (0x3 : (BitVec 4)))
  then
    (let rounding : FPRounding := FPRounding_ZERO
    let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
    let op : FPConvOp := FPConvOp_CVT_FtoI
    (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else sailThrow ((Error_Undefined ())))
  (execute_aarch64_instrs_float_convert_fix d fltsize fracbits intsize n op rounding is_unsigned)

def decode_fcvtzu_float_fix_aarch64_instrs_float_convert_fix (Rd : (BitVec 5)) (Rn : (BitVec 5)) (scale : (BitVec 6)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let fltsize := fltsize
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access scale 5)]) == (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let fracbits := (64 -i (BitVec.toNat scale))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif (b__3 == (0x3 : (BitVec 4)))
  then
    (let rounding : FPRounding := FPRounding_ZERO
    let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
    let op : FPConvOp := FPConvOp_CVT_FtoI
    (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else sailThrow ((Error_Undefined ())))
  (execute_aarch64_instrs_float_convert_fix d fltsize fracbits intsize n op rounding is_unsigned)

def decode_scvtf_float_fix_aarch64_instrs_float_convert_fix (Rd : (BitVec 5)) (Rn : (BitVec 5)) (scale : (BitVec 6)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let fltsize := fltsize
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access scale 5)]) == (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let fracbits := (64 -i (BitVec.toNat scale))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif (b__3 == (0x3 : (BitVec 4)))
  then
    (let rounding : FPRounding := FPRounding_ZERO
    let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
    let op : FPConvOp := FPConvOp_CVT_FtoI
    (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else sailThrow ((Error_Undefined ())))
  (execute_aarch64_instrs_float_convert_fix d fltsize fracbits intsize n op rounding is_unsigned)

def decode_ucvtf_float_fix_aarch64_instrs_float_convert_fix (Rd : (BitVec 5)) (Rn : (BitVec 5)) (scale : (BitVec 6)) (opcode : (BitVec 3)) (rmode : (BitVec 2)) (ftype : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let intsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let fltsize : Int := 16
  let op ← (( do (undefined_FPConvOp ()) ) : SailM FPConvOp )
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let fltsize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let fltsize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let fltsize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let fltsize := fltsize
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access scale 5)]) == (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let fracbits := (64 -i (BitVec.toNat scale))
  let b__3 := ((Sail.BitVec.extractLsb opcode 2 1) ++ rmode)
  bif (b__3 == (0x3 : (BitVec 4)))
  then
    (let rounding : FPRounding := FPRounding_ZERO
    let is_unsigned : Bool := ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
    let op : FPConvOp := FPConvOp_CVT_FtoI
    (pure ()))
  else
    (do
      bif (b__3 == (0x4 : (BitVec 4)))
      then
        (do
          let rounding ← (FPRoundingMode (← (FPCR_read ())))
          let is_unsigned : Bool :=
            ((BitVec.join1 [(BitVec.access opcode 0)]) == (0b1 : (BitVec 1)))
          let op : FPConvOp := FPConvOp_CVT_ItoF
          (pure ()))
      else sailThrow ((Error_Undefined ())))
  (execute_aarch64_instrs_float_convert_fix d fltsize fracbits intsize n op rounding is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, fracbits : Int, k_is_unsigned
  : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_conv_float_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (fracbits : Int) (n : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ←
          (Elem_set result e esize
            (← (FPToFixed element fracbits is_unsigned fpcr rounding esize)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((let b__0 := immh
       bif ((Sail.BitVec.extractLsb b__0 3 1) == (0b000 : (BitVec 3)))
       then true
       else false : Bool) || ((let b__1 := immh
         bif ((Sail.BitVec.extractLsb b__1 3 1) == (0b001 : (BitVec 3)))
         then true
         else false : Bool) && (! (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize :=
    bif (let b__3 := immh
       bif ((Sail.BitVec.extractLsb b__3 3 3) == (0b1 : (BitVec 1)))
       then true
       else false : Bool)
    then 64
    else
      (bif (let b__2 := immh
         bif ((Sail.BitVec.extractLsb b__2 3 2) == (0b01 : (BitVec 2)))
         then true
         else false : Bool)
      then 32
      else 16)
  let datasize := esize
  let elements := 1
  let fracbits := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : FPRounding := FPRounding_ZERO
  (execute_aarch64_instrs_vector_shift_conv_float_sisd d datasize elements esize fracbits n rounding
    is_unsigned)

def decode_fcvtzs_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((let b__0 := immh
       bif ((Sail.BitVec.extractLsb b__0 3 1) == (0b000 : (BitVec 3)))
       then true
       else false : Bool) || ((let b__1 := immh
         bif ((Sail.BitVec.extractLsb b__1 3 1) == (0b001 : (BitVec 3)))
         then true
         else false : Bool) && (! (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize :=
    bif (let b__3 := immh
       bif ((Sail.BitVec.extractLsb b__3 3 3) == (0b1 : (BitVec 1)))
       then true
       else false : Bool)
    then 64
    else
      (bif (let b__2 := immh
         bif ((Sail.BitVec.extractLsb b__2 3 2) == (0b01 : (BitVec 2)))
         then true
         else false : Bool)
      then 32
      else 16)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let fracbits := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : FPRounding := FPRounding_ZERO
  (execute_aarch64_instrs_vector_shift_conv_float_sisd d datasize elements esize fracbits n rounding
    is_unsigned)

def decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((let b__0 := immh
       bif ((Sail.BitVec.extractLsb b__0 3 1) == (0b000 : (BitVec 3)))
       then true
       else false : Bool) || ((let b__1 := immh
         bif ((Sail.BitVec.extractLsb b__1 3 1) == (0b001 : (BitVec 3)))
         then true
         else false : Bool) && (! (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize :=
    bif (let b__3 := immh
       bif ((Sail.BitVec.extractLsb b__3 3 3) == (0b1 : (BitVec 1)))
       then true
       else false : Bool)
    then 64
    else
      (bif (let b__2 := immh
         bif ((Sail.BitVec.extractLsb b__2 3 2) == (0b01 : (BitVec 2)))
         then true
         else false : Bool)
      then 32
      else 16)
  let datasize := esize
  let elements := 1
  let fracbits := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : FPRounding := FPRounding_ZERO
  (execute_aarch64_instrs_vector_shift_conv_float_sisd d datasize elements esize fracbits n rounding
    is_unsigned)

def decode_fcvtzu_advsimd_fix_aarch64_instrs_vector_shift_conv_float_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((let b__0 := immh
       bif ((Sail.BitVec.extractLsb b__0 3 1) == (0b000 : (BitVec 3)))
       then true
       else false : Bool) || ((let b__1 := immh
         bif ((Sail.BitVec.extractLsb b__1 3 1) == (0b001 : (BitVec 3)))
         then true
         else false : Bool) && (! (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize :=
    bif (let b__3 := immh
       bif ((Sail.BitVec.extractLsb b__3 3 3) == (0b1 : (BitVec 1)))
       then true
       else false : Bool)
    then 64
    else
      (bif (let b__2 := immh
         bif ((Sail.BitVec.extractLsb b__2 3 2) == (0b01 : (BitVec 2)))
         then true
         else false : Bool)
      then 32
      else 16)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let fracbits := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : FPRounding := FPRounding_ZERO
  (execute_aarch64_instrs_vector_shift_conv_float_sisd d datasize elements esize fracbits n rounding
    is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let result ←
          (Elem_set result e esize (← (FPDiv element1 element2 (← (FPCR_read ())))))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 d datasize elements esize m n)

def decode_fdiv_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_div (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_div_fp16 d datasize elements esize m n)

/-- Type quantifiers: d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_arithmetic_div (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPEnabled64 ())
  let operand1 ← (( do (V_read n esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (V_read m esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read n 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let result ← (Elem_set result 0 esize (← (FPDiv operand1 operand2 (← (FPCR_read ())))))
  (V_set d 128 result)

def decode_fdiv_float_aarch64_instrs_float_arithmetic_div (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  (execute_aarch64_instrs_float_arithmetic_div d esize m n)

/-- Type quantifiers: a : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, k_op1_neg : Bool, k_opa_neg :
  Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 -/
def execute_aarch64_instrs_float_arithmetic_mul_add_sub (a : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (opa_neg : Bool) : SailM Unit := do
  (CheckFPEnabled64 ())
  let operanda ← (( do (V_read a esize) ) : SailM (BitVec esize) )
  let operand1 ← (( do (V_read n esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (V_read m esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read a 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let operanda ← (( do
    bif opa_neg
    then
      (do
        (FPNeg operanda))
    else (pure operanda) ) : SailM (BitVec esize) )
  let operand1 ← (( do
    bif op1_neg
    then
      (do
        (FPNeg operand1))
    else (pure operand1) ) : SailM (BitVec esize) )
  let result ← (Elem_set result 0 esize (← (FPMulAdd operanda operand1 operand2 fpcr)))
  (V_set d 128 result)

def decode_fmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (o0 : (BitVec 1)) (Rm : (BitVec 5)) (o1 : (BitVec 1)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let a := (BitVec.toNat Ra)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let opa_neg : Bool := (o1 == (0b1 : (BitVec 1)))
  let op1_neg : Bool := (o0 != o1)
  (execute_aarch64_instrs_float_arithmetic_mul_add_sub a d esize m n op1_neg opa_neg)

def decode_fmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (o0 : (BitVec 1)) (Rm : (BitVec 5)) (o1 : (BitVec 1)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let a := (BitVec.toNat Ra)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let opa_neg : Bool := (o1 == (0b1 : (BitVec 1)))
  let op1_neg : Bool := (o0 != o1)
  (execute_aarch64_instrs_float_arithmetic_mul_add_sub a d esize m n op1_neg opa_neg)

def decode_fnmadd_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (o0 : (BitVec 1)) (Rm : (BitVec 5)) (o1 : (BitVec 1)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let a := (BitVec.toNat Ra)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let opa_neg : Bool := (o1 == (0b1 : (BitVec 1)))
  let op1_neg : Bool := (o0 != o1)
  (execute_aarch64_instrs_float_arithmetic_mul_add_sub a d esize m n op1_neg opa_neg)

def decode_fnmsub_float_aarch64_instrs_float_arithmetic_mul_add_sub (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (o0 : (BitVec 1)) (Rm : (BitVec 5)) (o1 : (BitVec 1)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let a := (BitVec.toNat Ra)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let opa_neg : Bool := (o1 == (0b1 : (BitVec 1)))
  let op1_neg : Bool := (o0 != o1)
  (execute_aarch64_instrs_float_arithmetic_mul_add_sub a d esize m n op1_neg opa_neg)

/-- Type quantifiers: d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_arithmetic_max_min (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (operation : FPMaxMinOp) : SailM Unit := do
  (CheckFPEnabled64 ())
  let operand1 ← (( do (V_read n esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (V_read m esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read n 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let result ← (( do
    match operation with
    | FPMaxMinOp_MAX =>
      (do
        (Elem_set result 0 esize (← (FPMax operand1 operand2 fpcr))))
    | FPMaxMinOp_MIN =>
      (do
        (Elem_set result 0 esize (← (FPMin operand1 operand2 fpcr))))
    | FPMaxMinOp_MAXNUM =>
      (do
        (Elem_set result 0 esize (← (FPMaxNum operand1 operand2 fpcr))))
    | FPMaxMinOp_MINNUM =>
      (do
        (Elem_set result 0 esize (← (FPMinNum operand1 operand2 fpcr)))) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_fmax_float_aarch64_instrs_float_arithmetic_max_min (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 2)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let operation ← (( do (undefined_FPMaxMinOp ()) ) : SailM FPMaxMinOp )
  let _ : Unit :=
    let b__3 := op
    bif (b__3 == (0b00 : (BitVec 2)))
    then
      (let operation : FPMaxMinOp := FPMaxMinOp_MAX
      ())
    else
      (bif (b__3 == (0b01 : (BitVec 2)))
      then
        (let operation : FPMaxMinOp := FPMaxMinOp_MIN
        ())
      else
        (bif (b__3 == (0b10 : (BitVec 2)))
        then
          (let operation : FPMaxMinOp := FPMaxMinOp_MAXNUM
          ())
        else
          (let operation : FPMaxMinOp := FPMaxMinOp_MINNUM
          ())))
  let operation := operation
  (execute_aarch64_instrs_float_arithmetic_max_min d esize m n operation)

def decode_fmaxnm_float_aarch64_instrs_float_arithmetic_max_min (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 2)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let operation ← (( do (undefined_FPMaxMinOp ()) ) : SailM FPMaxMinOp )
  let _ : Unit :=
    let b__3 := op
    bif (b__3 == (0b00 : (BitVec 2)))
    then
      (let operation : FPMaxMinOp := FPMaxMinOp_MAX
      ())
    else
      (bif (b__3 == (0b01 : (BitVec 2)))
      then
        (let operation : FPMaxMinOp := FPMaxMinOp_MIN
        ())
      else
        (bif (b__3 == (0b10 : (BitVec 2)))
        then
          (let operation : FPMaxMinOp := FPMaxMinOp_MAXNUM
          ())
        else
          (let operation : FPMaxMinOp := FPMaxMinOp_MINNUM
          ())))
  let operation := operation
  (execute_aarch64_instrs_float_arithmetic_max_min d esize m n operation)

def decode_fmin_float_aarch64_instrs_float_arithmetic_max_min (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 2)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let operation ← (( do (undefined_FPMaxMinOp ()) ) : SailM FPMaxMinOp )
  let _ : Unit :=
    let b__3 := op
    bif (b__3 == (0b00 : (BitVec 2)))
    then
      (let operation : FPMaxMinOp := FPMaxMinOp_MAX
      ())
    else
      (bif (b__3 == (0b01 : (BitVec 2)))
      then
        (let operation : FPMaxMinOp := FPMaxMinOp_MIN
        ())
      else
        (bif (b__3 == (0b10 : (BitVec 2)))
        then
          (let operation : FPMaxMinOp := FPMaxMinOp_MAXNUM
          ())
        else
          (let operation : FPMaxMinOp := FPMaxMinOp_MINNUM
          ())))
  let operation := operation
  (execute_aarch64_instrs_float_arithmetic_max_min d esize m n operation)

def decode_fminnm_float_aarch64_instrs_float_arithmetic_max_min (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 2)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let operation ← (( do (undefined_FPMaxMinOp ()) ) : SailM FPMaxMinOp )
  let _ : Unit :=
    let b__3 := op
    bif (b__3 == (0b00 : (BitVec 2)))
    then
      (let operation : FPMaxMinOp := FPMaxMinOp_MAX
      ())
    else
      (bif (b__3 == (0b01 : (BitVec 2)))
      then
        (let operation : FPMaxMinOp := FPMaxMinOp_MIN
        ())
      else
        (bif (b__3 == (0b10 : (BitVec 2)))
        then
          (let operation : FPMaxMinOp := FPMaxMinOp_MAXNUM
          ())
        else
          (let operation : FPMaxMinOp := FPMaxMinOp_MINNUM
          ())))
  let operation := operation
  (execute_aarch64_instrs_float_arithmetic_max_min d esize m n operation)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, k_minimum :
  Bool, n : Nat, k_pair : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (minimum : Bool) (n : Nat) (pair : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let concat : (BitVec (2 * datasize)) := (operand2 ++ operand1)
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2) ← (( do
          bif pair
          then
            (do
              let element1 ← (Elem_read concat (2 *i e) esize)
              let element2 ← (Elem_read concat ((2 *i e) +i 1) esize)
              (pure (element1, element2)))
          else
            (do
              let element1 ← (Elem_read operand1 e esize)
              let element2 ← (Elem_read operand2 e esize)
              (pure (element1, element2))) ) : SailM ((BitVec esize) × (BitVec esize)) )
        let result ← (( do
          bif minimum
          then
            (do
              (Elem_set result e esize (← (FPMin element1 element2 (← (FPCR_read ()))))))
          else
            (do
              (Elem_set result e esize (← (FPMax element1 element2 (← (FPCR_read ())))))) ) :
          SailM (BitVec datasize) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 d datasize elements
    esize m minimum n pair)

def decode_fmax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 d datasize elements
    esize m minimum n pair)

def decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 d datasize elements
    esize m minimum n pair)

def decode_fmaxp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 d datasize elements
    esize m minimum n pair)

def decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 d datasize elements
    esize m minimum n pair)

def decode_fmin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 d datasize elements
    esize m minimum n pair)

def decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 d datasize elements
    esize m minimum n pair)

def decode_fminp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_1985 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_1985 d datasize elements
    esize m minimum n pair)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, k_minimum :
  Bool, n : Nat, k_pair : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (minimum : Bool) (n : Nat) (pair : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let concat : (BitVec (2 * datasize)) := (operand2 ++ operand1)
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2) ← (( do
          bif pair
          then
            (do
              let element1 ← (Elem_read concat (2 *i e) esize)
              let element2 ← (Elem_read concat ((2 *i e) +i 1) esize)
              (pure (element1, element2)))
          else
            (do
              let element1 ← (Elem_read operand1 e esize)
              let element2 ← (Elem_read operand2 e esize)
              (pure (element1, element2))) ) : SailM ((BitVec esize) × (BitVec esize)) )
        let result ← (( do
          bif minimum
          then
            (do
              (Elem_set result e esize (← (FPMinNum element1 element2 (← (FPCR_read ()))))))
          else
            (do
              (Elem_set result e esize (← (FPMaxNum element1 element2 (← (FPCR_read ())))))) ) :
          SailM (BitVec datasize) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (a : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (a == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 d datasize elements
    esize m minimum n pair)

def decode_fmaxnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 d datasize elements
    esize m minimum n pair)

def decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (a : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (a == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 d datasize elements
    esize m minimum n pair)

def decode_fmaxnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 d datasize elements
    esize m minimum n pair)

def decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (a : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (a == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 d datasize elements
    esize m minimum n pair)

def decode_fminnm_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 d datasize elements
    esize m minimum n pair)

def decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (a : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (a == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 d datasize elements
    esize m minimum n pair)

def decode_fminnmp_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp_2008 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let pair : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_fp16_2008 d datasize elements
    esize m minimum n pair)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd (d : Nat) (datasize : Nat) (esize : Nat) (n : Nat) (op : ReduceOp) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let altfp : Bool := false
  assert (datasize ≥b esize) "src/instrs64.sail:18425.42-18425.43"
  (V_set d esize (← (Reduce__1 op operand esize altfp)))

def decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMINNUM
    else ReduceOp_FMAXNUM
  (execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd d datasize esize n op)

def decode_fmaxnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMINNUM
    else ReduceOp_FMAXNUM
  (execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd d datasize esize n op)

def decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_maxnm_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMINNUM
    else ReduceOp_FMAXNUM
  (execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd d datasize esize n op)

def decode_fminnmp_advsimd_pair_aarch64_instrs_vector_reduce_fp_maxnm_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMINNUM
    else ReduceOp_FMAXNUM
  (execute_aarch64_instrs_vector_reduce_fp16_maxnm_sisd d datasize esize n op)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd (d : Nat) (datasize : Nat) (esize : Nat) (n : Nat) (op : ReduceOp) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let altfp : Bool := false
  (V_set d esize (← (Reduce__1 op operand esize altfp)))

def decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMINNUM
    else ReduceOp_FMAXNUM
  (execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd d datasize esize n op)

def decode_fmaxnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) != (0b01 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMINNUM
    else ReduceOp_FMAXNUM
  (execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd d datasize esize n op)

def decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp16_maxnm_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMINNUM
    else ReduceOp_FMAXNUM
  (execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd d datasize esize n op)

def decode_fminnmv_advsimd_aarch64_instrs_vector_reduce_fp_maxnm_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) != (0b01 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMINNUM
    else ReduceOp_FMAXNUM
  (execute_aarch64_instrs_vector_reduce_fp16_maxnm_simd d datasize esize n op)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_reduce_fp16_max_sisd (d : Nat) (datasize : Nat) (esize : Nat) (n : Nat) (op : ReduceOp) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  assert (datasize ≥b esize) "src/instrs64.sail:18641.42-18641.43"
  (V_set d esize (← (Reduce op operand esize)))

def decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMIN
    else ReduceOp_FMAX
  (execute_aarch64_instrs_vector_reduce_fp16_max_sisd d datasize esize n op)

def decode_fmaxp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMIN
    else ReduceOp_FMAX
  (execute_aarch64_instrs_vector_reduce_fp16_max_sisd d datasize esize n op)

def decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp16_max_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMIN
    else ReduceOp_FMAX
  (execute_aarch64_instrs_vector_reduce_fp16_max_sisd d datasize esize n op)

def decode_fminp_advsimd_pair_aarch64_instrs_vector_reduce_fp_max_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := (esize *i 2)
  let elements := 2
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMIN
    else ReduceOp_FMAX
  (execute_aarch64_instrs_vector_reduce_fp16_max_sisd d datasize esize n op)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_reduce_fp16_max_simd (d : Nat) (datasize : Nat) (esize : Nat) (n : Nat) (op : ReduceOp) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  (V_set d esize (← (Reduce op operand esize)))

def decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMIN
    else ReduceOp_FMAX
  (execute_aarch64_instrs_vector_reduce_fp16_max_simd d datasize esize n op)

def decode_fmaxv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) != (0b01 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMIN
    else ReduceOp_FMAX
  (execute_aarch64_instrs_vector_reduce_fp16_max_simd d datasize esize n op)

def decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp16_max_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMIN
    else ReduceOp_FMAX
  (execute_aarch64_instrs_vector_reduce_fp16_max_simd d datasize esize n op)

def decode_fminv_advsimd_aarch64_instrs_vector_reduce_fp_max_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (o1 : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) != (0b01 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let op : ReduceOp :=
    bif (o1 == (0b1 : (BitVec 1)))
    then ReduceOp_FMIN
    else ReduceOp_FMAX
  (execute_aarch64_instrs_vector_reduce_fp16_max_simd d datasize esize n op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Nat, m : Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m idxdsize) ) : SailM (BitVec idxdsize) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (Elem_read operand2 index esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element1 ← (( do
          bif sub_op
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec esize) )
        let result ←
          (Elem_set result e esize
            (← (FPMulAdd (← (Elem_read operand3 e esize)) element1 element2 fpcr)))
        (pure (element1, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 16
  let datasize := esize
  let elements := 1
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd d datasize elements
    esize idxdsize index m n sub_op)

def decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 3) ) : SailM Nat )
  let Rmhi : (BitVec 1) := M
  let b__0 := (sz ++ L)
  bif ((Sail.BitVec.extractLsb b__0 1 1) == (0b0 : (BitVec 1)))
  then
    (let index : Nat := (BitVec.toNat (H ++ L))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat H)
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd d datasize elements
    esize idxdsize index m n sub_op)

def decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd d datasize elements
    esize idxdsize index m n sub_op)

def decode_fmla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 3) ) : SailM Nat )
  let Rmhi : (BitVec 1) := M
  let b__0 := (sz ++ L)
  bif ((Sail.BitVec.extractLsb b__0 1 1) == (0b0 : (BitVec 1)))
  then
    (let index : Nat := (BitVec.toNat (H ++ L))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat H)
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd d datasize elements
    esize idxdsize index m n sub_op)

def decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 16
  let datasize := esize
  let elements := 1
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd d datasize elements
    esize idxdsize index m n sub_op)

def decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 3) ) : SailM Nat )
  let Rmhi : (BitVec 1) := M
  let b__0 := (sz ++ L)
  bif ((Sail.BitVec.extractLsb b__0 1 1) == (0b0 : (BitVec 1)))
  then
    (let index : Nat := (BitVec.toNat (H ++ L))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat H)
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd d datasize elements
    esize idxdsize index m n sub_op)

def decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd d datasize elements
    esize idxdsize index m n sub_op)

def decode_fmls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 3) ) : SailM Nat )
  let Rmhi : (BitVec 1) := M
  let b__0 := (sz ++ L)
  bif ((Sail.BitVec.extractLsb b__0 1 1) == (0b0 : (BitVec 1)))
  then
    (let index : Nat := (BitVec.toNat (H ++ L))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat H)
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_fp16_sisd d datasize elements
    esize idxdsize index m n sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, k_sub_op
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let element1 ← (( do
          bif sub_op
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec esize) )
        let result ←
          (Elem_set result e esize
            (← (FPMulAdd (← (Elem_read operand3 e esize)) element1 element2 (← (FPCR_read ())))))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (a : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (a == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused d datasize elements esize
    m n sub_op)

def decode_fmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (op : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused d datasize elements esize
    m n sub_op)

def decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (a : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (a == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused d datasize elements esize
    m n sub_op)

def decode_fmls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_fused (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (op : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_fused d datasize elements esize
    m n sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, index : Nat, m : Nat, n
  : Nat, part : Nat, k_sub_op : Bool, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (part : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part (Int.ediv datasize 2)) ) : SailM (BitVec (datasize / 2))
    )
  let operand2 ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector (Int.ediv esize 2)) ) : SailM (BitVec (esize / 2)) )
  let element2 ← (( do (Elem_read operand2 index (Int.ediv esize 2)) ) : SailM
    (BitVec (esize / 2)) )
  let (element1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e (Int.ediv esize 2))
        let element1 ← (( do
          bif sub_op
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec (esize / 2)) )
        let result ←
          (Elem_set result e esize
            (← (FPMulAddH (← (Elem_read operand3 e esize)) element1 element2
                (← (FPCR_read ())))))
        (pure (element1, result))
    (pure loop_vars) ) : SailM ((BitVec (esize / 2)) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (S : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Rm))
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 32
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  let part := 0
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower d datasize
    elements esize index m n part sub_op)

def decode_fmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (S : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Rm))
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 32
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  let part := 1
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower d datasize
    elements esize index m n part sub_op)

def decode_fmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (S : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Rm))
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 32
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  let part := 0
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower d datasize
    elements esize index m n part sub_op)

def decode_fmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_upper (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (S : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat ((0b0 : (BitVec 1)) ++ Rm))
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 32
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  let part := 1
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_mul_norounding_i_lower d datasize
    elements esize index m n part sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, part :
  Nat, k_sub_op : Bool, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part (Int.ediv datasize 2)) ) : SailM (BitVec (datasize / 2))
    )
  let operand2 ← (( do (Vpart_read m part (Int.ediv datasize 2)) ) : SailM (BitVec (datasize / 2))
    )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector (Int.ediv esize 2)) ) : SailM (BitVec (esize / 2)) )
  let element2 ← (( do (undefined_bitvector (Int.ediv esize 2)) ) : SailM (BitVec (esize / 2)) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e (Int.ediv esize 2))
        let element2 ← (Elem_read operand2 e (Int.ediv esize 2))
        let element1 ← (( do
          bif sub_op
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec (esize / 2)) )
        let result ←
          (Elem_set result e esize
            (← (FPMulAddH (← (Elem_read operand3 e esize)) element1 element2
                (← (FPCR_read ())))))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec (esize / 2)) × (BitVec (esize / 2)) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (S : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  let part := 0
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower d datasize
    elements esize m n part sub_op)

def decode_fmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (S : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  let part := 1
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower d datasize
    elements esize m n part sub_op)

def decode_fmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (S : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  let part := 0
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower d datasize
    elements esize m n part sub_op)

def decode_fmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_upper (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (S : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  let part := 1
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_mul_norounding_lower d datasize
    elements esize m n part sub_op)

/-- Type quantifiers: datasize : Nat, rd : Nat, 0 ≤ rd ∧ rd ≤ 31 ∧ datasize ∈ {64, 128} -/
def execute_aarch64_instrs_vector_fp16_movi (datasize : Nat) (imm : (BitVec datasize)) (rd : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  (V_set rd datasize imm)

def decode_fmov_advsimd_aarch64_instrs_vector_fp16_movi (Rd : (BitVec 5)) (h : (BitVec 1)) (g : (BitVec 1)) (f : (BitVec 1)) (e : (BitVec 1)) (d : (BitVec 1)) (c : (BitVec 1)) (b : (BitVec 1)) (a : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rd := (BitVec.toNat Rd)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let imm8 : (BitVec 8) := (((((((a ++ b) ++ c) ++ d) ++ e) ++ f) ++ g) ++ h)
  let imm16 : (BitVec 16) :=
    (((((BitVec.join1 [(BitVec.access imm8 7)]) ++ (Complement.complement
              (BitVec.join1 [(BitVec.access imm8 6)]))) ++ (BitVec.replicateBits
            (BitVec.join1 [(BitVec.access imm8 6)]) 2)) ++ (Sail.BitVec.extractLsb imm8 5 0)) ++ (Zeros
        (n := 6)))
  let imm : (BitVec datasize) := (BitVec.replicateBits imm16 (Int.ediv datasize 16))
  (execute_aarch64_instrs_vector_fp16_movi datasize imm rd)

def decode_fmov_advsimd_aarch64_instrs_vector_logical (Rd : (BitVec 5)) (h : (BitVec 1)) (g : (BitVec 1)) (f : (BitVec 1)) (e : (BitVec 1)) (d : (BitVec 1)) (cmode : (BitVec 4)) (c : (BitVec 1)) (b : (BitVec 1)) (a : (BitVec 1)) (op : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let rd := (BitVec.toNat Rd)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let operation ← (( do (undefined_ImmediateOp ()) ) : SailM ImmediateOp )
  let b__0 := (cmode ++ op)
  bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb b__0 1
           0) == (0b00 : (BitVec 2))))
  then
    (let operation : ImmediateOp := ImmediateOp_MOVI
    (pure ()))
  else
    (do
      bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
               b__0 1 0) == (0b01 : (BitVec 2))))
      then
        (let operation : ImmediateOp := ImmediateOp_MVNI
        (pure ()))
      else
        (do
          bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                   b__0 1 0) == (0b10 : (BitVec 2))))
          then
            (let operation : ImmediateOp := ImmediateOp_ORR
            (pure ()))
          else
            (do
              bif (((Sail.BitVec.extractLsb b__0 4 4) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                       b__0 1 0) == (0b11 : (BitVec 2))))
              then
                (let operation : ImmediateOp := ImmediateOp_BIC
                (pure ()))
              else
                (do
                  bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                           b__0 1 0) == (0b00 : (BitVec 2))))
                  then
                    (let operation : ImmediateOp := ImmediateOp_MOVI
                    (pure ()))
                  else
                    (do
                      bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                               b__0 1 0) == (0b01 : (BitVec 2))))
                      then
                        (let operation : ImmediateOp := ImmediateOp_MVNI
                        (pure ()))
                      else
                        (do
                          bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                                   b__0 1 0) == (0b10 : (BitVec 2))))
                          then
                            (let operation : ImmediateOp := ImmediateOp_ORR
                            (pure ()))
                          else
                            (do
                              bif (((Sail.BitVec.extractLsb b__0 4 3) == (0b10 : (BitVec 2))) && ((Sail.BitVec.extractLsb
                                       b__0 1 0) == (0b11 : (BitVec 2))))
                              then
                                (let operation : ImmediateOp := ImmediateOp_BIC
                                (pure ()))
                              else
                                (do
                                  bif (((Sail.BitVec.extractLsb b__0 4 2) == (0b110 : (BitVec 3))) && ((Sail.BitVec.extractLsb
                                           b__0 0 0) == (0b0 : (BitVec 1))))
                                  then
                                    (let operation : ImmediateOp := ImmediateOp_MOVI
                                    (pure ()))
                                  else
                                    (do
                                      bif (((Sail.BitVec.extractLsb b__0 4 2) == (0b110 : (BitVec 3))) && ((Sail.BitVec.extractLsb
                                               b__0 0 0) == (0b1 : (BitVec 1))))
                                      then
                                        (let operation : ImmediateOp := ImmediateOp_MVNI
                                        (pure ()))
                                      else
                                        (do
                                          bif ((Sail.BitVec.extractLsb b__0 4 1) == (0xE : (BitVec 4)))
                                          then
                                            (let operation : ImmediateOp := ImmediateOp_MOVI
                                            (pure ()))
                                          else
                                            (do
                                              bif (b__0 == (0b11110 : (BitVec 5)))
                                              then
                                                (let operation : ImmediateOp := ImmediateOp_MOVI
                                                (pure ()))
                                              else
                                                (do
                                                  bif (Q == (0b0 : (BitVec 1)))
                                                  then sailThrow ((Error_Undefined ()))
                                                  else (pure ())
                                                  let operation : ImmediateOp := ImmediateOp_MOVI
                                                  (pure ())))))))))))))
  let operation := operation
  let imm64 ← (( do (AdvSIMDExpandImm op cmode (((((((a ++ b) ++ c) ++ d) ++ e) ++ f) ++ g) ++ h))
    ) : SailM (BitVec 64) )
  let imm : (BitVec datasize) := (BitVec.replicateBits imm64 (Int.ediv datasize 64))
  (execute_aarch64_instrs_vector_fp16_movi datasize imm rd)

/-- Type quantifiers: d : Nat, datasize : Nat, datasize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_move_fp_imm (d : Nat) (datasize : Nat) (imm : (BitVec datasize)) : SailM Unit := do
  (CheckFPEnabled64 ())
  (V_set d datasize imm)

def decode_fmov_float_imm_aarch64_instrs_float_move_fp_imm (Rd : (BitVec 5)) (imm8 : (BitVec 8)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let datasize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let datasize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let datasize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let datasize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let datasize := datasize
  let imm ← (( do (VFPExpandImm imm8 datasize) ) : SailM (BitVec datasize) )
  (execute_aarch64_instrs_float_move_fp_imm d datasize imm)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let result ←
          (Elem_set result e esize (← (FPMul element1 element2 (← (FPCR_read ())))))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product d datasize elements
    esize m n)

def decode_fmul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_product (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_product d datasize elements
    esize m n)

/-- Type quantifiers: d : Nat, esize : Nat, m : Nat, n : Nat, k_negated : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_arithmetic_mul_product (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (negated : Bool) : SailM Unit := do
  (CheckFPEnabled64 ())
  let operand1 ← (( do (V_read n esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (V_read m esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read n 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let product ← (( do (FPMul operand1 operand2 fpcr) ) : SailM (BitVec esize) )
  let product ← (( do
    bif negated
    then
      (do
        (FPNeg product))
    else (pure product) ) : SailM (BitVec esize) )
  let result ← (Elem_set result 0 esize product)
  (V_set d 128 result)

def decode_fmul_float_aarch64_instrs_float_arithmetic_mul_product (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let negated : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_float_arithmetic_mul_product d esize m n negated)

def decode_fnmul_float_aarch64_instrs_float_arithmetic_mul_product (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let negated : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_float_arithmetic_mul_product d esize m n negated)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Nat, m : Nat, k_mulx_op : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Nat) (m : Nat) (mulx_op : Bool) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m idxdsize) ) : SailM (BitVec idxdsize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (Elem_read operand2 index esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read n 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let result ← (( do
          bif mulx_op
          then
            (do
              (Elem_set result e esize (← (FPMulX element1 element2 fpcr))))
          else
            (do
              (Elem_set result e esize (← (FPMul element1 element2 fpcr)))) ) : SailM (BitVec 128)
          )
        (pure (element1, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 16
  let datasize := esize
  let elements := 1
  let mulx_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd d datasize elements esize
    idxdsize index m mulx_op n)

def decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 3) ) : SailM Nat )
  let Rmhi : (BitVec 1) := M
  let b__0 := (sz ++ L)
  bif ((Sail.BitVec.extractLsb b__0 1 1) == (0b0 : (BitVec 1)))
  then
    (let index : Nat := (BitVec.toNat (H ++ L))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat H)
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let mulx_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd d datasize elements esize
    idxdsize index m mulx_op n)

def decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let mulx_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd d datasize elements esize
    idxdsize index m mulx_op n)

def decode_fmul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 3) ) : SailM Nat )
  let Rmhi : (BitVec 1) := M
  let b__0 := (sz ++ L)
  bif ((Sail.BitVec.extractLsb b__0 1 1) == (0b0 : (BitVec 1)))
  then
    (let index : Nat := (BitVec.toNat (H ++ L))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat H)
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let mulx_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd d datasize elements esize
    idxdsize index m mulx_op n)

def decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 16
  let datasize := esize
  let elements := 1
  let mulx_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd d datasize elements esize
    idxdsize index m mulx_op n)

def decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 3) ) : SailM Nat )
  let Rmhi : (BitVec 1) := M
  let b__0 := (sz ++ L)
  bif ((Sail.BitVec.extractLsb b__0 1 1) == (0b0 : (BitVec 1)))
  then
    (let index : Nat := (BitVec.toNat (H ++ L))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat H)
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let mulx_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd d datasize elements esize
    idxdsize index m mulx_op n)

def decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  let index := (BitVec.toNat ((H ++ L) ++ M))
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let mulx_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd d datasize elements esize
    idxdsize index m mulx_op n)

def decode_fmulx_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 3) ) : SailM Nat )
  let Rmhi : (BitVec 1) := M
  let b__0 := (sz ++ L)
  bif ((Sail.BitVec.extractLsb b__0 1 1) == (0b0 : (BitVec 1)))
  then
    (let index : Nat := (BitVec.toNat (H ++ L))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat H)
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let mulx_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_fp16_sisd d datasize elements esize
    idxdsize index m mulx_op n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  bif (elements == 1)
  then (CheckFPEnabled64 ())
  else (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read n 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let result ← (Elem_set result e esize (← (FPMulX element1 element2 fpcr)))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize := esize
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd d datasize
    elements esize m n)

def decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd d datasize
    elements esize m n)

def decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd d datasize
    elements esize m n)

def decode_fmulx_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp_extended_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_fp16_extended_sisd d datasize
    elements esize m n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) : SailM Unit := do
  bif (elements == 1)
  then (CheckFPEnabled64 ())
  else (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ←
          (Elem_set result e esize (← (FPRecipEstimate element (← (FPCR_read ())))))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd d datasize elements esize
    n)

def decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd d datasize elements esize
    n)

def decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd d datasize elements esize
    n)

def decode_frecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_float_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_special_recip_fp16_sisd d datasize elements esize
    n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  bif (elements == 1)
  then (CheckFPEnabled64 ())
  else (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read n 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let result ← (Elem_set result e esize (← (FPRecipStepFused element1 element2)))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize := esize
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd d datasize elements esize
    m n)

def decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd d datasize elements esize
    m n)

def decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd d datasize elements esize
    m n)

def decode_frecps_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_recps_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_recps_fp16_sisd d datasize elements esize
    m n)

/-- Type quantifiers: d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPEnabled64 ())
  let operand ← (( do (V_read n esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let result ← (Elem_set result 0 esize (← (FPRecpX operand fpcr)))
  (V_set d 128 result)

def decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 (Rd : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  (execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 d esize n)

def decode_frecpx_advsimd_aarch64_instrs_vector_arithmetic_unary_special_frecpx (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  (execute_aarch64_instrs_vector_arithmetic_unary_special_frecpx_fp16 d esize n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, intsize : Nat, n : Nat, 0
  ≤ n ∧
  n ≤ 31 ∧
  intsize ∈ {32, 64} ∧ esize ∈ {32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (intsize : Nat) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ←
          (Elem_set result e esize (← (FPRoundIntN element (← (FPCR_read ())) rounding intsize)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_frint32x_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFrintExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let intsize :=
    bif (op == (0b0 : (BitVec 1)))
    then 32
    else 64
  let rounding ← (( do
    bif (U == (0b0 : (BitVec 1)))
    then (pure FPRounding_ZERO)
    else (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 d datasize elements esize
    intsize n rounding)

def decode_frint32z_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFrintExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let intsize :=
    bif (op == (0b0 : (BitVec 1)))
    then 32
    else 64
  let rounding ← (( do
    bif (U == (0b0 : (BitVec 1)))
    then (pure FPRounding_ZERO)
    else (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 d datasize elements esize
    intsize n rounding)

def decode_frint64x_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFrintExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let intsize :=
    bif (op == (0b0 : (BitVec 1)))
    then 32
    else 64
  let rounding ← (( do
    bif (U == (0b0 : (BitVec 1)))
    then (pure FPRounding_ZERO)
    else (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 d datasize elements esize
    intsize n rounding)

def decode_frint64z_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveFrintExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let intsize :=
    bif (op == (0b0 : (BitVec 1)))
    then 32
    else 64
  let rounding ← (( do
    bif (U == (0b0 : (BitVec 1)))
    then (pure FPRounding_ZERO)
    else (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_vector_arithmetic_unary_float_round_frint_32_64 d datasize elements esize
    intsize n rounding)

/-- Type quantifiers: d : Nat, esize : Nat, intsize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ intsize ∈ {32, 64} ∧ esize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_arithmetic_round_frint_32_64 (d : Nat) (esize : Nat) (intsize : Nat) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckFPEnabled64 ())
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let operand ← (( do (V_read n esize) ) : SailM (BitVec esize) )
  let result ← (Elem_set result 0 esize (← (FPRoundIntN operand fpcr rounding intsize)))
  (V_set d 128 result)

def decode_frint32x_float_aarch64_instrs_float_arithmetic_round_frint_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 2)) (ftype : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFrintExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 32
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let esize := esize
  let intsize :=
    bif ((BitVec.join1 [(BitVec.access op 1)]) == (0b0 : (BitVec 1)))
    then 32
    else 64
  let rounding ← (( do
    bif ((BitVec.join1 [(BitVec.access op 0)]) == (0b0 : (BitVec 1)))
    then (pure FPRounding_ZERO)
    else (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_float_arithmetic_round_frint_32_64 d esize intsize n rounding)

def decode_frint32z_float_aarch64_instrs_float_arithmetic_round_frint_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 2)) (ftype : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFrintExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 32
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let esize := esize
  let intsize :=
    bif ((BitVec.join1 [(BitVec.access op 1)]) == (0b0 : (BitVec 1)))
    then 32
    else 64
  let rounding ← (( do
    bif ((BitVec.join1 [(BitVec.access op 0)]) == (0b0 : (BitVec 1)))
    then (pure FPRounding_ZERO)
    else (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_float_arithmetic_round_frint_32_64 d esize intsize n rounding)

def decode_frint64x_float_aarch64_instrs_float_arithmetic_round_frint_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 2)) (ftype : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFrintExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 32
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let esize := esize
  let intsize :=
    bif ((BitVec.join1 [(BitVec.access op 1)]) == (0b0 : (BitVec 1)))
    then 32
    else 64
  let rounding ← (( do
    bif ((BitVec.join1 [(BitVec.access op 0)]) == (0b0 : (BitVec 1)))
    then (pure FPRounding_ZERO)
    else (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_float_arithmetic_round_frint_32_64 d esize intsize n rounding)

def decode_frint64z_float_aarch64_instrs_float_arithmetic_round_frint_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 2)) (ftype : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFrintExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 32
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let esize := esize
  let intsize :=
    bif ((BitVec.join1 [(BitVec.access op 1)]) == (0b0 : (BitVec 1)))
    then 32
    else 64
  let rounding ← (( do
    bif ((BitVec.join1 [(BitVec.access op 0)]) == (0b0 : (BitVec 1)))
    then (pure FPRounding_ZERO)
    else (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_float_arithmetic_round_frint_32_64 d esize intsize n rounding)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_exact : Bool, n : Nat, 0
  ≤ n ∧ n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_fp16_round (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (exact : Bool) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ←
          (Elem_set result e esize (← (FPRoundInt element (← (FPCR_read ())) rounding exact)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frinta_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frinti_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frintm_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frintn_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frintp_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frintx_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_fp16_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

def decode_frintz_advsimd_aarch64_instrs_vector_arithmetic_unary_float_round (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (sz : (BitVec 1)) (o2 : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__0 := ((U ++ o1) ++ o2)
  bif ((Sail.BitVec.extractLsb b__0 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (o1 ++ o2))
      (pure ()))
  else
    (do
      bif (b__0 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__0 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__0 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_round d datasize elements esize exact n
    rounding)

/-- Type quantifiers: d : Nat, esize : Nat, k_exact : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_float_arithmetic_round_frint (d : Nat) (esize : Nat) (exact : Bool) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckFPEnabled64 ())
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (IsMerging fpcr) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let operand ← (( do (V_read n esize) ) : SailM (BitVec esize) )
  let result ← (Elem_set result 0 esize (← (FPRoundInt operand fpcr rounding exact)))
  (V_set d 128 result)

def decode_frinta_float_aarch64_instrs_float_arithmetic_round_frint (Rd : (BitVec 5)) (Rn : (BitVec 5)) (rmode : (BitVec 3)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__3 := rmode
  bif ((Sail.BitVec.extractLsb b__3 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (Sail.BitVec.extractLsb rmode 1 0))
      (pure ()))
  else
    (do
      bif (b__3 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__3 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__3 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_float_arithmetic_round_frint d esize exact n rounding)

def decode_frinti_float_aarch64_instrs_float_arithmetic_round_frint (Rd : (BitVec 5)) (Rn : (BitVec 5)) (rmode : (BitVec 3)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__3 := rmode
  bif ((Sail.BitVec.extractLsb b__3 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (Sail.BitVec.extractLsb rmode 1 0))
      (pure ()))
  else
    (do
      bif (b__3 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__3 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__3 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_float_arithmetic_round_frint d esize exact n rounding)

def decode_frintm_float_aarch64_instrs_float_arithmetic_round_frint (Rd : (BitVec 5)) (Rn : (BitVec 5)) (rmode : (BitVec 3)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__3 := rmode
  bif ((Sail.BitVec.extractLsb b__3 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (Sail.BitVec.extractLsb rmode 1 0))
      (pure ()))
  else
    (do
      bif (b__3 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__3 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__3 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_float_arithmetic_round_frint d esize exact n rounding)

def decode_frintn_float_aarch64_instrs_float_arithmetic_round_frint (Rd : (BitVec 5)) (Rn : (BitVec 5)) (rmode : (BitVec 3)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__3 := rmode
  bif ((Sail.BitVec.extractLsb b__3 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (Sail.BitVec.extractLsb rmode 1 0))
      (pure ()))
  else
    (do
      bif (b__3 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__3 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__3 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_float_arithmetic_round_frint d esize exact n rounding)

def decode_frintp_float_aarch64_instrs_float_arithmetic_round_frint (Rd : (BitVec 5)) (Rn : (BitVec 5)) (rmode : (BitVec 3)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__3 := rmode
  bif ((Sail.BitVec.extractLsb b__3 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (Sail.BitVec.extractLsb rmode 1 0))
      (pure ()))
  else
    (do
      bif (b__3 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__3 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__3 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_float_arithmetic_round_frint d esize exact n rounding)

def decode_frintx_float_aarch64_instrs_float_arithmetic_round_frint (Rd : (BitVec 5)) (Rn : (BitVec 5)) (rmode : (BitVec 3)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__3 := rmode
  bif ((Sail.BitVec.extractLsb b__3 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (Sail.BitVec.extractLsb rmode 1 0))
      (pure ()))
  else
    (do
      bif (b__3 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__3 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__3 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_float_arithmetic_round_frint d esize exact n rounding)

def decode_frintz_float_aarch64_instrs_float_arithmetic_round_frint (Rd : (BitVec 5)) (Rn : (BitVec 5)) (rmode : (BitVec 3)) (ftype : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize : Int := 16
  let b__0 := ftype
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let esize : Int := 32
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (HaveFP16Ext ())
              then
                (let esize : Int := 16
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let esize := esize
  let exact : Bool := false
  let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
  let b__3 := rmode
  bif ((Sail.BitVec.extractLsb b__3 2 2) == (0b0 : (BitVec 1)))
  then
    (do
      let rounding ← (FPDecodeRounding (Sail.BitVec.extractLsb rmode 1 0))
      (pure ()))
  else
    (do
      bif (b__3 == (0b100 : (BitVec 3)))
      then
        (let rounding : FPRounding := FPRounding_TIEAWAY
        (pure ()))
      else
        (do
          bif (b__3 == (0b101 : (BitVec 3)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              bif (b__3 == (0b110 : (BitVec 3)))
              then
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  let exact : Bool := true
                  (pure ()))
              else
                (do
                  let rounding ← (FPRoundingMode (← (FPCR_read ())))
                  (pure ())))))
  let rounding := rounding
  (execute_aarch64_instrs_float_arithmetic_round_frint d esize exact n rounding)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) : SailM Unit := do
  bif (elements == 1)
  then (CheckFPEnabled64 ())
  else (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ← (Elem_set result e esize (← (FPRSqrtEstimate element fpcr)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd d datasize elements
    esize n)

def decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd d datasize elements
    esize n)

def decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd d datasize elements
    esize n)

def decode_frsqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_float_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_fp16_sisd d datasize elements
    esize n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  bif (elements == 1)
  then (CheckFPEnabled64 ())
  else (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read n 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let result ← (Elem_set result e esize (← (FPRSqrtStepFused element1 element2)))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize := esize
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd d datasize elements
    esize m n)

def decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd d datasize elements
    esize m n)

def decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd d datasize elements
    esize m n)

def decode_frsqrts_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_rsqrts_fp16_sisd d datasize elements
    esize m n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ← (Elem_set result e esize (← (FPSqrt element (← (FPCR_read ())))))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 d datasize elements esize n)

def decode_fsqrt_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_fp16 d datasize elements esize n)

/-- Type quantifiers: k_abs : Bool, d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n
  : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd (abs : Bool) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let diff ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let (diff, element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (diff, element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (diff, element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let diff ← (FPSub element1 element2 fpcr)
        let result ←
          (Elem_set result e esize
            (← do
              bif abs
              then (FPAbs diff)
              else (pure diff)))
        (pure (diff, element1, element2, result))
    (pure loop_vars) ) : SailM
    ((BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let abs : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd abs d datasize elements
    esize m n)

def decode_fsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let abs : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_fp16_simd abs d datasize elements
    esize m n)

/-- Type quantifiers: k_is_gcssttr : Bool, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_gcs_general_register (is_gcssttr : Bool) (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let effective_el ← (( do
    bif ((! is_gcssttr) || (← (AArch64_IsUnprivAccessPriv ())))
    then (pure (← readReg PSTATE).EL)
    else (pure EL0) ) : SailM (BitVec 2) )
  bif (effective_el == (← readReg PSTATE).EL)
  then (CheckGCSSTREnabled ())
  else (pure ())
  let accdesc ← (( do (CreateAccDescGCS effective_el MemOp_STORE) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let data ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  (Mem_set address 8 accdesc data)

def decode_gcsstr_aarch64_instrs_memory_gcs_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) : SailM Unit := do
  bif (! (← (HaveGCS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let is_gcssttr : Bool := (opc == (0b001 : (BitVec 3)))
  (execute_aarch64_instrs_memory_gcs_general_register is_gcssttr n t)

def decode_gcssttr_aarch64_instrs_memory_gcs_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) : SailM Unit := do
  bif (! (← (HaveGCS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let is_gcssttr : Bool := (opc == (0b001 : (BitVec 3)))
  (execute_aarch64_instrs_memory_gcs_general_register is_gcssttr n t)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcinserttagmask (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let address ← (( do
    bif (n == 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let mask ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let tag : (BitVec 4) := (AArch64_AllocationTagFromAddress address)
  let mask : (BitVec 64) := (BitVec.update mask (BitVec.toNat tag) (Bit (0b1 : (BitVec 1))))
  (X_set d 64 mask)

def decode_gmi_aarch64_instrs_integer_tags_mcinserttagmask (Xd : (BitVec 5)) (Xn : (BitVec 5)) (Xm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Xd)
  let n := (BitVec.toNat Xn)
  let m := (BitVec.toNat Xm)
  (execute_aarch64_instrs_integer_tags_mcinserttagmask d m n)

def execute_aarch64_instrs_system_exceptions_debug_halt (_ : Unit) : SailM Unit := do
  let is_async : Bool := false
  (Halt__1 DebugHalt_HaltInstruction is_async)

def decode_hlt_aarch64_instrs_system_exceptions_debug_halt (imm16 : (BitVec 16)) : SailM Unit := do
  bif (((_get_EDSCR_Type_HDE (← (EDSCR_read ()))) == (0b0 : (BitVec 1))) || (! (← (HaltingAllowed
             ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (← (HaveBTIExt ()))
  then (SetBTypeCompatible true)
  else (pure ())
  (execute_aarch64_instrs_system_exceptions_debug_halt ())

def execute_aarch64_instrs_system_exceptions_runtime_hvc (imm : (BitVec 16)) : SailM Unit := do
  bif (((! (HaveEL EL2)) || ((← readReg PSTATE).EL == EL0)) || (((← readReg PSTATE).EL == EL1) && (! (← (EL2Enabled
               ())))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let hvc_enable ← (( do
    bif (HaveEL EL3)
    then (pure (_get_SCR_EL3_Type_HCE (← readReg SCR_EL3)))
    else (pure (Complement.complement (_get_HCR_EL2_Type_HCD (← readReg HCR_EL2)))) ) : SailM
    (BitVec 1) )
  bif (hvc_enable == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (AArch64_CallHypervisor imm)

def decode_hvc_aarch64_instrs_system_exceptions_runtime_hvc (imm16 : (BitVec 16)) : SailM Unit := do
  let imm : (BitVec 16) := imm16
  (execute_aarch64_instrs_system_exceptions_runtime_hvc imm)

/-- Type quantifiers: d : Nat, dst_index : Int, esize : Nat, idxdsize : Nat, n : Nat, src_index :
  Int, 0 ≤ n ∧
  n ≤ 31 ∧
  idxdsize ∈ {64, 128} ∧ esize ∈ {8, 16, 32, 64, 128, 256} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_vector_insert (d : Nat) (dst_index : Int) (esize : Nat) (idxdsize : Nat) (n : Nat) (src_index : Int) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n idxdsize) ) : SailM (BitVec idxdsize) )
  let result ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let result ← (Elem_set result dst_index esize (← (Elem_read operand src_index esize)))
  (V_set d 128 result)

def decode_ins_advsimd_elt_aarch64_instrs_vector_transfer_vector_insert (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm4 : (BitVec 4)) (imm5 : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let size := (LowestSetBit imm5)
  bif (size >b 3)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  assert (0 ≤b (size +i 1)) "src/instrs64.sail:22555.37-22555.38"
  let dst_index := (BitVec.toNat (Sail.BitVec.extractLsb imm5 4 (size +i 1)))
  assert (0 ≤b size) "src/instrs64.sail:22557.33-22557.34"
  let src_index := (BitVec.toNat (Sail.BitVec.extractLsb imm4 3 size))
  let idxdsize :=
    bif ((BitVec.join1 [(BitVec.access imm4 3)]) == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 size)
  match esize with
  | 8 =>
    (do
      match idxdsize with
      | 64 => (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 8 64 n src_index)
      | 128 => (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 8 128 n src_index)
      | _ => assert false "src/instrs64.sail:22571.28-22571.29")
  | 16 =>
    (do
      match idxdsize with
      | 64 => (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 16 64 n src_index)
      | 128 => (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 16 128 n src_index)
      | _ => assert false "src/instrs64.sail:22584.28-22584.29")
  | 32 =>
    (do
      match idxdsize with
      | 64 => (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 32 64 n src_index)
      | 128 => (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 32 128 n src_index)
      | _ => assert false "src/instrs64.sail:22597.28-22597.29")
  | 64 =>
    (do
      match idxdsize with
      | 64 => (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 64 64 n src_index)
      | 128 => (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 64 128 n src_index)
      | _ => assert false "src/instrs64.sail:22610.28-22610.29")
  | 128 =>
    (do
      match idxdsize with
      | 64 => (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 128 64 n src_index)
      | 128 =>
        (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 128 128 n src_index)
      | _ => assert false "src/instrs64.sail:22623.28-22623.29")
  | 256 =>
    (do
      match idxdsize with
      | 64 => (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 256 64 n src_index)
      | 128 =>
        (execute_aarch64_instrs_vector_transfer_vector_insert d dst_index 256 128 n src_index)
      | _ => assert false "src/instrs64.sail:22636.28-22636.29")
  | _ => assert false "src/instrs64.sail:22641.22-22641.23"

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, index : Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64, 128, 256} ∧ datasize = 128 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_integer_insert (d : Nat) (datasize : Nat) (esize : Nat) (index : Int) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:22661.48-22661.49"
  let element ← (( do (X_read n esize) ) : SailM (BitVec esize) )
  let result ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (Elem_set result index esize element)
  (V_set d datasize result)

def decode_ins_advsimd_gen_aarch64_instrs_vector_transfer_integer_insert (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm5 : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let size := (LowestSetBit imm5)
  bif (size >b 3)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  assert (0 ≤b (size +i 1)) "src/instrs64.sail:22677.37-22677.38"
  let index := (BitVec.toNat (Sail.BitVec.extractLsb imm5 4 (size +i 1)))
  let esize := (_shl_int_general 8 size)
  let datasize := 128
  assert ((((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) || (esize == 128)) || (esize == 256)) "src/instrs64.sail:22681.58-22681.59"
  (execute_aarch64_instrs_vector_transfer_integer_insert d datasize esize index n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcinsertrandomtag (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let operand ← (( do
    bif (n == 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let exclude_reg ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let exclude ← (( do
    (pure ((Sail.BitVec.extractLsb exclude_reg 15 0) ||| (_get_GCR_EL1_Type_Exclude
          (← readReg GCR_EL1)))) ) : SailM (BitVec 16) )
  let rtag ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let rtag ← (( do
    bif (← (AArch64_AllocationTagAccessIsEnabled (← readReg PSTATE).EL))
    then
      (do
        bif ((_get_GCR_EL1_Type_RRND (← readReg GCR_EL1)) == (0b1 : (BitVec 1)))
        then
          (do
            bif (IsOnes exclude)
            then (pure (0x0 : (BitVec 4)))
            else
              (do
                (ChooseRandomNonExcludedTag exclude)))
        else
          (do
            let start_tag ← (( do (pure (_get_RGSR_EL1_Type_TAG (← readReg RGSR_EL1))) ) : SailM
              (BitVec 4) )
            let offset ← (( do (AArch64_RandomTag ()) ) : SailM (BitVec 4) )
            let rtag : (BitVec 4) := (AArch64_ChooseNonExcludedTag start_tag offset exclude)
            writeReg RGSR_EL1 (Sail.BitVec.updateSubrange (← readReg RGSR_EL1) 3 0 rtag)
            (pure rtag)))
    else (pure (0x0 : (BitVec 4))) ) : SailM (BitVec 4) )
  let result ← (( do (AArch64_AddressWithAllocationTag operand rtag) ) : SailM (BitVec 64) )
  bif (d == 31)
  then (SP_set result)
  else (X_set d 64 result)

def decode_irg_aarch64_instrs_integer_tags_mcinsertrandomtag (Xd : (BitVec 5)) (Xn : (BitVec 5)) (Xm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Xd)
  let n := (BitVec.toNat Xn)
  let m := (BitVec.toNat Xm)
  (execute_aarch64_instrs_integer_tags_mcinsertrandomtag d m n)

def execute_aarch64_instrs_system_barriers_isb (_ : Unit) : SailM Unit := do
  (InstructionSynchronizationBarrier ())
  bif ((← (HaveBRBExt ())) && (← (BRBEBranchOnISB ())))
  then (BRBEISB ())
  else (pure ())
  bif (← (HaveStatisticalProfiling ()))
  then (SPEISB ())
  else (pure ())

def decode_isb_aarch64_instrs_system_barriers_isb (opc : (BitVec 2)) (CRm : (BitVec 4)) : SailM Unit := do
  (execute_aarch64_instrs_system_barriers_isb ())

/-- Type quantifiers: datasize : Nat, esize : Nat, index : Int, m : Int, n : Nat, k_nontemporal :
  Bool, k_replicate : Bool, selem : Nat, t__arg : Nat, k_tagchecked : Bool, k_wback : Bool, 0 ≤
  t__arg ∧
  t__arg ≤ 31 ∧
  selem ∈ {1, 2, 3, 4} ∧
  0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} -/
def execute_aarch64_instrs_memory_vector_single_no_wb (datasize : Nat) (esize : Nat) (index : Int) (m : Int) (memop : MemOp) (n : Nat) (nontemporal : Bool) (replicate : Bool) (selem : Nat) (t__arg : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  let t : Int := t__arg
  (CheckFPAdvSIMDEnabled64 ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let rval ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let ebytes := (Int.ediv esize 8)
  let accdesc ← (( do (CreateAccDescASIMD memop nontemporal tagchecked) ) : SailM AccessDescriptor
    )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let offs : (BitVec 64) := (Zeros (n := 64))
  let offs ← (( do
    bif replicate
    then
      (do
        let (element, offs, t) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (selem -i 1)
          let mut loop_vars_1 := (element, offs, t)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (element, offs, t) := loop_vars_1
            loop_vars_1 ← do
              let element ← (Mem_read (address + offs) ebytes accdesc)
              (V_set t datasize (BitVec.replicateBits element (Int.ediv datasize esize)))
              let offs : (BitVec 64) := (BitVec.addInt offs ebytes)
              let t : Int := (fmod_int (t +i 1) 32)
              (pure (element, offs, t))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec 64) × Int) )
        (pure offs))
    else
      (do
        let (offs, rval, t) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (selem -i 1)
          let mut loop_vars := (offs, rval, t)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (offs, rval, t) := loop_vars
            loop_vars ← do
              let rval ← (V_read t 128)
              let rval ← (( do
                bif (BEq.beq memop MemOp_LOAD)
                then
                  (do
                    let rval ←
                      (Elem_set rval index esize (← (Mem_read (address + offs) ebytes accdesc)))
                    (V_set t 128 rval)
                    (pure rval))
                else
                  (do
                    (Mem_set (address + offs) ebytes accdesc (← (Elem_read rval index esize)))
                    (pure rval)) ) : SailM (BitVec 128) )
              let offs : (BitVec 64) := (BitVec.addInt offs ebytes)
              let t : Int := (fmod_int (t +i 1) 32)
              (pure (offs, rval, t))
          (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 128) × Int) )
        (pure offs)) ) : SailM (BitVec 64) )
  bif (← readReg SPESampleInFlight)
  then (SPESampleSIMDFPLoadStore ())
  else (pure ())
  bif wback
  then
    (do
      let offs ← (( do
        bif (m != 31)
        then
          (do
            (X_read m 64))
        else (pure offs) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set (address + offs))
      else (X_set n 64 (address + offs)))
  else (pure ())

def decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:22879.48-22879.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:22949.48-22949.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23019.48-23019.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld1r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23089.48-23089.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23159.48-23159.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23229.48-23229.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23299.48-23299.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld2r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23369.48-23369.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23439.48-23439.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23509.48-23509.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23579.48-23579.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld3r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23649.48-23649.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23719.48-23719.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23789.48-23789.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23859.48-23859.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_ld4r_advsimd_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23929.48-23929.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:23999.48-23999.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_st1_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:24069.48-24069.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:24139.48-24139.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_st2_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:24209.48-24209.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:24279.48-24279.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_st3_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:24349.48-24349.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (o2 : (BitVec 1)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:24419.48-24419.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

def decode_st4_advsimd_sngl_aarch64_instrs_memory_vector_single_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (Rm : (BitVec 5)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:24489.48-24489.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb datasize esize index m memop n nontemporal
    replicate selem t tagchecked wback)

/-- Type quantifiers: datasize : Nat, elements : Int, esize : Nat, m : Int, n : Nat, k_nontemporal :
  Bool, rpt : Nat, selem : Nat, t : Nat, k_tagchecked : Bool, k_wback : Bool, 0 ≤ t ∧
  t ≤ 31 ∧
  selem ∈ {1, 2, 3, 4} ∧
  rpt ∈ {1, 2, 3, 4} ∧
  0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} -/
def execute_aarch64_instrs_memory_vector_multiple_no_wb (datasize : Nat) (elements : Int) (esize : Nat) (m : Int) (memop : MemOp) (n : Nat) (nontemporal : Bool) (rpt : Nat) (selem : Nat) (t : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let rval ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let tt ← (( do (undefined_int ()) ) : SailM Int )
  let ebytes := (Int.ediv esize 8)
  let accdesc ← (( do (CreateAccDescASIMD memop nontemporal tagchecked) ) : SailM AccessDescriptor
    )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let offs : (BitVec 64) := (Zeros (n := 64))
  let (offs, rval, tt) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (rpt -i 1)
    let mut loop_vars := (offs, rval, tt)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (offs, rval, tt) := loop_vars
      loop_vars ← do
        let (offs, rval, tt) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (offs, rval, tt)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (offs, rval, tt) := loop_vars_1
            loop_vars_1 ← do
              let tt : Int := (Nat.div (t +i r) 32)
              let (offs, rval, tt) ← (( do
                let loop_s_lower := 0
                let loop_s_upper := (selem -i 1)
                let mut loop_vars_2 := (offs, rval, tt)
                for s in [loop_s_lower:loop_s_upper:1]i do
                  let (offs, rval, tt) := loop_vars_2
                  loop_vars_2 ← do
                    let tt := tt
                    let rval ← (V_read tt datasize)
                    (pure ())
                    let tt := tt
                    bif (BEq.beq memop MemOp_LOAD)
                    then
                      (do
                        let rval ←
                          (Elem_set rval e esize (← (Mem_read (address + offs) ebytes accdesc)))
                        (V_set tt datasize rval))
                    else (Mem_set (address + offs) ebytes accdesc (← (Elem_read rval e esize)))
                    let offs : (BitVec 64) := (BitVec.addInt offs ebytes)
                    let tt : Int := (fmod_int (tt +i 1) 32)
                    (pure (offs, rval, tt))
                (pure loop_vars_2) ) : SailM ((BitVec 64) × (BitVec datasize) × Int) )
              (pure (offs, rval, tt))
          (pure loop_vars_1) ) : SailM ((BitVec 64) × (BitVec datasize) × Int) )
        (pure (offs, rval, tt))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec datasize) × Int) )
  bif (← readReg SPESampleInFlight)
  then (SPESampleSIMDFPLoadStore ())
  else (pure ())
  bif wback
  then
    (do
      let offs ← (( do
        bif (m != 31)
        then
          (do
            (X_read m 64))
        else (pure offs) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set (address + offs))
      else (X_set n 64 (address + offs)))
  else (pure ())

def decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_ld1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (Rm : (BitVec 5)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_ld2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (Rm : (BitVec 5)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_ld3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (Rm : (BitVec 5)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_ld4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (Rm : (BitVec 5)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_st1_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (Rm : (BitVec 5)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_st2_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (Rm : (BitVec 5)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_st3_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (Rm : (BitVec 5)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_no_wb (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

def decode_st4_advsimd_mult_aarch64_instrs_memory_vector_multiple_post_inc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (opcode : (BitVec 4)) (Rm : (BitVec 5)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let wback : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let elements := (Int.ediv datasize esize)
  let rpt : Int := 1
  let selem : Int := 1
  let b__0 := opcode
  bif (b__0 == (0x0 : (BitVec 4)))
  then
    (let rpt : Int := 1
    let selem : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0x2 : (BitVec 4)))
      then
        (let rpt : Int := 4
        let selem : Int := 1
        (pure ()))
      else
        (do
          bif (b__0 == (0x4 : (BitVec 4)))
          then
            (let rpt : Int := 1
            let selem : Int := 3
            (pure ()))
          else
            (do
              bif (b__0 == (0x6 : (BitVec 4)))
              then
                (let rpt : Int := 3
                let selem : Int := 1
                (pure ()))
              else
                (do
                  bif (b__0 == (0x7 : (BitVec 4)))
                  then
                    (let rpt : Int := 1
                    let selem : Int := 1
                    (pure ()))
                  else
                    (do
                      bif (b__0 == (0x8 : (BitVec 4)))
                      then
                        (let rpt : Int := 1
                        let selem : Int := 2
                        (pure ()))
                      else
                        (do
                          bif (b__0 == (0xA : (BitVec 4)))
                          then
                            (let rpt : Int := 2
                            let selem : Int := 1
                            (pure ()))
                          else sailThrow ((Error_Undefined ()))))))))
  let selem := selem
  let rpt := rpt
  bif (((size ++ Q) == (0b110 : (BitVec 3))) && (selem != 1))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_memory_vector_multiple_no_wb datasize elements esize m memop n nontemporal
    rpt selem t tagchecked wback)

/-- Type quantifiers: n : Nat, t : Nat, k_tagchecked : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_atomicops_ld_acc (lst : (BitVec 2)) (memop : MemOp) (n : Nat) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  (CheckLDST64BEnabled ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let value_name ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescLS64 memop tagchecked) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let _ : Unit := (SetLoadStoreType lst)
  let _ : Unit := (AArch64_SetLSInstructionSyndrome 64 false t true false)
  let data ← (( do (MemLoad64B address accdesc) ) : SailM (BitVec 512) )
  let value_name ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 7
    let mut loop_vars := value_name
    for i in [loop_i_lower:loop_i_upper:1]i do
      let value_name := loop_vars
      loop_vars ← do
        let value_name : (BitVec 64) := (Sail.BitVec.extractLsb data (63 +i (64 *i i)) (64 *i i))
        let value_name ← (( do
          bif (← (BigEndian accdesc.acctype))
          then (pure (reverse_endianness value_name))
          else (pure value_name) ) : SailM (BitVec 64) )
        (X_set (t +i i) 64 value_name)
        (pure value_name)
    (pure loop_vars) ) : SailM (BitVec 64) )
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ld64b_aarch64_instrs_memory_atomicops_ld_acc (Rt : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveFeatLS64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (((Sail.BitVec.extractLsb Rt 4 3) == (0b11 : (BitVec 2))) || ((BitVec.join1 [(BitVec.access Rt
             0)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop : MemOp := MemOp_LOAD
  let tagchecked : Bool := (n != 31)
  let lst : (BitVec 2) := lst_64b
  (execute_aarch64_instrs_memory_atomicops_ld_acc lst memop n t tagchecked)

/-- Type quantifiers: k_acquire : Bool, datasize : Nat, k_is_load : Bool, n : Nat, regsize : Nat, k_release
  : Bool, s : Nat, t : Nat, k_tagchecked : Bool, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ s ∧
  s ≤ 31 ∧ regsize ∈ {32, 64} ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_atomicops_ld (acquire : Bool) (datasize : Nat) (is_load : Bool) (n : Nat) (op : MemAtomicOp) (regsize : Nat) (release : Bool) (s : Nat) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescAtomicOp op acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let value_name ← (( do (X_read s datasize) ) : SailM (BitVec datasize) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let comparevalue ← (( do (__UNKNOWN_bits datasize) ) : SailM (BitVec datasize) )
  let data ← (( do (MemAtomic address comparevalue value_name accdesc) ) : SailM (BitVec datasize)
    )
  bif (t != 31)
  then
    (do
      assert ((datasize ≥b 0) && (regsize ≥b datasize)) "src/instrs64.sail:25715.67-25715.68"
      (X_set t regsize (Sail.BitVec.zeroExtend data regsize)))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then
    (do
      let ar : (BitVec 1) :=
        bif (acquire || release)
        then (0b1 : (BitVec 1))
        else (0b0 : (BitVec 1))
      let excl : (BitVec 1) := (0b0 : (BitVec 1))
      let at' : (BitVec 1) := (0b1 : (BitVec 1))
      (SPESampleExtendedLoadStore ar excl at' is_load))
  else (pure ())

def decode_ldadd_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldaddb_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldaddh_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldclr_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldclrb_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldclrh_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldeor_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldeorb_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldeorh_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldset_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldsetb_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldseth_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldsmax_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldsmaxb_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldsmaxh_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldsmin_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldsminb_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldsminh_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldumax_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldumaxb_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldumaxh_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_ldumin_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_lduminb_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

def decode_lduminh_aarch64_instrs_memory_atomicops_ld (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let is_load : Bool := (Rt != (0b11111 : (BitVec 5)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b000 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_ADD
      ())
    else
      (bif (b__0 == (0b001 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_BIC
        ())
      else
        (bif (b__0 == (0b010 : (BitVec 3)))
        then
          (let op : MemAtomicOp := MemAtomicOp_EOR
          ())
        else
          (bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let op : MemAtomicOp := MemAtomicOp_ORR
            ())
          else
            (bif (b__0 == (0b100 : (BitVec 3)))
            then
              (let op : MemAtomicOp := MemAtomicOp_SMAX
              ())
            else
              (bif (b__0 == (0b101 : (BitVec 3)))
              then
                (let op : MemAtomicOp := MemAtomicOp_SMIN
                ())
              else
                (bif (b__0 == (0b110 : (BitVec 3)))
                then
                  (let op : MemAtomicOp := MemAtomicOp_UMAX
                  ())
                else
                  (let op : MemAtomicOp := MemAtomicOp_UMIN
                  ())))))))
  let op := op
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld acquire datasize is_load n op regsize release s t
    tagchecked)

/-- Type quantifiers: datasize : Nat, esize : Nat, index : Int, m : Int, n : Nat, k_replicate : Bool, selem
  : Nat, t__arg : Nat, k_tagchecked : Bool, k_wback : Bool, 0 ≤ t__arg ∧
  t__arg ≤ 31 ∧
  selem ∈ {1, 2, 3, 4} ∧
  0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} -/
def execute_aarch64_instrs_memory_vector_single_no_wb_ordered (datasize : Nat) (esize : Nat) (index : Int) (m : Int) (memop : MemOp) (n : Nat) (replicate : Bool) (selem : Nat) (t__arg : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  let t : Int := t__arg
  (CheckFPAdvSIMDEnabled64 ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let rval ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let ebytes := (Int.ediv esize 8)
  let accdesc ← (( do (CreateAccDescASIMDAcqRel memop tagchecked) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let offs : (BitVec 64) := (Zeros (n := 64))
  let offs ← (( do
    bif replicate
    then
      (do
        let (element, offs, t) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (selem -i 1)
          let mut loop_vars_1 := (element, offs, t)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (element, offs, t) := loop_vars_1
            loop_vars_1 ← do
              let element ← (Mem_read (address + offs) ebytes accdesc)
              (V_set t datasize (BitVec.replicateBits element (Int.ediv datasize esize)))
              let offs : (BitVec 64) := (BitVec.addInt offs ebytes)
              let t : Int := (fmod_int (t +i 1) 32)
              (pure (element, offs, t))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec 64) × Int) )
        (pure offs))
    else
      (do
        let (offs, rval, t) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (selem -i 1)
          let mut loop_vars := (offs, rval, t)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (offs, rval, t) := loop_vars
            loop_vars ← do
              let rval ← (V_read t 128)
              let rval ← (( do
                bif (BEq.beq memop MemOp_LOAD)
                then
                  (do
                    let rval ←
                      (Elem_set rval index esize (← (Mem_read (address + offs) ebytes accdesc)))
                    (V_set t 128 rval)
                    (pure rval))
                else
                  (do
                    (Mem_set (address + offs) ebytes accdesc (← (Elem_read rval index esize)))
                    (pure rval)) ) : SailM (BitVec 128) )
              let offs : (BitVec 64) := (BitVec.addInt offs ebytes)
              let t : Int := (fmod_int (t +i 1) 32)
              (pure (offs, rval, t))
          (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 128) × Int) )
        (pure offs)) ) : SailM (BitVec 64) )
  bif (← readReg SPESampleInFlight)
  then (SPESampleSIMDFPLoadStore ())
  else (pure ())
  bif wback
  then
    (do
      let offs ← (( do
        bif (m != 31)
        then
          (do
            (X_read m 64))
        else (pure offs) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set (address + offs))
      else (X_set n 64 (address + offs)))
  else (pure ())

def decode_ldap1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:27226.48-27226.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb_ordered datasize esize index m memop n
    replicate selem t tagchecked wback)

def decode_stl1_advsimd_sngl_aarch64_instrs_memory_vector_single_no_wb_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (S : (BitVec 1)) (opcode : (BitVec 3)) (R : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let m ← do (__UNKNOWN_integer ())
  let wback : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := (wback || (n != 31))
  let init_scale := (BitVec.toNat (Sail.BitVec.extractLsb opcode 2 1))
  let scale : Int := init_scale
  let selem := ((BitVec.toNat ((BitVec.join1 [(BitVec.access opcode 0)]) ++ R)) +i 1)
  let replicate : Bool := false
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, replicate, scale) ← (( do
    match scale with
    | 3 =>
      (do
        bif ((L == (0b0 : (BitVec 1))) || (S == (0b1 : (BitVec 1))))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let scale : Int := (BitVec.toNat size)
        let replicate : Bool := true
        (pure (index, replicate, scale)))
    | 0 =>
      (let index : Int := (BitVec.toNat ((Q ++ S) ++ size))
      (pure (index, replicate, scale)))
    | 1 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let index : Int := (BitVec.toNat ((Q ++ S) ++ (BitVec.join1 [(BitVec.access size 1)])))
        (pure (index, replicate, scale)))
    | 2 =>
      (do
        bif ((BitVec.join1 [(BitVec.access size 1)]) == (0b1 : (BitVec 1)))
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        let (index, scale) ← (( do
          bif ((BitVec.join1 [(BitVec.access size 0)]) == (0b0 : (BitVec 1)))
          then
            (let index : Int := (BitVec.toNat (Q ++ S))
            (pure (index, scale)))
          else
            (do
              bif (S == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let index : Int := (BitVec.toNat Q)
              let scale : Int := 3
              (pure (index, scale))) ) : SailM (Int × Int) )
        (pure (index, replicate, scale)))
    | _ => (pure (index, replicate, scale)) ) : SailM (Int × Bool × Int) )
  let scale := scale
  let index := index
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let esize := (_shl_int_general 8 scale)
  assert ((((esize == 8) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:27295.48-27295.49"
  (execute_aarch64_instrs_memory_vector_single_no_wb_ordered datasize esize index m memop n
    replicate selem t tagchecked wback)

/-- Type quantifiers: datasize : Nat, n : Nat, offset : Nat, regsize : Nat, t : Nat, k_tagchecked :
  Bool, k_wb_unknown : Bool, k_wback : Bool, 0 ≤ t ∧
  t ≤ 31 ∧
  regsize ∈ {32, 64} ∧
  offset ∈ {0, 1, 2, 4, 8} ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_ordered_rcpc (datasize : Nat) (n : Nat) (offset : Nat) (regsize : Nat) (t : Nat) (tagchecked : Bool) (wb_unknown : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let dbytes := (Int.ediv datasize 8)
  let accdesc ← (( do (CreateAccDescLDAcqPC tagchecked) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let data ← (( do (Mem_read address dbytes accdesc) ) : SailM (BitVec datasize) )
  assert (regsize ≥b datasize) "src/instrs64.sail:27327.44-27327.45"
  (X_set t regsize (Sail.BitVec.zeroExtend data regsize))
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else (pure (BitVec.addInt address offset)) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then
    (do
      let ar : (BitVec 1) := (0b1 : (BitVec 1))
      let excl : (BitVec 1) := (0b0 : (BitVec 1))
      let at' : (BitVec 1) := (0b0 : (BitVec 1))
      let is_load : Bool := true
      (SPESampleExtendedLoadStore ar excl at' is_load))
  else (pure ())

def decode_ldapr_aarch64_instrs_memory_ordered_rcpc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let offset := 0
  let wb_unknown : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let s := (BitVec.toNat Rs)
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered_rcpc datasize n offset regsize t tagchecked wb_unknown
    wback)

def decode_ldapr_aarch64_instrs_memory_ordered_rcpc_writeback (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let regsize :=
    bif (size == (0b11 : (BitVec 2)))
    then 64
    else 32
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let offset := (Int.shiftl 1 (BitVec.toNat size))
  let tagchecked : Bool := (wback || (n != 31))
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((wback && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27393.113-27393.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_ordered_rcpc datasize n offset regsize t tagchecked wb_unknown
    wback)

def decode_ldaprb_aarch64_instrs_memory_ordered_rcpc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let offset := 0
  let wb_unknown : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let s := (BitVec.toNat Rs)
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered_rcpc datasize n offset regsize t tagchecked wb_unknown
    wback)

def decode_ldaprh_aarch64_instrs_memory_ordered_rcpc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let offset := 0
  let wb_unknown : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let s := (BitVec.toNat Rs)
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered_rcpc datasize n offset regsize t tagchecked wb_unknown
    wback)

/-- Type quantifiers: datasize : Nat, k_is_signed : Bool, n : Nat, k_postindex : Bool, regsize : Nat, k_rt_unknown
  : Bool, t : Nat, k_tagchecked : Bool, k_wb_unknown : Bool, k_wback : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ regsize ∈ {32, 64} ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (datasize : Nat) (memop : MemOp) (n : Nat) (offset : (BitVec 64)) (postindex : Bool) (regsize : Nat) (rt_unknown : Bool) (is_signed : Bool) (t : Nat) (tagchecked : Bool) (wb_unknown : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let accdesc ← (( do (undefined_AccessDescriptor ()) ) : SailM AccessDescriptor )
  let accdesc ← (( do
    bif (BEq.beq memop MemOp_LOAD)
    then
      (do
        (CreateAccDescLDAcqPC tagchecked))
    else
      (do
        bif (BEq.beq memop MemOp_STORE)
        then
          (do
            (CreateAccDescAcqRel memop tagchecked))
        else (pure accdesc)) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        bif (bne memop MemOp_PREFETCH)
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      let data ← (( do
        bif rt_unknown
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let _ : Unit :=
        bif (! wback)
        then (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) false t (regsize == 64) false)
        else ()
      (Mem_set address (Int.ediv datasize 8) accdesc data))
  | MemOp_LOAD =>
    (do
      let _ : Unit :=
        bif (! wback)
        then
          (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) is_signed t (regsize == 64) false)
        else ()
      let data ← (( do (Mem_read address (Int.ediv datasize 8) accdesc) ) : SailM
        (BitVec datasize) )
      bif is_signed
      then
        (do
          assert ((datasize >b 0) && (regsize ≥b datasize)) "src/instrs64.sail:27521.72-27521.73"
          (X_set t regsize (sign_extend data regsize)))
      else
        (do
          assert ((datasize ≥b 0) && (regsize ≥b datasize)) "src/instrs64.sail:27524.73-27524.74"
          (X_set t regsize (Sail.BitVec.zeroExtend data regsize))))
  | MemOp_PREFETCH => (Prefetch address (integer_subrange t 4 0))
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (bif postindex
          then (pure (address + offset))
          else (pure address)) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ldapur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27586.113-27586.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27605.107-27605.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl datasize memop n
    offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldapurb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27671.113-27671.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27690.107-27690.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl datasize memop n
    offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldapurh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27756.113-27756.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27775.107-27775.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl datasize memop n
    offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldapursb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27841.113-27841.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27860.107-27860.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl datasize memop n
    offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldapursh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27926.113-27926.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:27945.107-27945.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl datasize memop n
    offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldapursw_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:28011.113-28011.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:28030.107-28030.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl datasize memop n
    offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_stlur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:28096.113-28096.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:28115.107-28115.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl datasize memop n
    offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_stlurb_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:28181.113-28181.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:28200.107-28200.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl datasize memop n
    offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_stlurh_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:28266.113-28266.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:28285.107-28285.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_lda_stl datasize memop n
    offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

/-- Type quantifiers: datasize : Nat, n : Nat, k_postindex : Bool, t : Nat, k_tagchecked : Bool, k_wback
  : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64, 128, 256, 512, 1024} -/
def execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered (datasize : Nat) (memop : MemOp) (n : Nat) (offset : (BitVec 64)) (postindex : Bool) (t : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let accdesc ← (( do (CreateAccDescASIMDAcqRel memop tagchecked) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:28335.62-28335.63"
      let data ← (( do (V_read t datasize) ) : SailM (BitVec datasize) )
      (Mem_set address (Int.ediv datasize 8) accdesc data))
  | MemOp_LOAD =>
    (do
      let data ← (( do (Mem_read address (Int.ediv datasize 8) accdesc) ) : SailM
        (BitVec datasize) )
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:28341.62-28341.63"
      (V_set t datasize data))
  | _ => (pure ())
  bif wback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleSIMDFPLoadStore ())
  else (pure ())

def decode_ldapur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:28378.72-28378.73"
  (execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered datasize memop n
    offset postindex t tagchecked wback)

def decode_stlur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:28408.72-28408.73"
  (execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_ordered datasize memop n
    offset postindex t tagchecked wback)

/-- Type quantifiers: datasize : Nat, k_limitedordered : Bool, n : Nat, offset : Int, regsize : Nat, k_rt_unknown
  : Bool, t : Nat, k_tagchecked : Bool, k_wback : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ regsize ∈ {32, 64} ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_ordered (datasize : Nat) (limitedordered : Bool) (memop : MemOp) (n : Nat) (offset : Int) (regsize : Nat) (rt_unknown : Bool) (t : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let dbytes := (Int.ediv datasize 8)
  let accdesc ← (( do (undefined_AccessDescriptor ()) ) : SailM AccessDescriptor )
  let accdesc ← (( do
    bif limitedordered
    then
      (do
        (CreateAccDescLOR memop tagchecked))
    else
      (do
        (CreateAccDescAcqRel memop tagchecked)) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  match memop with
  | MemOp_STORE =>
    (do
      let address : (BitVec 64) := (BitVec.addInt address offset)
      let data ← (( do
        bif rt_unknown
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let _ : Unit := (AArch64_SetLSInstructionSyndrome dbytes false t (regsize == 64) true)
      (Mem_set address dbytes accdesc data)
      bif wback
      then
        (do
          bif (n == 31)
          then (SP_set address)
          else (X_set n 64 address))
      else (pure ()))
  | MemOp_LOAD =>
    (do
      let _ : Unit := (AArch64_SetLSInstructionSyndrome dbytes false t (regsize == 64) true)
      let data ← (( do (Mem_read address dbytes accdesc) ) : SailM (BitVec datasize) )
      assert ((datasize ≥b 0) && (regsize ≥b datasize)) "src/instrs64.sail:28464.69-28464.70"
      (X_set t regsize (Sail.BitVec.zeroExtend data regsize)))
  | _ => (pure ())
  bif (← readReg SPESampleInFlight)
  then
    (do
      let ar : (BitVec 1) := (0b1 : (BitVec 1))
      let excl : (BitVec 1) := (0b0 : (BitVec 1))
      let at' : (BitVec 1) := (0b0 : (BitVec 1))
      let is_load : Bool := (BEq.beq memop MemOp_LOAD)
      (SPESampleExtendedLoadStore ar excl at' is_load))
  else (pure ())

def decode_ldar_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_ldarb_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_ldarh_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_ldlar_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_ldlarb_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_ldlarh_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_stllr_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_stllrb_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_stllrh_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_stlr_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_stlr_aarch64_instrs_memory_ordered_writeback (Rt : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let memop : MemOp := MemOp_STORE
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let limitedordered : Bool := false
  let regsize :=
    bif (size == (0b11 : (BitVec 2)))
    then 64
    else 32
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let offset := ((Neg.neg 1) *i (Int.shiftl 1 (BitVec.toNat size)))
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((wback && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:28844.107-28844.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_stlrb_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

def decode_stlrh_aarch64_instrs_memory_ordered (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let wback : Bool := false
  let offset := 0
  let rt_unknown : Bool := false
  let limitedordered : Bool := (o0 == (0b0 : (BitVec 1)))
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize := elsize
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_ordered datasize limitedordered memop n offset regsize rt_unknown t
    tagchecked wback)

/-- Type quantifiers: k_acqrel : Bool, datasize : Nat, elsize : Nat, n : Nat, k_pair : Bool, regsize
  : Nat, k_rn_unknown : Bool, k_rt_unknown : Bool, s : Nat, t : Nat, t2 : Nat, k_tagchecked : Bool, 0
  ≤ t2 ∧
  t2 ≤ 31 ∧
  0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  regsize ∈ {32, 64} ∧
  0 ≤ n ∧ n ≤ 31 ∧ elsize ∈ {32, 64} ∧ datasize ∈ {32, 64, 128} -/
def execute_aarch64_instrs_memory_exclusive_pair (acqrel : Bool) (datasize : Nat) (elsize : Nat) (memop : MemOp) (n : Nat) (pair : Bool) (regsize : Nat) (rn_unknown : Bool) (rt_unknown : Bool) (s : Nat) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let dbytes := (Int.ediv datasize 8)
  let accdesc ← (( do (CreateAccDescExLDST memop acqrel tagchecked) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        bif rn_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (do
            (X_read n 64))) ) : SailM (BitVec 64) )
  match memop with
  | MemOp_STORE =>
    (do
      let data ← (( do
        bif rt_unknown
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            bif pair
            then
              (do
                let el1 ← (( do (X_read t (Int.ediv datasize 2)) ) : SailM (BitVec (datasize / 2))
                  )
                let el2 ← (( do (X_read t2 (Int.ediv datasize 2)) ) : SailM
                  (BitVec (datasize / 2)) )
                bif (← (BigEndian accdesc.acctype))
                then (pure (el1 ++ el2))
                else (pure (el2 ++ el1)))
            else
              (do
                assert ((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) "src/instrs64.sail:28968.61-28968.62"
                (X_read t datasize))) ) : SailM (BitVec datasize) )
      let status : (BitVec 1) := (0b1 : (BitVec 1))
      let status ← (( do
        bif (← (AArch64_ExclusiveMonitorsPass address dbytes))
        then
          (do
            (Mem_set address dbytes accdesc data)
            (pure (ExclusiveMonitorsStatus ())))
        else
          (do
            bif (← readReg SPESampleInFlight)
            then (SPESetDataVirtualAddress address)
            else (pure ())
            (pure status)) ) : SailM (BitVec 1) )
      (X_set s 32 (Sail.BitVec.zeroExtend status 32)))
  | MemOp_LOAD =>
    (do
      (AArch64_SetExclusiveMonitors address dbytes)
      bif pair
      then
        (do
          bif rt_unknown
          then
            (do
              assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:28984.58-28984.59"
              (X_set t datasize (← (__UNKNOWN_bits datasize))))
          else
            (do
              bif (elsize == 32)
              then
                (do
                  let data ← (( do (Mem_read address dbytes accdesc) ) : SailM (BitVec datasize) )
                  bif (← (BigEndian accdesc.acctype))
                  then
                    (do
                      assert ((0 ≤b elsize) && ((elsize ≤b (datasize -i 1)) && ((datasize -i 1) <b datasize))) "src/instrs64.sail:28989.110-28989.111"
                      assert (((datasize -i elsize) == 32) || ((datasize -i elsize) == 64)) "src/instrs64.sail:28990.96-28990.97"
                      (X_set t (datasize -i elsize)
                        (Sail.BitVec.extractLsb data (datasize -i 1) elsize))
                      (X_set t2 elsize (Sail.BitVec.extractLsb data (elsize -i 1) 0)))
                  else
                    (do
                      (X_set t elsize (Sail.BitVec.extractLsb data (elsize -i 1) 0))
                      assert ((0 ≤b elsize) && ((elsize ≤b (datasize -i 1)) && ((datasize -i 1) <b datasize))) "src/instrs64.sail:28995.110-28995.111"
                      assert (((datasize -i elsize) == 32) || ((datasize -i elsize) == 64)) "src/instrs64.sail:28996.96-28996.97"
                      (X_set t2 (datasize -i elsize)
                        (Sail.BitVec.extractLsb data (datasize -i 1) elsize))))
              else
                (do
                  bif (! (IsAligned__1 address dbytes))
                  then (AArch64_Abort address (← (AlignmentFault accdesc)))
                  else (pure ())
                  (X_set t 64 (← (Mem_read (BitVec.addInt address 0) 8 accdesc)))
                  (X_set t2 64 (← (Mem_read (BitVec.addInt address 8) 8 accdesc))))))
      else
        (do
          let data ← (( do (Mem_read address dbytes accdesc) ) : SailM (BitVec datasize) )
          assert ((datasize ≥b 0) && (regsize ≥b datasize)) "src/instrs64.sail:29008.73-29008.74"
          (X_set t regsize (Sail.BitVec.zeroExtend data regsize))))
  | _ => (pure ())
  bif (← readReg SPESampleInFlight)
  then
    (do
      let ar : (BitVec 1) :=
        bif acqrel
        then (0b1 : (BitVec 1))
        else (0b0 : (BitVec 1))
      let excl : (BitVec 1) := (0b1 : (BitVec 1))
      let at' : (BitVec 1) := (0b0 : (BitVec 1))
      let is_load : Bool := (BEq.beq memop MemOp_LOAD)
      (SPESampleExtendedLoadStore ar excl at' is_load))
  else (pure ())

def decode_ldaxp_aarch64_instrs_memory_exclusive_pair (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (sz : (BitVec 1)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := true
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 32 (BitVec.toNat sz))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29042.84-29042.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29059.88-29059.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29075.88-29075.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_pair acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_ldxp_aarch64_instrs_memory_exclusive_pair (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (sz : (BitVec 1)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := true
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 32 (BitVec.toNat sz))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29128.84-29128.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29145.88-29145.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29161.88-29161.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_pair acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_stlxp_aarch64_instrs_memory_exclusive_pair (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (sz : (BitVec 1)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := true
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 32 (BitVec.toNat sz))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29214.84-29214.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29231.88-29231.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29247.88-29247.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_pair acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_stxp_aarch64_instrs_memory_exclusive_pair (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (sz : (BitVec 1)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := true
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 32 (BitVec.toNat sz))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29296.84-29296.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29313.88-29313.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29329.88-29329.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_pair acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

/-- Type quantifiers: k_acqrel : Bool, datasize : Nat, elsize : Nat, n : Nat, k_pair : Bool, regsize
  : Nat, k_rn_unknown : Bool, k_rt_unknown : Bool, s : Nat, t : Nat, t2 : Nat, k_tagchecked : Bool, 0
  ≤ t2 ∧
  t2 ≤ 31 ∧
  0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ s ∧
  s ≤ 31 ∧
  regsize ∈ {32, 64} ∧
  0 ≤ n ∧ n ≤ 31 ∧ elsize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} -/
def execute_aarch64_instrs_memory_exclusive_single (acqrel : Bool) (datasize : Nat) (elsize : Nat) (memop : MemOp) (n : Nat) (pair : Bool) (regsize : Nat) (rn_unknown : Bool) (rt_unknown : Bool) (s : Nat) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let dbytes := (Int.ediv datasize 8)
  let accdesc ← (( do (CreateAccDescExLDST memop acqrel tagchecked) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        bif rn_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (do
            (X_read n 64))) ) : SailM (BitVec 64) )
  match memop with
  | MemOp_STORE =>
    (do
      let data ← (( do
        bif rt_unknown
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            bif pair
            then
              (do
                assert (((Int.ediv datasize 2) == 8) || (((Int.ediv datasize 2) == 16) || (((Int.ediv
                          datasize 2) == 32) || ((Int.ediv datasize 2) == 64)))) "src/instrs64.sail:29382.135-29382.136"
                let el1 ← (( do (X_read t (Int.ediv datasize 2)) ) : SailM (BitVec (datasize / 2))
                  )
                let el2 ← (( do (X_read t2 (Int.ediv datasize 2)) ) : SailM
                  (BitVec (datasize / 2)) )
                bif (← (BigEndian accdesc.acctype))
                then (pure (el1 ++ el2))
                else (pure (el2 ++ el1)))
            else
              (do
                assert ((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) "src/instrs64.sail:29387.61-29387.62"
                (X_read t datasize))) ) : SailM (BitVec datasize) )
      let status : (BitVec 1) := (0b1 : (BitVec 1))
      let status ← (( do
        bif (← (AArch64_ExclusiveMonitorsPass address dbytes))
        then
          (do
            (Mem_set address dbytes accdesc data)
            (pure (ExclusiveMonitorsStatus ())))
        else
          (do
            bif (← readReg SPESampleInFlight)
            then (SPESetDataVirtualAddress address)
            else (pure ())
            (pure status)) ) : SailM (BitVec 1) )
      (X_set s 32 (Sail.BitVec.zeroExtend status 32)))
  | MemOp_LOAD =>
    (do
      (AArch64_SetExclusiveMonitors address dbytes)
      bif pair
      then
        (do
          bif rt_unknown
          then
            (do
              assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:29403.58-29403.59"
              (X_set t datasize (← (__UNKNOWN_bits datasize))))
          else
            (do
              bif (elsize == 32)
              then
                (do
                  let data ← (( do (Mem_read address dbytes accdesc) ) : SailM (BitVec datasize) )
                  bif (← (BigEndian accdesc.acctype))
                  then
                    (do
                      assert ((0 ≤b elsize) && ((elsize ≤b (datasize -i 1)) && ((datasize -i 1) <b datasize))) "src/instrs64.sail:29408.110-29408.111"
                      assert (((datasize -i elsize) == 32) || ((datasize -i elsize) == 64)) "src/instrs64.sail:29409.96-29409.97"
                      (X_set t (datasize -i elsize)
                        (Sail.BitVec.extractLsb data (datasize -i 1) elsize))
                      (X_set t2 elsize (Sail.BitVec.extractLsb data (elsize -i 1) 0)))
                  else
                    (do
                      assert ((0 ≤b (elsize -i 1)) && ((elsize -i 1) <b datasize)) "src/instrs64.sail:29413.85-29413.86"
                      (X_set t elsize (Sail.BitVec.extractLsb data (elsize -i 1) 0))
                      assert ((0 ≤b elsize) && ((elsize ≤b (datasize -i 1)) && ((datasize -i 1) <b datasize))) "src/instrs64.sail:29415.110-29415.111"
                      assert (((datasize -i elsize) == 32) || ((datasize -i elsize) == 64)) "src/instrs64.sail:29416.96-29416.97"
                      (X_set t2 (datasize -i elsize)
                        (Sail.BitVec.extractLsb data (datasize -i 1) elsize))))
              else
                (do
                  bif (! (IsAligned__1 address dbytes))
                  then (AArch64_Abort address (← (AlignmentFault accdesc)))
                  else (pure ())
                  (X_set t 64 (← (Mem_read (BitVec.addInt address 0) 8 accdesc)))
                  (X_set t2 64 (← (Mem_read (BitVec.addInt address 8) 8 accdesc))))))
      else
        (do
          let data ← (( do (Mem_read address dbytes accdesc) ) : SailM (BitVec datasize) )
          assert ((datasize ≥b 0) && (regsize ≥b datasize)) "src/instrs64.sail:29428.73-29428.74"
          (X_set t regsize (Sail.BitVec.zeroExtend data regsize))))
  | _ => (pure ())
  bif (← readReg SPESampleInFlight)
  then
    (do
      let ar : (BitVec 1) :=
        bif acqrel
        then (0b1 : (BitVec 1))
        else (0b0 : (BitVec 1))
      let excl : (BitVec 1) := (0b1 : (BitVec 1))
      let at' : (BitVec 1) := (0b0 : (BitVec 1))
      let is_load : Bool := (BEq.beq memop MemOp_LOAD)
      (SPESampleExtendedLoadStore ar excl at' is_load))
  else (pure ())

def decode_ldaxr_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29462.84-29462.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29479.88-29479.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29495.88-29495.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_ldaxrb_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29548.84-29548.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29565.88-29565.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29581.88-29581.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_ldaxrh_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29634.84-29634.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29651.88-29651.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29667.88-29667.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_ldxr_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29720.84-29720.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29737.88-29737.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29753.88-29753.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_ldxrb_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29806.84-29806.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29823.88-29823.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29839.88-29839.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_ldxrh_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29892.84-29892.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29909.88-29909.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29925.88-29925.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_stlxr_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:29978.84-29978.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:29995.88-29995.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30011.88-30011.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_stlxrb_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:30064.84-30064.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30081.88-30081.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30097.88-30097.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_stlxrh_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:30150.84-30150.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30167.88-30167.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30183.88-30183.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_stxr_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:30236.84-30236.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30253.88-30253.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30269.88-30269.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_stxrb_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:30322.84-30322.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30339.88-30339.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30355.88-30355.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

def decode_stxrh_aarch64_instrs_memory_exclusive_single (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (o0 : (BitVec 1)) (Rs : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let s := (BitVec.toNat Rs)
  let acqrel : Bool := (o0 == (0b1 : (BitVec 1)))
  let pair : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let elsize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (elsize == 64)
    then 64
    else 32
  let datasize :=
    bif pair
    then (elsize *i 2)
    else elsize
  let tagchecked : Bool := (n != 31)
  let rt_unknown : Bool := false
  let rn_unknown : Bool := false
  let rt_unknown ← (( do
    bif (((BEq.beq memop MemOp_LOAD) && pair) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:30408.84-30408.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let (rn_unknown, rt_unknown) ← (( do
    bif (BEq.beq memop MemOp_STORE)
    then
      (do
        let rt_unknown ← (( do
          bif ((s == t) || (pair && (s == t2)))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_DATAOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30425.88-30425.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rt_unknown))
              | _ => (pure rt_unknown))
          else (pure rt_unknown) ) : SailM Bool )
        let rn_unknown ← (( do
          bif ((s == n) && (n != 31))
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_BASEOVERLAP) ) : SailM
                Constraint )
              assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
                    Constraint_NOP))) "src/instrs64.sail:30441.88-30441.89"
              match c with
              | Constraint_UNKNOWN => (pure true)
              | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
              | Constraint_NOP =>
                (do
                  (EndOfInstruction ())
                  (pure rn_unknown))
              | _ => (pure rn_unknown))
          else (pure rn_unknown) ) : SailM Bool )
        (pure (rn_unknown, rt_unknown)))
    else (pure (rn_unknown, rt_unknown)) ) : SailM (Bool × Bool) )
  (execute_aarch64_instrs_memory_exclusive_single acqrel datasize elsize memop n pair regsize
    rn_unknown rt_unknown s t t2 tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, t : Nat, t2 : Nat, k_tagchecked :
  Bool, 0 ≤ t2 ∧ t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_atomicops_ld_128_ldclrp (acquire : Bool) (n : Nat) (op : MemAtomicOp) (release : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let value1_name ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let value2_name ← (( do (X_read t2 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescAtomicOp op acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let store_value ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (value1_name ++ value2_name))
    else (pure (value2_name ++ value1_name)) ) : SailM (BitVec 128) )
  let comparevalue ← (( do (__UNKNOWN_bits 128) ) : SailM (BitVec 128) )
  let data ← (( do (MemAtomic address comparevalue store_value accdesc) ) : SailM (BitVec 128) )
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set t 64 (Sail.BitVec.extractLsb data 127 64))
      (X_set t2 64 (Sail.BitVec.extractLsb data 63 0)))
  else
    (do
      (X_set t 64 (Sail.BitVec.extractLsb data 63 0))
      (X_set t2 64 (Sail.BitVec.extractLsb data 127 64)))

def decode_ldclrp_aarch64_instrs_memory_atomicops_ld_128_ldclrp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rt2 : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveLSE128 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt2 == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let n := (BitVec.toNat Rn)
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b001 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_BIC
      ())
    else
      (bif (b__0 == (0b011 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_ORR
        ())
      else ())
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld_128_ldclrp acquire n op release t t2 tagchecked)

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcgettag (n : Nat) (offset : (BitVec 64)) (t : Nat) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) := (address + offset)
  let address : (BitVec 64) := (Align_bits address TAG_GRANULE)
  let accdesc ← (( do (CreateAccDescLDGSTG MemOp_LOAD) ) : SailM AccessDescriptor )
  let tag ← (( do (AArch64_MemTag_read address accdesc) ) : SailM (BitVec 4) )
  (X_set t 64 (← (AArch64_AddressWithAllocationTag (← (X_read t 64)) tag)))

def decode_ldg_aarch64_instrs_integer_tags_mcgettag (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Xt)
  let n := (BitVec.toNat Xn)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  (execute_aarch64_instrs_integer_tags_mcgettag n offset t)

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcgettagarray (n : Nat) (t : Nat) : SailM Unit := do
  bif ((← readReg PSTATE).EL == EL0)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let data : (BitVec 64) := (Zeros (n := 64))
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let size ← do (pure (4 *i (2 ^i (BitVec.toNat (_get_GMID_EL1_Type_BS (← readReg GMID_EL1))))))
  let address : (BitVec 64) := (Align_bits address size)
  let count := (Int.shiftr size LOG2_TAG_GRANULE)
  let index : Int :=
    (BitVec.toNat (Sail.BitVec.extractLsb address (LOG2_TAG_GRANULE +i 3) LOG2_TAG_GRANULE))
  let accdesc ← (( do (CreateAccDescLDGSTG MemOp_LOAD) ) : SailM AccessDescriptor )
  let (address, data, index) ← (( do
    let loop_i_lower := 0
    let loop_i_upper := (count -i 1)
    let mut loop_vars := (address, data, index)
    for i in [loop_i_lower:loop_i_upper:1]i do
      let (address, data, index) := loop_vars
      loop_vars ← do
        let tag ← (( do (AArch64_MemTag_read address accdesc) ) : SailM (BitVec 4) )
        let index := index
        assert ((0 ≤b (index *i 4)) && (((index *i 4) +i 3) <b 64)) "src/instrs64.sail:30614.72-30614.73"
        let data : (BitVec 64) :=
          (Sail.BitVec.updateSubrange data ((index *i 4) +i 3) (index *i 4) tag)
        (pure ())
        let address : (BitVec 64) := (BitVec.addInt address TAG_GRANULE)
        let index : Int := (index +i 1)
        (pure (address, data, index))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64) × Int) )
  (X_set t 64 data)

def decode_ldgm_aarch64_instrs_integer_tags_mcgettagarray (Xt : (BitVec 5)) (Xn : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveMTE2Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Xt)
  let n := (BitVec.toNat Xn)
  (execute_aarch64_instrs_integer_tags_mcgettagarray n t)

/-- Type quantifiers: datasize : Nat, n : Nat, offset : Int, k_postindex : Bool, k_rt_unknown : Bool, t
  : Nat, t2 : Nat, k_tagchecked : Bool, k_wb_unknown : Bool, k_wback : Bool, 0 ≤ t2 ∧
  t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {32, 64} -/
def execute_aarch64_instrs_memory_ordered_pair_ldiapp (datasize : Nat) (memop : MemOp) (n : Nat) (offset : Int) (postindex : Bool) (rt_unknown : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) (wb_unknown : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data1 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let data2 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let dbytes := (Int.ediv datasize 8)
  let accdesc ← (( do (CreateAccDescAcqRel memop tagchecked) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (BitVec.addInt address offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      let data1 ← (( do
        bif (rt_unknown && (t == n))
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let data2 ← (( do
        bif (rt_unknown && (t2 == n))
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t2 datasize)) ) : SailM (BitVec datasize) )
      bif (← (HaveLSE2Ext ()))
      then
        (do
          let full_data ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM
            (BitVec (2 * datasize)) )
          let full_data ← (( do
            bif (← (BigEndian accdesc.acctype))
            then (pure (data1 ++ data2))
            else (pure (data2 ++ data1)) ) : SailM (BitVec (2 * datasize)) )
          let ispair : Bool := true
          let highestAddressfirst : Bool := ((! postindex) && (offset <b 0))
          (Mem_set__2 address (2 *i dbytes) accdesc ispair highestAddressfirst full_data))
      else
        (do
          bif ((! postindex) && (offset <b 0))
          then
            (do
              (Mem_set (BitVec.addInt address dbytes) dbytes accdesc data2)
              (Mem_set (BitVec.addInt address 0) dbytes accdesc data1))
          else
            (do
              (Mem_set (BitVec.addInt address 0) dbytes accdesc data1)
              (Mem_set (BitVec.addInt address dbytes) dbytes accdesc data2))))
  | MemOp_LOAD =>
    (do
      let (data1, data2) ← (( do
        bif (← (HaveLSE2Ext ()))
        then
          (do
            let ispair : Bool := true
            let full_data ← (( do (Mem_read__1 address (2 *i dbytes) accdesc ispair) ) : SailM
              (BitVec (2 * datasize)) )
            let (data1, data2) ← (( do
              bif (← (BigEndian accdesc.acctype))
              then
                (let data2 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data (datasize -i 1) 0)
                let data1 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data ((2 *i datasize) -i 1) datasize)
                (pure (data1, data2)))
              else
                (let data1 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data (datasize -i 1) 0)
                let data2 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data ((2 *i datasize) -i 1) datasize)
                (pure (data1, data2))) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
            (pure (data1, data2)))
        else
          (do
            let data1 ← (Mem_read (BitVec.addInt address 0) dbytes accdesc)
            let data2 ← (Mem_read (BitVec.addInt address dbytes) dbytes accdesc)
            (pure (data1, data2))) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
      let (data1, data2) ← (( do
        bif rt_unknown
        then
          (do
            let data1 ← (__UNKNOWN_bits datasize)
            let data2 ← (__UNKNOWN_bits datasize)
            (pure (data1, data2)))
        else (pure (data1, data2)) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
      (X_set t datasize data1)
      (X_set t2 datasize data2))
  | _ => (pure ())
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (bif postindex
          then (pure (BitVec.addInt address offset))
          else (pure address)) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ldiapp_aarch64_instrs_memory_ordered_pair_ldiapp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc2 : (BitVec 4)) (Rt2 : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let postindex : Bool := ((BitVec.join1 [(BitVec.access opc2 0)]) == (0b0 : (BitVec 1)))
  let wback : Bool := ((BitVec.join1 [(BitVec.access opc2 0)]) == (0b0 : (BitVec 1)))
  let offset ← (( do (undefined_int ()) ) : SailM Int )
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access size 0)])))
  let datasize := (Int.shiftl 8 scale)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let (memop, offset) : (MemOp × Int) :=
    bif (L == (0b1 : (BitVec 1)))
    then
      (let memop : MemOp := MemOp_LOAD
      let offset : Int :=
        bif ((BitVec.join1 [(BitVec.access opc2 0)]) == (0b0 : (BitVec 1)))
        then (Int.shiftl 2 scale)
        else 0
      (memop, offset))
    else
      (let memop : MemOp := MemOp_STORE
      let offset : Int :=
        bif ((BitVec.join1 [(BitVec.access opc2 0)]) == (0b0 : (BitVec 1)))
        then ((Neg.neg 1) *i (Int.shiftl 2 scale))
        else 0
      (memop, offset))
  let offset := offset
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:30759.113-30759.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:30778.107-30778.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:30797.84-30797.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:30811.44-30811.45"
  (execute_aarch64_instrs_memory_ordered_pair_ldiapp datasize memop n offset postindex rt_unknown t
    t2 tagchecked wb_unknown wback)

/-- Type quantifiers: datasize : Nat, n : Nat, k_nontemporal : Bool, k_postindex : Bool, k_rt_unknown
  : Bool, t : Nat, t2 : Nat, k_tagchecked : Bool, k_wback : Bool, 0 ≤ t2 ∧
  t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {32, 64} -/
def execute_aarch64_instrs_memory_pair_general_no_alloc (datasize : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (postindex : Bool) (rt_unknown : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data1 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let data2 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let dbytes := (Int.ediv datasize 8)
  let privileged ← (( do (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let accdesc ← (( do (CreateAccDescGPR memop nontemporal privileged tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      let data1 ← (( do
        bif (rt_unknown && (t == n))
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let data2 ← (( do
        bif (rt_unknown && (t2 == n))
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t2 datasize)) ) : SailM (BitVec datasize) )
      (Mem_set (BitVec.addInt address 0) dbytes accdesc data1)
      (Mem_set (BitVec.addInt address dbytes) dbytes accdesc data2))
  | MemOp_LOAD =>
    (do
      let (data1, data2) ← (( do
        bif (← (HaveLSE2Ext ()))
        then
          (do
            let ispair : Bool := true
            let full_data ← (( do (Mem_read__1 address (2 *i dbytes) accdesc ispair) ) : SailM
              (BitVec (2 * datasize)) )
            let (data1, data2) ← (( do
              bif (← (BigEndian accdesc.acctype))
              then
                (let data2 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data (datasize -i 1) 0)
                let data1 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data ((2 *i datasize) -i 1) datasize)
                (pure (data1, data2)))
              else
                (let data1 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data (datasize -i 1) 0)
                let data2 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data ((2 *i datasize) -i 1) datasize)
                (pure (data1, data2))) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
            (pure (data1, data2)))
        else
          (do
            let data1 ← (Mem_read (BitVec.addInt address 0) dbytes accdesc)
            let data2 ← (Mem_read (BitVec.addInt address dbytes) dbytes accdesc)
            (pure (data1, data2))) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
      let (data1, data2) ← (( do
        bif rt_unknown
        then
          (do
            let data1 ← (__UNKNOWN_bits datasize)
            let data2 ← (__UNKNOWN_bits datasize)
            (pure (data1, data2)))
        else (pure (data1, data2)) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
      (X_set t datasize data1)
      (X_set t2 datasize data2))
  | _ => (pure ())
  bif wback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ldnp_gen_aarch64_instrs_memory_pair_general_no_alloc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := true
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:30921.84-30921.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:30935.44-30935.45"
  (execute_aarch64_instrs_memory_pair_general_no_alloc datasize memop n nontemporal offset postindex
    rt_unknown t t2 tagchecked wback)

def decode_stnp_gen_aarch64_instrs_memory_pair_general_no_alloc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := true
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:30970.84-30970.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:30984.44-30984.45"
  (execute_aarch64_instrs_memory_pair_general_no_alloc datasize memop n nontemporal offset postindex
    rt_unknown t t2 tagchecked wback)

/-- Type quantifiers: datasize : Nat, n : Nat, k_nontemporal : Bool, k_postindex : Bool, k_rt_unknown
  : Bool, t : Nat, t2 : Nat, k_tagchecked : Bool, k_wback : Bool, 0 ≤ t2 ∧
  t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {32, 64, 128, 256} -/
def execute_aarch64_instrs_memory_pair_simdfp_no_alloc (datasize : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (postindex : Bool) (rt_unknown : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  (CheckFPEnabled64 ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data1 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let data2 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let dbytes := (Int.ediv datasize 8)
  let accdesc ← (( do (CreateAccDescASIMD memop nontemporal tagchecked) ) : SailM AccessDescriptor
    )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:31021.62-31021.63"
      let data1 ← (( do (V_read t datasize) ) : SailM (BitVec datasize) )
      let data2 ← (( do (V_read t2 datasize) ) : SailM (BitVec datasize) )
      (Mem_set (BitVec.addInt address 0) dbytes accdesc data1)
      (Mem_set (BitVec.addInt address dbytes) dbytes accdesc data2))
  | MemOp_LOAD =>
    (do
      let data1 ← (( (Mem_read (BitVec.addInt address 0) dbytes accdesc) ) : SailM
        (BitVec datasize) )
      let data2 ← (( (Mem_read (BitVec.addInt address dbytes) dbytes accdesc) ) : SailM
        (BitVec datasize) )
      let (data1, data2) ← (( do
        bif rt_unknown
        then
          (do
            let data1 ← (__UNKNOWN_bits datasize)
            let data2 ← (__UNKNOWN_bits datasize)
            (pure (data1, data2)))
        else (pure (data1, data2)) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:31034.62-31034.63"
      (V_set t datasize data1)
      (V_set t2 datasize data2))
  | _ => (pure ())
  bif wback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleSIMDFPLoadStore ())
  else (pure ())

def decode_ldnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := true
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (opc == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let scale := (2 +i (BitVec.toNat opc))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31076.84-31076.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((((datasize == 32) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) "src/instrs64.sail:31090.54-31090.55"
  (execute_aarch64_instrs_memory_pair_simdfp_no_alloc datasize memop n nontemporal offset postindex
    rt_unknown t t2 tagchecked wback)

def decode_stnp_fpsimd_aarch64_instrs_memory_pair_simdfp_no_alloc (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := true
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (opc == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let scale := (2 +i (BitVec.toNat opc))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31125.84-31125.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((((datasize == 32) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) "src/instrs64.sail:31139.54-31139.55"
  (execute_aarch64_instrs_memory_pair_simdfp_no_alloc datasize memop n nontemporal offset postindex
    rt_unknown t t2 tagchecked wback)

/-- Type quantifiers: datasize : Nat, n : Nat, k_nontemporal : Bool, k_postindex : Bool, k_rt_unknown
  : Bool, t : Nat, t2 : Nat, k_tagchecked : Bool, k_wback : Bool, 0 ≤ t2 ∧
  t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {32, 64, 128, 256} -/
def execute_aarch64_instrs_memory_pair_simdfp_post_idx (datasize : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (postindex : Bool) (rt_unknown : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  (CheckFPEnabled64 ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data1 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let data2 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let dbytes := (Int.ediv datasize 8)
  let accdesc ← (( do (CreateAccDescASIMD memop nontemporal tagchecked) ) : SailM AccessDescriptor
    )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:31176.62-31176.63"
      let data1 ← (( do (V_read t datasize) ) : SailM (BitVec datasize) )
      let data2 ← (( do (V_read t2 datasize) ) : SailM (BitVec datasize) )
      (Mem_set (BitVec.addInt address 0) dbytes accdesc data1)
      (Mem_set (BitVec.addInt address dbytes) dbytes accdesc data2))
  | MemOp_LOAD =>
    (do
      let data1 ← (( (Mem_read (BitVec.addInt address 0) dbytes accdesc) ) : SailM
        (BitVec datasize) )
      let data2 ← (( (Mem_read (BitVec.addInt address dbytes) dbytes accdesc) ) : SailM
        (BitVec datasize) )
      let (data1, data2) ← (( do
        bif rt_unknown
        then
          (do
            let data1 ← (__UNKNOWN_bits datasize)
            let data2 ← (__UNKNOWN_bits datasize)
            (pure (data1, data2)))
        else (pure (data1, data2)) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:31189.62-31189.63"
      (V_set t datasize data1)
      (V_set t2 datasize data2))
  | _ => (pure ())
  bif wback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleSIMDFPLoadStore ())
  else (pure ())

def decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (opc == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let scale := (2 +i (BitVec.toNat opc))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31231.84-31231.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((((datasize == 32) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) "src/instrs64.sail:31245.54-31245.55"
  (execute_aarch64_instrs_memory_pair_simdfp_post_idx datasize memop n nontemporal offset postindex
    rt_unknown t t2 tagchecked wback)

def decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (opc == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let scale := (2 +i (BitVec.toNat opc))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31280.84-31280.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((((datasize == 32) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) "src/instrs64.sail:31294.54-31294.55"
  (execute_aarch64_instrs_memory_pair_simdfp_post_idx datasize memop n nontemporal offset postindex
    rt_unknown t t2 tagchecked wback)

def decode_ldp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (opc == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let scale := (2 +i (BitVec.toNat opc))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31329.84-31329.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((((datasize == 32) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) "src/instrs64.sail:31343.54-31343.55"
  (execute_aarch64_instrs_memory_pair_simdfp_post_idx datasize memop n nontemporal offset postindex
    rt_unknown t t2 tagchecked wback)

def decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (opc == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let scale := (2 +i (BitVec.toNat opc))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31378.84-31378.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((((datasize == 32) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) "src/instrs64.sail:31392.54-31392.55"
  (execute_aarch64_instrs_memory_pair_simdfp_post_idx datasize memop n nontemporal offset postindex
    rt_unknown t t2 tagchecked wback)

def decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (opc == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let scale := (2 +i (BitVec.toNat opc))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31427.84-31427.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((((datasize == 32) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) "src/instrs64.sail:31441.54-31441.55"
  (execute_aarch64_instrs_memory_pair_simdfp_post_idx datasize memop n nontemporal offset postindex
    rt_unknown t t2 tagchecked wback)

def decode_stp_fpsimd_aarch64_instrs_memory_pair_simdfp_offset (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (opc == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let scale := (2 +i (BitVec.toNat opc))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31476.84-31476.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((((datasize == 32) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) "src/instrs64.sail:31490.54-31490.55"
  (execute_aarch64_instrs_memory_pair_simdfp_post_idx datasize memop n nontemporal offset postindex
    rt_unknown t t2 tagchecked wback)

/-- Type quantifiers: datasize : Nat, k_is_signed : Bool, n : Nat, k_nontemporal : Bool, k_postindex
  : Bool, k_rt_unknown : Bool, t : Nat, t2 : Nat, k_tagchecked : Bool, k_wb_unknown : Bool, k_wback
  : Bool, 0 ≤ t2 ∧
  t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {32, 64} -/
def execute_aarch64_instrs_memory_pair_general_post_idx (datasize : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (postindex : Bool) (rt_unknown : Bool) (is_signed : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) (wb_unknown : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data1 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let data2 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let dbytes := (Int.ediv datasize 8)
  let privileged ← (( do (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let accdesc ← (( do (CreateAccDescGPR memop nontemporal privileged tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      let data1 ← (( do
        bif (rt_unknown && (t == n))
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let data2 ← (( do
        bif (rt_unknown && (t2 == n))
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t2 datasize)) ) : SailM (BitVec datasize) )
      bif (← (HaveLSE2Ext ()))
      then
        (do
          let full_data ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM
            (BitVec (2 * datasize)) )
          let full_data ← (( do
            bif (← (BigEndian accdesc.acctype))
            then (pure (data1 ++ data2))
            else (pure (data2 ++ data1)) ) : SailM (BitVec (2 * datasize)) )
          let ispair : Bool := true
          (Mem_set__1 address (2 *i dbytes) accdesc ispair full_data))
      else
        (do
          (Mem_set (BitVec.addInt address 0) dbytes accdesc data1)
          (Mem_set (BitVec.addInt address dbytes) dbytes accdesc data2)))
  | MemOp_LOAD =>
    (do
      let (data1, data2) ← (( do
        bif ((← (HaveLSE2Ext ())) && (! is_signed))
        then
          (do
            let ispair : Bool := true
            let full_data ← (( do (Mem_read__1 address (2 *i dbytes) accdesc ispair) ) : SailM
              (BitVec (2 * datasize)) )
            let (data1, data2) ← (( do
              bif (← (BigEndian accdesc.acctype))
              then
                (let data2 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data (datasize -i 1) 0)
                let data1 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data ((2 *i datasize) -i 1) datasize)
                (pure (data1, data2)))
              else
                (let data1 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data (datasize -i 1) 0)
                let data2 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data ((2 *i datasize) -i 1) datasize)
                (pure (data1, data2))) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
            (pure (data1, data2)))
        else
          (do
            let data1 ← (Mem_read (BitVec.addInt address 0) dbytes accdesc)
            let data2 ← (Mem_read (BitVec.addInt address dbytes) dbytes accdesc)
            (pure (data1, data2))) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
      let (data1, data2) ← (( do
        bif rt_unknown
        then
          (do
            let data1 ← (__UNKNOWN_bits datasize)
            let data2 ← (__UNKNOWN_bits datasize)
            (pure (data1, data2)))
        else (pure (data1, data2)) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
      bif is_signed
      then
        (do
          (X_set t 64 (sign_extend data1 64))
          (X_set t2 64 (sign_extend data2 64)))
      else
        (do
          (X_set t datasize data1)
          (X_set t2 datasize data2)))
  | _ => (pure ())
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (bif postindex
          then (pure (address + offset))
          else (pure address)) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ldp_gen_aarch64_instrs_memory_pair_general_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (((L ++ (BitVec.join1 [(BitVec.access opc 0)])) == (0b01 : (BitVec 2))) || (opc == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) != (0b0 : (BitVec 1)))
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:31620.113-31620.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:31639.107-31639.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31658.84-31658.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:31672.44-31672.45"
  (execute_aarch64_instrs_memory_pair_general_post_idx datasize memop n nontemporal offset postindex
    rt_unknown is_signed t t2 tagchecked wb_unknown wback)

def decode_ldp_gen_aarch64_instrs_memory_pair_general_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (((L ++ (BitVec.join1 [(BitVec.access opc 0)])) == (0b01 : (BitVec 2))) || (opc == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) != (0b0 : (BitVec 1)))
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:31709.113-31709.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:31728.107-31728.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31747.84-31747.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:31761.44-31761.45"
  (execute_aarch64_instrs_memory_pair_general_post_idx datasize memop n nontemporal offset postindex
    rt_unknown is_signed t t2 tagchecked wb_unknown wback)

def decode_ldp_gen_aarch64_instrs_memory_pair_general_offset (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (((L ++ (BitVec.join1 [(BitVec.access opc 0)])) == (0b01 : (BitVec 2))) || (opc == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) != (0b0 : (BitVec 1)))
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:31798.113-31798.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:31817.107-31817.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31836.84-31836.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:31850.44-31850.45"
  (execute_aarch64_instrs_memory_pair_general_post_idx datasize memop n nontemporal offset postindex
    rt_unknown is_signed t t2 tagchecked wb_unknown wback)

def decode_ldpsw_aarch64_instrs_memory_pair_general_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (((L ++ (BitVec.join1 [(BitVec.access opc 0)])) == (0b01 : (BitVec 2))) || (opc == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) != (0b0 : (BitVec 1)))
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:31887.113-31887.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:31906.107-31906.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:31925.84-31925.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:31939.44-31939.45"
  (execute_aarch64_instrs_memory_pair_general_post_idx datasize memop n nontemporal offset postindex
    rt_unknown is_signed t t2 tagchecked wb_unknown wback)

def decode_ldpsw_aarch64_instrs_memory_pair_general_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (((L ++ (BitVec.join1 [(BitVec.access opc 0)])) == (0b01 : (BitVec 2))) || (opc == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) != (0b0 : (BitVec 1)))
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:31976.113-31976.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:31995.107-31995.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:32014.84-32014.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:32028.44-32028.45"
  (execute_aarch64_instrs_memory_pair_general_post_idx datasize memop n nontemporal offset postindex
    rt_unknown is_signed t t2 tagchecked wb_unknown wback)

def decode_ldpsw_aarch64_instrs_memory_pair_general_offset (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (((L ++ (BitVec.join1 [(BitVec.access opc 0)])) == (0b01 : (BitVec 2))) || (opc == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) != (0b0 : (BitVec 1)))
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:32065.113-32065.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:32084.107-32084.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:32103.84-32103.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:32117.44-32117.45"
  (execute_aarch64_instrs_memory_pair_general_post_idx datasize memop n nontemporal offset postindex
    rt_unknown is_signed t t2 tagchecked wb_unknown wback)

def decode_stp_gen_aarch64_instrs_memory_pair_general_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (((L ++ (BitVec.join1 [(BitVec.access opc 0)])) == (0b01 : (BitVec 2))) || (opc == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) != (0b0 : (BitVec 1)))
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:32154.113-32154.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:32173.107-32173.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:32192.84-32192.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:32206.44-32206.45"
  (execute_aarch64_instrs_memory_pair_general_post_idx datasize memop n nontemporal offset postindex
    rt_unknown is_signed t t2 tagchecked wb_unknown wback)

def decode_stp_gen_aarch64_instrs_memory_pair_general_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (((L ++ (BitVec.join1 [(BitVec.access opc 0)])) == (0b01 : (BitVec 2))) || (opc == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) != (0b0 : (BitVec 1)))
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:32243.113-32243.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:32262.107-32262.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:32281.84-32281.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:32295.44-32295.45"
  (execute_aarch64_instrs_memory_pair_general_post_idx datasize memop n nontemporal offset postindex
    rt_unknown is_signed t t2 tagchecked wb_unknown wback)

def decode_stp_gen_aarch64_instrs_memory_pair_general_offset (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rt2 : (BitVec 5)) (imm7 : (BitVec 7)) (L : (BitVec 1)) (opc : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif (L == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  bif (((L ++ (BitVec.join1 [(BitVec.access opc 0)])) == (0b01 : (BitVec 2))) || (opc == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := ((BitVec.join1 [(BitVec.access opc 0)]) != (0b0 : (BitVec 1)))
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access opc 1)])))
  let datasize := (Int.shiftl 8 scale)
  let offset : (BitVec 64) := ((sign_extend imm7 64) <<< scale)
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:32332.113-32332.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:32351.107-32351.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:32370.84-32370.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:32384.44-32384.45"
  (execute_aarch64_instrs_memory_pair_general_post_idx datasize memop n nontemporal offset postindex
    rt_unknown is_signed t t2 tagchecked wb_unknown wback)

/-- Type quantifiers: datasize : Nat, n : Nat, k_nontemporal : Bool, k_postindex : Bool, t : Nat, k_tagchecked
  : Bool, k_wback : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64, 128, 256, 512, 1024} -/
def execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx (datasize : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (postindex : Bool) (t : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  (CheckFPEnabled64 ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let accdesc ← (( do (CreateAccDescASIMD memop nontemporal tagchecked) ) : SailM AccessDescriptor
    )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:32419.62-32419.63"
      let data ← (( do (V_read t datasize) ) : SailM (BitVec datasize) )
      (Mem_set address (Int.ediv datasize 8) accdesc data))
  | MemOp_LOAD =>
    (do
      let data ← (( do (Mem_read address (Int.ediv datasize 8) accdesc) ) : SailM
        (BitVec datasize) )
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:32425.62-32425.63"
      (V_set t datasize data))
  | _ => (pure ())
  bif wback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleSIMDFPLoadStore ())
  else (pure ())

def decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:32462.72-32462.73"
  (execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex t tagchecked wback)

def decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:32492.72-32492.73"
  (execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex t tagchecked wback)

def decode_ldr_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:32522.72-32522.73"
  (execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex t tagchecked wback)

def decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:32552.72-32552.73"
  (execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex t tagchecked wback)

def decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:32582.72-32582.73"
  (execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex t tagchecked wback)

def decode_str_imm_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:32612.72-32612.73"
  (execute_aarch64_instrs_memory_single_simdfp_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex t tagchecked wback)

/-- Type quantifiers: k_is_signed : Bool, k_nontemporal : Bool, size : Nat, t : Nat, k_tagchecked :
  Bool, 0 ≤ t ∧ t ≤ 31 ∧ size ∈ {4, 8} -/
def execute_aarch64_instrs_memory_literal_general (memop : MemOp) (nontemporal : Bool) (offset : (BitVec 64)) (is_signed : Bool) (size : Nat) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (pure ((← (PC_read ())) + offset)) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector (size *i 8)) ) : SailM (BitVec (size * 8)) )
  let privileged ← (( do (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let accdesc ← (( do (CreateAccDescGPR memop nontemporal privileged tagchecked) ) : SailM
    AccessDescriptor )
  match memop with
  | MemOp_LOAD =>
    (do
      let data ← (( do (Mem_read address size accdesc) ) : SailM (BitVec (size * 8)) )
      bif is_signed
      then (X_set t 64 (sign_extend data 64))
      else (X_set t (size *i 8) data))
  | MemOp_PREFETCH => (Prefetch address (integer_subrange t 4 0))
  | _ => (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ldr_lit_gen_aarch64_instrs_memory_literal_general (Rt : (BitVec 5)) (imm19 : (BitVec 19)) (opc : (BitVec 2)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let memop : MemOp := MemOp_LOAD
  let is_signed : Bool := false
  let nontemporal : Bool := false
  let size : Int := 4
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let size : Int := 4
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let size : Int := 8
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let size : Int := 4
          let is_signed : Bool := true
          ())
        else
          (let memop : MemOp := MemOp_PREFETCH
          ())))
  let size := size
  let offset : (BitVec 64) := (sign_extend (imm19 ++ (0b00 : (BitVec 2))) 64)
  let tagchecked : Bool := false
  (execute_aarch64_instrs_memory_literal_general memop nontemporal offset is_signed size t
    tagchecked)

def decode_ldrsw_lit_aarch64_instrs_memory_literal_general (Rt : (BitVec 5)) (imm19 : (BitVec 19)) (opc : (BitVec 2)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let memop : MemOp := MemOp_LOAD
  let is_signed : Bool := false
  let nontemporal : Bool := false
  let size : Int := 4
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let size : Int := 4
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let size : Int := 8
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let size : Int := 4
          let is_signed : Bool := true
          ())
        else
          (let memop : MemOp := MemOp_PREFETCH
          ())))
  let size := size
  let offset : (BitVec 64) := (sign_extend (imm19 ++ (0b00 : (BitVec 2))) 64)
  let tagchecked : Bool := false
  (execute_aarch64_instrs_memory_literal_general memop nontemporal offset is_signed size t
    tagchecked)

def decode_prfm_lit_aarch64_instrs_memory_literal_general (Rt : (BitVec 5)) (imm19 : (BitVec 19)) (opc : (BitVec 2)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let memop : MemOp := MemOp_LOAD
  let is_signed : Bool := false
  let nontemporal : Bool := false
  let size : Int := 4
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b00 : (BitVec 2)))
    then
      (let size : Int := 4
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let size : Int := 8
        ())
      else
        (bif (b__0 == (0b10 : (BitVec 2)))
        then
          (let size : Int := 4
          let is_signed : Bool := true
          ())
        else
          (let memop : MemOp := MemOp_PREFETCH
          ())))
  let size := size
  let offset : (BitVec 64) := (sign_extend (imm19 ++ (0b00 : (BitVec 2))) 64)
  let tagchecked : Bool := false
  (execute_aarch64_instrs_memory_literal_general memop nontemporal offset is_signed size t
    tagchecked)

/-- Type quantifiers: k_nontemporal : Bool, size : Nat, t : Nat, k_tagchecked : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ size ∈ {4, 8, 16} -/
def execute_aarch64_instrs_memory_literal_simdfp (nontemporal : Bool) (offset : (BitVec 64)) (size : Nat) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (pure ((← (PC_read ())) + offset)) ) : SailM (BitVec 64) )
  let privileged ← (( do (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  (CheckFPEnabled64 ())
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do (Mem_read address size accdesc) ) : SailM (BitVec (size * 8)) )
  (V_set t (size *i 8) data)
  bif (← readReg SPESampleInFlight)
  then (SPESampleSIMDFPLoadStore ())
  else (pure ())

def decode_ldr_lit_fpsimd_aarch64_instrs_memory_literal_simdfp (Rt : (BitVec 5)) (imm19 : (BitVec 19)) (opc : (BitVec 2)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let size : Int := 4
  let b__0 := opc
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let size : Int := 4
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let size : Int := 8
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let size : Int := 16
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let size := size
  let offset : (BitVec 64) := (sign_extend (imm19 ++ (0b00 : (BitVec 2))) 64)
  let tagchecked : Bool := false
  (execute_aarch64_instrs_memory_literal_simdfp nontemporal offset size t tagchecked)

/-- Type quantifiers: datasize : Nat, k_is_signed : Bool, n : Nat, k_nontemporal : Bool, k_postindex
  : Bool, regsize : Nat, k_rt_unknown : Bool, t : Nat, k_tagchecked : Bool, k_wb_unknown : Bool, k_wback
  : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ regsize ∈ {32, 64} ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx (datasize : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (postindex : Bool) (regsize : Nat) (rt_unknown : Bool) (is_signed : Bool) (t : Nat) (tagchecked : Bool) (wb_unknown : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let privileged ← (( do (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let accdesc ← (( do (CreateAccDescGPR memop nontemporal privileged tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        bif (bne memop MemOp_PREFETCH)
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      let data ← (( do
        bif rt_unknown
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let _ : Unit :=
        bif (! wback)
        then (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) false t (regsize == 64) false)
        else ()
      (Mem_set address (Int.ediv datasize 8) accdesc data))
  | MemOp_LOAD =>
    (do
      let _ : Unit :=
        bif (! wback)
        then
          (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) is_signed t (regsize == 64) false)
        else ()
      let data ← (( do (Mem_read address (Int.ediv datasize 8) accdesc) ) : SailM
        (BitVec datasize) )
      bif is_signed
      then
        (do
          assert ((datasize >b 0) && (regsize ≥b datasize)) "src/instrs64.sail:32855.72-32855.73"
          (X_set t regsize (sign_extend data regsize)))
      else
        (do
          assert ((datasize ≥b 0) && (regsize ≥b datasize)) "src/instrs64.sail:32858.73-32858.74"
          (X_set t regsize (Sail.BitVec.zeroExtend data regsize))))
  | MemOp_PREFETCH => (Prefetch address (integer_subrange t 4 0))
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (bif postindex
          then (pure (address + offset))
          else (pure address)) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:32921.113-32921.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:32940.107-32940.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33007.113-33007.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33026.107-33026.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldr_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33093.113-33093.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33112.107-33112.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33179.113-33179.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33198.107-33198.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33265.113-33265.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33284.107-33284.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrb_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33351.113-33351.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33370.107-33370.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33437.113-33437.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33456.107-33456.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33523.113-33523.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33542.107-33542.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrh_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33609.113-33609.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33628.107-33628.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33695.113-33695.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33714.107-33714.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33781.113-33781.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33800.107-33800.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrsb_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33867.113-33867.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33886.107-33886.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33953.113-33953.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:33972.107-33972.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34039.113-34039.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34058.107-34058.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrsh_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34125.113-34125.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34144.107-34144.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34211.113-34211.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34230.107-34230.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34297.113-34297.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34316.107-34316.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldrsw_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34383.113-34383.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34402.107-34402.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34469.113-34469.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34488.107-34488.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34555.113-34555.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34574.107-34574.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_str_imm_gen_aarch64_instrs_memory_single_general_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34641.113-34641.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34660.107-34660.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34727.113-34727.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34746.107-34746.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_strb_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34813.113-34813.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34832.107-34832.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_strb_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34899.113-34899.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34918.107-34918.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_post_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := true
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:34985.113-34985.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35004.107-35004.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_strh_imm_aarch64_instrs_memory_single_general_immediate_signed_pre_idx (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := true
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35071.113-35071.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35090.107-35090.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_strh_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35157.113-35157.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35176.107-35176.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_post_idx datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

/-- Type quantifiers: datasize : Nat, k_is_signed : Bool, m : Nat, n : Nat, k_nontemporal : Bool, k_postindex
  : Bool, regsize : Nat, k_rt_unknown : Bool, shift : Nat, t : Nat, k_tagchecked : Bool, k_wb_unknown
  : Bool, k_wback : Bool, 0 ≤ t ∧
  t ≤ 31 ∧
  shift ∈ {0, 1, 2, 3} ∧
  regsize ∈ {32, 64} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_single_general_register (datasize : Nat) (extend_type : ExtendType) (m : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (postindex : Bool) (regsize : Nat) (rt_unknown : Bool) (shift : Nat) (is_signed : Bool) (t : Nat) (tagchecked : Bool) (wb_unknown : Bool) (wback : Bool) : SailM Unit := do
  let offset ← (( do (ExtendReg m extend_type shift 64) ) : SailM (BitVec 64) )
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let privileged ← (( do (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let accdesc ← (( do (CreateAccDescGPR memop nontemporal privileged tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        bif (bne memop MemOp_PREFETCH)
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      let data ← (( do
        bif rt_unknown
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let _ : Unit :=
        bif (! wback)
        then (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) false t (regsize == 64) false)
        else ()
      (Mem_set address (Int.ediv datasize 8) accdesc data))
  | MemOp_LOAD =>
    (do
      let _ : Unit :=
        bif (! wback)
        then
          (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) is_signed t (regsize == 64) false)
        else ()
      let data ← (( do (Mem_read address (Int.ediv datasize 8) accdesc) ) : SailM
        (BitVec datasize) )
      bif is_signed
      then
        (do
          assert ((datasize >b 0) && (regsize ≥b datasize)) "src/instrs64.sail:35245.72-35245.73"
          (X_set t regsize (sign_extend data regsize)))
      else
        (do
          assert ((datasize ≥b 0) && (regsize ≥b datasize)) "src/instrs64.sail:35248.73-35248.74"
          (X_set t regsize (Sail.BitVec.zeroExtend data regsize))))
  | MemOp_PREFETCH => (Prefetch address (integer_subrange t 4 0))
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (bif postindex
          then (pure (address + offset))
          else (pure address)) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ldr_reg_gen_aarch64_instrs_memory_single_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35320.113-35320.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35339.107-35339.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_register datasize extend_type m memop n nontemporal
    postindex regsize rt_unknown shift is_signed t tagchecked wb_unknown wback)

def decode_ldrb_reg_aarch64_instrs_memory_single_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35417.113-35417.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35436.107-35436.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_register datasize extend_type m memop n nontemporal
    postindex regsize rt_unknown shift is_signed t tagchecked wb_unknown wback)

def decode_ldrh_reg_aarch64_instrs_memory_single_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35514.113-35514.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35533.107-35533.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_register datasize extend_type m memop n nontemporal
    postindex regsize rt_unknown shift is_signed t tagchecked wb_unknown wback)

def decode_ldrsb_reg_aarch64_instrs_memory_single_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35611.113-35611.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35630.107-35630.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_register datasize extend_type m memop n nontemporal
    postindex regsize rt_unknown shift is_signed t tagchecked wb_unknown wback)

def decode_ldrsh_reg_aarch64_instrs_memory_single_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35708.113-35708.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35727.107-35727.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_register datasize extend_type m memop n nontemporal
    postindex regsize rt_unknown shift is_signed t tagchecked wb_unknown wback)

def decode_ldrsw_reg_aarch64_instrs_memory_single_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35805.113-35805.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35824.107-35824.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_register datasize extend_type m memop n nontemporal
    postindex regsize rt_unknown shift is_signed t tagchecked wb_unknown wback)

def decode_prfm_reg_aarch64_instrs_memory_single_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  assert (! (let b__0 := Rt
    bif ((Sail.BitVec.extractLsb b__0 4 3) == (0b11 : (BitVec 2)))
    then true
    else false : Bool)) "src/instrs64.sail:35862.14-35862.15"
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35906.113-35906.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:35925.107-35925.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_register datasize extend_type m memop n nontemporal
    postindex regsize rt_unknown shift is_signed t tagchecked wb_unknown wback)

def decode_str_reg_gen_aarch64_instrs_memory_single_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36006.113-36006.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36025.107-36025.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_register datasize extend_type m memop n nontemporal
    postindex regsize rt_unknown shift is_signed t tagchecked wb_unknown wback)

def decode_strb_reg_aarch64_instrs_memory_single_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36103.113-36103.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36122.107-36122.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_register datasize extend_type m memop n nontemporal
    postindex regsize rt_unknown shift is_signed t tagchecked wb_unknown wback)

def decode_strh_reg_aarch64_instrs_memory_single_general_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36200.113-36200.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36219.107-36219.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_register datasize extend_type m memop n nontemporal
    postindex regsize rt_unknown shift is_signed t tagchecked wb_unknown wback)

/-- Type quantifiers: datasize : Nat, m : Nat, n : Nat, k_nontemporal : Bool, k_postindex : Bool, shift
  : Nat, t : Nat, k_tagchecked : Bool, k_wback : Bool, 0 ≤ t ∧
  t ≤ 31 ∧
  shift ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {8, 16, 32, 64, 128, 256, 512, 1024} -/
def execute_aarch64_instrs_memory_single_simdfp_register (datasize : Nat) (extend_type : ExtendType) (m : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (postindex : Bool) (shift : Nat) (t : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  let offset ← (( do (ExtendReg m extend_type shift 64) ) : SailM (BitVec 64) )
  (CheckFPEnabled64 ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let accdesc ← (( do (CreateAccDescASIMD memop nontemporal tagchecked) ) : SailM AccessDescriptor
    )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:36272.62-36272.63"
      let data ← (( do (V_read t datasize) ) : SailM (BitVec datasize) )
      (Mem_set address (Int.ediv datasize 8) accdesc data))
  | MemOp_LOAD =>
    (do
      let data ← (( do (Mem_read address (Int.ediv datasize 8) accdesc) ) : SailM
        (BitVec datasize) )
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:36278.62-36278.63"
      (V_set t datasize data))
  | _ => (pure ())
  bif wback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleSIMDFPLoadStore ())
  else (pure ())

def decode_ldr_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:36320.72-36320.73"
  (execute_aarch64_instrs_memory_single_simdfp_register datasize extend_type m memop n nontemporal
    postindex shift t tagchecked wback)

def decode_str_reg_fpsimd_aarch64_instrs_memory_single_simdfp_register (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access option_name 1)]) == (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let extend_type ← (( do (DecodeRegExtend option_name) ) : SailM ExtendType )
  let shift :=
    bif (S == (0b1 : (BitVec 1)))
    then scale
    else 0
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let m := (BitVec.toNat Rm)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := (bne memop MemOp_PREFETCH)
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:36357.72-36357.73"
  (execute_aarch64_instrs_memory_single_simdfp_register datasize extend_type m memop n nontemporal
    postindex shift t tagchecked wback)

/-- Type quantifiers: n : Nat, k_nontemporal : Bool, t : Nat, k_tagchecked : Bool, k_use_key_a :
  Bool, k_wback : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_single_general_immediate_signed_pac (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (t : Nat) (tagchecked : Bool) (use_key_a : Bool) (wback__arg : Bool) : SailM Unit := do
  let wback : Bool := wback__arg
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let privileged ← (( do (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let wb_unknown : Bool := false
  let auth_then_branch : Bool := true
  let accdesc ← (( do (CreateAccDescGPR memop nontemporal privileged tagchecked) ) : SailM
    AccessDescriptor )
  let (wb_unknown, wback) ← (( do
    bif ((wback && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36386.113-36386.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let _ : Unit :=
    bif (! wback)
    then (AArch64_SetLSInstructionSyndrome 8 false t true false)
    else ()
  let address ← (( do
    bif use_key_a
    then
      (do
        (AuthDA address (← (X_read 31 64)) auth_then_branch))
    else
      (do
        (AuthDB address (← (X_read 31 64)) auth_then_branch)) ) : SailM (BitVec 64) )
  bif (n == 31)
  then (CheckSPAlignment ())
  else (pure ())
  let address : (BitVec 64) := (address + offset)
  let data ← (( do (Mem_read address 8 accdesc) ) : SailM (BitVec 64) )
  (X_set t 64 data)
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else (pure address) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ldra_aarch64_instrs_memory_single_general_immediate_signed_pac (Rt : (BitVec 5)) (Rn : (BitVec 5)) (W : (BitVec 1)) (imm9 : (BitVec 9)) (S : (BitVec 1)) (M : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif ((! (← (HavePACExt ()))) || (size != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let wback : Bool := (W == (0b1 : (BitVec 1)))
  let use_key_a : Bool := (M == (0b0 : (BitVec 1)))
  let S10 : (BitVec 10) := (S ++ imm9)
  let scale := 3
  let offset : (BitVec 64) := ((sign_extend S10 64) <<< scale)
  let nontemporal : Bool := false
  let memop : MemOp := MemOp_LOAD
  let tagchecked : Bool := (wback || (n != 31))
  (execute_aarch64_instrs_memory_single_general_immediate_signed_pac memop n nontemporal offset t
    tagchecked use_key_a wback)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, t : Nat, t2 : Nat, k_tagchecked :
  Bool, 0 ≤ t2 ∧ t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_atomicops_ld_128_ldsetp (acquire : Bool) (n : Nat) (op : MemAtomicOp) (release : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let value1_name ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let value2_name ← (( do (X_read t2 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescAtomicOp op acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let store_value ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (value1_name ++ value2_name))
    else (pure (value2_name ++ value1_name)) ) : SailM (BitVec 128) )
  let comparevalue ← (( do (__UNKNOWN_bits 128) ) : SailM (BitVec 128) )
  let data ← (( do (MemAtomic address comparevalue store_value accdesc) ) : SailM (BitVec 128) )
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set t 64 (Sail.BitVec.extractLsb data 127 64))
      (X_set t2 64 (Sail.BitVec.extractLsb data 63 0)))
  else
    (do
      (X_set t 64 (Sail.BitVec.extractLsb data 63 0))
      (X_set t2 64 (Sail.BitVec.extractLsb data 127 64)))

def decode_ldsetp_aarch64_instrs_memory_atomicops_ld_128_ldsetp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rt2 : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveLSE128 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt2 == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let n := (BitVec.toNat Rn)
  let op ← (( do (undefined_MemAtomicOp ()) ) : SailM MemAtomicOp )
  let _ : Unit :=
    let b__0 := opc
    bif (b__0 == (0b001 : (BitVec 3)))
    then
      (let op : MemAtomicOp := MemAtomicOp_BIC
      ())
    else
      (bif (b__0 == (0b011 : (BitVec 3)))
      then
        (let op : MemAtomicOp := MemAtomicOp_ORR
        ())
      else ())
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_ld_128_ldsetp acquire n op release t t2 tagchecked)

/-- Type quantifiers: datasize : Nat, k_is_signed : Bool, n : Nat, k_nontemporal : Bool, k_postindex
  : Bool, regsize : Nat, k_rt_unknown : Bool, t : Nat, k_tagchecked : Bool, k_wb_unknown : Bool, k_wback
  : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ regsize ∈ {32, 64} ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (datasize : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (postindex : Bool) (regsize : Nat) (rt_unknown : Bool) (is_signed : Bool) (t : Nat) (tagchecked : Bool) (wb_unknown : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let privileged ← (( do (AArch64_IsUnprivAccessPriv ()) ) : SailM Bool )
  let accdesc ← (( do (CreateAccDescGPR memop nontemporal privileged tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        bif (bne memop MemOp_PREFETCH)
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      let data ← (( do
        bif rt_unknown
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let _ : Unit :=
        bif (! wback)
        then (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) false t (regsize == 64) false)
        else ()
      (Mem_set address (Int.ediv datasize 8) accdesc data))
  | MemOp_LOAD =>
    (do
      let _ : Unit :=
        bif (! wback)
        then
          (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) is_signed t (regsize == 64) false)
        else ()
      let data ← (( do (Mem_read address (Int.ediv datasize 8) accdesc) ) : SailM
        (BitVec datasize) )
      bif is_signed
      then
        (do
          assert ((datasize >b 0) && (regsize ≥b datasize)) "src/instrs64.sail:36581.72-36581.73"
          (X_set t regsize (sign_extend data regsize)))
      else
        (do
          assert ((datasize ≥b 0) && (regsize ≥b datasize)) "src/instrs64.sail:36584.73-36584.74"
          (X_set t regsize (Sail.BitVec.zeroExtend data regsize))))
  | MemOp_PREFETCH => (Prefetch address (integer_subrange t 4 0))
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (bif postindex
          then (pure (address + offset))
          else (pure address)) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ldtr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36647.113-36647.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36666.107-36666.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldtrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36733.113-36733.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36752.107-36752.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldtrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36819.113-36819.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36838.107-36838.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldtrsb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36905.113-36905.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36924.107-36924.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldtrsh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:36991.113-36991.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37010.107-37010.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldtrsw_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37077.113-37077.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37096.107-37096.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_sttr_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37163.113-37163.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37182.107-37182.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_sttrb_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37249.113-37249.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37268.107-37268.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_sttrh_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then sailThrow ((Error_Undefined ()))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37335.113-37335.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37354.107-37354.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_unpriv datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

/-- Type quantifiers: datasize : Nat, n : Nat, k_nontemporal : Bool, k_postindex : Bool, t : Nat, k_tagchecked
  : Bool, k_wback : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64, 128, 256, 512, 1024} -/
def execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal (datasize : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (postindex : Bool) (t : Nat) (tagchecked : Bool) (wback : Bool) : SailM Unit := do
  (CheckFPEnabled64 ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let accdesc ← (( do (CreateAccDescASIMD memop nontemporal tagchecked) ) : SailM AccessDescriptor
    )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:37404.62-37404.63"
      let data ← (( do (V_read t datasize) ) : SailM (BitVec datasize) )
      (Mem_set address (Int.ediv datasize 8) accdesc data))
  | MemOp_LOAD =>
    (do
      let data ← (( do (Mem_read address (Int.ediv datasize 8) accdesc) ) : SailM
        (BitVec datasize) )
      assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:37410.62-37410.63"
      (V_set t datasize data))
  | _ => (pure ())
  bif wback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleSIMDFPLoadStore ())
  else (pure ())

def decode_ldur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:37447.72-37447.73"
  (execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex t tagchecked wback)

def decode_stur_fpsimd_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat ((BitVec.join1 [(BitVec.access opc 1)]) ++ size))
  bif (scale >b 4)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop : MemOp :=
    bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
    then MemOp_LOAD
    else MemOp_STORE
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  assert ((((((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) || (datasize == 256)) || (datasize == 512)) || (datasize == 1024)) "src/instrs64.sail:37477.72-37477.73"
  (execute_aarch64_instrs_memory_single_simdfp_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex t tagchecked wback)

/-- Type quantifiers: datasize : Nat, k_is_signed : Bool, n : Nat, k_nontemporal : Bool, k_postindex
  : Bool, regsize : Nat, k_rt_unknown : Bool, t : Nat, k_tagchecked : Bool, k_wb_unknown : Bool, k_wback
  : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ regsize ∈ {32, 64} ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (datasize : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (postindex : Bool) (regsize : Nat) (rt_unknown : Bool) (is_signed : Bool) (t : Nat) (tagchecked : Bool) (wb_unknown : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let privileged ← (( do (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let accdesc ← (( do (CreateAccDescGPR memop nontemporal privileged tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        bif (bne memop MemOp_PREFETCH)
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      let data ← (( do
        bif rt_unknown
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let _ : Unit :=
        bif (! wback)
        then (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) false t (regsize == 64) false)
        else ()
      (Mem_set address (Int.ediv datasize 8) accdesc data))
  | MemOp_LOAD =>
    (do
      let _ : Unit :=
        bif (! wback)
        then
          (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) is_signed t (regsize == 64) false)
        else ()
      let data ← (( do (Mem_read address (Int.ediv datasize 8) accdesc) ) : SailM
        (BitVec datasize) )
      bif is_signed
      then
        (do
          assert ((datasize >b 0) && (regsize ≥b datasize)) "src/instrs64.sail:37529.72-37529.73"
          (X_set t regsize (sign_extend data regsize)))
      else
        (do
          assert ((datasize ≥b 0) && (regsize ≥b datasize)) "src/instrs64.sail:37532.73-37532.74"
          (X_set t regsize (Sail.BitVec.zeroExtend data regsize))))
  | MemOp_PREFETCH => (Prefetch address (integer_subrange t 4 0))
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (bif postindex
          then (pure (address + offset))
          else (pure address)) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_ldur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37599.113-37599.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37618.107-37618.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldurb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37689.113-37689.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37708.107-37708.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldurh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37779.113-37779.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37798.107-37798.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldursb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37869.113-37869.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37888.107-37888.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldursh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37959.113-37959.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:37978.107-37978.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_ldursw_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:38049.113-38049.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:38068.107-38068.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_prfum_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:38139.113-38139.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:38158.107-38158.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_stur_gen_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:38229.113-38229.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:38248.107-38248.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_sturb_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:38319.113-38319.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:38338.107-38338.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

def decode_sturh_aarch64_instrs_memory_single_general_immediate_signed_offset_normal (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm9 : (BitVec 9)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := (sign_extend imm9 64)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:38409.113-38409.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:38428.107-38428.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_signed_offset_normal datasize memop n
    nontemporal offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

/-- Type quantifiers: a : Nat, d : Nat, datasize : Nat, destsize : Nat, m : Nat, n : Nat, k_sub_op :
  Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  destsize ∈ {32, 64} ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub (a : Nat) (d : Nat) (datasize : Nat) (destsize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (X_read a destsize) ) : SailM (BitVec destsize) )
  let result ← (( do (undefined_int ()) ) : SailM Int )
  let result : Int :=
    bif sub_op
    then ((BitVec.toNat operand3) -i ((BitVec.toNat operand1) *i (BitVec.toNat operand2)))
    else ((BitVec.toNat operand3) +i ((BitVec.toNat operand1) *i (BitVec.toNat operand2)))
  let result := result
  (X_set d destsize (integer_subrange result (destsize -i 1) 0))

def decode_madd_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (o0 : (BitVec 1)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  let destsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let datasize := destsize
  let sub_op : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub a d datasize destsize m n sub_op)

def decode_msub_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (o0 : (BitVec 1)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  let destsize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let datasize := destsize
  let sub_op : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_mul_uniform_add_sub a d datasize destsize m n sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, k_sub_op
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let product ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, product, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, product, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, product, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let product : (BitVec esize) :=
          (integer_subrange ((BitVec.toNat element1) *i (BitVec.toNat element2)) (esize -i 1) 0)
        let result ← (( do
          bif sub_op
          then
            (do
              (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product)))
          else
            (do
              (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))) ) : SailM
          (BitVec datasize) )
        (pure (element1, element2, product, result))
    (pure loop_vars) ) : SailM
    ((BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_mla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum d datasize elements esize m
    n sub_op)

def decode_mls_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_accum d datasize elements esize m
    n sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Nat, m : Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m idxdsize) ) : SailM (BitVec idxdsize) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 index esize))))
  let (element1, product, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, product, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, product, result) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        let result ← (( do
          bif sub_op
          then
            (do
              (Elem_set result e esize ((← (Elem_read operand3 e esize)) - product)))
          else
            (do
              (Elem_set result e esize ((← (Elem_read operand3 e esize)) + product))) ) : SailM
          (BitVec datasize) )
        (pure (element1, product, result))
    (pure loop_vars) ) : SailM (Int × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_mla_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int d datasize elements esize
    idxdsize index m n sub_op)

def decode_mls_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_int d datasize elements esize
    idxdsize index m n sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, pos : Nat, 0 ≤ pos ∧
  pos ≤ 63 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_ins_ext_insert_movewide (d : Nat) (datasize : Nat) (imm : (BitVec 16)) (opcode : MoveWideOp) (pos : Nat) : SailM Unit := do
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    bif (BEq.beq opcode MoveWideOp_K)
    then
      (do
        (X_read d datasize))
    else (pure (Zeros (n := datasize))) ) : SailM (BitVec datasize) )
  assert ((pos +i 15) <b datasize) "src/instrs64.sail:38730.44-38730.45"
  let result : (BitVec datasize) := (Sail.BitVec.updateSubrange result (pos +i 15) pos imm)
  let result : (BitVec datasize) :=
    bif (BEq.beq opcode MoveWideOp_N)
    then (Complement.complement result)
    else result
  let result := result
  (X_set d datasize result)

def decode_movk_aarch64_instrs_integer_ins_ext_insert_movewide (Rd : (BitVec 5)) (imm16 : (BitVec 16)) (hw : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let imm : (BitVec 16) := imm16
  let opcode ← (( do (undefined_MoveWideOp ()) ) : SailM MoveWideOp )
  let b__0 := opc
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let opcode : MoveWideOp := MoveWideOp_N
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let opcode : MoveWideOp := MoveWideOp_Z
        (pure ()))
      else
        (do
          bif (b__0 == (0b11 : (BitVec 2)))
          then
            (let opcode : MoveWideOp := MoveWideOp_K
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let opcode := opcode
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access hw 1)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pos := (BitVec.toNat (hw ++ (0x0 : (BitVec 4))))
  (execute_aarch64_instrs_integer_ins_ext_insert_movewide d datasize imm opcode pos)

def decode_movn_aarch64_instrs_integer_ins_ext_insert_movewide (Rd : (BitVec 5)) (imm16 : (BitVec 16)) (hw : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let imm : (BitVec 16) := imm16
  let opcode ← (( do (undefined_MoveWideOp ()) ) : SailM MoveWideOp )
  let b__0 := opc
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let opcode : MoveWideOp := MoveWideOp_N
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let opcode : MoveWideOp := MoveWideOp_Z
        (pure ()))
      else
        (do
          bif (b__0 == (0b11 : (BitVec 2)))
          then
            (let opcode : MoveWideOp := MoveWideOp_K
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let opcode := opcode
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access hw 1)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pos := (BitVec.toNat (hw ++ (0x0 : (BitVec 4))))
  (execute_aarch64_instrs_integer_ins_ext_insert_movewide d datasize imm opcode pos)

def decode_movz_aarch64_instrs_integer_ins_ext_insert_movewide (Rd : (BitVec 5)) (imm16 : (BitVec 16)) (hw : (BitVec 2)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let imm : (BitVec 16) := imm16
  let opcode ← (( do (undefined_MoveWideOp ()) ) : SailM MoveWideOp )
  let b__0 := opc
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let opcode : MoveWideOp := MoveWideOp_N
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let opcode : MoveWideOp := MoveWideOp_Z
        (pure ()))
      else
        (do
          bif (b__0 == (0b11 : (BitVec 2)))
          then
            (let opcode : MoveWideOp := MoveWideOp_K
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let opcode := opcode
  bif ((sf == (0b0 : (BitVec 1))) && ((BitVec.join1 [(BitVec.access hw 1)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pos := (BitVec.toNat (hw ++ (0x0 : (BitVec 4))))
  (execute_aarch64_instrs_integer_ins_ext_insert_movewide d datasize imm opcode pos)

/-- Type quantifiers: k_read : Bool, sys_crm : Nat, sys_crn : Nat, sys_op0 : Nat, sys_op1 : Nat, sys_op2
  : Nat, t : Nat, t2 : Nat, 0 ≤ t2 ∧
  t2 ≤ 31 ∧
  0 ≤ t ∧
  t ≤ 31 ∧
  sys_op2 ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  sys_op1 ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  sys_op0 ∈ {2, 3} ∧ 0 ≤ sys_crn ∧ sys_crn ≤ 15 ∧ 0 ≤ sys_crm ∧ sys_crm ≤ 15 -/
def execute_aarch64_instrs_system_register_system_128 (read : Bool) (sys_crm : Nat) (sys_crn : Nat) (sys_op0 : Nat) (sys_op1 : Nat) (sys_op2 : Nat) (t : Nat) (t2 : Nat) : SailM Unit := do
  bif read
  then (AArch64_SysRegRead128 sys_op0 sys_op1 sys_crn sys_crm sys_op2 t t2)
  else (AArch64_SysRegWrite128 sys_op0 sys_op1 sys_crn sys_crm sys_op2 t t2)

def decode_mrrs_aarch64_instrs_system_register_system_128 (Rt : (BitVec 5)) (op2 : (BitVec 3)) (CRm : (BitVec 4)) (CRn : (BitVec 4)) (op1 : (BitVec 3)) (o0 : (BitVec 1)) (L : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveSysReg128 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access Rt 0)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (AArch64_CheckSystemAccess ((0b1 : (BitVec 1)) ++ o0) op1 CRn CRm op2 Rt L)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat (BitVec.addInt Rt 1))
  let sys_op0 := (2 +i (BitVec.toNat o0))
  let sys_op1 := (BitVec.toNat op1)
  let sys_op2 := (BitVec.toNat op2)
  let sys_crn := (BitVec.toNat CRn)
  let sys_crm := (BitVec.toNat CRm)
  let read : Bool := (L == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_system_register_system_128 read sys_crm sys_crn sys_op0 sys_op1 sys_op2 t
    t2)

def decode_msrr_aarch64_instrs_system_register_system_128 (Rt : (BitVec 5)) (op2 : (BitVec 3)) (CRm : (BitVec 4)) (CRn : (BitVec 4)) (op1 : (BitVec 3)) (o0 : (BitVec 1)) (L : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveSysReg128 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access Rt 0)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (AArch64_CheckSystemAccess ((0b1 : (BitVec 1)) ++ o0) op1 CRn CRm op2 Rt L)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat (BitVec.addInt Rt 1))
  let sys_op0 := (2 +i (BitVec.toNat o0))
  let sys_op1 := (BitVec.toNat op1)
  let sys_op2 := (BitVec.toNat op2)
  let sys_crn := (BitVec.toNat CRn)
  let sys_crm := (BitVec.toNat CRm)
  let read : Bool := (L == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_system_register_system_128 read sys_crm sys_crn sys_op0 sys_op1 sys_op2 t
    t2)

/-- Type quantifiers: k_read : Bool, sys_crm : Nat, sys_crn : Nat, sys_op0 : Nat, sys_op1 : Nat, sys_op2
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  sys_op2 ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  sys_op1 ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  sys_op0 ∈ {2, 3} ∧ 0 ≤ sys_crn ∧ sys_crn ≤ 15 ∧ 0 ≤ sys_crm ∧ sys_crm ≤ 15 -/
def execute_aarch64_instrs_system_register_system (read : Bool) (sys_crm : Nat) (sys_crn : Nat) (sys_op0 : Nat) (sys_op1 : Nat) (sys_op2 : Nat) (t : Nat) : SailM Unit := do
  bif read
  then (AArch64_SysRegRead sys_op0 sys_op1 sys_crn sys_crm sys_op2 t)
  else (AArch64_SysRegWrite sys_op0 sys_op1 sys_crn sys_crm sys_op2 t)

def decode_mrs_aarch64_instrs_system_register_system (Rt : (BitVec 5)) (op2 : (BitVec 3)) (CRm : (BitVec 4)) (CRn : (BitVec 4)) (op1 : (BitVec 3)) (o0 : (BitVec 1)) (L : (BitVec 1)) : SailM Unit := do
  (AArch64_CheckSystemAccess ((0b1 : (BitVec 1)) ++ o0) op1 CRn CRm op2 Rt L)
  let t := (BitVec.toNat Rt)
  let sys_op0 := (2 +i (BitVec.toNat o0))
  let sys_op1 := (BitVec.toNat op1)
  let sys_op2 := (BitVec.toNat op2)
  let sys_crn := (BitVec.toNat CRn)
  let sys_crm := (BitVec.toNat CRm)
  let read : Bool := (L == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_system_register_system read sys_crm sys_crn sys_op0 sys_op1 sys_op2 t)

def decode_msr_reg_aarch64_instrs_system_register_system (Rt : (BitVec 5)) (op2 : (BitVec 3)) (CRm : (BitVec 4)) (CRn : (BitVec 4)) (op1 : (BitVec 3)) (o0 : (BitVec 1)) (L : (BitVec 1)) : SailM Unit := do
  (AArch64_CheckSystemAccess ((0b1 : (BitVec 1)) ++ o0) op1 CRn CRm op2 Rt L)
  let t := (BitVec.toNat Rt)
  let sys_op0 := (2 +i (BitVec.toNat o0))
  let sys_op1 := (BitVec.toNat op1)
  let sys_op2 := (BitVec.toNat op2)
  let sys_crn := (BitVec.toNat CRn)
  let sys_crm := (BitVec.toNat CRm)
  let read : Bool := (L == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_system_register_system read sys_crm sys_crn sys_op0 sys_op1 sys_op2 t)

def execute_aarch64_instrs_system_register_cpsr (field : PSTATEField) (operand : (BitVec 4)) : SailM Unit := do
  match field with
  | PSTATEField_SSBS =>
    writeReg PSTATE { (← readReg PSTATE) with SSBS := (BitVec.join1 [(BitVec.access operand 0)]) }
  | PSTATEField_SP =>
    writeReg PSTATE { (← readReg PSTATE) with SP := (BitVec.join1 [(BitVec.access operand 0)]) }
  | PSTATEField_DAIFSet =>
    (do
      writeReg PSTATE { (← readReg PSTATE) with D := ((← readReg PSTATE).D ||| (BitVec.join1 [(BitVec.access
            operand 3)])) }
      writeReg PSTATE { (← readReg PSTATE) with A := ((← readReg PSTATE).A ||| (BitVec.join1 [(BitVec.access
            operand 2)])) }
      writeReg PSTATE { (← readReg PSTATE) with I := ((← readReg PSTATE).I ||| (BitVec.join1 [(BitVec.access
            operand 1)])) }
      writeReg PSTATE { (← readReg PSTATE) with F := ((← readReg PSTATE).F ||| (BitVec.join1 [(BitVec.access
            operand 0)])) })
  | PSTATEField_DAIFClr =>
    (do
      writeReg PSTATE { (← readReg PSTATE) with D := ((← readReg PSTATE).D &&& (Complement.complement
          (BitVec.join1 [(BitVec.access operand 3)]))) }
      writeReg PSTATE { (← readReg PSTATE) with A := ((← readReg PSTATE).A &&& (Complement.complement
          (BitVec.join1 [(BitVec.access operand 2)]))) }
      writeReg PSTATE { (← readReg PSTATE) with I := ((← readReg PSTATE).I &&& (Complement.complement
          (BitVec.join1 [(BitVec.access operand 1)]))) }
      writeReg PSTATE { (← readReg PSTATE) with F := ((← readReg PSTATE).F &&& (Complement.complement
          (BitVec.join1 [(BitVec.access operand 0)]))) })
  | PSTATEField_PAN =>
    writeReg PSTATE { (← readReg PSTATE) with PAN := (BitVec.join1 [(BitVec.access operand 0)]) }
  | PSTATEField_UAO =>
    writeReg PSTATE { (← readReg PSTATE) with UAO := (BitVec.join1 [(BitVec.access operand 0)]) }
  | PSTATEField_DIT =>
    writeReg PSTATE { (← readReg PSTATE) with DIT := (BitVec.join1 [(BitVec.access operand 0)]) }
  | PSTATEField_TCO =>
    writeReg PSTATE { (← readReg PSTATE) with TCO := (BitVec.join1 [(BitVec.access operand 0)]) }
  | PSTATEField_ALLINT =>
    (do
      bif (((((← readReg PSTATE).EL == EL1) && (← (IsHCRXEL2Enabled ()))) && ((_get_HCRX_EL2_Type_TALLINT
                 (← readReg HCRX_EL2)) == (0b1 : (BitVec 1)))) && ((BitVec.join1 [(BitVec.access
                 operand 0)]) == (0b1 : (BitVec 1))))
      then (AArch64_SystemAccessTrap EL2 (BitVec.toNat (0x18 : (BitVec 8))))
      else (pure ())
      writeReg PSTATE { (← readReg PSTATE) with ALLINT := (BitVec.join1 [(BitVec.access operand 0)]) })
  | PSTATEField_SVCRSM =>
    (do
      (CheckSMEAccess ())
      (SetPSTATE_SM (BitVec.join1 [(BitVec.access operand 0)])))
  | PSTATEField_SVCRZA =>
    (do
      (CheckSMEAccess ())
      (SetPSTATE_ZA (BitVec.join1 [(BitVec.access operand 0)])))
  | PSTATEField_SVCRSMZA =>
    (do
      (CheckSMEAccess ())
      (SetPSTATE_SM (BitVec.join1 [(BitVec.access operand 0)]))
      (SetPSTATE_ZA (BitVec.join1 [(BitVec.access operand 0)])))
  | PSTATEField_PM =>
    writeReg PSTATE { (← readReg PSTATE) with PM := (BitVec.join1 [(BitVec.access operand 0)]) }

def decode_msr_imm_aarch64_instrs_system_register_cpsr (op2 : (BitVec 3)) (CRm : (BitVec 4)) (op1 : (BitVec 3)) : SailM Unit := do
  bif ((op1 == (0b000 : (BitVec 3))) && (op2 == (0b000 : (BitVec 3))))
  then sailThrow ((Error_See "CFINV"))
  else (pure ())
  bif ((op1 == (0b000 : (BitVec 3))) && (op2 == (0b001 : (BitVec 3))))
  then sailThrow ((Error_See "XAFLAG"))
  else (pure ())
  bif ((op1 == (0b000 : (BitVec 3))) && (op2 == (0b010 : (BitVec 3))))
  then sailThrow ((Error_See "AXFLAG"))
  else (pure ())
  (AArch64_CheckSystemAccess (0b00 : (BitVec 2)) op1 (0x4 : (BitVec 4)) CRm op2
    (0b11111 : (BitVec 5)) (0b0 : (BitVec 1)))
  let min_EL ← (( do (undefined_bitvector 2) ) : SailM (BitVec 2) )
  let need_secure : Bool := false
  let b__0 := op1
  bif ((Sail.BitVec.extractLsb b__0 2 1) == (0b00 : (BitVec 2)))
  then
    (let min_EL : (BitVec 2) := EL1
    (pure ()))
  else
    (do
      bif (b__0 == (0b010 : (BitVec 3)))
      then
        (let min_EL : (BitVec 2) := EL1
        (pure ()))
      else
        (do
          bif (b__0 == (0b011 : (BitVec 3)))
          then
            (let min_EL : (BitVec 2) := EL0
            (pure ()))
          else
            (do
              bif (b__0 == (0b100 : (BitVec 3)))
              then
                (let min_EL : (BitVec 2) := EL2
                (pure ()))
              else
                (do
                  bif (b__0 == (0b101 : (BitVec 3)))
                  then
                    (do
                      bif (! (← (HaveVirtHostExt ())))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let min_EL : (BitVec 2) := EL2
                      (pure ()))
                  else
                    (bif (b__0 == (0b110 : (BitVec 3)))
                    then
                      (let min_EL : (BitVec 2) := EL3
                      (pure ()))
                    else
                      (let min_EL : (BitVec 2) := EL1
                      let need_secure : Bool := true
                      (pure ())))))))
  let min_EL := min_EL
  bif (((BitVec.toNat (← readReg PSTATE).EL) <b (BitVec.toNat min_EL)) || (need_secure && (bne
           (← (CurrentSecurityState ())) SS_Secure)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let operand : (BitVec 4) := CRm
  let field ← (( do (undefined_PSTATEField ()) ) : SailM PSTATEField )
  let b__6 := (op1 ++ op2)
  bif (b__6 == (0b000011 : (BitVec 6)))
  then
    (do
      bif (! (← (HaveUAOExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let field : PSTATEField := PSTATEField_UAO
      (pure ()))
  else
    (do
      bif (b__6 == (0b000100 : (BitVec 6)))
      then
        (do
          bif (! (← (HavePANExt ())))
          then sailThrow ((Error_Undefined ()))
          else (pure ())
          let field : PSTATEField := PSTATEField_PAN
          (pure ()))
      else
        (do
          bif (b__6 == (0b000101 : (BitVec 6)))
          then
            (let field : PSTATEField := PSTATEField_SP
            (pure ()))
          else
            (do
              bif (b__6 == (0b001000 : (BitVec 6)))
              then
                (do
                  let b__10 := CRm
                  bif ((Sail.BitVec.extractLsb b__10 3 1) == (0b000 : (BitVec 3)))
                  then
                    (do
                      bif (! (← (HaveFeatNMI ())))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let field : PSTATEField := PSTATEField_ALLINT
                      (pure ()))
                  else
                    (do
                      bif ((Sail.BitVec.extractLsb b__10 3 1) == (0b001 : (BitVec 3)))
                      then
                        (do
                          bif (! (← (HaveFeatEBEP ())))
                          then sailThrow ((Error_Undefined ()))
                          else (pure ())
                          let field : PSTATEField := PSTATEField_PM
                          (pure ()))
                      else sailThrow ((Error_Undefined ()))))
              else
                (do
                  bif (b__6 == (0b011010 : (BitVec 6)))
                  then
                    (do
                      bif (! (← (HaveDITExt ())))
                      then sailThrow ((Error_Undefined ()))
                      else (pure ())
                      let field : PSTATEField := PSTATEField_DIT
                      (pure ()))
                  else
                    (do
                      bif (b__6 == (0b011011 : (BitVec 6)))
                      then
                        (do
                          let b__14 := CRm
                          bif ((Sail.BitVec.extractLsb b__14 3 1) == (0b001 : (BitVec 3)))
                          then
                            (do
                              bif (! (← (HaveSME ())))
                              then sailThrow ((Error_Undefined ()))
                              else (pure ())
                              let field : PSTATEField := PSTATEField_SVCRSM
                              (pure ()))
                          else
                            (do
                              bif ((Sail.BitVec.extractLsb b__14 3 1) == (0b010 : (BitVec 3)))
                              then
                                (do
                                  bif (! (← (HaveSME ())))
                                  then sailThrow ((Error_Undefined ()))
                                  else (pure ())
                                  let field : PSTATEField := PSTATEField_SVCRZA
                                  (pure ()))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__14 3 1) == (0b011 : (BitVec 3)))
                                  then
                                    (do
                                      bif (! (← (HaveSME ())))
                                      then sailThrow ((Error_Undefined ()))
                                      else (pure ())
                                      let field : PSTATEField := PSTATEField_SVCRSMZA
                                      (pure ()))
                                  else sailThrow ((Error_Undefined ())))))
                      else
                        (do
                          bif (b__6 == (0b011100 : (BitVec 6)))
                          then
                            (do
                              bif (! (← (HaveMTEExt ())))
                              then sailThrow ((Error_Undefined ()))
                              else (pure ())
                              let field : PSTATEField := PSTATEField_TCO
                              (pure ()))
                          else
                            (do
                              bif (b__6 == (0b011110 : (BitVec 6)))
                              then
                                (let field : PSTATEField := PSTATEField_DAIFSet
                                (pure ()))
                              else
                                (do
                                  bif (b__6 == (0b011111 : (BitVec 6)))
                                  then
                                    (let field : PSTATEField := PSTATEField_DAIFClr
                                    (pure ()))
                                  else
                                    (do
                                      bif (b__6 == (0b011001 : (BitVec 6)))
                                      then
                                        (do
                                          bif (! (← (HaveSSBSExt ())))
                                          then sailThrow ((Error_Undefined ()))
                                          else (pure ())
                                          let field : PSTATEField := PSTATEField_SSBS
                                          (pure ()))
                                      else sailThrow ((Error_Undefined ())))))))))))
  bif (((← readReg PSTATE).EL == EL0) && ((BEq.beq field PSTATEField_DAIFSet) || (BEq.beq field
           PSTATEField_DAIFClr)))
  then
    (do
      bif ((← (IsInHost ())) || ((_get_SCTLR_EL1_Type_UMA (← readReg SCTLR_EL1)) == (0b0 : (BitVec 1))))
      then
        (do
          bif ((← (EL2Enabled ())) && ((_get_HCR_EL2_Type_TGE (← readReg HCR_EL2)) == (0b1 : (BitVec 1))))
          then (AArch64_SystemAccessTrap EL2 (BitVec.toNat (0x18 : (BitVec 8))))
          else (AArch64_SystemAccessTrap EL1 (BitVec.toNat (0x18 : (BitVec 8)))))
      else (pure ()))
  else (pure ())
  (execute_aarch64_instrs_system_register_cpsr field operand)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, k_poly
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (poly : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let product ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, product, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, product, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, product, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let product : (BitVec esize) :=
          bif poly
          then (Sail.BitVec.extractLsb (PolynomialMult element1 element2) (esize -i 1) 0)
          else
            (integer_subrange ((BitVec.toNat element1) *i (BitVec.toNat element2)) (esize -i 1) 0)
        let result ← (Elem_set result e esize product)
        (pure (element1, element2, product, result))
    (pure loop_vars) ) : SailM
    ((BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_mul_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((U == (0b1 : (BitVec 1))) && (size != (0b00 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let poly : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product d datasize elements esize
    m n poly)

def decode_pmul_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((U == (0b1 : (BitVec 1))) && (size != (0b00 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let poly : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_product d datasize elements esize
    m n poly)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_int (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m idxdsize) ) : SailM (BitVec idxdsize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 index esize))))
  let (element1, product, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, product, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, product, result) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        let result ← (Elem_set result e esize product)
        (pure (element1, product, result))
    (pure loop_vars) ) : SailM (Int × (BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_mul_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_int d datasize elements esize
    idxdsize index m n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize = 8 ∧ elements ∈ {8, 16} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_not (d : Nat) (datasize : Nat) (elements : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ← (Elem_set result e esize (Complement.complement element))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_not_advsimd_aarch64_instrs_vector_arithmetic_unary_not (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize 8)
  (execute_aarch64_instrs_vector_arithmetic_unary_not d datasize elements esize n)

/-- Type quantifiers: d : Nat, n : Nat, k_source_is_sp : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_pac_pacda_dp_1src (d : Nat) (n : Nat) (source_is_sp : Bool) : SailM Unit := do
  bif source_is_sp
  then (X_set d 64 (← (AddPACDA (← (X_read d 64)) (← (SP_read ())))))
  else (X_set d 64 (← (AddPACDA (← (X_read d 64)) (← (X_read n 64)))))

def decode_pacda_aarch64_instrs_integer_pac_pacda_dp_1src (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Z : (BitVec 1)) : SailM Unit := do
  let source_is_sp : Bool := false
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HavePACExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let source_is_sp ← (( do
    bif (Z == (0b0 : (BitVec 1)))
    then
      (bif (n == 31)
      then (pure true)
      else (pure source_is_sp))
    else
      (do
        bif (n != 31)
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        (pure source_is_sp)) ) : SailM Bool )
  (execute_aarch64_instrs_integer_pac_pacda_dp_1src d n source_is_sp)

/-- Type quantifiers: d : Nat, n : Nat, k_source_is_sp : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_pac_pacdb_dp_1src (d : Nat) (n : Nat) (source_is_sp : Bool) : SailM Unit := do
  bif source_is_sp
  then (X_set d 64 (← (AddPACDB (← (X_read d 64)) (← (SP_read ())))))
  else (X_set d 64 (← (AddPACDB (← (X_read d 64)) (← (X_read n 64)))))

def decode_pacdb_aarch64_instrs_integer_pac_pacdb_dp_1src (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Z : (BitVec 1)) : SailM Unit := do
  let source_is_sp : Bool := false
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HavePACExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let source_is_sp ← (( do
    bif (Z == (0b0 : (BitVec 1)))
    then
      (bif (n == 31)
      then (pure true)
      else (pure source_is_sp))
    else
      (do
        bif (n != 31)
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        (pure source_is_sp)) ) : SailM Bool )
  (execute_aarch64_instrs_integer_pac_pacdb_dp_1src d n source_is_sp)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_source_is_sp : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_pac_pacga_dp_2src (d : Nat) (m : Nat) (n : Nat) (source_is_sp : Bool) : SailM Unit := do
  bif source_is_sp
  then (X_set d 64 (← (AddPACGA (← (X_read n 64)) (← (SP_read ())))))
  else (X_set d 64 (← (AddPACGA (← (X_read n 64)) (← (X_read m 64)))))

def decode_pacga_aarch64_instrs_integer_pac_pacga_dp_2src (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  let source_is_sp : Bool := false
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (! (← (HavePACExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let source_is_sp : Bool :=
    bif (m == 31)
    then true
    else source_is_sp
  (execute_aarch64_instrs_integer_pac_pacga_dp_2src d m n source_is_sp)

/-- Type quantifiers: d : Nat, n : Nat, k_source_is_sp : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_pac_pacia_dp_1src (d : Nat) (n : Nat) (source_is_sp : Bool) : SailM Unit := do
  bif (← (HavePACExt ()))
  then
    (do
      bif source_is_sp
      then (X_set d 64 (← (AddPACIA (← (X_read d 64)) (← (SP_read ())))))
      else (X_set d 64 (← (AddPACIA (← (X_read d 64)) (← (X_read n 64))))))
  else (pure ())

def decode_pacia_aarch64_instrs_integer_pac_pacia_dp_1src (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Z : (BitVec 1)) : SailM Unit := do
  let source_is_sp : Bool := false
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HavePACExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let source_is_sp ← (( do
    bif (Z == (0b0 : (BitVec 1)))
    then
      (bif (n == 31)
      then (pure true)
      else (pure source_is_sp))
    else
      (do
        bif (n != 31)
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        (pure source_is_sp)) ) : SailM Bool )
  (execute_aarch64_instrs_integer_pac_pacia_dp_1src d n source_is_sp)

def decode_pacia_aarch64_instrs_integer_pac_pacia_hint (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let d : Int := 17
  let n ← (( do (undefined_int ()) ) : SailM Int )
  let source_is_sp : Bool := false
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0011000 : (BitVec 7)))
  then
    (let d : Int := 30
    let n : Int := 31
    (pure ()))
  else
    (do
      bif (b__0 == (0b0011001 : (BitVec 7)))
      then
        (do
          let d : Int := 30
          let source_is_sp : Bool := true
          bif (← (HaveBTIExt ()))
          then (SetBTypeCompatible (← (BTypeCompatible_PACIXSP ())))
          else (pure ()))
      else
        (do
          bif (b__0 == (0b0001000 : (BitVec 7)))
          then
            (let d : Int := 17
            let n : Int := 16
            (pure ()))
          else
            (do
              bif (b__0 == (0b0001010 : (BitVec 7)))
              then sailThrow ((Error_See "PACIB"))
              else
                (do
                  bif (b__0 == (0b0001100 : (BitVec 7)))
                  then sailThrow ((Error_See "AUTIA"))
                  else
                    (do
                      bif (b__0 == (0b0001110 : (BitVec 7)))
                      then sailThrow ((Error_See "AUTIB"))
                      else
                        (do
                          bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001101 : (BitVec 6)))
                          then sailThrow ((Error_See "PACIB"))
                          else
                            (do
                              bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001110 : (BitVec 6)))
                              then sailThrow ((Error_See "AUTIA"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001111 : (BitVec 6)))
                                  then sailThrow ((Error_See "AUTIB"))
                                  else
                                    (do
                                      bif (b__0 == (0b0000111 : (BitVec 7)))
                                      then sailThrow ((Error_See "XPACLRI"))
                                      else sailThrow ((Error_See "HINT")))))))))))
  let n := n
  let d := d
  assert ((0 ≤b n) && (n ≤b 31)) "src/instrs64.sail:39615.43-39615.44"
  (execute_aarch64_instrs_integer_pac_pacia_dp_1src d n source_is_sp)

/-- Type quantifiers: d : Nat, n : Nat, k_source_is_sp : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_pac_pacib_dp_1src (d : Nat) (n : Nat) (source_is_sp : Bool) : SailM Unit := do
  bif (← (HavePACExt ()))
  then
    (do
      bif source_is_sp
      then (X_set d 64 (← (AddPACIB (← (X_read d 64)) (← (SP_read ())))))
      else (X_set d 64 (← (AddPACIB (← (X_read d 64)) (← (X_read n 64))))))
  else (pure ())

def decode_pacib_aarch64_instrs_integer_pac_pacib_dp_1src (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Z : (BitVec 1)) : SailM Unit := do
  let source_is_sp : Bool := false
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HavePACExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let source_is_sp ← (( do
    bif (Z == (0b0 : (BitVec 1)))
    then
      (bif (n == 31)
      then (pure true)
      else (pure source_is_sp))
    else
      (do
        bif (n != 31)
        then sailThrow ((Error_Undefined ()))
        else (pure ())
        (pure source_is_sp)) ) : SailM Bool )
  (execute_aarch64_instrs_integer_pac_pacib_dp_1src d n source_is_sp)

def decode_pacib_aarch64_instrs_integer_pac_pacib_hint (op2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  let d : Int := 17
  let n ← (( do (undefined_int ()) ) : SailM Int )
  let source_is_sp : Bool := false
  let b__0 := (CRm ++ op2)
  bif (b__0 == (0b0011010 : (BitVec 7)))
  then
    (let d : Int := 30
    let n : Int := 31
    (pure ()))
  else
    (do
      bif (b__0 == (0b0011011 : (BitVec 7)))
      then
        (do
          let d : Int := 30
          let source_is_sp : Bool := true
          bif (← (HaveBTIExt ()))
          then (SetBTypeCompatible (← (BTypeCompatible_PACIXSP ())))
          else (pure ()))
      else
        (do
          bif (b__0 == (0b0001010 : (BitVec 7)))
          then
            (let d : Int := 17
            let n : Int := 16
            (pure ()))
          else
            (do
              bif (b__0 == (0b0001000 : (BitVec 7)))
              then sailThrow ((Error_See "PACIA"))
              else
                (do
                  bif (b__0 == (0b0001100 : (BitVec 7)))
                  then sailThrow ((Error_See "AUTIA"))
                  else
                    (do
                      bif (b__0 == (0b0001110 : (BitVec 7)))
                      then sailThrow ((Error_See "AUTIB"))
                      else
                        (do
                          bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001100 : (BitVec 6)))
                          then sailThrow ((Error_See "PACIA"))
                          else
                            (do
                              bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001110 : (BitVec 6)))
                              then sailThrow ((Error_See "AUTIA"))
                              else
                                (do
                                  bif ((Sail.BitVec.extractLsb b__0 6 1) == (0b001111 : (BitVec 6)))
                                  then sailThrow ((Error_See "AUTIB"))
                                  else
                                    (do
                                      bif (b__0 == (0b0000111 : (BitVec 7)))
                                      then sailThrow ((Error_See "XPACLRI"))
                                      else sailThrow ((Error_See "HINT")))))))))))
  let n := n
  let d := d
  assert ((0 ≤b n) && (n ≤b 31)) "src/instrs64.sail:39722.43-39722.44"
  (execute_aarch64_instrs_integer_pac_pacib_dp_1src d n source_is_sp)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, part :
  Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (Vpart_read m part datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (Elem_read operand1 e esize)
        let element2 ← (Elem_read operand2 e esize)
        let result ← (Elem_set result e (2 *i esize) (PolynomialMult element1 element2))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec (2 * datasize))) )
  (V_set d (2 *i datasize) result)

def decode_pmull_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b01 : (BitVec 2))) || (size == (0b10 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((size == (0b11 : (BitVec 2))) && (! (← (HaveBit128PMULLExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_poly d datasize elements esize m n
    part)

/-- Type quantifiers: datasize : Nat, k_is_signed : Bool, n : Nat, k_nontemporal : Bool, k_postindex
  : Bool, regsize : Nat, k_rt_unknown : Bool, t : Nat, k_tagchecked : Bool, k_wb_unknown : Bool, k_wback
  : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ regsize ∈ {32, 64} ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_single_general_immediate_unsigned (datasize : Nat) (memop : MemOp) (n : Nat) (nontemporal : Bool) (offset : (BitVec 64)) (postindex : Bool) (regsize : Nat) (rt_unknown : Bool) (is_signed : Bool) (t : Nat) (tagchecked : Bool) (wb_unknown : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let privileged ← (( do (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let accdesc ← (( do (CreateAccDescGPR memop nontemporal privileged tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        bif (bne memop MemOp_PREFETCH)
        then (CheckSPAlignment ())
        else (pure ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      let data ← (( do
        bif rt_unknown
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let _ : Unit :=
        bif (! wback)
        then (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) false t (regsize == 64) false)
        else ()
      (Mem_set address (Int.ediv datasize 8) accdesc data))
  | MemOp_LOAD =>
    (do
      let _ : Unit :=
        bif (! wback)
        then
          (AArch64_SetLSInstructionSyndrome (Int.ediv datasize 8) is_signed t (regsize == 64) false)
        else ()
      let data ← (( do (Mem_read address (Int.ediv datasize 8) accdesc) ) : SailM
        (BitVec datasize) )
      bif is_signed
      then
        (do
          assert ((datasize >b 0) && (regsize ≥b datasize)) "src/instrs64.sail:39819.72-39819.73"
          (X_set t regsize (sign_extend data regsize)))
      else
        (do
          assert ((datasize ≥b 0) && (regsize ≥b datasize)) "src/instrs64.sail:39822.73-39822.74"
          (X_set t regsize (Sail.BitVec.zeroExtend data regsize))))
  | MemOp_PREFETCH => (Prefetch address (integer_subrange t 4 0))
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (bif postindex
          then (pure (address + offset))
          else (pure address)) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_prfm_imm_aarch64_instrs_memory_single_general_immediate_unsigned (Rt : (BitVec 5)) (Rn : (BitVec 5)) (imm12 : (BitVec 12)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let wback : Bool := false
  let postindex : Bool := false
  let scale := (BitVec.toNat size)
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend imm12 64) <<< scale)
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let nontemporal : Bool := false
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let is_signed ← (( do (undefined_bool ()) ) : SailM Bool )
  let regsize : Int := 32
  let (is_signed, memop, regsize) ← (( do
    bif ((BitVec.join1 [(BitVec.access opc 1)]) == (0b0 : (BitVec 1)))
    then
      (let memop : MemOp :=
        bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
        then MemOp_LOAD
        else MemOp_STORE
      let regsize : Int :=
        bif (size == (0b11 : (BitVec 2)))
        then 64
        else 32
      let is_signed : Bool := false
      (pure (is_signed, memop, regsize)))
    else
      (do
        let (is_signed, memop, regsize) ← (( do
          bif (size == (0b11 : (BitVec 2)))
          then
            (do
              let memop : MemOp := MemOp_PREFETCH
              bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              (pure (is_signed, memop, regsize)))
          else
            (do
              let memop : MemOp := MemOp_LOAD
              bif ((size == (0b10 : (BitVec 2))) && ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1))))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let regsize : Int :=
                bif ((BitVec.join1 [(BitVec.access opc 0)]) == (0b1 : (BitVec 1)))
                then 32
                else 64
              let is_signed : Bool := true
              (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
        (pure (is_signed, memop, regsize))) ) : SailM (Bool × MemOp × Int) )
  let regsize := regsize
  let datasize := (Int.shiftl 8 scale)
  let tagchecked : Bool := ((bne memop MemOp_PREFETCH) && (wback || (n != 31)))
  let wb_unknown : Bool := false
  let rt_unknown : Bool := false
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  let (c, wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (ConstrainUnpredictable Unpredictable_WBOVERLAPLD)
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:39889.113-39889.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (c, wb_unknown, wback)))
    else (pure (c, wb_unknown, wback)) ) : SailM (Constraint × Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && (n == t)) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:39908.107-39908.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  (execute_aarch64_instrs_memory_single_general_immediate_unsigned datasize memop n nontemporal
    offset postindex regsize rt_unknown is_signed t tagchecked wb_unknown wback)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha3_rax1 (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  (V_set d 128
    (Vn ^^^ ((← (ROL (Sail.BitVec.extractLsb Vm 127 64) 1)) ++ (← (ROL
            (Sail.BitVec.extractLsb Vm 63 0) 1)))))

def decode_rax1_advsimd_aarch64_instrs_vector_crypto_sha3_rax1 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSHA3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  (execute_aarch64_instrs_vector_crypto_sha3_rax1 d m n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize = 8 ∧ elements ∈ {8, 16} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_rbit (d : Nat) (datasize : Nat) (elements : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let rev ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element, result, rev) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, rev)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, rev) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let rev ← (( do
          let loop_i_lower := 0
          let loop_i_upper := (esize -i 1)
          let mut loop_vars_1 := rev
          for i in [loop_i_lower:loop_i_upper:1]i do
            let rev := loop_vars_1
            loop_vars_1 :=
              (BitVec.update rev ((esize -i 1) -i i)
                (Bit (BitVec.join1 [(BitVec.access element i)])))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        let result ← (Elem_set result e esize rev)
        (pure (element, result, rev))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec datasize) × (BitVec esize)) )
  (V_set d datasize result)

def decode_rbit_advsimd_aarch64_instrs_vector_arithmetic_unary_rbit (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 8
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize 8)
  (execute_aarch64_instrs_vector_arithmetic_unary_rbit d datasize elements esize n)

/-- Type quantifiers: d : Nat, datasize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_rbit (d : Nat) (datasize : Nat) (n : Nat) : SailM Unit := do
  let operand ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_i_lower := 0
    let loop_i_upper := (datasize -i 1)
    let mut loop_vars := result
    for i in [loop_i_lower:loop_i_upper:1]i do
      let result := loop_vars
      loop_vars :=
        (BitVec.update result ((datasize -i 1) -i i)
          (Bit (BitVec.join1 [(BitVec.access operand i)])))
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (X_set d datasize result)

def decode_rbit_int_aarch64_instrs_integer_arithmetic_rbit (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  (execute_aarch64_instrs_integer_arithmetic_rbit d datasize n)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, s : Nat, k_soft : Bool, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcw_cas (acquire : Bool) (n : Nat) (release : Bool) (s : Nat) (soft : Bool) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (← (IsD128Enabled (← readReg PSTATE).EL))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let newdata ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let compdata ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW MemAtomicOp_CAS soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 64) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  (X_set s 64 readdata)

def decode_rcwcas_aarch64_instrs_memory_rcw_cas (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveTHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let soft : Bool := false
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcw_cas acquire n release s soft t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, s : Nat, k_soft : Bool, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcw_cas_128 (acquire : Bool) (n : Nat) (release : Bool) (s : Nat) (soft : Bool) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (! (← (IsD128Enabled (← readReg PSTATE).EL)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let s1 ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let s2 ← (( do (X_read (s +i 1) 64) ) : SailM (BitVec 64) )
  let t1 ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let t2 ← (( do (X_read (t +i 1) 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescRCW MemAtomicOp_CAS soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let compdata ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (s1 ++ s2))
    else (pure (s2 ++ s1)) ) : SailM (BitVec 128) )
  let newdata ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (t1 ++ t2))
    else (pure (t2 ++ t1)) ) : SailM (BitVec 128) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 128) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set s 64 (Sail.BitVec.extractLsb readdata 127 64))
      (X_set (s +i 1) 64 (Sail.BitVec.extractLsb readdata 63 0)))
  else
    (do
      (X_set s 64 (Sail.BitVec.extractLsb readdata 63 0))
      (X_set (s +i 1) 64 (Sail.BitVec.extractLsb readdata 127 64)))

def decode_rcwcasp_aarch64_instrs_memory_rcw_cas_128 (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif ((! (← (Have128BitDescriptorExt ()))) || (! (← (HaveTHExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access Rs 0)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access Rt 0)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let soft : Bool := false
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcw_cas_128 acquire n release s soft t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, s : Nat, k_soft : Bool, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcw_ld_rcwclr (acquire : Bool) (n : Nat) (op : MemAtomicOp) (release : Bool) (s : Nat) (soft : Bool) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (← (IsD128Enabled (← readReg PSTATE).EL))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let newdata ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW op soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let compdata ← (( do (__UNKNOWN_bits 64) ) : SailM (BitVec 64) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 64) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  (X_set t 64 readdata)

def decode_rcwclr_aarch64_instrs_memory_rcw_ld_rcwclr (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveTHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let soft : Bool := false
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op : MemAtomicOp :=
    bif (opc == (0b001 : (BitVec 3)))
    then MemAtomicOp_BIC
    else MemAtomicOp_ORR
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcw_ld_rcwclr acquire n op release s soft t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, k_soft : Bool, t : Nat, t2 : Nat, k_tagchecked
  : Bool, 0 ≤ t2 ∧ t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcw_ld_128_rcwclrp (acquire : Bool) (n : Nat) (op : MemAtomicOp) (release : Bool) (soft : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (! (← (IsD128Enabled (← readReg PSTATE).EL)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW op soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let value1_name ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let value2_name ← (( do (X_read t2 64) ) : SailM (BitVec 64) )
  let newdata ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (value1_name ++ value2_name))
    else (pure (value2_name ++ value1_name)) ) : SailM (BitVec 128) )
  let compdata ← (( do (__UNKNOWN_bits 128) ) : SailM (BitVec 128) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 128) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 127 64))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 63 0)))
  else
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 63 0))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 127 64)))

def decode_rcwclrp_aarch64_instrs_memory_rcw_ld_128_rcwclrp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rt2 : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif ((! (← (Have128BitDescriptorExt ()))) || (! (← (HaveTHExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt2 == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let n := (BitVec.toNat Rn)
  let soft : Bool := false
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op : MemAtomicOp :=
    bif (opc == (0b001 : (BitVec 3)))
    then MemAtomicOp_BIC
    else MemAtomicOp_ORR
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcw_ld_128_rcwclrp acquire n op release soft t t2 tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, s : Nat, k_soft : Bool, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcws_cas (acquire : Bool) (n : Nat) (release : Bool) (s : Nat) (soft : Bool) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (← (IsD128Enabled (← readReg PSTATE).EL))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let newdata ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let compdata ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW MemAtomicOp_CAS soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 64) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  (X_set s 64 readdata)

def decode_rcwscas_aarch64_instrs_memory_rcws_cas (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveTHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let soft : Bool := true
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcws_cas acquire n release s soft t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, s : Nat, k_soft : Bool, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcws_cas_128 (acquire : Bool) (n : Nat) (release : Bool) (s : Nat) (soft : Bool) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (! (← (IsD128Enabled (← readReg PSTATE).EL)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let s1 ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let s2 ← (( do (X_read (s +i 1) 64) ) : SailM (BitVec 64) )
  let t1 ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let t2 ← (( do (X_read (t +i 1) 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescRCW MemAtomicOp_CAS soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let compdata ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (s1 ++ s2))
    else (pure (s2 ++ s1)) ) : SailM (BitVec 128) )
  let newdata ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (t1 ++ t2))
    else (pure (t2 ++ t1)) ) : SailM (BitVec 128) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 128) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set s 64 (Sail.BitVec.extractLsb readdata 127 64))
      (X_set (s +i 1) 64 (Sail.BitVec.extractLsb readdata 63 0)))
  else
    (do
      (X_set s 64 (Sail.BitVec.extractLsb readdata 63 0))
      (X_set (s +i 1) 64 (Sail.BitVec.extractLsb readdata 127 64)))

def decode_rcwscasp_aarch64_instrs_memory_rcws_cas_128 (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif ((! (← (Have128BitDescriptorExt ()))) || (! (← (HaveTHExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access Rs 0)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access Rt 0)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let soft : Bool := true
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcws_cas_128 acquire n release s soft t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, s : Nat, k_soft : Bool, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcws_ld_rcwsclr (acquire : Bool) (n : Nat) (op : MemAtomicOp) (release : Bool) (s : Nat) (soft : Bool) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (← (IsD128Enabled (← readReg PSTATE).EL))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let newdata ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW op soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let compdata ← (( do (__UNKNOWN_bits 64) ) : SailM (BitVec 64) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 64) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  (X_set t 64 readdata)

def decode_rcwsclr_aarch64_instrs_memory_rcws_ld_rcwsclr (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveTHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let soft : Bool := true
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op : MemAtomicOp :=
    bif (opc == (0b001 : (BitVec 3)))
    then MemAtomicOp_BIC
    else MemAtomicOp_ORR
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcws_ld_rcwsclr acquire n op release s soft t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, k_soft : Bool, t : Nat, t2 : Nat, k_tagchecked
  : Bool, 0 ≤ t2 ∧ t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcws_ld_128_rcwsclrp (acquire : Bool) (n : Nat) (op : MemAtomicOp) (release : Bool) (soft : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (! (← (IsD128Enabled (← readReg PSTATE).EL)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW op soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let value1_name ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let value2_name ← (( do (X_read t2 64) ) : SailM (BitVec 64) )
  let newdata ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (value1_name ++ value2_name))
    else (pure (value2_name ++ value1_name)) ) : SailM (BitVec 128) )
  let compdata ← (( do (__UNKNOWN_bits 128) ) : SailM (BitVec 128) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 128) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 127 64))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 63 0)))
  else
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 63 0))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 127 64)))

def decode_rcwsclrp_aarch64_instrs_memory_rcws_ld_128_rcwsclrp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rt2 : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif ((! (← (Have128BitDescriptorExt ()))) || (! (← (HaveTHExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt2 == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let n := (BitVec.toNat Rn)
  let soft : Bool := true
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op : MemAtomicOp :=
    bif (opc == (0b001 : (BitVec 3)))
    then MemAtomicOp_BIC
    else MemAtomicOp_ORR
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcws_ld_128_rcwsclrp acquire n op release soft t t2 tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, s : Nat, k_soft : Bool, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcw_ld_rcwset (acquire : Bool) (n : Nat) (op : MemAtomicOp) (release : Bool) (s : Nat) (soft : Bool) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (← (IsD128Enabled (← readReg PSTATE).EL))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let newdata ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW op soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let compdata ← (( do (__UNKNOWN_bits 64) ) : SailM (BitVec 64) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 64) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  (X_set t 64 readdata)

def decode_rcwset_aarch64_instrs_memory_rcw_ld_rcwset (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveTHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let soft : Bool := false
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op : MemAtomicOp :=
    bif (opc == (0b001 : (BitVec 3)))
    then MemAtomicOp_BIC
    else MemAtomicOp_ORR
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcw_ld_rcwset acquire n op release s soft t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, k_soft : Bool, t : Nat, t2 : Nat, k_tagchecked
  : Bool, 0 ≤ t2 ∧ t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcw_ld_128_rcwsetp (acquire : Bool) (n : Nat) (op : MemAtomicOp) (release : Bool) (soft : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (! (← (IsD128Enabled (← readReg PSTATE).EL)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW op soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let value1_name ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let value2_name ← (( do (X_read t2 64) ) : SailM (BitVec 64) )
  let newdata ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (value1_name ++ value2_name))
    else (pure (value2_name ++ value1_name)) ) : SailM (BitVec 128) )
  let compdata ← (( do (__UNKNOWN_bits 128) ) : SailM (BitVec 128) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 128) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 127 64))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 63 0)))
  else
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 63 0))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 127 64)))

def decode_rcwsetp_aarch64_instrs_memory_rcw_ld_128_rcwsetp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rt2 : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif ((! (← (Have128BitDescriptorExt ()))) || (! (← (HaveTHExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt2 == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let n := (BitVec.toNat Rn)
  let soft : Bool := false
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op : MemAtomicOp :=
    bif (opc == (0b001 : (BitVec 3)))
    then MemAtomicOp_BIC
    else MemAtomicOp_ORR
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcw_ld_128_rcwsetp acquire n op release soft t t2 tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, s : Nat, k_soft : Bool, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcws_ld_rcwsset (acquire : Bool) (n : Nat) (op : MemAtomicOp) (release : Bool) (s : Nat) (soft : Bool) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (← (IsD128Enabled (← readReg PSTATE).EL))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let newdata ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW op soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let compdata ← (( do (__UNKNOWN_bits 64) ) : SailM (BitVec 64) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 64) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  (X_set t 64 readdata)

def decode_rcwsset_aarch64_instrs_memory_rcws_ld_rcwsset (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveTHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let soft : Bool := true
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op : MemAtomicOp :=
    bif (opc == (0b001 : (BitVec 3)))
    then MemAtomicOp_BIC
    else MemAtomicOp_ORR
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcws_ld_rcwsset acquire n op release s soft t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, k_soft : Bool, t : Nat, t2 : Nat, k_tagchecked
  : Bool, 0 ≤ t2 ∧ t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcws_ld_128_rcwssetp (acquire : Bool) (n : Nat) (op : MemAtomicOp) (release : Bool) (soft : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (! (← (IsD128Enabled (← readReg PSTATE).EL)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW op soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let value1_name ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let value2_name ← (( do (X_read t2 64) ) : SailM (BitVec 64) )
  let newdata ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (value1_name ++ value2_name))
    else (pure (value2_name ++ value1_name)) ) : SailM (BitVec 128) )
  let compdata ← (( do (__UNKNOWN_bits 128) ) : SailM (BitVec 128) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 128) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 127 64))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 63 0)))
  else
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 63 0))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 127 64)))

def decode_rcwssetp_aarch64_instrs_memory_rcws_ld_128_rcwssetp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rt2 : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif ((! (← (Have128BitDescriptorExt ()))) || (! (← (HaveTHExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt2 == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let n := (BitVec.toNat Rn)
  let soft : Bool := true
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let op : MemAtomicOp :=
    bif (opc == (0b001 : (BitVec 3)))
    then MemAtomicOp_BIC
    else MemAtomicOp_ORR
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcws_ld_128_rcwssetp acquire n op release soft t t2 tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, s : Nat, k_soft : Bool, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcws_swp (acquire : Bool) (n : Nat) (release : Bool) (s : Nat) (soft : Bool) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (← (IsD128Enabled (← readReg PSTATE).EL))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let newdata ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW MemAtomicOp_SWP soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let compdata ← (( do (__UNKNOWN_bits 64) ) : SailM (BitVec 64) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 64) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  (X_set t 64 readdata)

def decode_rcwsswp_aarch64_instrs_memory_rcws_swp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveTHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let soft : Bool := true
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcws_swp acquire n release s soft t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, k_soft : Bool, t : Nat, t2 : Nat, k_tagchecked
  : Bool, 0 ≤ t2 ∧ t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcws_swp_128 (acquire : Bool) (n : Nat) (release : Bool) (soft : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (! (← (IsD128Enabled (← readReg PSTATE).EL)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW MemAtomicOp_SWP soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let value1_name ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let value2_name ← (( do (X_read t2 64) ) : SailM (BitVec 64) )
  let newdata ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (value1_name ++ value2_name))
    else (pure (value2_name ++ value1_name)) ) : SailM (BitVec 128) )
  let compdata ← (( do (__UNKNOWN_bits 128) ) : SailM (BitVec 128) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 128) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 127 64))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 63 0)))
  else
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 63 0))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 127 64)))

def decode_rcwsswpp_aarch64_instrs_memory_rcws_swp_128 (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rt2 : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif ((! (← (Have128BitDescriptorExt ()))) || (! (← (HaveTHExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt2 == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let n := (BitVec.toNat Rn)
  let soft : Bool := true
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcws_swp_128 acquire n release soft t t2 tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, s : Nat, k_soft : Bool, t : Nat, k_tagchecked
  : Bool, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcw_swp (acquire : Bool) (n : Nat) (release : Bool) (s : Nat) (soft : Bool) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (← (IsD128Enabled (← readReg PSTATE).EL))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let newdata ← (( do (X_read s 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW MemAtomicOp_SWP soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let compdata ← (( do (__UNKNOWN_bits 64) ) : SailM (BitVec 64) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 64) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  (X_set t 64 readdata)

def decode_rcwswp_aarch64_instrs_memory_rcw_swp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveTHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let soft : Bool := false
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcw_swp acquire n release s soft t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, k_soft : Bool, t : Nat, t2 : Nat, k_tagchecked
  : Bool, 0 ≤ t2 ∧ t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_rcw_swp_128 (acquire : Bool) (n : Nat) (release : Bool) (soft : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  bif (! (← (IsD128Enabled (← readReg PSTATE).EL)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let readdata ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let accdesc ← (( do (CreateAccDescRCW MemAtomicOp_SWP soft acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let value1_name ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let value2_name ← (( do (X_read t2 64) ) : SailM (BitVec 64) )
  let newdata ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (value1_name ++ value2_name))
    else (pure (value2_name ++ value1_name)) ) : SailM (BitVec 128) )
  let compdata ← (( do (__UNKNOWN_bits 128) ) : SailM (BitVec 128) )
  let (tup__0, tup__1) ← do (MemAtomicRCW address compdata newdata accdesc)
  let nzcv : (BitVec 4) := tup__0
  let readdata : (BitVec 128) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 127 64))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 63 0)))
  else
    (do
      (X_set t 64 (Sail.BitVec.extractLsb readdata 63 0))
      (X_set t2 64 (Sail.BitVec.extractLsb readdata 127 64)))

def decode_rcwswpp_aarch64_instrs_memory_rcw_swp_128 (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rt2 : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif ((! (← (Have128BitDescriptorExt ()))) || (! (← (HaveTHExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt2 == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let n := (BitVec.toNat Rn)
  let soft : Bool := false
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_rcw_swp_128 acquire n release soft t t2 tagchecked)

/-- Type quantifiers: container_size : Nat, d : Nat, datasize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ container_size ∈ {16, 32, 64} -/
def execute_aarch64_instrs_integer_arithmetic_rev (container_size : Nat) (d : Nat) (datasize : Nat) (n : Nat) : SailM Unit := do
  let operand ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let containers := (Int.ediv datasize container_size)
  let elements_per_container := (Int.ediv container_size 8)
  let index : Int := 0
  let rev_index ← (( do (undefined_int ()) ) : SailM Int )
  let (index, result, rev_index) ← (( do
    let loop_c_lower := 0
    let loop_c_upper := (containers -i 1)
    let mut loop_vars := (index, result, rev_index)
    for c in [loop_c_lower:loop_c_upper:1]i do
      let (index, result, rev_index) := loop_vars
      loop_vars ← do
        let rev_index : Int := (index +i ((elements_per_container -i 1) *i 8))
        let (index, result, rev_index) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements_per_container -i 1)
          let mut loop_vars_1 := (index, result, rev_index)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (index, result, rev_index) := loop_vars_1
            loop_vars_1 ← do
              let rev_index := rev_index
              let index := index
              assert ((0 ≤b rev_index) && ((rev_index +i 7) <b datasize)) "src/instrs64.sail:41065.83-41065.84"
              assert ((0 ≤b index) && ((index +i 7) <b datasize)) "src/instrs64.sail:41066.75-41066.76"
              let result : (BitVec datasize) :=
                (Sail.BitVec.updateSubrange result (rev_index +i 7) rev_index
                  (Sail.BitVec.extractLsb operand (index +i 7) index))
              (pure ())
              let index : Int := (index +i 8)
              let rev_index : Int := (rev_index -i 8)
              (pure (index, result, rev_index))
          (pure loop_vars_1) ) : SailM (Int × (BitVec datasize) × Int) )
        (pure (index, result, rev_index))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize) × Int) )
  (X_set d datasize result)

def decode_rev_aarch64_instrs_integer_arithmetic_rev (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let container_size : Int := 16
  let b__0 := opc
  bif (b__0 == (0b00 : (BitVec 2)))
  then (Unreachable ())
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let container_size : Int := 16
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let container_size : Int := 32
            (pure ()))
          else
            (do
              bif (sf == (0b0 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let container_size : Int := 64
              (pure ()))))
  let container_size := container_size
  (execute_aarch64_instrs_integer_arithmetic_rev container_size d datasize n)

def decode_rev16_int_aarch64_instrs_integer_arithmetic_rev (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let container_size : Int := 16
  let b__0 := opc
  bif (b__0 == (0b00 : (BitVec 2)))
  then (Unreachable ())
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let container_size : Int := 16
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let container_size : Int := 32
            (pure ()))
          else
            (do
              bif (sf == (0b0 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let container_size : Int := 64
              (pure ()))))
  let container_size := container_size
  (execute_aarch64_instrs_integer_arithmetic_rev container_size d datasize n)

def decode_rev32_int_aarch64_instrs_integer_arithmetic_rev (Rd : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 2)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let container_size : Int := 16
  let b__0 := opc
  bif (b__0 == (0b00 : (BitVec 2)))
  then (Unreachable ())
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let container_size : Int := 16
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let container_size : Int := 32
            (pure ()))
          else
            (do
              bif (sf == (0b0 : (BitVec 1)))
              then sailThrow ((Error_Undefined ()))
              else (pure ())
              let container_size : Int := 64
              (pure ()))))
  let container_size := container_size
  (execute_aarch64_instrs_integer_arithmetic_rev container_size d datasize n)

/-- Type quantifiers: containers : Int, d : Nat, datasize : Nat, elements_per_container : Int, esize
  : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_rev (containers : Int) (d : Nat) (datasize : Nat) (elements_per_container : Int) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element : Int := 0
  let rev_element ← (( do (undefined_int ()) ) : SailM Int )
  let (element, result, rev_element) ← (( do
    let loop_c_lower := 0
    let loop_c_upper := (containers -i 1)
    let mut loop_vars := (element, result, rev_element)
    for c in [loop_c_lower:loop_c_upper:1]i do
      let (element, result, rev_element) := loop_vars
      loop_vars ← do
        let rev_element : Int := ((element +i elements_per_container) -i 1)
        let (element, result, rev_element) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements_per_container -i 1)
          let mut loop_vars_1 := (element, result, rev_element)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (element, result, rev_element) := loop_vars_1
            loop_vars_1 ← do
              let rev_element := rev_element
              let element := element
              let result ←
                (Elem_set result rev_element esize (← (Elem_read operand element esize)))
              (pure ())
              let element : Int := (element +i 1)
              let rev_element : Int := (rev_element -i 1)
              (pure (element, result, rev_element))
          (pure loop_vars_1) ) : SailM (Int × (BitVec datasize) × Int) )
        (pure (element, result, rev_element))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize) × Int) )
  (V_set d datasize result)

def decode_rev16_advsimd_aarch64_instrs_vector_arithmetic_unary_rev (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let op : (BitVec 2) := (o0 ++ U)
  bif (((BitVec.toNat op) +i (BitVec.toNat size)) ≥b 3)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let container_size : Int := 16
  let _ : Unit :=
    let b__0 := op
    bif (b__0 == (0b10 : (BitVec 2)))
    then
      (let container_size : Int := 16
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let container_size : Int := 32
        ())
      else
        (bif (b__0 == (0b00 : (BitVec 2)))
        then
          (let container_size : Int := 64
          ())
        else ()))
  let container_size := container_size
  let containers := (Int.ediv datasize container_size)
  let elements_per_container := (Int.ediv container_size esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_rev containers d datasize elements_per_container
    esize n)

def decode_rev32_advsimd_aarch64_instrs_vector_arithmetic_unary_rev (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let op : (BitVec 2) := (o0 ++ U)
  bif (((BitVec.toNat op) +i (BitVec.toNat size)) ≥b 3)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let container_size : Int := 16
  let _ : Unit :=
    let b__0 := op
    bif (b__0 == (0b10 : (BitVec 2)))
    then
      (let container_size : Int := 16
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let container_size : Int := 32
        ())
      else
        (bif (b__0 == (0b00 : (BitVec 2)))
        then
          (let container_size : Int := 64
          ())
        else ()))
  let container_size := container_size
  let containers := (Int.ediv datasize container_size)
  let elements_per_container := (Int.ediv container_size esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_rev containers d datasize elements_per_container
    esize n)

def decode_rev64_advsimd_aarch64_instrs_vector_arithmetic_unary_rev (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let op : (BitVec 2) := (o0 ++ U)
  bif (((BitVec.toNat op) +i (BitVec.toNat size)) ≥b 3)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let container_size : Int := 16
  let _ : Unit :=
    let b__0 := op
    bif (b__0 == (0b10 : (BitVec 2)))
    then
      (let container_size : Int := 16
      ())
    else
      (bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let container_size : Int := 32
        ())
      else
        (bif (b__0 == (0b00 : (BitVec 2)))
        then
          (let container_size : Int := 64
          ())
        else ()))
  let container_size := container_size
  let containers := (Int.ediv datasize container_size)
  let elements_per_container := (Int.ediv container_size esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_rev containers d datasize elements_per_container
    esize n)

/-- Type quantifiers: lsb : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ lsb ∧ lsb ≤ 63 -/
def execute_aarch64_instrs_integer_flags_rmif (lsb : Nat) (mask : (BitVec 4)) (n : Nat) : SailM Unit := do
  let tmpreg ← (( do (X_read n 64) ) : SailM (BitVec 64) )
  let tmp : (BitVec 4) := (Sail.BitVec.extractLsb (tmpreg ++ tmpreg) (lsb +i 3) lsb)
  bif ((BitVec.join1 [(BitVec.access mask 3)]) == (0b1 : (BitVec 1)))
  then writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access tmp 3)]) }
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access mask 2)]) == (0b1 : (BitVec 1)))
  then writeReg PSTATE { (← readReg PSTATE) with Z := (BitVec.join1 [(BitVec.access tmp 2)]) }
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access mask 1)]) == (0b1 : (BitVec 1)))
  then writeReg PSTATE { (← readReg PSTATE) with C := (BitVec.join1 [(BitVec.access tmp 1)]) }
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access mask 0)]) == (0b1 : (BitVec 1)))
  then writeReg PSTATE { (← readReg PSTATE) with V := (BitVec.join1 [(BitVec.access tmp 0)]) }
  else (pure ())

def decode_rmif_aarch64_instrs_integer_flags_rmif (mask : (BitVec 4)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (sf : (BitVec 1)) : SailM Unit := do
  bif ((! (← (HaveFlagManipulateExt ()))) || (sf != (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let lsb := (BitVec.toNat imm6)
  let n := (BitVec.toNat Rn)
  (execute_aarch64_instrs_integer_flags_rmif lsb mask n)

/-- Type quantifiers: m : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 -/
def execute_aarch64_instrs_memory_single_general_range (m : Nat) (n : Nat) (operation : (BitVec 6)) : SailM Unit := do
  let address ← (( do
    bif (n == 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let metadata ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let stride := (BitVec.toInt (Sail.BitVec.extractLsb metadata 59 38))
  let count := ((BitVec.toNat (Sail.BitVec.extractLsb metadata 37 22)) +i 1)
  let length := (BitVec.toInt (Sail.BitVec.extractLsb metadata 21 0))
  let reuse ← (( do (undefined_int ()) ) : SailM Int )
  let reuse : Int :=
    bif ((Sail.BitVec.extractLsb metadata 63 60) == (0x0 : (BitVec 4)))
    then (Neg.neg 1)
    else (Int.shiftl 32768 (15 -i (BitVec.toNat (Sail.BitVec.extractLsb metadata 63 60))))
  let reuse := reuse
  (pure (Hint_RangePrefetch address length stride count reuse operation))

def decode_rprfm_reg_aarch64_instrs_memory_single_general_range (Rt : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (option_name : (BitVec 3)) (Rm : (BitVec 5)) (opc : (BitVec 2)) (size : (BitVec 2)) : SailM Unit := do
  let operation : (BitVec 6) :=
    ((((BitVec.join1 [(BitVec.access option_name 2)]) ++ (BitVec.join1 [(BitVec.access option_name 0)])) ++ S) ++ (Sail.BitVec.extractLsb
        Rt 2 0))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  (execute_aarch64_instrs_memory_single_general_range m n operation)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, part : Nat, k_round
  : Bool, shift : Int, part ∈ {0, 1} ∧
  0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {4, 8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_right_narrow_logical (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (part : Nat) (round : Bool) (shift : Int) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n (datasize *i 2)) ) : SailM (BitVec (datasize * 2)) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (RShr (BitVec.toNat (← (Elem_read operand e (2 *i esize)))) shift round)
        let result ← (Elem_set result e esize (integer_subrange element (esize -i 1) 0))
        (pure (element, result))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize)) )
  (Vpart_set d part datasize result)

def decode_rshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:41451.51-41451.52"
  (execute_aarch64_instrs_vector_shift_right_narrow_logical d datasize elements esize n part round
    shift)

def decode_shrn_advsimd_aarch64_instrs_vector_shift_right_narrow_logical (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:41483.51-41483.52"
  (execute_aarch64_instrs_vector_shift_right_narrow_logical d datasize elements esize n part round
    shift)

/-- Type quantifiers: k_accumulate : Bool, d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned
  : Bool, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff (accumulate : Bool) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let absdiff ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let result ← (( do
    bif accumulate
    then (V_read d datasize)
    else (pure (Zeros (n := datasize))) ) : SailM (BitVec datasize) )
  let (absdiff, element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (absdiff, element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (absdiff, element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let absdiff : (BitVec esize) :=
          (integer_subrange (Int.natAbs (element1 -i element2)) (esize -i 1) 0)
        let result ← (Elem_set result e esize ((← (Elem_read result e esize)) + absdiff))
        (pure (absdiff, element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × Int × Int × (BitVec datasize)) )
  (V_set d datasize result)

def decode_saba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let accumulate : Bool := (ac == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff accumulate d datasize elements esize
    m n is_unsigned)

def decode_sabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let accumulate : Bool := (ac == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff accumulate d datasize elements esize
    m n is_unsigned)

def decode_uaba_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let accumulate : Bool := (ac == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff accumulate d datasize elements esize
    m n is_unsigned)

def decode_uabd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_diff (Rd : (BitVec 5)) (Rn : (BitVec 5)) (ac : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let accumulate : Bool := (ac == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_diff accumulate d datasize elements esize
    m n is_unsigned)

/-- Type quantifiers: k_accumulate : Bool, d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned
  : Bool, m : Nat, n : Nat, part : Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff (accumulate : Bool) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (Vpart_read m part datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let absdiff ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let result ← (( do
    bif accumulate
    then (V_read d (2 *i datasize))
    else (pure (Zeros (n := (2 *i datasize)))) ) : SailM (BitVec (2 * datasize)) )
  let (absdiff, element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (absdiff, element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (absdiff, element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let absdiff : (BitVec (2 * esize)) :=
          (integer_subrange (Int.natAbs (element1 -i element2)) ((2 *i esize) -i 1) 0)
        let result ←
          (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) + absdiff))
        (pure (absdiff, element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec (2 * esize)) × Int × Int × (BitVec (2 * datasize))) )
  (V_set d (2 *i datasize) result)

def decode_sabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let accumulate : Bool := (op == (0b0 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff accumulate d datasize elements
    esize m n part is_unsigned)

def decode_sabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let accumulate : Bool := (op == (0b0 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff accumulate d datasize elements
    esize m n part is_unsigned)

def decode_uabal_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let accumulate : Bool := (op == (0b0 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff accumulate d datasize elements
    esize m n part is_unsigned)

def decode_uabdl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_diff (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let accumulate : Bool := (op == (0b0 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_diff accumulate d datasize elements
    esize m n part is_unsigned)

/-- Type quantifiers: k_acc : Bool, d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned
  : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise (acc : Bool) (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let sum ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do
    bif acc
    then
      (do
        (V_read d datasize))
    else (pure result) ) : SailM (BitVec datasize) )
  let (op1, op2, result, sum) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (op1, op2, result, sum)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (op1, op2, result, sum) := loop_vars
      loop_vars ← do
        let op1 ← (asl_Int (← (Elem_read operand ((2 *i e) +i 0) esize)) is_unsigned)
        let op2 ← (asl_Int (← (Elem_read operand ((2 *i e) +i 1) esize)) is_unsigned)
        let sum : (BitVec (2 * esize)) := (integer_subrange (op1 +i op2) ((2 *i esize) -i 1) 0)
        let result ← (( do
          bif acc
          then
            (do
              (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) + sum)))
          else
            (do
              (Elem_set result e (2 *i esize) sum)) ) : SailM (BitVec datasize) )
        (pure (op1, op2, result, sum))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec datasize) × (BitVec (2 * esize))) )
  (V_set d datasize result)

def decode_sadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize (2 *i esize))
  let acc : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise acc d datasize elements esize n
    is_unsigned)

def decode_saddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize (2 *i esize))
  let acc : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise acc d datasize elements esize n
    is_unsigned)

def decode_uadalp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize (2 *i esize))
  let acc : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise acc d datasize elements esize n
    is_unsigned)

def decode_uaddlp_advsimd_aarch64_instrs_vector_arithmetic_unary_add_pairwise (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize (2 *i esize))
  let acc : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_add_pairwise acc d datasize elements esize n
    is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, part : Nat, k_sub_op : Bool, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) (sub_op : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (Vpart_read m part datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let sum ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result, sum) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result, sum)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result, sum) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let sum : Int :=
          bif sub_op
          then (element1 -i element2)
          else (element1 +i element2)
        let result ← (Elem_set result e (2 *i esize) (integer_subrange sum ((2 *i esize) -i 1) 0))
        (pure (element1, element2, result, sum))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec (2 * datasize)) × Int) )
  (V_set d (2 *i datasize) result)

def decode_saddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long d datasize elements esize
    m n part sub_op is_unsigned)

def decode_ssubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long d datasize elements esize
    m n part sub_op is_unsigned)

def decode_uaddl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long d datasize elements esize
    m n part sub_op is_unsigned)

def decode_usubl_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_long d datasize elements esize
    m n part sub_op is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, n
  : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_reduce_add_long (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let sum ← (( do (asl_Int (← (Elem_read operand 0 esize)) is_unsigned) ) : SailM Int )
  let sum ← (( do
    let loop_e_lower := 1
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := sum
    for e in [loop_e_lower:loop_e_upper:1]i do
      let sum := loop_vars
      loop_vars ← do (pure (sum +i (← (asl_Int (← (Elem_read operand e esize)) is_unsigned))))
    (pure loop_vars) ) : SailM Int )
  let sum := sum
  (V_set d (2 *i esize) (integer_subrange sum ((2 *i esize) -i 1) 0))

def decode_saddlv_advsimd_aarch64_instrs_vector_reduce_add_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b100 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_reduce_add_long d datasize elements esize n is_unsigned)

def decode_uaddlv_advsimd_aarch64_instrs_vector_reduce_add_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b100 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_reduce_add_long d datasize elements esize n is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, part : Nat, k_sub_op : Bool, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) (sub_op : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let operand2 ← (( do (Vpart_read m part datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let sum ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result, sum) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result, sum)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result, sum) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e (2 *i esize))) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let sum : Int :=
          bif sub_op
          then (element1 -i element2)
          else (element1 +i element2)
        let result ← (Elem_set result e (2 *i esize) (integer_subrange sum ((2 *i esize) -i 1) 0))
        (pure (element1, element2, result, sum))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec (2 * datasize)) × Int) )
  (V_set d (2 *i datasize) result)

def decode_saddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide d datasize elements esize
    m n part sub_op is_unsigned)

def decode_ssubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide d datasize elements esize
    m n part sub_op is_unsigned)

def decode_uaddw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide d datasize elements esize
    m n part sub_op is_unsigned)

def decode_usubw_advsimd_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_add_sub_wide d datasize elements esize
    m n part sub_op is_unsigned)

def execute_aarch64_instrs_system_barriers_sb (_ : Unit) : SailM Unit := do
  (SpeculationBarrier ())

def decode_sb_aarch64_instrs_system_barriers_sb (opc : (BitVec 2)) (CRm : (BitVec 4)) : SailM Unit := do
  bif (! (← (HaveSBExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_system_barriers_sb ())

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, fracbits : Int, k_is_unsigned
  : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_conv_int_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (fracbits : Int) (n : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ←
          (Elem_set result e esize
            (← (FixedToFP element fracbits is_unsigned fpcr rounding esize)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((let b__0 := immh
       bif ((Sail.BitVec.extractLsb b__0 3 1) == (0b000 : (BitVec 3)))
       then true
       else false : Bool) || ((let b__1 := immh
         bif ((Sail.BitVec.extractLsb b__1 3 1) == (0b001 : (BitVec 3)))
         then true
         else false : Bool) && (! (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize :=
    bif (let b__3 := immh
       bif ((Sail.BitVec.extractLsb b__3 3 3) == (0b1 : (BitVec 1)))
       then true
       else false : Bool)
    then 64
    else
      (bif (let b__2 := immh
         bif ((Sail.BitVec.extractLsb b__2 3 2) == (0b01 : (BitVec 2)))
         then true
         else false : Bool)
      then 32
      else 16)
  let datasize := esize
  let elements := 1
  let fracbits := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_vector_shift_conv_int_sisd d datasize elements esize fracbits n rounding
    is_unsigned)

def decode_scvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((let b__0 := immh
       bif ((Sail.BitVec.extractLsb b__0 3 1) == (0b000 : (BitVec 3)))
       then true
       else false : Bool) || ((let b__1 := immh
         bif ((Sail.BitVec.extractLsb b__1 3 1) == (0b001 : (BitVec 3)))
         then true
         else false : Bool) && (! (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize :=
    bif (let b__3 := immh
       bif ((Sail.BitVec.extractLsb b__3 3 3) == (0b1 : (BitVec 1)))
       then true
       else false : Bool)
    then 64
    else
      (bif (let b__2 := immh
         bif ((Sail.BitVec.extractLsb b__2 3 2) == (0b01 : (BitVec 2)))
         then true
         else false : Bool)
      then 32
      else 16)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let fracbits := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_vector_shift_conv_int_sisd d datasize elements esize fracbits n rounding
    is_unsigned)

def decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((let b__0 := immh
       bif ((Sail.BitVec.extractLsb b__0 3 1) == (0b000 : (BitVec 3)))
       then true
       else false : Bool) || ((let b__1 := immh
         bif ((Sail.BitVec.extractLsb b__1 3 1) == (0b001 : (BitVec 3)))
         then true
         else false : Bool) && (! (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize :=
    bif (let b__3 := immh
       bif ((Sail.BitVec.extractLsb b__3 3 3) == (0b1 : (BitVec 1)))
       then true
       else false : Bool)
    then 64
    else
      (bif (let b__2 := immh
         bif ((Sail.BitVec.extractLsb b__2 3 2) == (0b01 : (BitVec 2)))
         then true
         else false : Bool)
      then 32
      else 16)
  let datasize := esize
  let elements := 1
  let fracbits := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_vector_shift_conv_int_sisd d datasize elements esize fracbits n rounding
    is_unsigned)

def decode_ucvtf_advsimd_fix_aarch64_instrs_vector_shift_conv_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((let b__0 := immh
       bif ((Sail.BitVec.extractLsb b__0 3 1) == (0b000 : (BitVec 3)))
       then true
       else false : Bool) || ((let b__1 := immh
         bif ((Sail.BitVec.extractLsb b__1 3 1) == (0b001 : (BitVec 3)))
         then true
         else false : Bool) && (! (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize :=
    bif (let b__3 := immh
       bif ((Sail.BitVec.extractLsb b__3 3 3) == (0b1 : (BitVec 1)))
       then true
       else false : Bool)
    then 64
    else
      (bif (let b__2 := immh
         bif ((Sail.BitVec.extractLsb b__2 3 2) == (0b01 : (BitVec 2)))
         then true
         else false : Bool)
      then 32
      else 16)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let fracbits := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  (execute_aarch64_instrs_vector_shift_conv_int_sisd d datasize elements esize fracbits n rounding
    is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, n
  : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ datasize ∈ {16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let fpcr ← (( do (FPCR_read ()) ) : SailM FPCRType )
  let merge ← (( do (pure ((elements == 1) && (← (IsMerging fpcr)))) ) : SailM Bool )
  let result ← (( do
    bif merge
    then (V_read d 128)
    else (pure (Zeros (n := 128))) ) : SailM (BitVec 128) )
  let rounding ← (( do (FPRoundingMode fpcr) ) : SailM FPRounding )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e esize)
        let result ←
          (Elem_set result e esize (← (FixedToFP element 0 is_unsigned fpcr rounding esize)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128)) )
  (V_set d 128 result)

def decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd d datasize elements esize n
    is_unsigned)

def decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd d datasize elements esize n
    is_unsigned)

def decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd d datasize elements esize n
    is_unsigned)

def decode_scvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd d datasize elements esize n
    is_unsigned)

def decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd d datasize elements esize n
    is_unsigned)

def decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd d datasize elements esize n
    is_unsigned)

def decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (HaveFP16Ext ()))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := 16
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd d datasize elements esize n
    is_unsigned)

def decode_ucvtf_advsimd_int_aarch64_instrs_vector_arithmetic_unary_float_conv_int_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((sz ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_fp16_conv_int_sisd d datasize elements esize n
    is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_div (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do
    bif (IsZero operand2)
    then (pure 0)
    else
      (do
        (pure (RoundTowardsZero
            (div_real (to_real (← (asl_Int operand1 is_unsigned)))
              (to_real (← (asl_Int operand2 is_unsigned))))))) ) : SailM Int )
  let result := result
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_sdiv_aarch64_instrs_integer_arithmetic_div (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let is_unsigned : Bool := (o1 == (0b0 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_div d datasize m n is_unsigned)

def decode_udiv_aarch64_instrs_integer_arithmetic_div (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (sf == (0b1 : (BitVec 1)))
    then 64
    else 32
  let is_unsigned : Bool := (o1 == (0b0 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_div d datasize m n is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_signed : Bool, m :
  Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (is_signed : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let res : Int := 0
        let element1 ← (( do (undefined_int ()) ) : SailM Int )
        let element2 ← (( do (undefined_int ()) ) : SailM Int )
        let (element1, element2, res) ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := (element1, element2, res)
          for i in [loop_i_lower:loop_i_upper:1]i do
            let (element1, element2, res) := loop_vars_1
            loop_vars_1 ← do
              let (element1, element2) ← (( do
                bif is_signed
                then
                  (do
                    let element1 ←
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ←
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ←
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ←
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    (pure (element1, element2))) ) : SailM (Int × Int) )
              let res : Int := (res +i (element1 *i element2))
              (pure (element1, element2, res))
          (pure loop_vars_1) ) : SailM (Int × Int × Int) )
        let res := res
        (Elem_set result e esize (BitVec.addInt (← (Elem_read result e esize)) res))
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_sdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveDOTPExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size != (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := (U == (0b0 : (BitVec 1)))
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp d datasize elements esize m
    n is_signed)

def decode_udot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveDOTPExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size != (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := (U == (0b0 : (BitVec 1)))
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_dotp d datasize elements esize m
    n is_signed)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, index : Nat, k_is_signed
  : Bool, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3} ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_dotp (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (is_signed : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let result ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let res : Int := 0
        let element1 ← (( do (undefined_int ()) ) : SailM Int )
        let element2 ← (( do (undefined_int ()) ) : SailM Int )
        let (element1, element2, res) ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := (element1, element2, res)
          for i in [loop_i_lower:loop_i_upper:1]i do
            let (element1, element2, res) := loop_vars_1
            loop_vars_1 ← do
              let (element1, element2) ← (( do
                bif is_signed
                then
                  (do
                    let element1 ←
                      (pure (BitVec.toInt
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ←
                      (pure (BitVec.toInt
                          (← (Elem_read operand2 ((4 *i index) +i i) (Int.ediv esize 4)))))
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ←
                      (pure (BitVec.toNat
                          (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
                    let element2 ←
                      (pure (BitVec.toNat
                          (← (Elem_read operand2 ((4 *i index) +i i) (Int.ediv esize 4)))))
                    (pure (element1, element2))) ) : SailM (Int × Int) )
              let res : Int := (res +i (element1 *i element2))
              (pure (element1, element2, res))
          (pure loop_vars_1) ) : SailM (Int × Int × Int) )
        let res := res
        (Elem_set result e esize (BitVec.addInt (← (Elem_read result e esize)) res))
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_sdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveDOTPExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size != (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := (U == (0b0 : (BitVec 1)))
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (M ++ Rm))
  let index := (BitVec.toNat (H ++ L))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_element_dotp d datasize elements esize index m n
    is_signed)

def decode_udot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_dotp (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveDOTPExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size != (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := (U == (0b0 : (BitVec 1)))
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (M ++ Rm))
  let index := (BitVec.toNat (H ++ L))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_element_dotp d datasize elements esize index m n
    is_signed)

/-- Type quantifiers: d : Nat, n : Nat, s : Nat, 0 ≤ s ∧
  s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_memory_mcpymset_set (d : Nat) (n : Nat) (options_name : (BitVec 2)) (s : Nat) (stage : MOPSStage) : SailM Unit := do
  let toaddress ← (( do (X_read d 64) ) : SailM (BitVec 64) )
  let setsize ← (( do (X_read n 64) ) : SailM (BitVec 64) )
  let data ← (( do (X_read s 8) ) : SailM (BitVec 8) )
  let nzcv ← (( do
    (pure ((← readReg PSTATE).N ++ ((← readReg PSTATE).Z ++ ((← readReg PSTATE).C ++ (← readReg PSTATE).V))))
    ) : SailM (BitVec 4) )
  let stagesetsize ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let is_setg : Bool := false
  let B ← (( do (undefined_int ()) ) : SailM Int )
  let supports_option_a ← (( do (SETOptionA ()) ) : SailM Bool )
  let privileged ← (( do
    bif ((BitVec.join1 [(BitVec.access options_name 0)]) == (0b1 : (BitVec 1)))
    then (AArch64_IsUnprivAccessPriv ())
    else (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let nontemporal : Bool := ((BitVec.join1 [(BitVec.access options_name 1)]) == (0b1 : (BitVec 1)))
  let accdesc ← (( do (CreateAccDescMOPS MemOp_STORE privileged nontemporal) ) : SailM
    AccessDescriptor )
  let (nzcv, setsize, stagesetsize, toaddress) ← (( do
    bif (BEq.beq stage MOPSStage_Prologue)
    then
      (do
        let setsize : (BitVec 64) :=
          bif ((BitVec.join1 [(BitVec.access setsize 63)]) == (0b1 : (BitVec 1)))
          then (0x7FFFFFFFFFFFFFFF : (BitVec 64))
          else setsize
        let (nzcv, setsize, toaddress) : ((BitVec 4) × (BitVec 64) × (BitVec 64)) :=
          bif supports_option_a
          then
            (let nzcv : (BitVec 4) := (0x0 : (BitVec 4))
            let toaddress : (BitVec 64) := (toaddress + setsize)
            let setsize : (BitVec 64) := ((Zeros (n := 64)) - setsize)
            (nzcv, setsize, toaddress))
          else
            (let nzcv : (BitVec 4) := (0x2 : (BitVec 4))
            (nzcv, setsize, toaddress))
        let stagesetsize ← (SETPreSizeChoice toaddress setsize is_setg)
        assert (((BitVec.join1 [(BitVec.access stagesetsize 63)]) == (BitVec.join1 [(BitVec.access
                setsize 63)])) || (stagesetsize == (Zeros (n := 64)))) "src/instrs64.sail:42994.78-42994.79"
        bif ((BitVec.toInt setsize) >b 0)
        then
          assert ((BitVec.toInt stagesetsize) ≤b (BitVec.toInt setsize)) "src/instrs64.sail:42996.54-42996.55"
        else
          assert ((BitVec.toInt stagesetsize) ≥b (BitVec.toInt setsize)) "src/instrs64.sail:42998.54-42998.55"
        (pure (nzcv, setsize, stagesetsize, toaddress)))
    else
      (do
        let postsize ← (( do (SETPostSizeChoice toaddress setsize is_setg) ) : SailM (BitVec 64) )
        assert (((BitVec.join1 [(BitVec.access postsize 63)]) == (BitVec.join1 [(BitVec.access
                setsize 63)])) || (postsize == (Zeros (n := 64)))) "src/instrs64.sail:43002.70-43002.71"
        let zero_size_exceptions ← (( do (MemSetZeroSizeCheck ()) ) : SailM Bool )
        bif (zero_size_exceptions || (((BitVec.toInt setsize) != 0) : Bool))
        then
          (do
            bif supports_option_a
            then
              (do
                bif ((BitVec.join1 [(BitVec.access nzcv 1)]) == (0b1 : (BitVec 1)))
                then
                  (do
                    let wrong_option : Bool := true
                    let from_epilogue : Bool := (BEq.beq stage MOPSStage_Epilogue)
                    (MismatchedMemSetException supports_option_a d s n wrong_option from_epilogue
                      options_name is_setg))
                else (pure ()))
            else
              (do
                bif ((BitVec.join1 [(BitVec.access nzcv 1)]) == (0b0 : (BitVec 1)))
                then
                  (do
                    let wrong_option : Bool := true
                    let from_epilogue : Bool := (BEq.beq stage MOPSStage_Epilogue)
                    (MismatchedMemSetException supports_option_a d s n wrong_option from_epilogue
                      options_name is_setg))
                else (pure ())))
        else (pure ())
        let stagesetsize ← (( do
          bif (BEq.beq stage MOPSStage_Main)
          then
            (do
              let stagesetsize : (BitVec 64) := (setsize - postsize)
              bif (← (MemSetParametersIllformedM toaddress setsize is_setg))
              then
                (do
                  let wrong_option : Bool := false
                  let from_epilogue : Bool := false
                  (MismatchedMemSetException supports_option_a d s n wrong_option from_epilogue
                    options_name is_setg))
              else (pure ())
              (pure stagesetsize))
          else
            (do
              let stagesetsize : (BitVec 64) := postsize
              bif ((setsize != postsize) || (← (MemSetParametersIllformedE toaddress setsize
                       is_setg)))
              then
                (do
                  let wrong_option : Bool := false
                  let from_epilogue : Bool := true
                  (MismatchedMemSetException supports_option_a d s n wrong_option from_epilogue
                    options_name is_setg))
              else (pure ())
              (pure stagesetsize)) ) : SailM (BitVec 64) )
        (pure (nzcv, setsize, stagesetsize, toaddress))) ) : SailM
    ((BitVec 4) × (BitVec 64) × (BitVec 64) × (BitVec 64)) )
  bif (← readReg SPESampleInFlight)
  then (SPESampleMemSet ())
  else (pure ())
  let (setsize, toaddress) ← (( do
    bif supports_option_a
    then
      (do
        let (B, setsize, stagesetsize) ← (( do
          let mut loop_vars_1 := (B, setsize, stagesetsize)
          while (λ (B, setsize, stagesetsize) => ((BitVec.toInt stagesetsize) <b 0)) loop_vars_1 do
            let (B, setsize, stagesetsize) := loop_vars_1
            loop_vars_1 ← do
              let B ← (SETSizeChoice toaddress setsize 1)
              assert (B ≤b ((Neg.neg 1) *i (BitVec.toInt stagesetsize))) "src/instrs64.sail:43045.54-43045.55"
              let B := B
              assert ((B *i 8) ≥b 0) "src/instrs64.sail:43048.48-43048.49"
              (Mem_set (toaddress + setsize) B accdesc (BitVec.replicateBits data B))
              let setsize : (BitVec 64) := (BitVec.addInt setsize B)
              let stagesetsize : (BitVec 64) := (BitVec.addInt stagesetsize B)
              bif (bne stage MOPSStage_Prologue)
              then (X_set n 64 setsize)
              else (pure ())
              (pure (B, setsize, stagesetsize))
          (pure loop_vars_1) ) : SailM (Int × (BitVec 64) × (BitVec 64)) )
        (pure (setsize, toaddress)))
    else
      (do
        let (B, setsize, stagesetsize, toaddress) ← (( do
          let mut loop_vars := (B, setsize, stagesetsize, toaddress)
          while (λ (B, setsize, stagesetsize, toaddress) => ((BitVec.toNat stagesetsize) >b 0))
            loop_vars
            do
            let (B, setsize, stagesetsize, toaddress) := loop_vars
            loop_vars ← do
              let B ← (SETSizeChoice toaddress setsize 1)
              assert (B ≤b (BitVec.toNat stagesetsize)) "src/instrs64.sail:43061.42-43061.43"
              let B := B
              assert ((B *i 8) ≥b 0) "src/instrs64.sail:43064.48-43064.49"
              (Mem_set toaddress B accdesc (BitVec.replicateBits data B))
              let toaddress : (BitVec 64) := (BitVec.addInt toaddress B)
              let setsize : (BitVec 64) := (BitVec.subInt setsize B)
              let stagesetsize : (BitVec 64) := (BitVec.subInt stagesetsize B)
              bif (bne stage MOPSStage_Prologue)
              then
                (do
                  (X_set n 64 setsize)
                  (X_set d 64 toaddress))
              else (pure ())
              (pure (B, setsize, stagesetsize, toaddress))
          (pure loop_vars) ) : SailM (Int × (BitVec 64) × (BitVec 64) × (BitVec 64)) )
        (pure (setsize, toaddress))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  bif (BEq.beq stage MOPSStage_Prologue)
  then
    (do
      (X_set n 64 setsize)
      (X_set d 64 toaddress)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_setp_aarch64_instrs_memory_mcpymset_set (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 2) := (Sail.BitVec.extractLsb op2 1 0)
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := (Sail.BitVec.extractLsb op2 3 2)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif (((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:43117.58-43117.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_set d n options_name s stage)

def decode_setpn_aarch64_instrs_memory_mcpymset_set (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 2) := (Sail.BitVec.extractLsb op2 1 0)
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := (Sail.BitVec.extractLsb op2 3 2)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif (((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:43173.58-43173.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_set d n options_name s stage)

def decode_setpt_aarch64_instrs_memory_mcpymset_set (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 2) := (Sail.BitVec.extractLsb op2 1 0)
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := (Sail.BitVec.extractLsb op2 3 2)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif (((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:43229.58-43229.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_set d n options_name s stage)

def decode_setptn_aarch64_instrs_memory_mcpymset_set (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 2) := (Sail.BitVec.extractLsb op2 1 0)
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := (Sail.BitVec.extractLsb op2 3 2)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif (((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:43285.58-43285.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_set d n options_name s stage)

/-- Type quantifiers: msb : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ msb ∈ {7, 15} -/
def execute_aarch64_instrs_integer_flags_setf (msb : Nat) (n : Nat) : SailM Unit := do
  let tmpreg ← (( do (X_read n 32) ) : SailM (BitVec 32) )
  writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access tmpreg msb)]) }
  writeReg PSTATE { (← readReg PSTATE) with Z := bif ((Sail.BitVec.extractLsb tmpreg msb 0) == (Zeros
         (n := (msb +i 1))))
  then (0b1 : (BitVec 1))
  else (0b0 : (BitVec 1)) }
  writeReg PSTATE { (← readReg PSTATE) with V := ((BitVec.join1 [(BitVec.access tmpreg (msb +i 1))]) ^^^ (BitVec.join1 [(BitVec.access
        tmpreg msb)])) }

def decode_setf_aarch64_instrs_integer_flags_setf (Rn : (BitVec 5)) (sz : (BitVec 1)) (sf : (BitVec 1)) : SailM Unit := do
  bif ((! (← (HaveFlagManipulateExt ()))) || (sf != (0b0 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let msb :=
    bif (sz == (0b1 : (BitVec 1)))
    then 15
    else 7
  let n := (BitVec.toNat Rn)
  (execute_aarch64_instrs_integer_flags_setf msb n)

/-- Type quantifiers: d : Nat, n : Nat, s : Nat, 0 ≤ s ∧
  s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_memory_mcpymset_setg (d : Nat) (n : Nat) (options_name : (BitVec 2)) (s : Nat) (stage : MOPSStage) : SailM Unit := do
  let toaddress ← (( do (X_read d 64) ) : SailM (BitVec 64) )
  let setsize ← (( do (X_read n 64) ) : SailM (BitVec 64) )
  let data ← (( do (X_read s 8) ) : SailM (BitVec 8) )
  let nzcv ← (( do
    (pure ((← readReg PSTATE).N ++ ((← readReg PSTATE).Z ++ ((← readReg PSTATE).C ++ (← readReg PSTATE).V))))
    ) : SailM (BitVec 4) )
  let stagesetsize ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let is_setg : Bool := true
  let B ← (( do (undefined_int ()) ) : SailM Int )
  let supports_option_a ← (( do (SETGOptionA ()) ) : SailM Bool )
  let privileged ← (( do
    bif ((BitVec.join1 [(BitVec.access options_name 0)]) == (0b1 : (BitVec 1)))
    then (AArch64_IsUnprivAccessPriv ())
    else (pure ((← readReg PSTATE).EL != EL0)) ) : SailM Bool )
  let nontemporal : Bool := ((BitVec.join1 [(BitVec.access options_name 1)]) == (0b1 : (BitVec 1)))
  let accdesc ← (( do (CreateAccDescSTGMOPS privileged nontemporal) ) : SailM AccessDescriptor )
  let (nzcv, setsize, stagesetsize, toaddress) ← (( do
    bif (BEq.beq stage MOPSStage_Prologue)
    then
      (do
        let setsize : (BitVec 64) :=
          bif ((BitVec.join1 [(BitVec.access setsize 63)]) == (0b1 : (BitVec 1)))
          then (0x7FFFFFFFFFFFFFF0 : (BitVec 64))
          else setsize
        bif ((setsize != (Zeros (n := 64))) && (! (IsAligned__1 toaddress TAG_GRANULE)))
        then (AArch64_Abort toaddress (← (AlignmentFault accdesc)))
        else (pure ())
        bif (! (IsAligned__1 setsize TAG_GRANULE))
        then (AArch64_Abort toaddress (← (AlignmentFault accdesc)))
        else (pure ())
        let (nzcv, setsize, toaddress) : ((BitVec 4) × (BitVec 64) × (BitVec 64)) :=
          bif supports_option_a
          then
            (let nzcv : (BitVec 4) := (0x0 : (BitVec 4))
            let toaddress : (BitVec 64) := (toaddress + setsize)
            let setsize : (BitVec 64) := ((Zeros (n := 64)) - setsize)
            (nzcv, setsize, toaddress))
          else
            (let nzcv : (BitVec 4) := (0x2 : (BitVec 4))
            (nzcv, setsize, toaddress))
        let stagesetsize ← (SETPreSizeChoice toaddress setsize is_setg)
        assert (((BitVec.join1 [(BitVec.access stagesetsize 63)]) == (BitVec.join1 [(BitVec.access
                setsize 63)])) || (stagesetsize == (Zeros (n := 64)))) "src/instrs64.sail:43376.78-43376.79"
        assert ((Sail.BitVec.extractLsb stagesetsize 3 0) == (0x0 : (BitVec 4))) "src/instrs64.sail:43377.45-43377.46"
        bif ((BitVec.toInt setsize) >b 0)
        then
          assert ((BitVec.toInt stagesetsize) ≤b (BitVec.toInt setsize)) "src/instrs64.sail:43379.54-43379.55"
        else
          assert ((BitVec.toInt stagesetsize) ≥b (BitVec.toInt setsize)) "src/instrs64.sail:43381.54-43381.55"
        (pure (nzcv, setsize, stagesetsize, toaddress)))
    else
      (do
        let postsize ← (( do (SETPostSizeChoice toaddress setsize is_setg) ) : SailM (BitVec 64) )
        assert (((BitVec.join1 [(BitVec.access postsize 63)]) == (BitVec.join1 [(BitVec.access
                setsize 63)])) || (postsize == (Zeros (n := 64)))) "src/instrs64.sail:43385.70-43385.71"
        assert ((Sail.BitVec.extractLsb postsize 3 0) == (0x0 : (BitVec 4))) "src/instrs64.sail:43386.41-43386.42"
        let zero_size_exceptions ← (( do (MemSetZeroSizeCheck ()) ) : SailM Bool )
        bif (zero_size_exceptions || (((BitVec.toInt setsize) != 0) : Bool))
        then
          (do
            bif supports_option_a
            then
              (do
                bif ((BitVec.join1 [(BitVec.access nzcv 1)]) == (0b1 : (BitVec 1)))
                then
                  (do
                    let wrong_option : Bool := true
                    let from_epilogue : Bool := (BEq.beq stage MOPSStage_Epilogue)
                    (MismatchedMemSetException supports_option_a d s n wrong_option from_epilogue
                      options_name is_setg))
                else (pure ()))
            else
              (do
                bif ((BitVec.join1 [(BitVec.access nzcv 1)]) == (0b0 : (BitVec 1)))
                then
                  (do
                    let wrong_option : Bool := true
                    let from_epilogue : Bool := (BEq.beq stage MOPSStage_Epilogue)
                    (MismatchedMemSetException supports_option_a d s n wrong_option from_epilogue
                      options_name is_setg))
                else (pure ())))
        else (pure ())
        let stagesetsize ← (( do
          bif (BEq.beq stage MOPSStage_Main)
          then
            (do
              let stagesetsize : (BitVec 64) := (setsize - postsize)
              bif (← (MemSetParametersIllformedM toaddress setsize is_setg))
              then
                (do
                  let wrong_option : Bool := false
                  let from_epilogue : Bool := false
                  (MismatchedMemSetException supports_option_a d s n wrong_option from_epilogue
                    options_name is_setg))
              else (pure ())
              (pure stagesetsize))
          else
            (do
              let stagesetsize : (BitVec 64) := postsize
              bif ((setsize != postsize) || (← (MemSetParametersIllformedE toaddress setsize
                       is_setg)))
              then
                (do
                  let wrong_option : Bool := false
                  let from_epilogue : Bool := true
                  (MismatchedMemSetException supports_option_a d s n wrong_option from_epilogue
                    options_name is_setg))
              else (pure ())
              (pure stagesetsize)) ) : SailM (BitVec 64) )
        bif ((setsize != (Zeros (n := 64))) && (! (IsAligned__1 toaddress TAG_GRANULE)))
        then (AArch64_Abort toaddress (← (AlignmentFault accdesc)))
        else (pure ())
        bif (! (IsAligned__1 setsize TAG_GRANULE))
        then (AArch64_Abort toaddress (← (AlignmentFault accdesc)))
        else (pure ())
        (pure (nzcv, setsize, stagesetsize, toaddress))) ) : SailM
    ((BitVec 4) × (BitVec 64) × (BitVec 64) × (BitVec 64)) )
  let tagstep ← (( do (undefined_int ()) ) : SailM Int )
  let tag ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let tagaddr ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  bif (← readReg SPESampleInFlight)
  then (SPESampleMemSet ())
  else (pure ())
  let (setsize, toaddress) ← (( do
    bif supports_option_a
    then
      (do
        let (B, setsize, stagesetsize, tag, tagaddr, tagstep) ← (( do
          let mut loop_vars_2 := (B, setsize, stagesetsize, tag, tagaddr, tagstep)
          while (λ (B, setsize, stagesetsize, tag, tagaddr, tagstep) =>
            ((BitVec.toInt stagesetsize) <b 0))
            loop_vars_2
            do
            let (B, setsize, stagesetsize, tag, tagaddr, tagstep) := loop_vars_2
            loop_vars_2 ← do
              let B ← (SETSizeChoice toaddress setsize 16)
              assert (B ≤b ((Neg.neg 1) *i (BitVec.toInt stagesetsize))) "src/instrs64.sail:43439.54-43439.55"
              assert ((integer_subrange B 3 0) == (0x0 : (BitVec 4))) "src/instrs64.sail:43440.38-43440.39"
              let B := B
              assert ((B *i 8) ≥b 0) "src/instrs64.sail:43443.48-43443.49"
              (Mem_set (toaddress + setsize) B accdesc (BitVec.replicateBits data B))
              let tagstep : Int := (fdiv_int B 16)
              let tag : (BitVec 4) := (AArch64_AllocationTagFromAddress (toaddress + setsize))
              let (tagaddr, tagstep) ← (( do
                let mut loop_vars_3 := (tagaddr, tagstep)
                while (λ (tagaddr, tagstep) => (tagstep >b 0)) loop_vars_3 do
                  let (tagaddr, tagstep) := loop_vars_3
                  loop_vars_3 ← do
                    let tagaddr : (BitVec 64) :=
                      (BitVec.addInt (toaddress + setsize) ((tagstep -i 1) *i 16))
                    (AArch64_MemTag_set tagaddr accdesc tag)
                    let tagstep : Int := (tagstep -i 1)
                    (pure (tagaddr, tagstep))
                (pure loop_vars_3) ) : SailM ((BitVec 64) × Int) )
              let setsize : (BitVec 64) := (BitVec.addInt setsize B)
              let stagesetsize : (BitVec 64) := (BitVec.addInt stagesetsize B)
              bif (bne stage MOPSStage_Prologue)
              then (X_set n 64 setsize)
              else (pure ())
              (pure (B, setsize, stagesetsize, tag, tagaddr, tagstep))
          (pure loop_vars_2) ) : SailM
          (Int × (BitVec 64) × (BitVec 64) × (BitVec 4) × (BitVec 64) × Int) )
        (pure (setsize, toaddress)))
    else
      (do
        let (B, setsize, stagesetsize, tag, tagaddr, tagstep, toaddress) ← (( do
          let mut loop_vars := (B, setsize, stagesetsize, tag, tagaddr, tagstep, toaddress)
          while (λ (B, setsize, stagesetsize, tag, tagaddr, tagstep, toaddress) =>
            ((BitVec.toNat stagesetsize) >b 0))
            loop_vars
            do
            let (B, setsize, stagesetsize, tag, tagaddr, tagstep, toaddress) := loop_vars
            loop_vars ← do
              let B ← (SETSizeChoice toaddress setsize 16)
              assert (B ≤b (BitVec.toNat stagesetsize)) "src/instrs64.sail:43463.42-43463.43"
              assert ((integer_subrange B 3 0) == (0x0 : (BitVec 4))) "src/instrs64.sail:43464.38-43464.39"
              let B := B
              assert ((B *i 8) ≥b 0) "src/instrs64.sail:43467.48-43467.49"
              (Mem_set toaddress B accdesc (BitVec.replicateBits data B))
              let tagstep : Int := (fdiv_int B 16)
              let tag : (BitVec 4) := (AArch64_AllocationTagFromAddress toaddress)
              let (tagaddr, tagstep) ← (( do
                let mut loop_vars_1 := (tagaddr, tagstep)
                while (λ (tagaddr, tagstep) => (tagstep >b 0)) loop_vars_1 do
                  let (tagaddr, tagstep) := loop_vars_1
                  loop_vars_1 ← do
                    let tagaddr : (BitVec 64) := (BitVec.addInt toaddress ((tagstep -i 1) *i 16))
                    (AArch64_MemTag_set tagaddr accdesc tag)
                    let tagstep : Int := (tagstep -i 1)
                    (pure (tagaddr, tagstep))
                (pure loop_vars_1) ) : SailM ((BitVec 64) × Int) )
              let toaddress : (BitVec 64) := (BitVec.addInt toaddress B)
              let setsize : (BitVec 64) := (BitVec.subInt setsize B)
              let stagesetsize : (BitVec 64) := (BitVec.subInt stagesetsize B)
              bif (bne stage MOPSStage_Prologue)
              then
                (do
                  (X_set n 64 setsize)
                  (X_set d 64 toaddress))
              else (pure ())
              (pure (B, setsize, stagesetsize, tag, tagaddr, tagstep, toaddress))
          (pure loop_vars) ) : SailM
          (Int × (BitVec 64) × (BitVec 64) × (BitVec 4) × (BitVec 64) × Int × (BitVec 64)) )
        (pure (setsize, toaddress))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  bif (BEq.beq stage MOPSStage_Prologue)
  then
    (do
      (X_set n 64 setsize)
      (X_set d 64 toaddress)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_setgp_aarch64_instrs_memory_mcpymset_setg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 2) := (Sail.BitVec.extractLsb op2 1 0)
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := (Sail.BitVec.extractLsb op2 3 2)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif (((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:43530.58-43530.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_setg d n options_name s stage)

def decode_setgpn_aarch64_instrs_memory_mcpymset_setg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 2) := (Sail.BitVec.extractLsb op2 1 0)
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := (Sail.BitVec.extractLsb op2 3 2)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif (((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:43589.58-43589.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_setg d n options_name s stage)

def decode_setgpt_aarch64_instrs_memory_mcpymset_setg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 2) := (Sail.BitVec.extractLsb op2 1 0)
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := (Sail.BitVec.extractLsb op2 3 2)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif (((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:43648.58-43648.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_setg d n options_name s stage)

def decode_setgptn_aarch64_instrs_memory_mcpymset_setg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op2 : (BitVec 4)) (Rs : (BitVec 5)) (sz : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveFeatMOPS ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (sz != (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let s := (BitVec.toNat Rs)
  let n := (BitVec.toNat Rn)
  let options_name : (BitVec 2) := (Sail.BitVec.extractLsb op2 1 0)
  let stage ← (( do (undefined_MOPSStage ()) ) : SailM MOPSStage )
  let b__0 := (Sail.BitVec.extractLsb op2 3 2)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let stage : MOPSStage := MOPSStage_Prologue
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let stage : MOPSStage := MOPSStage_Main
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let stage : MOPSStage := MOPSStage_Epilogue
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let stage := stage
  (CheckMOPSEnabled ())
  bif (((((s == n) || (s == d)) || (n == d)) || (d == 31)) || (n == 31))
  then
    (do
      let c ← (( do (ConstrainUnpredictable Unpredictable_MOPSOVERLAP31) ) : SailM Constraint )
      assert ((BEq.beq c Constraint_UNDEF) || (BEq.beq c Constraint_NOP)) "src/instrs64.sail:43707.58-43707.59"
      match c with
      | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
      | Constraint_NOP => (EndOfInstruction ())
      | _ => (pure ()))
  else (pure ())
  (execute_aarch64_instrs_memory_mcpymset_setg d n options_name s stage)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let x ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let y ← (( do (V_read n 32) ) : SailM (BitVec 32) )
  let w ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let t ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (t, x, y) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := 3
    let mut loop_vars := (t, x, y)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (t, x, y) := loop_vars
      loop_vars ← do
        let t : (BitVec 32) :=
          (SHAchoose (Sail.BitVec.extractLsb x 63 32) (Sail.BitVec.extractLsb x 95 64)
            (Sail.BitVec.extractLsb x 127 96))
        let y ←
          (pure (((y + (← (ROL (Sail.BitVec.extractLsb x 31 0) 5))) + t) + (← (Elem_read w e 32))))
        let x ←
          (pure (Sail.BitVec.updateSubrange x 63 32 (← (ROL (Sail.BitVec.extractLsb x 63 32) 30))))
        let split_vec ← do (ROL (y ++ x) 32)
        let y : (BitVec 32) := (Sail.BitVec.extractLsb split_vec 159 128)
        let x : (BitVec 128) := (Sail.BitVec.extractLsb split_vec 127 0)
        (pure (t, x, y))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 128) × (BitVec 32)) )
  (V_set d 128 x)

def decode_sha1c_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (! (← (HaveSHA1Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_choose d m n)

/-- Type quantifiers: d : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha2op_sha1_hash (d : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let operand ← (( do (V_read n 32) ) : SailM (BitVec 32) )
  (V_set d 32 (← (ROL operand 30)))

def decode_sha1h_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_hash (Rd : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HaveSHA1Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_crypto_sha2op_sha1_hash d n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let x ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let y ← (( do (V_read n 32) ) : SailM (BitVec 32) )
  let w ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let t ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (t, x, y) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := 3
    let mut loop_vars := (t, x, y)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (t, x, y) := loop_vars
      loop_vars ← do
        let t : (BitVec 32) :=
          (SHAmajority (Sail.BitVec.extractLsb x 63 32) (Sail.BitVec.extractLsb x 95 64)
            (Sail.BitVec.extractLsb x 127 96))
        let y ←
          (pure (((y + (← (ROL (Sail.BitVec.extractLsb x 31 0) 5))) + t) + (← (Elem_read w e 32))))
        let x ←
          (pure (Sail.BitVec.updateSubrange x 63 32 (← (ROL (Sail.BitVec.extractLsb x 63 32) 30))))
        let split_vec ← do (ROL (y ++ x) 32)
        let y : (BitVec 32) := (Sail.BitVec.extractLsb split_vec 159 128)
        let x : (BitVec 128) := (Sail.BitVec.extractLsb split_vec 127 0)
        (pure (t, x, y))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 128) × (BitVec 32)) )
  (V_set d 128 x)

def decode_sha1m_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (! (← (HaveSHA1Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_majority d m n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let x ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let y ← (( do (V_read n 32) ) : SailM (BitVec 32) )
  let w ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let t ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (t, x, y) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := 3
    let mut loop_vars := (t, x, y)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (t, x, y) := loop_vars
      loop_vars ← do
        let t : (BitVec 32) :=
          (SHAparity (Sail.BitVec.extractLsb x 63 32) (Sail.BitVec.extractLsb x 95 64)
            (Sail.BitVec.extractLsb x 127 96))
        let y ←
          (pure (((y + (← (ROL (Sail.BitVec.extractLsb x 31 0) 5))) + t) + (← (Elem_read w e 32))))
        let x ←
          (pure (Sail.BitVec.updateSubrange x 63 32 (← (ROL (Sail.BitVec.extractLsb x 63 32) 30))))
        let split_vec ← do (ROL (y ++ x) 32)
        let y : (BitVec 32) := (Sail.BitVec.extractLsb split_vec 159 128)
        let x : (BitVec 128) := (Sail.BitVec.extractLsb split_vec 127 0)
        (pure (t, x, y))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 128) × (BitVec 32)) )
  (V_set d 128 x)

def decode_sha1p_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (! (← (HaveSHA1Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_crypto_sha3op_sha1_hash_parity d m n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let operand1 ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let operand2 ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let operand3 ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let result : (BitVec 128) :=
    ((Sail.BitVec.extractLsb operand2 63 0) ++ (Sail.BitVec.extractLsb operand1 127 64))
  let result : (BitVec 128) := ((result ^^^ operand1) ^^^ operand3)
  (V_set d 128 result)

def decode_sha1su0_advsimd_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (! (← (HaveSHA1Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_crypto_sha3op_sha1_sched0 d m n)

/-- Type quantifiers: d : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 (d : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let operand1 ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let operand2 ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let T : (BitVec 128) := (operand1 ^^^ (operand2 >>> 32))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 31 0 (← (ROL (Sail.BitVec.extractLsb T 31 0) 1))))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 63 32 (← (ROL (Sail.BitVec.extractLsb T 63 32) 1))))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 95 64 (← (ROL (Sail.BitVec.extractLsb T 95 64) 1))))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 127 96
        ((← (ROL (Sail.BitVec.extractLsb T 127 96) 1)) ^^^ (← (ROL
              (Sail.BitVec.extractLsb T 31 0) 2)))))
  (V_set d 128 result)

def decode_sha1su1_advsimd_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 (Rd : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HaveSHA1Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_crypto_sha2op_sha1_sched1 d n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_part1 : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash (d : Nat) (m : Nat) (n : Nat) (part1 : Bool) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let result ← (( do
    bif part1
    then
      (do
        (SHA256hash (← (V_read d 128)) (← (V_read n 128)) (← (V_read m 128)) true))
    else
      (do
        (SHA256hash (← (V_read n 128)) (← (V_read d 128)) (← (V_read m 128)) false)) ) : SailM
    (BitVec 128) )
  (V_set d 128 result)

def decode_sha256h_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash (Rd : (BitVec 5)) (Rn : (BitVec 5)) (P : (BitVec 1)) (Rm : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (! (← (HaveSHA256Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let part1 : Bool := (P == (0b0 : (BitVec 1)))
  (execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash d m n part1)

def decode_sha256h2_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_hash (Rd : (BitVec 5)) (Rn : (BitVec 5)) (P : (BitVec 1)) (Rm : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (! (← (HaveSHA256Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let part1 : Bool := (P == (0b0 : (BitVec 1)))
  (execute_aarch64_instrs_vector_crypto_sha3op_sha256_hash d m n part1)

/-- Type quantifiers: d : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 (d : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let operand1 ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let operand2 ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let T : (BitVec 128) :=
    ((Sail.BitVec.extractLsb operand2 31 0) ++ (Sail.BitVec.extractLsb operand1 127 32))
  let elt ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (elt, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := 3
    let mut loop_vars := (elt, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (elt, result) := loop_vars
      loop_vars ← do
        let elt ← (Elem_read T e 32)
        let elt : (BitVec 32) := (((ROR elt 7) ^^^ (ROR elt 18)) ^^^ (elt >>> 3))
        let result ← (Elem_set result e 32 (elt + (← (Elem_read operand1 e 32))))
        (pure (elt, result))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 128)) )
  (V_set d 128 result)

def decode_sha256su0_advsimd_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 (Rd : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HaveSHA256Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_crypto_sha2op_sha256_sched0 d n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let operand1 ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let operand2 ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let operand3 ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let T0 : (BitVec 128) :=
    ((Sail.BitVec.extractLsb operand3 31 0) ++ (Sail.BitVec.extractLsb operand2 127 32))
  let elt ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let T1 : (BitVec 64) := (Sail.BitVec.extractLsb operand3 127 64)
  let (elt, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := 1
    let mut loop_vars := (elt, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (elt, result) := loop_vars
      loop_vars ← do
        let elt ← (Elem_read T1 e 32)
        let elt : (BitVec 32) := (((ROR elt 17) ^^^ (ROR elt 19)) ^^^ (elt >>> 10))
        let elt ← (pure ((elt + (← (Elem_read operand1 e 32))) + (← (Elem_read T0 e 32))))
        let result ← (Elem_set result e 32 elt)
        (pure (elt, result))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 128)) )
  let T1 : (BitVec 64) := (Sail.BitVec.extractLsb result 63 0)
  let (elt, result) ← (( do
    let loop_e_lower := 2
    let loop_e_upper := 3
    let mut loop_vars_1 := (elt, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (elt, result) := loop_vars_1
      loop_vars_1 ← do
        let elt ← (Elem_read T1 (e -i 2) 32)
        let elt : (BitVec 32) := (((ROR elt 17) ^^^ (ROR elt 19)) ^^^ (elt >>> 10))
        let elt ← (pure ((elt + (← (Elem_read operand1 e 32))) + (← (Elem_read T0 e 32))))
        let result ← (Elem_set result e 32 elt)
        (pure (elt, result))
    (pure loop_vars_1) ) : SailM ((BitVec 32) × (BitVec 128)) )
  (V_set d 128 result)

def decode_sha256su1_advsimd_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (! (← (HaveSHA256Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_crypto_sha3op_sha256_sched1 d m n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha512_sha512h (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vtmp ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let x ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let y ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let w ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let MSigma1 : (BitVec 64) :=
    (((ROR (Sail.BitVec.extractLsb y 127 64) 14) ^^^ (ROR (Sail.BitVec.extractLsb y 127 64) 18)) ^^^ (ROR
        (Sail.BitVec.extractLsb y 127 64) 41))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 127 64
      (((Sail.BitVec.extractLsb y 127 64) &&& (Sail.BitVec.extractLsb x 63 0)) ^^^ ((Complement.complement
            (Sail.BitVec.extractLsb y 127 64)) &&& (Sail.BitVec.extractLsb x 127 64))))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 127 64
      (((Sail.BitVec.extractLsb Vtmp 127 64) + MSigma1) + (Sail.BitVec.extractLsb w 127 64)))
  let tmp : (BitVec 64) := ((Sail.BitVec.extractLsb Vtmp 127 64) + (Sail.BitVec.extractLsb y 63 0))
  let MSigma1 : (BitVec 64) := (((ROR tmp 14) ^^^ (ROR tmp 18)) ^^^ (ROR tmp 41))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 63 0
      ((tmp &&& (Sail.BitVec.extractLsb y 127 64)) ^^^ ((Complement.complement tmp) &&& (Sail.BitVec.extractLsb
            x 63 0))))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 63 0
      (((Sail.BitVec.extractLsb Vtmp 63 0) + MSigma1) + (Sail.BitVec.extractLsb w 63 0)))
  (V_set d 128 Vtmp)

def decode_sha512h_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSHA512Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  (execute_aarch64_instrs_vector_crypto_sha512_sha512h d m n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha512_sha512h2 (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vtmp ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let x ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let y ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let w ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let NSigma0 : (BitVec 64) :=
    (((ROR (Sail.BitVec.extractLsb y 63 0) 28) ^^^ (ROR (Sail.BitVec.extractLsb y 63 0) 34)) ^^^ (ROR
        (Sail.BitVec.extractLsb y 63 0) 39))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 127 64
      ((((Sail.BitVec.extractLsb x 63 0) &&& (Sail.BitVec.extractLsb y 127 64)) ^^^ ((Sail.BitVec.extractLsb
              x 63 0) &&& (Sail.BitVec.extractLsb y 63 0))) ^^^ ((Sail.BitVec.extractLsb y 127 64) &&& (Sail.BitVec.extractLsb
            y 63 0))))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 127 64
      (((Sail.BitVec.extractLsb Vtmp 127 64) + NSigma0) + (Sail.BitVec.extractLsb w 127 64)))
  let NSigma0 : (BitVec 64) :=
    (((ROR (Sail.BitVec.extractLsb Vtmp 127 64) 28) ^^^ (ROR (Sail.BitVec.extractLsb Vtmp 127 64) 34)) ^^^ (ROR
        (Sail.BitVec.extractLsb Vtmp 127 64) 39))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 63 0
      ((((Sail.BitVec.extractLsb Vtmp 127 64) &&& (Sail.BitVec.extractLsb y 63 0)) ^^^ ((Sail.BitVec.extractLsb
              Vtmp 127 64) &&& (Sail.BitVec.extractLsb y 127 64))) ^^^ ((Sail.BitVec.extractLsb y
            127 64) &&& (Sail.BitVec.extractLsb y 63 0))))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 63 0
      (((Sail.BitVec.extractLsb Vtmp 63 0) + NSigma0) + (Sail.BitVec.extractLsb w 63 0)))
  (V_set d 128 Vtmp)

def decode_sha512h2_advsimd_aarch64_instrs_vector_crypto_sha512_sha512h2 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSHA512Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  (execute_aarch64_instrs_vector_crypto_sha512_sha512h2 d m n)

/-- Type quantifiers: d : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha512_sha512su0 (d : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vtmp ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let x ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let w ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let sig0 : (BitVec 64) :=
    (((ROR (Sail.BitVec.extractLsb w 127 64) 1) ^^^ (ROR (Sail.BitVec.extractLsb w 127 64) 8)) ^^^ ((0b0000000 : (BitVec 7)) ++ (Sail.BitVec.extractLsb
          w 127 71)))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 63 0 ((Sail.BitVec.extractLsb w 63 0) + sig0))
  let sig0 : (BitVec 64) :=
    (((ROR (Sail.BitVec.extractLsb x 63 0) 1) ^^^ (ROR (Sail.BitVec.extractLsb x 63 0) 8)) ^^^ ((0b0000000 : (BitVec 7)) ++ (Sail.BitVec.extractLsb
          x 63 7)))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 127 64 ((Sail.BitVec.extractLsb w 127 64) + sig0))
  (V_set d 128 Vtmp)

def decode_sha512su0_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su0 (Rd : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSHA512Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  (execute_aarch64_instrs_vector_crypto_sha512_sha512su0 d n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha512_sha512su1 (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vtmp ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let x ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let y ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let w ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let sig1 : (BitVec 64) :=
    (((ROR (Sail.BitVec.extractLsb x 127 64) 19) ^^^ (ROR (Sail.BitVec.extractLsb x 127 64) 61)) ^^^ ((0b000000 : (BitVec 6)) ++ (Sail.BitVec.extractLsb
          x 127 70)))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 127 64
      (((Sail.BitVec.extractLsb w 127 64) + sig1) + (Sail.BitVec.extractLsb y 127 64)))
  let sig1 : (BitVec 64) :=
    (((ROR (Sail.BitVec.extractLsb x 63 0) 19) ^^^ (ROR (Sail.BitVec.extractLsb x 63 0) 61)) ^^^ ((0b000000 : (BitVec 6)) ++ (Sail.BitVec.extractLsb
          x 63 6)))
  let Vtmp : (BitVec 128) :=
    (Sail.BitVec.updateSubrange Vtmp 63 0
      (((Sail.BitVec.extractLsb w 63 0) + sig1) + (Sail.BitVec.extractLsb y 63 0)))
  (V_set d 128 Vtmp)

def decode_sha512su1_advsimd_aarch64_instrs_vector_crypto_sha512_sha512su1 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSHA512Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  (execute_aarch64_instrs_vector_crypto_sha512_sha512su1 d m n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let sum ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result, sum) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result, sum)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result, sum) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let sum : Int := (Int.shiftr (element1 +i element2) 1)
        let result ← (Elem_set result e esize (integer_subrange sum (esize -i 1) 0))
        (pure (element1, element2, result, sum))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec datasize) × Int) )
  (V_set d datasize result)

def decode_shadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating d datasize
    elements esize m n is_unsigned)

def decode_uhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_truncating d datasize
    elements esize m n is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Int, elements : Int, esize : Int, n : Nat, shift : Int, 0
  ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_left_sisd (d : Nat) (datasize : Int) (elements : Int) (esize : Int) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:44321.56-44321.57"
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        assert (esize ≥b 0) "src/instrs64.sail:44325.38-44325.39"
        assert (((e *i esize) ≤b (((e *i esize) +i esize) -i 1)) || ((! ((e ≥b 0) && (((e +i 1) *i esize) ≤b datasize))) || (! (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128))))) "src/instrs64.sail:44326.179-44326.180"
        (Elem_set result e esize ((← (Elem_read operand e esize)) <<< shift))
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_shl_advsimd_aarch64_instrs_vector_shift_left_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  (execute_aarch64_instrs_vector_shift_left_sisd d datasize elements esize n shift)

def decode_shl_advsimd_aarch64_instrs_vector_shift_left_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  (execute_aarch64_instrs_vector_shift_left_sisd d datasize elements esize n shift)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, n
  : Nat, part : Nat, shift : Nat, shift ∈ {8, 16, 32, 64} ∧
  part ∈ {0, 1} ∧
  0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_shift (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (part : Nat) (shift : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ←
          (pure (Int.shiftl (← (asl_Int (← (Elem_read operand e esize)) is_unsigned)) shift))
        let result ←
          (Elem_set result e (2 *i esize) (integer_subrange element ((2 *i esize) -i 1) 0))
        (pure (element, result))
    (pure loop_vars) ) : SailM (Int × (BitVec (2 * datasize))) )
  (V_set d (2 *i datasize) result)

def decode_shll_advsimd_aarch64_instrs_vector_arithmetic_unary_shift (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let shift := esize
  let is_unsigned : Bool := false
  (execute_aarch64_instrs_vector_arithmetic_unary_shift d datasize elements esize n part shift
    is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let diff ← (( do (undefined_int ()) ) : SailM Int )
  let (diff, element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (diff, element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (diff, element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let diff : Int := (Int.shiftr (element1 -i element2) 1)
        let result ← (Elem_set result e esize (integer_subrange diff (esize -i 1) 0))
        (pure (diff, element1, element2, result))
    (pure loop_vars) ) : SailM (Int × Int × Int × (BitVec datasize)) )
  (V_set d datasize result)

def decode_shsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int d datasize elements esize m n
    is_unsigned)

def decode_uhsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_int d datasize elements esize m n
    is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Int, elements : Int, esize : Int, n : Nat, shift : Int, 0
  ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_left_insert_sisd (d : Nat) (datasize : Int) (elements : Int) (esize : Int) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:44507.56-44507.57"
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  assert (esize ≥b 0) "src/instrs64.sail:44511.34-44511.35"
  let mask : (BitVec esize) := ((Ones (n := esize)) <<< shift)
  let shifted ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (result, shifted) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (result, shifted)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (result, shifted) := loop_vars
      loop_vars ← do
        assert (((e *i esize) ≤b (((e *i esize) +i esize) -i 1)) || ((! ((e ≥b 0) && (((e +i 1) *i esize) ≤b datasize))) || ((! (esize ≥b 0)) || (! (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)))))) "src/instrs64.sail:44515.198-44515.199"
        let shifted ← (pure ((← (Elem_read operand e esize)) <<< shift))
        let result ←
          (Elem_set result e esize
            (((← (Elem_read operand2 e esize)) &&& (Complement.complement mask)) ||| shifted))
        (pure (result, shifted))
    (pure loop_vars) ) : SailM ((BitVec datasize) × (BitVec esize)) )
  (V_set d datasize result)

def decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  (execute_aarch64_instrs_vector_shift_left_insert_sisd d datasize elements esize n shift)

def decode_sli_advsimd_aarch64_instrs_vector_shift_left_insert_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  (execute_aarch64_instrs_vector_shift_left_insert_sisd d datasize elements esize n shift)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sm3_sm3partw1 (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let Vd ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let result ←
    (pure (Sail.BitVec.updateSubrange result 95 0
        ((Sail.BitVec.extractLsb (Vd ^^^ Vn) 95 0) ^^^ (((← (ROL
                  (Sail.BitVec.extractLsb Vm 127 96) 15)) ++ (← (ROL
                  (Sail.BitVec.extractLsb Vm 95 64) 15))) ++ (← (ROL
                (Sail.BitVec.extractLsb Vm 63 32) 15))))))
  let result ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 3
    let mut loop_vars := result
    for i in [loop_i_lower:loop_i_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ← (( do
          bif (i == 3)
          then
            (do
              (pure (Sail.BitVec.updateSubrange result 127 96
                  ((Sail.BitVec.extractLsb (Vd ^^^ Vn) 127 96) ^^^ (← (ROL
                        (Sail.BitVec.extractLsb result 31 0) 15))))))
          else (pure result) ) : SailM (BitVec 128) )
        (pure (Sail.BitVec.updateSubrange result ((32 *i i) +i 31) (32 *i i)
            (((Sail.BitVec.extractLsb result ((32 *i i) +i 31) (32 *i i)) ^^^ (← (ROL
                    (Sail.BitVec.extractLsb result ((32 *i i) +i 31) (32 *i i)) 15))) ^^^ (← (ROL
                  (Sail.BitVec.extractLsb result ((32 *i i) +i 31) (32 *i i)) 23)))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_sm3partw1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw1 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSM3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  (execute_aarch64_instrs_vector_crypto_sm3_sm3partw1 d m n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sm3_sm3partw2 (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let Vd ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let tmp ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let tmp ←
    (pure (Sail.BitVec.updateSubrange tmp 127 0
        (Vn ^^^ ((((← (ROL (Sail.BitVec.extractLsb Vm 127 96) 7)) ++ (← (ROL
                    (Sail.BitVec.extractLsb Vm 95 64) 7))) ++ (← (ROL
                  (Sail.BitVec.extractLsb Vm 63 32) 7))) ++ (← (ROL
                (Sail.BitVec.extractLsb Vm 31 0) 7))))))
  let result : (BitVec 128) :=
    (Sail.BitVec.updateSubrange result 127 0
      ((Sail.BitVec.extractLsb Vd 127 0) ^^^ (Sail.BitVec.extractLsb tmp 127 0)))
  let tmp2 ← (( do (ROL (Sail.BitVec.extractLsb tmp 31 0) 15) ) : SailM (BitVec 32) )
  let tmp2 ← (( do (pure ((tmp2 ^^^ (← (ROL tmp2 15))) ^^^ (← (ROL tmp2 23)))) ) : SailM
    (BitVec 32) )
  let result : (BitVec 128) :=
    (Sail.BitVec.updateSubrange result 127 96 ((Sail.BitVec.extractLsb result 127 96) ^^^ tmp2))
  (V_set d 128 result)

def decode_sm3partw2_advsimd_aarch64_instrs_vector_crypto_sm3_sm3partw2 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSM3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  (execute_aarch64_instrs_vector_crypto_sm3_sm3partw2 d m n)

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sm3_sm3ss1 (a : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let Va ← (( do (V_read a 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let result ←
    (pure (Sail.BitVec.updateSubrange result 127 96
        (← (ROL
            (((← (ROL (Sail.BitVec.extractLsb Vn 127 96) 12)) + (Sail.BitVec.extractLsb Vm 127 96)) + (Sail.BitVec.extractLsb
                Va 127 96)) 7))))
  let result : (BitVec 128) := (Sail.BitVec.updateSubrange result 95 0 (Zeros (n := 96)))
  (V_set d 128 result)

def decode_sm3ss1_advsimd_aarch64_instrs_vector_crypto_sm3_sm3ss1 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSM3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  (execute_aarch64_instrs_vector_crypto_sm3_sm3ss1 a d m n)

/-- Type quantifiers: d : Nat, i : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ i ∈ {0, 1, 2, 3} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sm3_sm3tt1a (d : Nat) (i : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let Vd ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let WjPrime ← (( do (Elem_read Vm i 32) ) : SailM (BitVec 32) )
  let SS2 ← (( do
    (pure ((Sail.BitVec.extractLsb Vn 127 96) ^^^ (← (ROL (Sail.BitVec.extractLsb Vd 127 96) 12))))
    ) : SailM (BitVec 32) )
  let TT1 : (BitVec 32) :=
    ((Sail.BitVec.extractLsb Vd 63 32) ^^^ ((Sail.BitVec.extractLsb Vd 127 96) ^^^ (Sail.BitVec.extractLsb
          Vd 95 64)))
  let TT1 : (BitVec 32) :=
    (Sail.BitVec.extractLsb (((TT1 + (Sail.BitVec.extractLsb Vd 31 0)) + SS2) + WjPrime) 31 0)
  let result : (BitVec 128) :=
    (Sail.BitVec.updateSubrange result 31 0 (Sail.BitVec.extractLsb Vd 63 32))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 63 32 (← (ROL (Sail.BitVec.extractLsb Vd 95 64) 9))))
  let result : (BitVec 128) :=
    (Sail.BitVec.updateSubrange result 95 64 (Sail.BitVec.extractLsb Vd 127 96))
  let result : (BitVec 128) := (Sail.BitVec.updateSubrange result 127 96 TT1)
  (V_set d 128 result)

def decode_sm3tt1a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1a (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm2 : (BitVec 2)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSM3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let i := (BitVec.toNat imm2)
  (execute_aarch64_instrs_vector_crypto_sm3_sm3tt1a d i m n)

/-- Type quantifiers: d : Nat, i : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ i ∈ {0, 1, 2, 3} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sm3_sm3tt1b (d : Nat) (i : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let Vd ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let WjPrime ← (( do (Elem_read Vm i 32) ) : SailM (BitVec 32) )
  let SS2 ← (( do
    (pure ((Sail.BitVec.extractLsb Vn 127 96) ^^^ (← (ROL (Sail.BitVec.extractLsb Vd 127 96) 12))))
    ) : SailM (BitVec 32) )
  let TT1 : (BitVec 32) :=
    ((((Sail.BitVec.extractLsb Vd 127 96) &&& (Sail.BitVec.extractLsb Vd 63 32)) ||| ((Sail.BitVec.extractLsb
            Vd 127 96) &&& (Sail.BitVec.extractLsb Vd 95 64))) ||| ((Sail.BitVec.extractLsb Vd 63 32) &&& (Sail.BitVec.extractLsb
          Vd 95 64)))
  let TT1 : (BitVec 32) :=
    (Sail.BitVec.extractLsb (((TT1 + (Sail.BitVec.extractLsb Vd 31 0)) + SS2) + WjPrime) 31 0)
  let result : (BitVec 128) :=
    (Sail.BitVec.updateSubrange result 31 0 (Sail.BitVec.extractLsb Vd 63 32))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 63 32 (← (ROL (Sail.BitVec.extractLsb Vd 95 64) 9))))
  let result : (BitVec 128) :=
    (Sail.BitVec.updateSubrange result 95 64 (Sail.BitVec.extractLsb Vd 127 96))
  let result : (BitVec 128) := (Sail.BitVec.updateSubrange result 127 96 TT1)
  (V_set d 128 result)

def decode_sm3tt1b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt1b (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm2 : (BitVec 2)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSM3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let i := (BitVec.toNat imm2)
  (execute_aarch64_instrs_vector_crypto_sm3_sm3tt1b d i m n)

/-- Type quantifiers: d : Nat, i : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ i ∈ {0, 1, 2, 3} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sm3_sm3tt2a (d : Nat) (i : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let Vd ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let Wj ← (( do (Elem_read Vm i 32) ) : SailM (BitVec 32) )
  let TT2 : (BitVec 32) :=
    ((Sail.BitVec.extractLsb Vd 63 32) ^^^ ((Sail.BitVec.extractLsb Vd 127 96) ^^^ (Sail.BitVec.extractLsb
          Vd 95 64)))
  let TT2 : (BitVec 32) :=
    (Sail.BitVec.extractLsb
      (((TT2 + (Sail.BitVec.extractLsb Vd 31 0)) + (Sail.BitVec.extractLsb Vn 127 96)) + Wj) 31 0)
  let result : (BitVec 128) :=
    (Sail.BitVec.updateSubrange result 31 0 (Sail.BitVec.extractLsb Vd 63 32))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 63 32 (← (ROL (Sail.BitVec.extractLsb Vd 95 64) 19))))
  let result : (BitVec 128) :=
    (Sail.BitVec.updateSubrange result 95 64 (Sail.BitVec.extractLsb Vd 127 96))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 127 96
        ((TT2 ^^^ (← (ROL TT2 9))) ^^^ (← (ROL TT2 17)))))
  (V_set d 128 result)

def decode_sm3tt2a_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2a (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm2 : (BitVec 2)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSM3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let i := (BitVec.toNat imm2)
  (execute_aarch64_instrs_vector_crypto_sm3_sm3tt2a d i m n)

/-- Type quantifiers: d : Nat, i : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ i ∈ {0, 1, 2, 3} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sm3_sm3tt2b (d : Nat) (i : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let Vd ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let Wj ← (( do (Elem_read Vm i 32) ) : SailM (BitVec 32) )
  let TT2 : (BitVec 32) :=
    (((Sail.BitVec.extractLsb Vd 127 96) &&& (Sail.BitVec.extractLsb Vd 95 64)) ||| ((Complement.complement
          (Sail.BitVec.extractLsb Vd 127 96)) &&& (Sail.BitVec.extractLsb Vd 63 32)))
  let TT2 : (BitVec 32) :=
    (Sail.BitVec.extractLsb
      (((TT2 + (Sail.BitVec.extractLsb Vd 31 0)) + (Sail.BitVec.extractLsb Vn 127 96)) + Wj) 31 0)
  let result : (BitVec 128) :=
    (Sail.BitVec.updateSubrange result 31 0 (Sail.BitVec.extractLsb Vd 63 32))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 63 32 (← (ROL (Sail.BitVec.extractLsb Vd 95 64) 19))))
  let result : (BitVec 128) :=
    (Sail.BitVec.updateSubrange result 95 64 (Sail.BitVec.extractLsb Vd 127 96))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 127 96
        ((TT2 ^^^ (← (ROL TT2 9))) ^^^ (← (ROL TT2 17)))))
  (V_set d 128 result)

def decode_sm3tt2b_advsimd_aarch64_instrs_vector_crypto_sm3_sm3tt2b (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm2 : (BitVec 2)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSM3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let i := (BitVec.toNat imm2)
  (execute_aarch64_instrs_vector_crypto_sm3_sm3tt2b d i m n)

/-- Type quantifiers: d : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sm4_sm4enc (d : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let intval ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let roundkey ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let roundresult ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  let (intval, roundkey, roundresult) ← (( do
    let loop_index_lower := 0
    let loop_index_upper := 3
    let mut loop_vars := (intval, roundkey, roundresult)
    for index in [loop_index_lower:loop_index_upper:1]i do
      let (intval, roundkey, roundresult) := loop_vars
      loop_vars ← do
        let roundkey ← (Elem_read Vn index 32)
        let intval : (BitVec 32) :=
          ((((Sail.BitVec.extractLsb roundresult 127 96) ^^^ (Sail.BitVec.extractLsb roundresult 95
                  64)) ^^^ (Sail.BitVec.extractLsb roundresult 63 32)) ^^^ roundkey)
        let intval ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := intval
          for i in [loop_i_lower:loop_i_upper:1]i do
            let intval := loop_vars_1
            loop_vars_1 ← do (Elem_set intval i 8 (Sbox (← (Elem_read intval i 8))))
          (pure loop_vars_1) ) : SailM (BitVec 32) )
        let intval ←
          (pure ((((intval ^^^ (← (ROL intval 2))) ^^^ (← (ROL intval 10))) ^^^ (← (ROL intval
                    18))) ^^^ (← (ROL intval 24))))
        let intval : (BitVec 32) := (intval ^^^ (Sail.BitVec.extractLsb roundresult 31 0))
        let roundresult : (BitVec 128) :=
          (Sail.BitVec.updateSubrange roundresult 31 0 (Sail.BitVec.extractLsb roundresult 63 32))
        let roundresult : (BitVec 128) :=
          (Sail.BitVec.updateSubrange roundresult 63 32 (Sail.BitVec.extractLsb roundresult 95 64))
        let roundresult : (BitVec 128) :=
          (Sail.BitVec.updateSubrange roundresult 95 64 (Sail.BitVec.extractLsb roundresult 127 96))
        let roundresult : (BitVec 128) := (Sail.BitVec.updateSubrange roundresult 127 96 intval)
        (pure (intval, roundkey, roundresult))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 32) × (BitVec 128)) )
  (V_set d 128 roundresult)

def decode_sm4e_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enc (Rd : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSM4Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  (execute_aarch64_instrs_vector_crypto_sm4_sm4enc d n)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sm4_sm4enckey (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let intval ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let const ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let roundresult ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let (const, intval, roundresult) ← (( do
    let loop_index_lower := 0
    let loop_index_upper := 3
    let mut loop_vars := (const, intval, roundresult)
    for index in [loop_index_lower:loop_index_upper:1]i do
      let (const, intval, roundresult) := loop_vars
      loop_vars ← do
        let const ← (Elem_read Vm index 32)
        let intval : (BitVec 32) :=
          ((((Sail.BitVec.extractLsb roundresult 127 96) ^^^ (Sail.BitVec.extractLsb roundresult 95
                  64)) ^^^ (Sail.BitVec.extractLsb roundresult 63 32)) ^^^ const)
        let intval ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := intval
          for i in [loop_i_lower:loop_i_upper:1]i do
            let intval := loop_vars_1
            loop_vars_1 ← do (Elem_set intval i 8 (Sbox (← (Elem_read intval i 8))))
          (pure loop_vars_1) ) : SailM (BitVec 32) )
        let intval ← (pure ((intval ^^^ (← (ROL intval 13))) ^^^ (← (ROL intval 23))))
        let intval : (BitVec 32) := (intval ^^^ (Sail.BitVec.extractLsb roundresult 31 0))
        let roundresult : (BitVec 128) :=
          (Sail.BitVec.updateSubrange roundresult 31 0 (Sail.BitVec.extractLsb roundresult 63 32))
        let roundresult : (BitVec 128) :=
          (Sail.BitVec.updateSubrange roundresult 63 32 (Sail.BitVec.extractLsb roundresult 95 64))
        let roundresult : (BitVec 128) :=
          (Sail.BitVec.updateSubrange roundresult 95 64 (Sail.BitVec.extractLsb roundresult 127 96))
        let roundresult : (BitVec 128) := (Sail.BitVec.updateSubrange roundresult 127 96 intval)
        (pure (const, intval, roundresult))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 32) × (BitVec 128)) )
  (V_set d 128 roundresult)

def decode_sm4ekey_advsimd_aarch64_instrs_vector_crypto_sm4_sm4enckey (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSM4Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  (execute_aarch64_instrs_vector_crypto_sm4_sm4enckey d m n)

/-- Type quantifiers: a : Nat, d : Nat, datasize : Nat, destsize : Nat, k_is_unsigned : Bool, m :
  Nat, n : Nat, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ destsize = 64 ∧ datasize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (a : Nat) (d : Nat) (datasize : Nat) (destsize : Nat) (m : Nat) (n : Nat) (sub_op : Bool) (is_unsigned : Bool) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (X_read a destsize) ) : SailM (BitVec destsize) )
  let result ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do
    bif sub_op
    then
      (do
        (pure ((← (asl_Int operand3 is_unsigned)) -i ((← (asl_Int operand1 is_unsigned)) *i (← (asl_Int
                  operand2 is_unsigned))))))
    else
      (do
        (pure ((← (asl_Int operand3 is_unsigned)) +i ((← (asl_Int operand1 is_unsigned)) *i (← (asl_Int
                  operand2 is_unsigned)))))) ) : SailM Int )
  let result := result
  (X_set d 64 (integer_subrange result 63 0))

def decode_smaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (o0 : (BitVec 1)) (Rm : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  let destsize := 64
  let datasize := 32
  let sub_op : Bool := (o0 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64 a d datasize destsize m n sub_op
    is_unsigned)

def decode_smsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (o0 : (BitVec 1)) (Rm : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  let destsize := 64
  let datasize := 32
  let sub_op : Bool := (o0 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64 a d datasize destsize m n sub_op
    is_unsigned)

def decode_umaddl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (o0 : (BitVec 1)) (Rm : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  let destsize := 64
  let datasize := 32
  let sub_op : Bool := (o0 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64 a d datasize destsize m n sub_op
    is_unsigned)

def decode_umsubl_aarch64_instrs_integer_arithmetic_mul_widening_32_64 (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (o0 : (BitVec 1)) (Rm : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  let destsize := 64
  let datasize := 32
  let sub_op : Bool := (o0 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_mul_widening_32_64 a d datasize destsize m n sub_op
    is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, imm : Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_max_min_smax_imm (d : Nat) (datasize : Nat) (imm : Int) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let result := (Max.max (BitVec.toInt operand1) imm)
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_smax_imm_aarch64_instrs_integer_arithmetic_max_min_smax_imm (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm8 : (BitVec 8)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  let imm := (BitVec.toInt imm8)
  (execute_aarch64_instrs_integer_arithmetic_max_min_smax_imm d datasize imm n)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_max_min_smax_reg (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let result := (Max.max (BitVec.toInt operand1) (BitVec.toInt operand2))
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_smax_reg_aarch64_instrs_integer_arithmetic_max_min_smax_reg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_integer_arithmetic_max_min_smax_reg d datasize m n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, k_minimum : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (minimum : Bool) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let maxmin ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, maxmin, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, maxmin, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, maxmin, result) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let maxmin : Int :=
          bif minimum
          then (Min.min element1 element2)
          else (Max.max element1 element2)
        let result ← (Elem_set result e esize (integer_subrange maxmin (esize -i 1) 0))
        (pure (element1, element2, maxmin, result))
    (pure loop_vars) ) : SailM (Int × Int × Int × (BitVec datasize)) )
  (V_set d datasize result)

def decode_smax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single d datasize elements esize
    m minimum n is_unsigned)

def decode_smin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single d datasize elements esize
    m minimum n is_unsigned)

def decode_umax_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single d datasize elements esize
    m minimum n is_unsigned)

def decode_umin_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_single d datasize elements esize
    m minimum n is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, k_minimum : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (minimum : Bool) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let concat : (BitVec (2 * datasize)) := (operand2 ++ operand1)
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let maxmin ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, maxmin, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, maxmin, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, maxmin, result) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read concat (2 *i e) esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read concat ((2 *i e) +i 1) esize)) is_unsigned)
        let maxmin : Int :=
          bif minimum
          then (Min.min element1 element2)
          else (Max.max element1 element2)
        let result ← (Elem_set result e esize (integer_subrange maxmin (esize -i 1) 0))
        (pure (element1, element2, maxmin, result))
    (pure loop_vars) ) : SailM (Int × Int × Int × (BitVec datasize)) )
  (V_set d datasize result)

def decode_smaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair d datasize elements esize m
    minimum n is_unsigned)

def decode_sminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair d datasize elements esize m
    minimum n is_unsigned)

def decode_umaxp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair d datasize elements esize m
    minimum n is_unsigned)

def decode_uminp_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let minimum : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_max_min_pair d datasize elements esize m
    minimum n is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, k_min
  : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_reduce_int_max (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (min : Bool) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let maxmin ← (( do (asl_Int (← (Elem_read operand 0 esize)) is_unsigned) ) : SailM Int )
  let (element, maxmin) ← (( do
    let loop_e_lower := 1
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, maxmin)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, maxmin) := loop_vars
      loop_vars ← do
        let element ← (asl_Int (← (Elem_read operand e esize)) is_unsigned)
        let maxmin : Int :=
          bif min
          then (Min.min maxmin element)
          else (Max.max maxmin element)
        (pure (element, maxmin))
    (pure loop_vars) ) : SailM (Int × Int) )
  let maxmin := maxmin
  (V_set d esize (integer_subrange maxmin (esize -i 1) 0))

def decode_smaxv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b100 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let min : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_reduce_int_max d datasize elements esize min n is_unsigned)

def decode_sminv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b100 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let min : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_reduce_int_max d datasize elements esize min n is_unsigned)

def decode_umaxv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b100 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let min : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_reduce_int_max d datasize elements esize min n is_unsigned)

def decode_uminv_advsimd_aarch64_instrs_vector_reduce_int_max (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b100 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let min : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_reduce_int_max d datasize elements esize min n is_unsigned)

def execute_aarch64_instrs_system_exceptions_runtime_smc (imm : (BitVec 16)) : SailM Unit := do
  (AArch64_CheckForSMCUndefOrTrap imm)
  (AArch64_CallSecureMonitor imm)

def decode_smc_aarch64_instrs_system_exceptions_runtime_smc (imm16 : (BitVec 16)) : SailM Unit := do
  let imm : (BitVec 16) := imm16
  (execute_aarch64_instrs_system_exceptions_runtime_smc imm)

/-- Type quantifiers: d : Nat, datasize : Nat, imm : Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_max_min_smin_imm (d : Nat) (datasize : Nat) (imm : Int) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let result := (Min.min (BitVec.toInt operand1) imm)
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_smin_imm_aarch64_instrs_integer_arithmetic_max_min_smin_imm (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm8 : (BitVec 8)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  let imm := (BitVec.toInt imm8)
  (execute_aarch64_instrs_integer_arithmetic_max_min_smin_imm d datasize imm n)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_max_min_smin_reg (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let result := (Min.min (BitVec.toInt operand1) (BitVec.toInt operand2))
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_smin_reg_aarch64_instrs_integer_arithmetic_max_min_smin_reg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_integer_arithmetic_max_min_smin_reg d datasize m n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, part : Nat, k_sub_op : Bool, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) (sub_op : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (Vpart_read m part datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (V_read d (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let accum ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let (accum, element1, element2, product, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accum, element1, element2, product, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accum, element1, element2, product, result) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        let accum ← (( do
          bif sub_op
          then
            (do
              (pure ((← (Elem_read operand3 e (2 *i esize))) - product)))
          else
            (do
              (pure ((← (Elem_read operand3 e (2 *i esize))) + product))) ) : SailM
          (BitVec (2 * esize)) )
        let result ← (Elem_set result e (2 *i esize) accum)
        (pure (accum, element1, element2, product, result))
    (pure loop_vars) ) : SailM
    ((BitVec (2 * esize)) × Int × Int × (BitVec (2 * esize)) × (BitVec (2 * datasize))) )
  (V_set d (2 *i datasize) result)

def decode_smlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum d datasize elements esize m n
    part sub_op is_unsigned)

def decode_smlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum d datasize elements esize m n
    part sub_op is_unsigned)

def decode_umlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum d datasize elements esize m n
    part sub_op is_unsigned)

def decode_umlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_accum d datasize elements esize m n
    part sub_op is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Nat, k_is_unsigned : Bool, m : Nat, n : Nat, part : Nat, k_sub_op : Bool, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  idxdsize ∈ {64, 128} ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Nat) (m : Nat) (n : Nat) (part : Nat) (sub_op : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m idxdsize) ) : SailM (BitVec idxdsize) )
  let operand3 ← (( do (V_read d (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let element2 ← do (asl_Int (← (Elem_read operand2 index esize)) is_unsigned)
  let (element1, product, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, product, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, product, result) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        let result ← (( do
          bif sub_op
          then
            (do
              (Elem_set result e (2 *i esize) ((← (Elem_read operand3 e (2 *i esize))) - product)))
          else
            (do
              (Elem_set result e (2 *i esize) ((← (Elem_read operand3 e (2 *i esize))) + product)))
          ) : SailM (BitVec (2 * datasize)) )
        (pure (element1, product, result))
    (pure loop_vars) ) : SailM (Int × (BitVec (2 * esize)) × (BitVec (2 * datasize))) )
  (V_set d (2 *i datasize) result)

def decode_smlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long d datasize elements esize
    idxdsize index m n part sub_op is_unsigned)

def decode_smlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long d datasize elements esize
    idxdsize index m n part sub_op is_unsigned)

def decode_umlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long d datasize elements esize
    idxdsize index m n part sub_op is_unsigned)

def decode_umlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_long d datasize elements esize
    idxdsize index m n part sub_op is_unsigned)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, 0 ≤
  n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla (d : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let operand2 ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let addend ← (( do (V_read d 128) ) : SailM (BitVec 128) )
  (V_set d 128 (← (MatMulAdd addend operand1 operand2 op1_unsigned op2_unsigned)))

def decode_smmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla (Rd : (BitVec 5)) (Rn : (BitVec 5)) (B : (BitVec 1)) (Rm : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveInt8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let op1_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let op2_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (B ++ U)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let op1_unsigned : Bool := false
    let op2_unsigned : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op1_unsigned : Bool := true
        let op2_unsigned : Bool := true
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let op1_unsigned : Bool := true
            let op2_unsigned : Bool := false
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let op2_unsigned := op2_unsigned
  let op1_unsigned := op1_unsigned
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla d m n op1_unsigned
    op2_unsigned)

def decode_ummla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla (Rd : (BitVec 5)) (Rn : (BitVec 5)) (B : (BitVec 1)) (Rm : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveInt8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let op1_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let op2_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (B ++ U)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let op1_unsigned : Bool := false
    let op2_unsigned : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op1_unsigned : Bool := true
        let op2_unsigned : Bool := true
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let op1_unsigned : Bool := true
            let op2_unsigned : Bool := false
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let op2_unsigned := op2_unsigned
  let op1_unsigned := op1_unsigned
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla d m n op1_unsigned
    op2_unsigned)

def decode_usmmla_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla (Rd : (BitVec 5)) (Rn : (BitVec 5)) (B : (BitVec 1)) (Rm : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveInt8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let op1_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let op2_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (B ++ U)
  bif (b__0 == (0b00 : (BitVec 2)))
  then
    (let op1_unsigned : Bool := false
    let op2_unsigned : Bool := false
    (pure ()))
  else
    (do
      bif (b__0 == (0b01 : (BitVec 2)))
      then
        (let op1_unsigned : Bool := true
        let op2_unsigned : Bool := true
        (pure ()))
      else
        (do
          bif (b__0 == (0b10 : (BitVec 2)))
          then
            (let op1_unsigned : Bool := true
            let op2_unsigned : Bool := false
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let op2_unsigned := op2_unsigned
  let op1_unsigned := op1_unsigned
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_mla d m n op1_unsigned
    op2_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, idxdsize : Nat, index : Int, n : Nat, 0
  ≤ n ∧
  n ≤ 31 ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {8, 16, 32} ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_integer_move_signed (d : Nat) (datasize : Nat) (esize : Nat) (idxdsize : Nat) (index : Int) (n : Nat) : SailM Unit := do
  bif (index == 0)
  then (CheckFPEnabled64 ())
  else (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n idxdsize) ) : SailM (BitVec idxdsize) )
  (X_set d datasize (sign_extend (← (Elem_read operand index esize)) datasize))

def decode_smov_advsimd_aarch64_instrs_vector_transfer_integer_move_signed (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm5 : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let size : Int := 0
  let b__0 := (Q ++ imm5)
  bif ((Sail.BitVec.extractLsb b__0 0 0) == (0b1 : (BitVec 1)))
  then
    (let size : Int := 0
    (pure ()))
  else
    (do
      bif ((Sail.BitVec.extractLsb b__0 1 0) == (0b10 : (BitVec 2)))
      then
        (let size : Int := 1
        (pure ()))
      else
        (do
          bif (((Sail.BitVec.extractLsb b__0 5 5) == (0b1 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                   b__0 2 0) == (0b100 : (BitVec 3))))
          then
            (let size : Int := 2
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let size := size
  let idxdsize :=
    bif ((BitVec.join1 [(BitVec.access imm5 4)]) == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index := (BitVec.toNat (Sail.BitVec.extractLsb imm5 4 (size +i 1)))
  let esize := (Int.shiftl 8 size)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 64
    else 32
  assert (((esize == 8) || (esize == 16)) || (esize == 32)) "src/instrs64.sail:46177.44-46177.45"
  (execute_aarch64_instrs_vector_transfer_integer_move_signed d datasize esize idxdsize index n)

/-- Type quantifiers: d : Nat, datasize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let result ← do
    (pure ((← (asl_Int operand1 is_unsigned)) *i (← (asl_Int operand2 is_unsigned))))
  (X_set d 64 (integer_subrange result 127 64))

def decode_smulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (Rm : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  let destsize := 64
  let datasize := destsize
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi d datasize m n is_unsigned)

def decode_umulh_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Ra : (BitVec 5)) (Rm : (BitVec 5)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let a := (BitVec.toNat Ra)
  let destsize := 64
  let datasize := destsize
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_integer_arithmetic_mul_widening_64_128hi d datasize m n is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, part : Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (Vpart_read m part datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let result ←
          (Elem_set result e (2 *i esize)
            (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0))
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec (2 * datasize))) )
  (V_set d (2 *i datasize) result)

def decode_smull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product d datasize elements esize m
    n part is_unsigned)

def decode_umull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_product d datasize elements esize m
    n part is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Nat, k_is_unsigned : Bool, m : Nat, n : Nat, part : Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  idxdsize ∈ {64, 128} ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Nat) (m : Nat) (n : Nat) (part : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m idxdsize) ) : SailM (BitVec idxdsize) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let element2 ← do (asl_Int (← (Elem_read operand2 index esize)) is_unsigned)
  let (element1, product, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, product, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, product, result) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        let result ← (Elem_set result e (2 *i esize) product)
        (pure (element1, product, result))
    (pure loop_vars) ) : SailM (Int × (BitVec (2 * esize)) × (BitVec (2 * datasize))) )
  (V_set d (2 *i datasize) result)

def decode_smull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long d datasize elements esize
    idxdsize index m n part is_unsigned)

def decode_umull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_long d datasize elements esize
    idxdsize index m n part is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, k_neg : Bool, 0
  ≤ n ∧
  n ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (neg : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, sat) := loop_vars
      loop_vars ← do
        let element ← (pure (BitVec.toInt (← (Elem_read operand e esize))))
        let element : Int :=
          bif neg
          then (Neg.neg element)
          else (Int.natAbs element)
        let (__tup_0, __tup_1) ← do (SignedSatQ element esize)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element, result, sat))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd d datasize elements esize n neg)

def decode_sqabs_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd d datasize elements esize n neg)

def decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd d datasize elements esize n neg)

def decode_sqneg_advsimd_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let neg : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_diff_neg_sat_sisd d datasize elements esize n neg)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let sum ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element1, element2, result, sat, sum) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result, sat, sum)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result, sat, sum) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let sum : Int := (element1 +i element2)
        let (__tup_0, __tup_1) ← do (SatQ sum esize is_unsigned)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element1, element2, result, sat, sum))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec datasize) × Bool × Int) )
  (V_set d datasize result)

def decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd d datasize elements
    esize m n is_unsigned)

def decode_sqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd d datasize elements
    esize m n is_unsigned)

def decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd d datasize elements
    esize m n is_unsigned)

def decode_uqadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_saturating_sisd d datasize elements
    esize m n is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Nat, m : Nat, n : Nat, part : Nat, k_sub_op : Bool, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Nat) (m : Nat) (n : Nat) (part : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m idxdsize) ) : SailM (BitVec idxdsize) )
  let operand3 ← (( do (V_read d (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let accum ← (( do (undefined_int ()) ) : SailM Int )
  let sat1 ← (( do (undefined_bool ()) ) : SailM Bool )
  let sat2 ← (( do (undefined_bool ()) ) : SailM Bool )
  let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 index esize))))
  let (accum, element1, product, result, sat1, sat2) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accum, element1, product, result, sat1, sat2)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accum, element1, product, result, sat1, sat2) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let (tup__0, tup__1) ← do (SignedSatQ ((2 *i element1) *i element2) (2 *i esize))
        let product : (BitVec (2 * esize)) := tup__0
        let sat1 : Bool := tup__1
        (pure ())
        let accum ← (( do
          bif sub_op
          then
            (do
              (pure ((BitVec.toInt (← (Elem_read operand3 e (2 *i esize)))) -i (BitVec.toInt
                    product))))
          else
            (do
              (pure ((BitVec.toInt (← (Elem_read operand3 e (2 *i esize)))) +i (BitVec.toInt
                    product)))) ) : SailM Int )
        let (__tup_0, __tup_1) ← do (SignedSatQ accum (2 *i esize))
        let result ← (Elem_set result e (2 *i esize) __tup_0)
        let sat2 : Bool := __tup_1
        (pure ())
        bif (sat1 || sat2)
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (accum, element1, product, result, sat1, sat2))
    (pure loop_vars) ) : SailM
    (Int × Int × (BitVec (2 * esize)) × (BitVec (2 * datasize)) × Bool × Bool) )
  (V_set d (2 *i datasize) result)

def decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let part := 0
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd d datasize elements
    esize idxdsize index m n part sub_op)

def decode_sqdmlal_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd d datasize elements
    esize idxdsize index m n part sub_op)

def decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let part := 0
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd d datasize elements
    esize idxdsize index m n part sub_op)

def decode_sqdmlsl_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (o2 : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o2 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_double_sisd d datasize elements
    esize idxdsize index m n part sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, part :
  Nat, k_sub_op : Bool, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (Vpart_read m part datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (V_read d (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let accum ← (( do (undefined_int ()) ) : SailM Int )
  let sat1 ← (( do (undefined_bool ()) ) : SailM Bool )
  let sat2 ← (( do (undefined_bool ()) ) : SailM Bool )
  let (accum, element1, element2, product, result, sat1, sat2) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accum, element1, element2, product, result, sat1, sat2)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accum, element1, element2, product, result, sat1, sat2) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        let (tup__0, tup__1) ← do (SignedSatQ ((2 *i element1) *i element2) (2 *i esize))
        let product : (BitVec (2 * esize)) := tup__0
        let sat1 : Bool := tup__1
        (pure ())
        let accum ← (( do
          bif sub_op
          then
            (do
              (pure ((BitVec.toInt (← (Elem_read operand3 e (2 *i esize)))) -i (BitVec.toInt
                    product))))
          else
            (do
              (pure ((BitVec.toInt (← (Elem_read operand3 e (2 *i esize)))) +i (BitVec.toInt
                    product)))) ) : SailM Int )
        let (__tup_0, __tup_1) ← do (SignedSatQ accum (2 *i esize))
        let result ← (Elem_set result e (2 *i esize) __tup_0)
        let sat2 : Bool := __tup_1
        (pure ())
        bif (sat1 || sat2)
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (accum, element1, element2, product, result, sat1, sat2))
    (pure loop_vars) ) : SailM
    (Int × Int × Int × (BitVec (2 * esize)) × (BitVec (2 * datasize)) × Bool × Bool) )
  (V_set d (2 *i datasize) result)

def decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b00 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let part := 0
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd d datasize elements
    esize m n part sub_op)

def decode_sqdmlal_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b00 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd d datasize elements
    esize m n part sub_op)

def decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b00 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let part := 0
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd d datasize elements
    esize m n part sub_op)

def decode_sqdmlsl_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o1 : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b00 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let sub_op : Bool := (o1 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_dmacc_sisd d datasize elements
    esize m n part sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, k_rounding
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (rounding : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element1, element2, product, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, product, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, product, result, sat) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        let product : Int := ((2 *i element1) *i element2)
        let product ← (RShr product esize rounding)
        let (__tup_0, __tup_1) ← do (SignedSatQ product esize)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element1, element2, product, result, sat))
    (pure loop_vars) ) : SailM (Int × Int × Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b11 : (BitVec 2))) || (size == (0b00 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let rounding : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd d datasize elements
    esize m n rounding)

def decode_sqdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b11 : (BitVec 2))) || (size == (0b00 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd d datasize elements
    esize m n rounding)

def decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b11 : (BitVec 2))) || (size == (0b00 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let rounding : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd d datasize elements
    esize m n rounding)

def decode_sqrdmulh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b11 : (BitVec 2))) || (size == (0b00 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_sisd d datasize elements
    esize m n rounding)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Nat, m : Nat, n : Nat, k_round : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Nat) (m : Nat) (n : Nat) (round : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m idxdsize) ) : SailM (BitVec idxdsize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 index esize))))
  let (element1, product, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, product, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, product, result, sat) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let product : Int := ((2 *i element1) *i element2)
        let product ← (RShr product esize round)
        let (__tup_0, __tup_1) ← do (SignedSatQ product esize)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element1, product, result, sat))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (op : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let round : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd d datasize elements esize
    idxdsize index m n round)

def decode_sqdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (op : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let round : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd d datasize elements esize
    idxdsize index m n round)

def decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (op : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let round : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd d datasize elements esize
    idxdsize index m n round)

def decode_sqrdmulh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_high_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (op : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let round : Bool := (op == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_high_sisd d datasize elements esize
    idxdsize index m n round)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, part :
  Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (Vpart_read m part datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element1, element2, product, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, product, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, product, result, sat) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        let (tup__0, tup__1) ← do (SignedSatQ ((2 *i element1) *i element2) (2 *i esize))
        let product : (BitVec (2 * esize)) := tup__0
        let sat : Bool := tup__1
        (pure ())
        let result ← (Elem_set result e (2 *i esize) product)
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element1, element2, product, result, sat))
    (pure loop_vars) ) : SailM
    (Int × Int × (BitVec (2 * esize)) × (BitVec (2 * datasize)) × Bool) )
  (V_set d (2 *i datasize) result)

def decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b00 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let part := 0
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd d datasize elements
    esize m n part)

def decode_sqdmull_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b00 : (BitVec 2))) || (size == (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_disparate_mul_double_sisd d datasize elements
    esize m n part)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Nat, m : Nat, n : Nat, part : Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m idxdsize) ) : SailM (BitVec idxdsize) )
  let result ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 index esize))))
  let (element1, product, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, product, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, product, result, sat) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let (tup__0, tup__1) ← do (SignedSatQ ((2 *i element1) *i element2) (2 *i esize))
        let product : (BitVec (2 * esize)) := tup__0
        let sat : Bool := tup__1
        (pure ())
        let result ← (Elem_set result e (2 *i esize) product)
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element1, product, result, sat))
    (pure loop_vars) ) : SailM (Int × (BitVec (2 * esize)) × (BitVec (2 * datasize)) × Bool) )
  (V_set d (2 *i datasize) result)

def decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let part := 0
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd d datasize elements esize
    idxdsize index m n part)

def decode_sqdmull_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_double_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_double_sisd d datasize elements esize
    idxdsize index m n part)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, k_rounding
  : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (rounding : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let element3 ← (( do (undefined_int ()) ) : SailM Int )
  let accum ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (accum, element1, element2, element3, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accum, element1, element2, element3, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accum, element1, element2, element3, result, sat) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        let element3 ← (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let accum : Int :=
          bif sub_op
          then ((Int.shiftl element3 esize) -i (2 *i (element1 *i element2)))
          else ((Int.shiftl element3 esize) +i (2 *i (element1 *i element2)))
        let accum ← (RShr accum esize rounding)
        let (__tup_0, __tup_1) ← do (SignedSatQ accum esize)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (accum, element1, element2, element3, result, sat))
    (pure loop_vars) ) : SailM (Int × Int × Int × Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b11 : (BitVec 2))) || (size == (0b00 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let rounding : Bool := true
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd d datasize
    elements esize m n rounding sub_op)

def decode_sqrdmlah_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b11 : (BitVec 2))) || (size == (0b00 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding : Bool := true
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd d datasize
    elements esize m n rounding sub_op)

def decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b11 : (BitVec 2))) || (size == (0b00 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let rounding : Bool := true
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd d datasize
    elements esize m n rounding sub_op)

def decode_sqrdmlsh_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size == (0b11 : (BitVec 2))) || (size == (0b00 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding : Bool := true
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mul_int_doubling_accum_sisd d datasize
    elements esize m n rounding sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, idxdsize : Nat, index :
  Nat, m : Nat, n : Nat, k_rounding : Bool, k_sub_op : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (idxdsize : Nat) (index : Nat) (m : Nat) (n : Nat) (rounding : Bool) (sub_op : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m idxdsize) ) : SailM (BitVec idxdsize) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element3 ← (( do (undefined_int ()) ) : SailM Int )
  let accum ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 index esize))))
  let (accum, element1, element3, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accum, element1, element3, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accum, element1, element3, result, sat) := loop_vars
      loop_vars ← do
        let element1 ← (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element3 ← (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let accum : Int :=
          bif sub_op
          then ((Int.shiftl element3 esize) -i (2 *i (element1 *i element2)))
          else ((Int.shiftl element3 esize) +i (2 *i (element1 *i element2)))
        let accum ← (RShr accum esize rounding)
        let (__tup_0, __tup_1) ← do (SignedSatQ accum esize)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (accum, element1, element3, result, sat))
    (pure loop_vars) ) : SailM (Int × Int × Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (S : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let rounding : Bool := true
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd d datasize elements
    esize idxdsize index m n rounding sub_op)

def decode_sqrdmlah_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (S : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding : Bool := true
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd d datasize elements
    esize idxdsize index m n rounding sub_op)

def decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (S : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let rounding : Bool := true
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd d datasize elements
    esize idxdsize index m n rounding sub_op)

def decode_sqrdmlsh_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (S : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let idxdsize :=
    bif (H == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index ← (( do (undefined_range 0 7) ) : SailM Nat )
  let Rmhi ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let b__0 := size
  bif (b__0 == (0b01 : (BitVec 2)))
  then
    (let index : Nat := (BitVec.toNat ((H ++ L) ++ M))
    let Rmhi : (BitVec 1) := (0b0 : (BitVec 1))
    (pure ()))
  else
    (do
      bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let index : Nat := (BitVec.toNat (H ++ L))
        let Rmhi : (BitVec 1) := M
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let Rmhi := Rmhi
  let index := index
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (Rmhi ++ Rm))
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let rounding : Bool := true
  let sub_op : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mul_acc_high_sisd d datasize elements
    esize idxdsize index m n rounding sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, k_rounding : Bool, k_saturating : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (rounding : Bool) (saturating : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (result, sat) := loop_vars
      loop_vars ← do
        let element ← (( do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned) ) : SailM Int
          )
        let shift ← (( do
          (pure (BitVec.toInt (Sail.BitVec.extractLsb (← (Elem_read operand2 e esize)) 7 0))) ) :
          SailM Int )
        let element ← (( do
          bif (shift ≥b 0)
          then (pure (_shl_int_general element shift))
          else
            (do
              let shift := (Neg.neg shift)
              (RShr element shift rounding)) ) : SailM Int )
        let element := element
        let (result, sat) ← (( do
          bif saturating
          then
            (do
              let (__tup_0, __tup_1) ← do (SatQ element esize is_unsigned)
              let result ← (Elem_set result e esize __tup_0)
              let sat : Bool := __tup_1
              (pure ())
              bif sat
              then
                writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27
                  (0b1 : (BitVec 1)))
              else (pure ())
              (pure (result, sat)))
          else
            (do
              let result ← (Elem_set result e esize (integer_subrange element (esize -i 1) 0))
              (pure (result, sat))) ) : SailM ((BitVec datasize) × Bool) )
        (pure (result, sat))
    (pure loop_vars) ) : SailM ((BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  bif ((S == (0b0 : (BitVec 1))) && (size != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_sqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  bif ((S == (0b0 : (BitVec 1))) && (size != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_sqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  bif ((S == (0b0 : (BitVec 1))) && (size != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_srshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  bif ((S == (0b0 : (BitVec 1))) && (size != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_sshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  bif ((S == (0b0 : (BitVec 1))) && (size != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_uqrshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  bif ((S == (0b0 : (BitVec 1))) && (size != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_uqshl_advsimd_reg_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  bif ((S == (0b0 : (BitVec 1))) && (size != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_urshl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  bif ((S == (0b0 : (BitVec 1))) && (size != (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

def decode_ushl_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_shift_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let rounding : Bool := (R == (0b1 : (BitVec 1)))
  let saturating : Bool := (S == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_shift_sisd d datasize elements esize m n
    rounding saturating is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, n
  : Nat, part : Nat, k_round : Bool, shift : Int, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  esize ∈ {4, 8, 16, 32, 64} ∧ datasize ∈ {4, 8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (part : Nat) (round : Bool) (shift : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n (datasize *i 2)) ) : SailM (BitVec (datasize * 2)) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, sat) := loop_vars
      loop_vars ← do
        let element ←
          (RShr (← (asl_Int (← (Elem_read operand e (2 *i esize))) is_unsigned)) shift round)
        let (__tup_0, __tup_1) ← do (SatQ element esize is_unsigned)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element, result, sat))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize) × Bool) )
  (Vpart_set d part datasize result)

def decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := esize
  let elements := 1
  let part := 0
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  assert ((((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) && (((((datasize == 4) || (datasize == 8)) || (datasize == 16)) || (datasize == 32)) || (datasize == 64))) "src/instrs64.sail:48572.87-48572.88"
  (execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd d datasize elements esize n part
    round shift is_unsigned)

def decode_sqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:48605.51-48605.52"
  (execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd d datasize elements esize n part
    round shift is_unsigned)

def decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := esize
  let elements := 1
  let part := 0
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  assert ((((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) && (((((datasize == 4) || (datasize == 8)) || (datasize == 16)) || (datasize == 32)) || (datasize == 64))) "src/instrs64.sail:48639.87-48639.88"
  (execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd d datasize elements esize n part
    round shift is_unsigned)

def decode_sqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:48672.51-48672.52"
  (execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd d datasize elements esize n part
    round shift is_unsigned)

def decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := esize
  let elements := 1
  let part := 0
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  assert ((((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) && (((((datasize == 4) || (datasize == 8)) || (datasize == 16)) || (datasize == 32)) || (datasize == 64))) "src/instrs64.sail:48706.87-48706.88"
  (execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd d datasize elements esize n part
    round shift is_unsigned)

def decode_uqrshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:48739.51-48739.52"
  (execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd d datasize elements esize n part
    round shift is_unsigned)

def decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := esize
  let elements := 1
  let part := 0
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  assert ((((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) && (((((datasize == 4) || (datasize == 8)) || (datasize == 16)) || (datasize == 32)) || (datasize == 64))) "src/instrs64.sail:48773.87-48773.88"
  (execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd d datasize elements esize n part
    round shift is_unsigned)

def decode_uqshrn_advsimd_aarch64_instrs_vector_shift_right_narrow_uniform_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:48806.51-48806.52"
  (execute_aarch64_instrs_vector_shift_right_narrow_uniform_sisd d datasize elements esize n part
    round shift is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, part : Nat, k_round
  : Bool, shift : Int, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  esize ∈ {4, 8, 16, 32, 64} ∧ datasize ∈ {4, 8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (part : Nat) (round : Bool) (shift : Int) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n (datasize *i 2)) ) : SailM (BitVec (datasize * 2)) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, sat) := loop_vars
      loop_vars ← do
        let element ← (RShr (BitVec.toInt (← (Elem_read operand e (2 *i esize)))) shift round)
        let (__tup_0, __tup_1) ← do (UnsignedSatQ element esize)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element, result, sat))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize) × Bool) )
  (Vpart_set d part datasize result)

def decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := esize
  let elements := 1
  let part := 0
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  assert ((((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) && (((((datasize == 4) || (datasize == 8)) || (datasize == 16)) || (datasize == 32)) || (datasize == 64))) "src/instrs64.sail:48866.87-48866.88"
  (execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd d datasize elements esize n part
    round shift)

def decode_sqrshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:48897.51-48897.52"
  (execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd d datasize elements esize n part
    round shift)

def decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := esize
  let elements := 1
  let part := 0
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  assert ((((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) && (((((datasize == 4) || (datasize == 8)) || (datasize == 16)) || (datasize == 32)) || (datasize == 64))) "src/instrs64.sail:48929.87-48929.88"
  (execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd d datasize elements esize n part
    round shift)

def decode_sqshrun_advsimd_aarch64_instrs_vector_shift_right_narrow_nonuniform_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  let shift := ((2 *i esize) -i (BitVec.toNat (immh ++ immb)))
  let round : Bool := (op == (0b1 : (BitVec 1)))
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:48960.51-48960.52"
  (execute_aarch64_instrs_vector_shift_right_narrow_nonuniform_sisd d datasize elements esize n part
    round shift)

/-- Type quantifiers: d : Nat, datasize : Nat, k_dst_unsigned : Bool, elements : Int, esize : Nat, n
  : Nat, shift : Int, k_src_unsigned : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  esize ∈ {4, 8, 16, 32, 64} ∧ datasize ∈ {4, 8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_left_sat_sisd (d : Nat) (datasize : Nat) (dst_unsigned : Bool) (elements : Int) (esize : Nat) (n : Nat) (shift : Int) (src_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:48981.56-48981.57"
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, sat) := loop_vars
      loop_vars ← do
        let element ←
          (pure (_shl_int_general (← (asl_Int (← (Elem_read operand e esize)) src_unsigned))
              shift))
        let (__tup_0, __tup_1) ← do (SatQ element esize dst_unsigned)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element, result, sat))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := esize
  let elements := 1
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  let src_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let dst_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (op ++ U)
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let src_unsigned : Bool := false
      let dst_unsigned : Bool := true
      (pure ()))
    else
      (bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let src_unsigned : Bool := false
        let dst_unsigned : Bool := false
        (pure ()))
      else
        (let src_unsigned : Bool := true
        let dst_unsigned : Bool := true
        (pure ()))))
  let dst_unsigned := dst_unsigned
  let src_unsigned := src_unsigned
  assert ((((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) && ((((((datasize == 4) || (datasize == 8)) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128))) "src/instrs64.sail:49036.92-49036.93"
  (execute_aarch64_instrs_vector_shift_left_sat_sisd d datasize dst_unsigned elements esize n shift
    src_unsigned)

def decode_sqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  let src_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let dst_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (op ++ U)
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let src_unsigned : Bool := false
      let dst_unsigned : Bool := true
      (pure ()))
    else
      (bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let src_unsigned : Bool := false
        let dst_unsigned : Bool := false
        (pure ()))
      else
        (let src_unsigned : Bool := true
        let dst_unsigned : Bool := true
        (pure ()))))
  let dst_unsigned := dst_unsigned
  let src_unsigned := src_unsigned
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:49087.51-49087.52"
  (execute_aarch64_instrs_vector_shift_left_sat_sisd d datasize dst_unsigned elements esize n shift
    src_unsigned)

def decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := esize
  let elements := 1
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  let src_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let dst_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (op ++ U)
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let src_unsigned : Bool := false
      let dst_unsigned : Bool := true
      (pure ()))
    else
      (bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let src_unsigned : Bool := false
        let dst_unsigned : Bool := false
        (pure ()))
      else
        (let src_unsigned : Bool := true
        let dst_unsigned : Bool := true
        (pure ()))))
  let dst_unsigned := dst_unsigned
  let src_unsigned := src_unsigned
  assert ((((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) && ((((((datasize == 4) || (datasize == 8)) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128))) "src/instrs64.sail:49136.92-49136.93"
  (execute_aarch64_instrs_vector_shift_left_sat_sisd d datasize dst_unsigned elements esize n shift
    src_unsigned)

def decode_sqshlu_advsimd_aarch64_instrs_vector_shift_left_sat_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  let src_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let dst_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (op ++ U)
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let src_unsigned : Bool := false
      let dst_unsigned : Bool := true
      (pure ()))
    else
      (bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let src_unsigned : Bool := false
        let dst_unsigned : Bool := false
        (pure ()))
      else
        (let src_unsigned : Bool := true
        let dst_unsigned : Bool := true
        (pure ()))))
  let dst_unsigned := dst_unsigned
  let src_unsigned := src_unsigned
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:49187.51-49187.52"
  (execute_aarch64_instrs_vector_shift_left_sat_sisd d datasize dst_unsigned elements esize n shift
    src_unsigned)

def decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := esize
  let elements := 1
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  let src_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let dst_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (op ++ U)
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let src_unsigned : Bool := false
      let dst_unsigned : Bool := true
      (pure ()))
    else
      (bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let src_unsigned : Bool := false
        let dst_unsigned : Bool := false
        (pure ()))
      else
        (let src_unsigned : Bool := true
        let dst_unsigned : Bool := true
        (pure ()))))
  let dst_unsigned := dst_unsigned
  let src_unsigned := src_unsigned
  assert ((((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) && ((((((datasize == 4) || (datasize == 8)) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128))) "src/instrs64.sail:49236.92-49236.93"
  (execute_aarch64_instrs_vector_shift_left_sat_sisd d datasize dst_unsigned elements esize n shift
    src_unsigned)

def decode_uqshl_advsimd_imm_aarch64_instrs_vector_shift_left_sat_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  let src_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let dst_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (op ++ U)
  bif (b__0 == (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (b__0 == (0b01 : (BitVec 2)))
    then
      (let src_unsigned : Bool := false
      let dst_unsigned : Bool := true
      (pure ()))
    else
      (bif (b__0 == (0b10 : (BitVec 2)))
      then
        (let src_unsigned : Bool := false
        let dst_unsigned : Bool := false
        (pure ()))
      else
        (let src_unsigned : Bool := true
        let dst_unsigned : Bool := true
        (pure ()))))
  let dst_unsigned := dst_unsigned
  let src_unsigned := src_unsigned
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:49287.51-49287.52"
  (execute_aarch64_instrs_vector_shift_left_sat_sisd d datasize dst_unsigned elements esize n shift
    src_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let diff ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (diff, element1, element2, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (diff, element1, element2, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (diff, element1, element2, result, sat) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let diff : Int := (element1 -i element2)
        let (__tup_0, __tup_1) ← do (SatQ diff esize is_unsigned)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (diff, element1, element2, result, sat))
    (pure loop_vars) ) : SailM (Int × Int × Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd d datasize elements
    esize m n is_unsigned)

def decode_sqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd d datasize elements
    esize m n is_unsigned)

def decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd d datasize elements
    esize m n is_unsigned)

def decode_uqsub_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_sub_saturating_sisd d datasize elements
    esize m n is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, n
  : Nat, part : Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (part : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, sat) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e (2 *i esize))
        let (__tup_0, __tup_1) ← do (SatQ (← (asl_Int element is_unsigned)) esize is_unsigned)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element, result, sat))
    (pure loop_vars) ) : SailM ((BitVec (2 * esize)) × (BitVec datasize) × Bool) )
  (Vpart_set d part datasize result)

def decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let part := 0
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd d datasize elements esize n part
    is_unsigned)

def decode_sqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd d datasize elements esize n part
    is_unsigned)

def decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let part := 0
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd d datasize elements esize n part
    is_unsigned)

def decode_uqxtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sat_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_extract_sat_sisd d datasize elements esize n part
    is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, part : Nat, part
  ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (element, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result, sat) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e (2 *i esize))
        let (__tup_0, __tup_1) ← do (UnsignedSatQ (BitVec.toInt element) esize)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (element, result, sat))
    (pure loop_vars) ) : SailM ((BitVec (2 * esize)) × (BitVec datasize) × Bool) )
  (Vpart_set d part datasize result)

def decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let part := 0
  let elements := 1
  (execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd d datasize elements esize n
    part)

def decode_sqxtun_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_extract_sqxtun_sisd d datasize elements esize n
    part)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let sum ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result, sum) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result, sum)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result, sum) := loop_vars
      loop_vars ← do
        let element1 ← (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let sum : Int := (Int.shiftr ((element1 +i element2) +i 1) 1)
        let result ← (Elem_set result e esize (integer_subrange sum (esize -i 1) 0))
        (pure (element1, element2, result, sum))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec datasize) × Int) )
  (V_set d datasize result)

def decode_srhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding d datasize elements
    esize m n is_unsigned)

def decode_urhadd_advsimd_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_add_halving_rounding d datasize elements
    esize m n is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Int, elements : Int, esize : Int, n : Nat, shift : Int, 0
  ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_right_insert_sisd (d : Nat) (datasize : Int) (elements : Int) (esize : Int) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:49719.56-49719.57"
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  assert (esize ≥b 0) "src/instrs64.sail:49723.34-49723.35"
  let mask : (BitVec esize) := ((Ones (n := esize)) >>> shift)
  let shifted ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (result, shifted) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (result, shifted)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (result, shifted) := loop_vars
      loop_vars ← do
        assert (((e *i esize) ≤b (((e *i esize) +i esize) -i 1)) || ((! ((e ≥b 0) && (((e +i 1) *i esize) ≤b datasize))) || ((! (esize ≥b 0)) || (! (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)))))) "src/instrs64.sail:49727.198-49727.199"
        let shifted ← (pure ((← (Elem_read operand e esize)) >>> shift))
        let result ←
          (Elem_set result e esize
            (((← (Elem_read operand2 e esize)) &&& (Complement.complement mask)) ||| shifted))
        (pure (result, shifted))
    (pure loop_vars) ) : SailM ((BitVec datasize) × (BitVec esize)) )
  (V_set d datasize result)

def decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  (execute_aarch64_instrs_vector_shift_right_insert_sisd d datasize elements esize n shift)

def decode_sri_advsimd_aarch64_instrs_vector_shift_right_insert_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  (execute_aarch64_instrs_vector_shift_right_insert_sisd d datasize elements esize n shift)

/-- Type quantifiers: k_accumulate : Bool, d : Nat, datasize : Int, elements : Int, esize : Int, k_is_unsigned
  : Bool, n : Nat, k_round : Bool, shift : Int, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_right_sisd (accumulate : Bool) (d : Nat) (datasize : Int) (elements : Int) (esize : Int) (n : Nat) (round : Bool) (shift : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  assert (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128)) "src/instrs64.sail:49792.56-49792.57"
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let operand2 ← (( do
    bif accumulate
    then (V_read d datasize)
    else (pure (Zeros (n := datasize))) ) : SailM (BitVec datasize) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        assert (esize ≥b 0) "src/instrs64.sail:49799.38-49799.39"
        assert (((e *i esize) ≤b (((e *i esize) +i esize) -i 1)) || ((! ((e ≥b 0) && (((e +i 1) *i esize) ≤b datasize))) || (! (((((datasize == 8) || (datasize == 16)) || (datasize == 32)) || (datasize == 64)) || (datasize == 128))))) "src/instrs64.sail:49800.179-49800.180"
        let element ←
          (RShr (← (asl_Int (← (Elem_read operand e esize)) is_unsigned)) shift round)
        let result ←
          (Elem_set result e esize
            ((← (Elem_read operand2 e esize)) + (integer_subrange element (esize -i 1) 0)))
        (pure (element, result))
    (pure loop_vars) ) : SailM (Int × (BitVec datasize)) )
  (V_set d datasize result)

def decode_srshr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_srshr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_srsra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_srsra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_sshr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_sshr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_ssra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_ssra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_urshr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_urshr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_ursra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_ursra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_ushr_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_ushr_advsimd_aarch64_instrs_vector_shift_right_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_usra_advsimd_aarch64_instrs_vector_shift_right_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((BitVec.join1 [(BitVec.access immh 3)]) != (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 3)
  let datasize := esize
  let elements := 1
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

def decode_usra_advsimd_aarch64_instrs_vector_shift_right_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (o0 : (BitVec 1)) (o1 : (BitVec 1)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access immh 3)]) ++ Q) == (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (fdiv_int datasize esize)
  let shift := ((esize *i 2) -i (BitVec.toNat (immh ++ immb)))
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  let round : Bool := (o1 == (0b1 : (BitVec 1)))
  let accumulate : Bool := (o0 == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_shift_right_sisd accumulate d datasize elements esize n round shift
    is_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, n
  : Nat, part : Nat, shift : Int, part ∈ {0, 1} ∧
  0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {4, 8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_shift_left_long (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (part : Nat) (shift : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (Vpart_read n part datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector (datasize *i 2)) ) : SailM (BitVec (datasize * 2)) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ←
          (pure (_shl_int_general (← (asl_Int (← (Elem_read operand e esize)) is_unsigned))
              shift))
        let result ←
          (Elem_set result e (2 *i esize) (integer_subrange element ((2 *i esize) -i 1) 0))
        (pure (element, result))
    (pure loop_vars) ) : SailM (Int × (BitVec (datasize * 2))) )
  (V_set d (datasize *i 2) result)

def decode_sshll_advsimd_aarch64_instrs_vector_shift_left_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:50352.51-50352.52"
  (execute_aarch64_instrs_vector_shift_left_long d datasize elements esize n part shift is_unsigned)

def decode_ushll_advsimd_aarch64_instrs_vector_shift_left_long (Rd : (BitVec 5)) (Rn : (BitVec 5)) (immb : (BitVec 3)) (immh : (BitVec 4)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (immh == (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "asimdimm"))
  else (pure ())
  bif ((BitVec.join1 [(BitVec.access immh 3)]) == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (_shl_int_general 8 (HighestSetBit immh))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (fdiv_int datasize esize)
  let shift := ((BitVec.toNat (immh ++ immb)) -i esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  assert (((((esize == 4) || (esize == 8)) || (esize == 16)) || (esize == 32)) || (esize == 64)) "src/instrs64.sail:50384.51-50384.52"
  (execute_aarch64_instrs_vector_shift_left_long d datasize elements esize n part shift is_unsigned)

/-- Type quantifiers: n : Nat, k_postindex : Bool, t : Nat, k_writeback : Bool, k_zero_data : Bool, 0
  ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcsettagpairpost (n : Nat) (offset : (BitVec 64)) (postindex : Bool) (t : Nat) (writeback : Bool) (zero_data : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do
    bif (t == 31)
    then (SP_read ())
    else (X_read t 64) ) : SailM (BitVec 64) )
  let tag : (BitVec 4) := (AArch64_AllocationTagFromAddress data)
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  let accdesc ← (( do (CreateAccDescLDGSTG MemOp_STORE) ) : SailM AccessDescriptor )
  bif zero_data
  then
    (do
      bif (! (IsAligned__1 address TAG_GRANULE))
      then (AArch64_Abort address (← (AlignmentFault accdesc)))
      else (pure ())
      (Mem_set address TAG_GRANULE accdesc (Zeros (n := (TAG_GRANULE *i 8))))
      (Mem_set (BitVec.addInt address TAG_GRANULE) TAG_GRANULE accdesc
        (Zeros (n := (TAG_GRANULE *i 8)))))
  else (pure ())
  (AArch64_MemTag_set address accdesc tag)
  (AArch64_MemTag_set (BitVec.addInt address TAG_GRANULE) accdesc tag)
  bif writeback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())

def decode_st2g_aarch64_instrs_integer_tags_mcsettagpairpost (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := true
  let postindex : Bool := true
  let zero_data : Bool := false
  (execute_aarch64_instrs_integer_tags_mcsettagpairpost n offset postindex t writeback zero_data)

def decode_st2g_aarch64_instrs_integer_tags_mcsettagpairpre (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := true
  let postindex : Bool := false
  let zero_data : Bool := false
  (execute_aarch64_instrs_integer_tags_mcsettagpairpost n offset postindex t writeback zero_data)

def decode_st2g_aarch64_instrs_integer_tags_mcsettagpair (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := false
  let postindex : Bool := false
  let zero_data : Bool := false
  (execute_aarch64_instrs_integer_tags_mcsettagpairpost n offset postindex t writeback zero_data)

/-- Type quantifiers: n : Nat, t : Nat, k_tagchecked : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_atomicops_st_acc_st64b (lst : (BitVec 2)) (memop : MemOp) (n : Nat) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  (CheckLDST64BEnabled ())
  let data ← (( do (undefined_bitvector 512) ) : SailM (BitVec 512) )
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let value_name ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescLS64 memop tagchecked) ) : SailM AccessDescriptor )
  let (data, value_name) ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 7
    let mut loop_vars := (data, value_name)
    for i in [loop_i_lower:loop_i_upper:1]i do
      let (data, value_name) := loop_vars
      loop_vars ← do
        let value_name ← (X_read (t +i i) 64)
        let value_name ← (( do
          bif (← (BigEndian accdesc.acctype))
          then (pure (reverse_endianness value_name))
          else (pure value_name) ) : SailM (BitVec 64) )
        let data : (BitVec 512) :=
          (Sail.BitVec.updateSubrange data (63 +i (64 *i i)) (64 *i i) value_name)
        (pure (data, value_name))
    (pure loop_vars) ) : SailM ((BitVec 512) × (BitVec 64)) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let _ : Unit := (SetLoadStoreType lst)
  let _ : Unit := (AArch64_SetLSInstructionSyndrome 64 false t true false)
  (MemStore64B address data accdesc)
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_st64b_aarch64_instrs_memory_atomicops_st_acc_st64b (Rt : (BitVec 5)) (Rn : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveFeatLS64 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (((Sail.BitVec.extractLsb Rt 4 3) == (0b11 : (BitVec 2))) || ((BitVec.join1 [(BitVec.access Rt
             0)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop : MemOp := MemOp_STORE
  let tagchecked : Bool := (n != 31)
  let lst : (BitVec 2) := lst_64b
  (execute_aarch64_instrs_memory_atomicops_st_acc_st64b lst memop n t tagchecked)

/-- Type quantifiers: n : Nat, s : Nat, t : Nat, k_tagchecked : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_atomicops_st_acc_st64bv (Rs : (BitVec 5)) (lst : (BitVec 2)) (memop : MemOp) (n : Nat) (s : Nat) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  (CheckST64BVEnabled ())
  let data ← (( do (undefined_bitvector 512) ) : SailM (BitVec 512) )
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let value_name ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescLS64 memop tagchecked) ) : SailM AccessDescriptor )
  let (data, value_name) ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 7
    let mut loop_vars := (data, value_name)
    for i in [loop_i_lower:loop_i_upper:1]i do
      let (data, value_name) := loop_vars
      loop_vars ← do
        let value_name ← (X_read (t +i i) 64)
        let value_name ← (( do
          bif (← (BigEndian accdesc.acctype))
          then (pure (reverse_endianness value_name))
          else (pure value_name) ) : SailM (BitVec 64) )
        let data : (BitVec 512) :=
          (Sail.BitVec.updateSubrange data (63 +i (64 *i i)) (64 *i i) value_name)
        (pure (data, value_name))
    (pure loop_vars) ) : SailM ((BitVec 512) × (BitVec 64)) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let _ : Unit := (SetLoadStoreType lst)
  let _ : Unit := (AArch64_SetLSInstructionSyndrome 64 false t true false)
  let _ : Unit := (SetIss2 Rs)
  let status ← (( do (MemStore64BWithRet address data accdesc) ) : SailM (BitVec 64) )
  bif (s != 31)
  then (X_set s 64 status)
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_st64bv_aarch64_instrs_memory_atomicops_st_acc_st64bv (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveFeatLS64_V ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (((Sail.BitVec.extractLsb Rt 4 3) == (0b11 : (BitVec 2))) || ((BitVec.join1 [(BitVec.access Rt
             0)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop : MemOp := MemOp_STORE
  let s := (BitVec.toNat Rs)
  let tagchecked : Bool := (n != 31)
  let lst : (BitVec 2) := lst_64bv
  (execute_aarch64_instrs_memory_atomicops_st_acc_st64bv Rs lst memop n s t tagchecked)

/-- Type quantifiers: n : Nat, s : Nat, t : Nat, k_tagchecked : Bool, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ s ∧ s ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_atomicops_st_acc_st64bv0 (Rs : (BitVec 5)) (lst : (BitVec 2)) (memop : MemOp) (n : Nat) (s : Nat) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  (CheckST64BV0Enabled ())
  let data ← (( do (undefined_bitvector 512) ) : SailM (BitVec 512) )
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let value_name ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescLS64 memop tagchecked) ) : SailM AccessDescriptor )
  let Xt ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let value_name ←
    (pure (Sail.BitVec.updateSubrange value_name 31 0
        (Sail.BitVec.extractLsb (← readReg ACCDATA_EL1) 31 0)))
  let value_name : (BitVec 64) :=
    (Sail.BitVec.updateSubrange value_name 63 32 (Sail.BitVec.extractLsb Xt 63 32))
  let value_name ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (reverse_endianness value_name))
    else (pure value_name) ) : SailM (BitVec 64) )
  let data : (BitVec 512) := (Sail.BitVec.updateSubrange data 63 0 value_name)
  let (data, value_name) ← (( do
    let loop_i_lower := 1
    let loop_i_upper := 7
    let mut loop_vars := (data, value_name)
    for i in [loop_i_lower:loop_i_upper:1]i do
      let (data, value_name) := loop_vars
      loop_vars ← do
        let value_name ← (X_read (t +i i) 64)
        let value_name ← (( do
          bif (← (BigEndian accdesc.acctype))
          then (pure (reverse_endianness value_name))
          else (pure value_name) ) : SailM (BitVec 64) )
        let data : (BitVec 512) :=
          (Sail.BitVec.updateSubrange data (63 +i (64 *i i)) (64 *i i) value_name)
        (pure (data, value_name))
    (pure loop_vars) ) : SailM ((BitVec 512) × (BitVec 64)) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let _ : Unit := (SetLoadStoreType lst)
  let _ : Unit := (AArch64_SetLSInstructionSyndrome 64 false t true false)
  let _ : Unit := (SetIss2 Rs)
  let status ← (( do (MemStore64BWithRet address data accdesc) ) : SailM (BitVec 64) )
  bif (s != 31)
  then (X_set s 64 status)
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_st64bv0_aarch64_instrs_memory_atomicops_st_acc_st64bv0 (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveFeatLS64_ACCDATA ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (((Sail.BitVec.extractLsb Rt 4 3) == (0b11 : (BitVec 2))) || ((BitVec.join1 [(BitVec.access Rt
             0)]) == (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let memop : MemOp := MemOp_STORE
  let s := (BitVec.toNat Rs)
  let tagchecked : Bool := (n != 31)
  let lst : (BitVec 2) := lst_64bv0
  (execute_aarch64_instrs_memory_atomicops_st_acc_st64bv0 Rs lst memop n s t tagchecked)

/-- Type quantifiers: n : Nat, k_postindex : Bool, t : Nat, k_writeback : Bool, k_zero_data : Bool, 0
  ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcsettagpost (n : Nat) (offset : (BitVec 64)) (postindex : Bool) (t : Nat) (writeback : Bool) (zero_data : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  let accdesc ← (( do (CreateAccDescLDGSTG MemOp_STORE) ) : SailM AccessDescriptor )
  bif zero_data
  then
    (do
      bif (! (IsAligned__1 address TAG_GRANULE))
      then (AArch64_Abort address (← (AlignmentFault accdesc)))
      else (pure ())
      (Mem_set address TAG_GRANULE accdesc (Zeros (n := (TAG_GRANULE *i 8)))))
  else (pure ())
  let data ← (( do
    bif (t == 31)
    then (SP_read ())
    else (X_read t 64) ) : SailM (BitVec 64) )
  let tag : (BitVec 4) := (AArch64_AllocationTagFromAddress data)
  (AArch64_MemTag_set address accdesc tag)
  bif writeback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())

def decode_stg_aarch64_instrs_integer_tags_mcsettagpost (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := true
  let postindex : Bool := true
  let zero_data : Bool := false
  (execute_aarch64_instrs_integer_tags_mcsettagpost n offset postindex t writeback zero_data)

def decode_stg_aarch64_instrs_integer_tags_mcsettagpre (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := true
  let postindex : Bool := false
  let zero_data : Bool := false
  (execute_aarch64_instrs_integer_tags_mcsettagpost n offset postindex t writeback zero_data)

def decode_stg_aarch64_instrs_integer_tags_mcsettag (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := false
  let postindex : Bool := false
  let zero_data : Bool := false
  (execute_aarch64_instrs_integer_tags_mcsettagpost n offset postindex t writeback zero_data)

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcsettagarray (n : Nat) (t : Nat) : SailM Unit := do
  bif ((← readReg PSTATE).EL == EL0)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let data ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let size ← do (pure (4 *i (2 ^i (BitVec.toNat (_get_GMID_EL1_Type_BS (← readReg GMID_EL1))))))
  let address : (BitVec 64) := (Align_bits address size)
  let count := (Int.shiftr size LOG2_TAG_GRANULE)
  let index : Int :=
    (BitVec.toNat (Sail.BitVec.extractLsb address (LOG2_TAG_GRANULE +i 3) LOG2_TAG_GRANULE))
  let accdesc ← (( do (CreateAccDescLDGSTG MemOp_STORE) ) : SailM AccessDescriptor )
  let (address, index) ← (( do
    let loop_i_lower := 0
    let loop_i_upper := (count -i 1)
    let mut loop_vars := (address, index)
    for i in [loop_i_lower:loop_i_upper:1]i do
      let (address, index) := loop_vars
      loop_vars ← do
        let tag ← (( do
          let index := index
          assert ((0 ≤b (index *i 4)) && (((index *i 4) +i 3) <b 64)) "src/instrs64.sail:50826.72-50826.73"
          (pure (Sail.BitVec.extractLsb data ((index *i 4) +i 3) (index *i 4))) ) : SailM (BitVec 4)
          )
        (AArch64_MemTag_set address accdesc tag)
        let address : (BitVec 64) := (BitVec.addInt address TAG_GRANULE)
        let index : Int := (index +i 1)
        (pure (address, index))
    (pure loop_vars) ) : SailM ((BitVec 64) × Int) )
  (pure ())

def decode_stgm_aarch64_instrs_integer_tags_mcsettagarray (Xt : (BitVec 5)) (Xn : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveMTE2Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Xt)
  let n := (BitVec.toNat Xn)
  (execute_aarch64_instrs_integer_tags_mcsettagarray n t)

/-- Type quantifiers: n : Nat, k_postindex : Bool, t : Nat, t2 : Nat, k_writeback : Bool, 0 ≤ t2
  ∧ t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcsettaganddatapairpost (n : Nat) (offset : (BitVec 64)) (postindex : Bool) (t : Nat) (t2 : Nat) (writeback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let data1 ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let data2 ← (( do (X_read t2 64) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  let accdesc ← (( do (CreateAccDescLDGSTG MemOp_STORE) ) : SailM AccessDescriptor )
  bif (! (IsAligned__1 address TAG_GRANULE))
  then (AArch64_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  (Mem_set address 8 accdesc data1)
  (Mem_set (BitVec.addInt address 8) 8 accdesc data2)
  (AArch64_MemTag_set address accdesc (AArch64_AllocationTagFromAddress address))
  bif writeback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())

def decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapairpost (Xt : (BitVec 5)) (Xn : (BitVec 5)) (Xt2 : (BitVec 5)) (simm7 : (BitVec 7)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let t2 := (BitVec.toNat Xt2)
  let offset : (BitVec 64) := ((sign_extend simm7 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := true
  let postindex : Bool := true
  (execute_aarch64_instrs_integer_tags_mcsettaganddatapairpost n offset postindex t t2 writeback)

def decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapairpre (Xt : (BitVec 5)) (Xn : (BitVec 5)) (Xt2 : (BitVec 5)) (simm7 : (BitVec 7)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let t2 := (BitVec.toNat Xt2)
  let offset : (BitVec 64) := ((sign_extend simm7 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := true
  let postindex : Bool := false
  (execute_aarch64_instrs_integer_tags_mcsettaganddatapairpost n offset postindex t t2 writeback)

def decode_stgp_aarch64_instrs_integer_tags_mcsettaganddatapair (Xt : (BitVec 5)) (Xn : (BitVec 5)) (Xt2 : (BitVec 5)) (simm7 : (BitVec 7)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let t2 := (BitVec.toNat Xt2)
  let offset : (BitVec 64) := ((sign_extend simm7 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := false
  let postindex : Bool := false
  (execute_aarch64_instrs_integer_tags_mcsettaganddatapairpost n offset postindex t t2 writeback)

/-- Type quantifiers: datasize : Nat, n : Nat, offset : Int, k_postindex : Bool, k_rt_unknown : Bool, t
  : Nat, t2 : Nat, k_tagchecked : Bool, k_wb_unknown : Bool, k_wback : Bool, 0 ≤ t2 ∧
  t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {32, 64} -/
def execute_aarch64_instrs_memory_ordered_pair_stilp (datasize : Nat) (memop : MemOp) (n : Nat) (offset : Int) (postindex : Bool) (rt_unknown : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) (wb_unknown : Bool) (wback : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data1 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let data2 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let dbytes := (Int.ediv datasize 8)
  let accdesc ← (( do (CreateAccDescAcqRel memop tagchecked) ) : SailM AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (BitVec.addInt address offset)
    else address
  match memop with
  | MemOp_STORE =>
    (do
      let data1 ← (( do
        bif (rt_unknown && (t == n))
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t datasize)) ) : SailM (BitVec datasize) )
      let data2 ← (( do
        bif (rt_unknown && (t2 == n))
        then
          (do
            (__UNKNOWN_bits datasize))
        else
          (do
            (X_read t2 datasize)) ) : SailM (BitVec datasize) )
      bif (← (HaveLSE2Ext ()))
      then
        (do
          let full_data ← (( do (undefined_bitvector (2 *i datasize)) ) : SailM
            (BitVec (2 * datasize)) )
          let full_data ← (( do
            bif (← (BigEndian accdesc.acctype))
            then (pure (data1 ++ data2))
            else (pure (data2 ++ data1)) ) : SailM (BitVec (2 * datasize)) )
          let ispair : Bool := true
          let highestAddressfirst : Bool := ((! postindex) && (offset <b 0))
          (Mem_set__2 address (2 *i dbytes) accdesc ispair highestAddressfirst full_data))
      else
        (do
          bif ((! postindex) && (offset <b 0))
          then
            (do
              (Mem_set (BitVec.addInt address dbytes) dbytes accdesc data2)
              (Mem_set (BitVec.addInt address 0) dbytes accdesc data1))
          else
            (do
              (Mem_set (BitVec.addInt address 0) dbytes accdesc data1)
              (Mem_set (BitVec.addInt address dbytes) dbytes accdesc data2))))
  | MemOp_LOAD =>
    (do
      let (data1, data2) ← (( do
        bif (← (HaveLSE2Ext ()))
        then
          (do
            let ispair : Bool := true
            let full_data ← (( do (Mem_read__1 address (2 *i dbytes) accdesc ispair) ) : SailM
              (BitVec (2 * datasize)) )
            let (data1, data2) ← (( do
              bif (← (BigEndian accdesc.acctype))
              then
                (let data2 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data (datasize -i 1) 0)
                let data1 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data ((2 *i datasize) -i 1) datasize)
                (pure (data1, data2)))
              else
                (let data1 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data (datasize -i 1) 0)
                let data2 : (BitVec datasize) :=
                  (Sail.BitVec.extractLsb full_data ((2 *i datasize) -i 1) datasize)
                (pure (data1, data2))) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
            (pure (data1, data2)))
        else
          (do
            let data1 ← (Mem_read (BitVec.addInt address 0) dbytes accdesc)
            let data2 ← (Mem_read (BitVec.addInt address dbytes) dbytes accdesc)
            (pure (data1, data2))) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
      let (data1, data2) ← (( do
        bif rt_unknown
        then
          (do
            let data1 ← (__UNKNOWN_bits datasize)
            let data2 ← (__UNKNOWN_bits datasize)
            (pure (data1, data2)))
        else (pure (data1, data2)) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
      (X_set t datasize data1)
      (X_set t2 datasize data2))
  | _ => (pure ())
  bif wback
  then
    (do
      let address ← (( do
        bif wb_unknown
        then
          (do
            (__UNKNOWN_bits 64))
        else
          (bif postindex
          then (pure (BitVec.addInt address offset))
          else (pure address)) ) : SailM (BitVec 64) )
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())
  bif (← readReg SPESampleInFlight)
  then (SPESampleGeneralPurposeLoadStore ())
  else (pure ())

def decode_stilp_aarch64_instrs_memory_ordered_pair_stilp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc2 : (BitVec 4)) (Rt2 : (BitVec 5)) (L : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  let postindex : Bool := false
  let wback : Bool := ((BitVec.join1 [(BitVec.access opc2 0)]) == (0b0 : (BitVec 1)))
  let offset ← (( do (undefined_int ()) ) : SailM Int )
  let n := (BitVec.toNat Rn)
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let scale := (2 +i (BitVec.toNat (BitVec.join1 [(BitVec.access size 0)])))
  let datasize := (Int.shiftl 8 scale)
  let memop ← (( do (undefined_MemOp ()) ) : SailM MemOp )
  let (memop, offset) : (MemOp × Int) :=
    bif (L == (0b1 : (BitVec 1)))
    then
      (let memop : MemOp := MemOp_LOAD
      let offset : Int :=
        bif ((BitVec.join1 [(BitVec.access opc2 0)]) == (0b0 : (BitVec 1)))
        then (Int.shiftl 2 scale)
        else 0
      (memop, offset))
    else
      (let memop : MemOp := MemOp_STORE
      let offset : Int :=
        bif ((BitVec.join1 [(BitVec.access opc2 0)]) == (0b0 : (BitVec 1)))
        then ((Neg.neg 1) *i (Int.shiftl 2 scale))
        else 0
      (memop, offset))
  let offset := offset
  let tagchecked : Bool := (wback || (n != 31))
  let rt_unknown : Bool := false
  let wb_unknown : Bool := false
  let (wb_unknown, wback) ← (( do
    bif ((((BEq.beq memop MemOp_LOAD) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPLD) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_WBSUPPRESS) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:51080.113-51080.114"
        let (wb_unknown, wback) ← (( do
          match c with
          | Constraint_WBSUPPRESS =>
            (let wback : Bool := false
            (pure (wb_unknown, wback)))
          | Constraint_UNKNOWN =>
            (let wb_unknown : Bool := true
            (pure (wb_unknown, wback)))
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP =>
            (do
              (EndOfInstruction ())
              (pure (wb_unknown, wback)))
          | _ => (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
        (pure (wb_unknown, wback)))
    else (pure (wb_unknown, wback)) ) : SailM (Bool × Bool) )
  let rt_unknown ← (( do
    bif ((((BEq.beq memop MemOp_STORE) && wback) && ((t == n) || (t2 == n))) && (n != 31))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_WBOVERLAPST) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_NONE) || ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c
                Constraint_UNDEF) || (BEq.beq c Constraint_NOP)))) "src/instrs64.sail:51099.107-51099.108"
        match c with
        | Constraint_NONE => (pure false)
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  let rt_unknown ← (( do
    bif ((BEq.beq memop MemOp_LOAD) && (t == t2))
    then
      (do
        let c ← (( do (ConstrainUnpredictable Unpredictable_LDPOVERLAP) ) : SailM Constraint )
        assert ((BEq.beq c Constraint_UNKNOWN) || ((BEq.beq c Constraint_UNDEF) || (BEq.beq c
              Constraint_NOP))) "src/instrs64.sail:51118.84-51118.85"
        match c with
        | Constraint_UNKNOWN => (pure true)
        | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
        | Constraint_NOP =>
          (do
            (EndOfInstruction ())
            (pure rt_unknown))
        | _ => (pure rt_unknown))
    else (pure rt_unknown) ) : SailM Bool )
  assert ((datasize == 32) || (datasize == 64)) "src/instrs64.sail:51132.44-51132.45"
  (execute_aarch64_instrs_memory_ordered_pair_stilp datasize memop n offset postindex rt_unknown t
    t2 tagchecked wb_unknown wback)

/-- Type quantifiers: n : Nat, k_postindex : Bool, t : Nat, k_writeback : Bool, k_zero_data : Bool, 0
  ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost (n : Nat) (offset : (BitVec 64)) (postindex : Bool) (t : Nat) (writeback : Bool) (zero_data : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let data ← (( do
    bif (t == 31)
    then (SP_read ())
    else (X_read t 64) ) : SailM (BitVec 64) )
  let tag : (BitVec 4) := (AArch64_AllocationTagFromAddress data)
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  let accdesc ← (( do (CreateAccDescLDGSTG MemOp_STORE) ) : SailM AccessDescriptor )
  bif zero_data
  then
    (do
      bif (! (IsAligned__1 address TAG_GRANULE))
      then (AArch64_Abort address (← (AlignmentFault accdesc)))
      else (pure ())
      (Mem_set address TAG_GRANULE accdesc (Zeros (n := (TAG_GRANULE *i 8))))
      (Mem_set (BitVec.addInt address TAG_GRANULE) TAG_GRANULE accdesc
        (Zeros (n := (TAG_GRANULE *i 8)))))
  else (pure ())
  (AArch64_MemTag_set address accdesc tag)
  (AArch64_MemTag_set (BitVec.addInt address TAG_GRANULE) accdesc tag)
  bif writeback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())

def decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := true
  let postindex : Bool := true
  let zero_data : Bool := true
  (execute_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost n offset postindex t writeback
    zero_data)

def decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodatapre (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := true
  let postindex : Bool := false
  let zero_data : Bool := true
  (execute_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost n offset postindex t writeback
    zero_data)

def decode_stz2g_aarch64_instrs_integer_tags_mcsettagpairandzerodata (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := false
  let postindex : Bool := false
  let zero_data : Bool := true
  (execute_aarch64_instrs_integer_tags_mcsettagpairandzerodatapost n offset postindex t writeback
    zero_data)

/-- Type quantifiers: n : Nat, k_postindex : Bool, t : Nat, k_writeback : Bool, k_zero_data : Bool, 0
  ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcsettagandzerodatapost (n : Nat) (offset : (BitVec 64)) (postindex : Bool) (t : Nat) (writeback : Bool) (zero_data : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let address : (BitVec 64) :=
    bif (! postindex)
    then (address + offset)
    else address
  let accdesc ← (( do (CreateAccDescLDGSTG MemOp_STORE) ) : SailM AccessDescriptor )
  bif zero_data
  then
    (do
      bif (! (IsAligned__1 address TAG_GRANULE))
      then (AArch64_Abort address (← (AlignmentFault accdesc)))
      else (pure ())
      (Mem_set address TAG_GRANULE accdesc (Zeros (n := (TAG_GRANULE *i 8)))))
  else (pure ())
  let data ← (( do
    bif (t == 31)
    then (SP_read ())
    else (X_read t 64) ) : SailM (BitVec 64) )
  let tag : (BitVec 4) := (AArch64_AllocationTagFromAddress data)
  (AArch64_MemTag_set address accdesc tag)
  bif writeback
  then
    (do
      let address : (BitVec 64) :=
        bif postindex
        then (address + offset)
        else address
      bif (n == 31)
      then (SP_set address)
      else (X_set n 64 address))
  else (pure ())

def decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodatapost (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := true
  let postindex : Bool := true
  let zero_data : Bool := true
  (execute_aarch64_instrs_integer_tags_mcsettagandzerodatapost n offset postindex t writeback
    zero_data)

def decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodatapre (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := true
  let postindex : Bool := false
  let zero_data : Bool := true
  (execute_aarch64_instrs_integer_tags_mcsettagandzerodatapost n offset postindex t writeback
    zero_data)

def decode_stzg_aarch64_instrs_integer_tags_mcsettagandzerodata (Xt : (BitVec 5)) (Xn : (BitVec 5)) (imm9 : (BitVec 9)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Xn)
  let t := (BitVec.toNat Xt)
  let offset : (BitVec 64) := ((sign_extend imm9 64) <<< LOG2_TAG_GRANULE)
  let writeback : Bool := false
  let postindex : Bool := false
  let zero_data : Bool := true
  (execute_aarch64_instrs_integer_tags_mcsettagandzerodatapost n offset postindex t writeback
    zero_data)

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcsettagandzeroarray (n : Nat) (t : Nat) : SailM Unit := do
  bif ((← readReg PSTATE).EL == EL0)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let data ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let tag : (BitVec 4) := (Sail.BitVec.extractLsb data 3 0)
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let size ← do
    (pure (4 *i (2 ^i (BitVec.toNat (_get_DCZID_EL0_Type_BS (← readReg DCZID_EL0))))))
  let address : (BitVec 64) := (Align_bits address size)
  let count := (Int.shiftr size LOG2_TAG_GRANULE)
  let accdesc ← (( do (CreateAccDescLDGSTG MemOp_STORE) ) : SailM AccessDescriptor )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := (count -i 1)
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        (AArch64_MemTag_set address accdesc tag)
        (Mem_set address TAG_GRANULE accdesc (Zeros (n := (8 *i TAG_GRANULE))))
        (pure (BitVec.addInt address TAG_GRANULE))
    (pure loop_vars) ) : SailM (BitVec 64) )
  (pure ())

def decode_stzgm_aarch64_instrs_integer_tags_mcsettagandzeroarray (Xt : (BitVec 5)) (Xn : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveMTE2Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Xt)
  let n := (BitVec.toNat Xn)
  (execute_aarch64_instrs_integer_tags_mcsettagandzeroarray n t)

/-- Type quantifiers: k_ADD : Bool, d : Nat, n : Nat, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_tags_mcsubtag (ADD : Bool) (d : Nat) (n : Nat) (offset : (BitVec 64)) (tag_offset : (BitVec 4)) : SailM Unit := do
  let operand1 ← (( do
    bif (n == 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let start_tag : (BitVec 4) := (AArch64_AllocationTagFromAddress operand1)
  let exclude ← (( do (pure (_get_GCR_EL1_Type_Exclude (← readReg GCR_EL1))) ) : SailM
    (BitVec 16) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let rtag ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let rtag ← (( do
    bif (← (AArch64_AllocationTagAccessIsEnabled (← readReg PSTATE).EL))
    then (pure (AArch64_ChooseNonExcludedTag start_tag tag_offset exclude))
    else (pure (0x0 : (BitVec 4))) ) : SailM (BitVec 4) )
  let result : (BitVec 64) :=
    bif ADD
    then
      (let (__tup_0, _) := (AddWithCarry operand1 offset (0b0 : (BitVec 1)))
      __tup_0)
    else
      (let (__tup_0, _) := (AddWithCarry operand1 (Complement.complement offset) (0b1 : (BitVec 1)))
      __tup_0)
  let result ← (( do (AArch64_AddressWithAllocationTag result rtag) ) : SailM (BitVec 64) )
  bif (d == 31)
  then (SP_set result)
  else (X_set d 64 result)

def decode_subg_aarch64_instrs_integer_tags_mcsubtag (Xd : (BitVec 5)) (Xn : (BitVec 5)) (uimm4 : (BitVec 4)) (op3 : (BitVec 2)) (uimm6 : (BitVec 6)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Xd)
  let n := (BitVec.toNat Xn)
  let tag_offset : (BitVec 4) := uimm4
  let offset : (BitVec 64) := ((Sail.BitVec.zeroExtend uimm6 64) <<< LOG2_TAG_GRANULE)
  let ADD : Bool := false
  (execute_aarch64_instrs_integer_tags_mcsubtag ADD d n offset tag_offset)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddress (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let operand1 ← (( do
    bif (n == 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do
    bif (m == 31)
    then (SP_read ())
    else (X_read m 64) ) : SailM (BitVec 64) )
  let operand1 : (BitVec 64) := (sign_extend (Sail.BitVec.extractLsb operand1 55 0) 64)
  let operand2 : (BitVec 64) := (sign_extend (Sail.BitVec.extractLsb operand2 55 0) 64)
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let operand2 : (BitVec 64) := (Complement.complement operand2)
  let _ : Unit :=
    let (tup__0, tup__1) :=
      ((AddWithCarry operand1 operand2 (0b1 : (BitVec 1))) : ((BitVec 64) × (BitVec 4)))
    let result : (BitVec 64) := tup__0
    let nzcv : (BitVec 4) := tup__1
    ()
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())
  (X_set d 64 result)

def decode_subp_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddress (Xd : (BitVec 5)) (Xn : (BitVec 5)) (Xm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Xd)
  let n := (BitVec.toNat Xn)
  let m := (BitVec.toNat Xm)
  let setflags : Bool := false
  (execute_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddress d m n setflags)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let operand1 ← (( do
    bif (n == 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do
    bif (m == 31)
    then (SP_read ())
    else (X_read m 64) ) : SailM (BitVec 64) )
  let operand1 : (BitVec 64) := (sign_extend (Sail.BitVec.extractLsb operand1 55 0) 64)
  let operand2 : (BitVec 64) := (sign_extend (Sail.BitVec.extractLsb operand2 55 0) 64)
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let operand2 : (BitVec 64) := (Complement.complement operand2)
  let _ : Unit :=
    let (tup__0, tup__1) :=
      ((AddWithCarry operand1 operand2 (0b1 : (BitVec 1))) : ((BitVec 64) × (BitVec 4)))
    let result : (BitVec 64) := tup__0
    let nzcv : (BitVec 4) := tup__1
    ()
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())
  (X_set d 64 result)

def decode_subps_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags (Xd : (BitVec 5)) (Xn : (BitVec 5)) (Xm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveMTEExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Xd)
  let n := (BitVec.toNat Xn)
  let m := (BitVec.toNat Xm)
  let setflags : Bool := true
  (execute_aarch64_instrs_integer_arithmetic_pointer_mcsubtracttaggedaddresssetflags d m n setflags)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Nat, i : Nat, m : Nat, n : Nat, k_op1_unsigned
  : Bool, k_op2_unsigned : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  i ∈ {0, 1, 2, 3} ∧ elements ∈ {2, 4} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp (d : Nat) (datasize : Nat) (elements : Nat) (i : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let res ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let res ← (( do
          let loop_b_lower := 0
          let loop_b_upper := 3
          let mut loop_vars_1 := res
          for b in [loop_b_lower:loop_b_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (asl_Int (← (Elem_read operand1 ((4 *i e) +i b) 8)) op1_unsigned)
              let element2 ← do
                (asl_Int (← (Elem_read operand2 ((4 *i i) +i b) 8)) op2_unsigned)
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec 32) )
        (Elem_set result e 32 res)
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_sudot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (US : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveInt8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let op1_unsigned : Bool := (US == (0b1 : (BitVec 1)))
  let op2_unsigned : Bool := (US == (0b0 : (BitVec 1)))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (M ++ Rm))
  let d := (BitVec.toNat Rd)
  let i := (BitVec.toNat (H ++ L))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize 32)
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp d datasize elements i m
    n op1_unsigned op2_unsigned)

def decode_usdot_advsimd_elt_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp (Rd : (BitVec 5)) (Rn : (BitVec 5)) (H : (BitVec 1)) (Rm : (BitVec 4)) (M : (BitVec 1)) (L : (BitVec 1)) (US : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveInt8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let op1_unsigned : Bool := (US == (0b1 : (BitVec 1)))
  let op2_unsigned : Bool := (US == (0b0 : (BitVec 1)))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat (M ++ Rm))
  let d := (BitVec.toNat Rd)
  let i := (BitVec.toNat (H ++ L))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize 32)
  (execute_aarch64_instrs_vector_arithmetic_binary_element_mat_mul_int_dotp d datasize elements i m
    n op1_unsigned op2_unsigned)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, n
  : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (op1, op2, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (op1, op2, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (op1, op2, result, sat) := loop_vars
      loop_vars ← do
        let op1 ← (asl_Int (← (Elem_read operand e esize)) (! is_unsigned))
        let op2 ← (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let (__tup_0, __tup_1) ← do (SatQ (op1 +i op2) esize is_unsigned)
        let result ← (Elem_set result e esize __tup_0)
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then writeReg FPSR (Sail.BitVec.updateSubrange (← readReg FPSR) 27 27 (0b1 : (BitVec 1)))
        else (pure ())
        (pure (op1, op2, result, sat))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec datasize) × Bool) )
  (V_set d datasize result)

def decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd d datasize elements esize n
    is_unsigned)

def decode_suqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd d datasize elements esize n
    is_unsigned)

def decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := esize
  let elements := 1
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd d datasize elements esize n
    is_unsigned)

def decode_usqadd_advsimd_aarch64_instrs_vector_arithmetic_unary_add_saturating_simd (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (U : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let is_unsigned : Bool := (U == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_vector_arithmetic_unary_add_saturating_sisd d datasize elements esize n
    is_unsigned)

def execute_aarch64_instrs_system_exceptions_runtime_svc (imm : (BitVec 16)) : SailM Unit := do
  (AArch64_CheckForSVCTrap imm)
  (AArch64_CallSupervisor imm)

def decode_svc_aarch64_instrs_system_exceptions_runtime_svc (imm16 : (BitVec 16)) : SailM Unit := do
  let imm : (BitVec 16) := imm16
  (execute_aarch64_instrs_system_exceptions_runtime_svc imm)

/-- Type quantifiers: k_acquire : Bool, datasize : Nat, n : Nat, regsize : Nat, k_release : Bool, s
  : Nat, t : Nat, k_tagchecked : Bool, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ s ∧
  s ≤ 31 ∧ regsize ∈ {32, 64} ∧ 0 ≤ n ∧ n ≤ 31 ∧ datasize ∈ {8, 16, 32, 64} -/
def execute_aarch64_instrs_memory_atomicops_swp (acquire : Bool) (datasize : Nat) (n : Nat) (regsize : Nat) (release : Bool) (s : Nat) (t : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescAtomicOp MemAtomicOp_SWP acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let store_value ← (( do (X_read s datasize) ) : SailM (BitVec datasize) )
  let comparevalue ← (( do (__UNKNOWN_bits datasize) ) : SailM (BitVec datasize) )
  let data ← (( do (MemAtomic address comparevalue store_value accdesc) ) : SailM
    (BitVec datasize) )
  assert (regsize ≥b datasize) "src/instrs64.sail:51787.44-51787.45"
  (X_set t regsize (Sail.BitVec.zeroExtend data regsize))
  bif (← readReg SPESampleInFlight)
  then
    (do
      let ar : (BitVec 1) :=
        bif (acquire || release)
        then (0b1 : (BitVec 1))
        else (0b0 : (BitVec 1))
      let excl : (BitVec 1) := (0b0 : (BitVec 1))
      let at' : (BitVec 1) := (0b1 : (BitVec 1))
      let is_load : Bool := true
      (SPESampleExtendedLoadStore ar excl at' is_load))
  else (pure ())

def decode_swp_aarch64_instrs_memory_atomicops_swp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_swp acquire datasize n regsize release s t tagchecked)

def decode_swpb_aarch64_instrs_memory_atomicops_swp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_swp acquire datasize n regsize release s t tagchecked)

def decode_swph_aarch64_instrs_memory_atomicops_swp (Rt : (BitVec 5)) (Rn : (BitVec 5)) (Rs : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (size : (BitVec 2)) : SailM Unit := do
  bif (! (← (HaveAtomicExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let n := (BitVec.toNat Rn)
  let s := (BitVec.toNat Rs)
  let datasize := (Int.shiftl 8 (BitVec.toNat size))
  let regsize :=
    bif (datasize == 64)
    then 64
    else 32
  let acquire : Bool := ((A == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_swp acquire datasize n regsize release s t tagchecked)

/-- Type quantifiers: k_acquire : Bool, n : Nat, k_release : Bool, t : Nat, t2 : Nat, k_tagchecked :
  Bool, 0 ≤ t2 ∧ t2 ≤ 31 ∧ 0 ≤ t ∧ t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch64_instrs_memory_atomicops_swp_128 (acquire : Bool) (n : Nat) (release : Bool) (t : Nat) (t2 : Nat) (tagchecked : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let value1_name ← (( do (X_read t 64) ) : SailM (BitVec 64) )
  let value2_name ← (( do (X_read t2 64) ) : SailM (BitVec 64) )
  let accdesc ← (( do (CreateAccDescAtomicOp MemAtomicOp_SWP acquire release tagchecked) ) : SailM
    AccessDescriptor )
  let address ← (( do
    bif (n == 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let store_value ← (( do
    bif (← (BigEndian accdesc.acctype))
    then (pure (value1_name ++ value2_name))
    else (pure (value2_name ++ value1_name)) ) : SailM (BitVec 128) )
  let comparevalue ← (( do (__UNKNOWN_bits 128) ) : SailM (BitVec 128) )
  let data ← (( do (MemAtomic address comparevalue store_value accdesc) ) : SailM (BitVec 128) )
  bif (← (BigEndian accdesc.acctype))
  then
    (do
      (X_set t 64 (Sail.BitVec.extractLsb data 127 64))
      (X_set t2 64 (Sail.BitVec.extractLsb data 63 0)))
  else
    (do
      (X_set t 64 (Sail.BitVec.extractLsb data 63 0))
      (X_set t2 64 (Sail.BitVec.extractLsb data 127 64)))

def decode_swpp_aarch64_instrs_memory_atomicops_swp_128 (Rt : (BitVec 5)) (Rn : (BitVec 5)) (opc : (BitVec 3)) (o3 : (BitVec 1)) (Rt2 : (BitVec 5)) (R : (BitVec 1)) (A : (BitVec 1)) (S : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveLSE128 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Rt2 == (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  let t2 := (BitVec.toNat Rt2)
  let n := (BitVec.toNat Rn)
  let acquire : Bool := (A == (0b1 : (BitVec 1)))
  let release : Bool := (R == (0b1 : (BitVec 1)))
  let tagchecked : Bool := (n != 31)
  (execute_aarch64_instrs_memory_atomicops_swp_128 acquire n release t t2 tagchecked)

/-- Type quantifiers: k_has_result : Bool, sys_crm : Nat, sys_crn : Nat, sys_op0 : Nat, sys_op1 :
  Nat, sys_op2 : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  sys_op2 ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  sys_op1 ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  sys_op0 = 1 ∧ 0 ≤ sys_crn ∧ sys_crn ≤ 15 ∧ 0 ≤ sys_crm ∧ sys_crm ≤ 15 -/
def execute_aarch64_instrs_system_sysops (has_result : Bool) (sys_crm : Nat) (sys_crn : Nat) (sys_op0 : Nat) (sys_op1 : Nat) (sys_op2 : Nat) (t : Nat) : SailM Unit := do
  bif has_result
  then (AArch64_SysInstrWithResult sys_op0 sys_op1 sys_crn sys_crm sys_op2 t)
  else (AArch64_SysInstr sys_op0 sys_op1 sys_crn sys_crm sys_op2 t)

def decode_sys_aarch64_instrs_system_sysops (Rt : (BitVec 5)) (op2 : (BitVec 3)) (CRm : (BitVec 4)) (CRn : (BitVec 4)) (op1 : (BitVec 3)) (L : (BitVec 1)) : SailM Unit := do
  (AArch64_CheckSystemAccess (0b01 : (BitVec 2)) op1 CRn CRm op2 Rt L)
  let t := (BitVec.toNat Rt)
  let sys_op0 := 1
  let sys_op1 := (BitVec.toNat op1)
  let sys_op2 := (BitVec.toNat op2)
  let sys_crn := (BitVec.toNat CRn)
  let sys_crm := (BitVec.toNat CRm)
  let has_result : Bool := (L == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_system_sysops has_result sys_crm sys_crn sys_op0 sys_op1 sys_op2 t)

def decode_sysl_aarch64_instrs_system_sysops (Rt : (BitVec 5)) (op2 : (BitVec 3)) (CRm : (BitVec 4)) (CRn : (BitVec 4)) (op1 : (BitVec 3)) (L : (BitVec 1)) : SailM Unit := do
  (AArch64_CheckSystemAccess (0b01 : (BitVec 2)) op1 CRn CRm op2 Rt L)
  let t := (BitVec.toNat Rt)
  let sys_op0 := 1
  let sys_op1 := (BitVec.toNat op1)
  let sys_op2 := (BitVec.toNat op2)
  let sys_crn := (BitVec.toNat CRn)
  let sys_crm := (BitVec.toNat CRm)
  let has_result : Bool := (L == (0b1 : (BitVec 1)))
  (execute_aarch64_instrs_system_sysops has_result sys_crm sys_crn sys_op0 sys_op1 sys_op2 t)

/-- Type quantifiers: sys_crm : Nat, sys_crn : Nat, sys_op0 : Nat, sys_op1 : Nat, sys_op2 : Nat, t :
  Nat, t2 : Nat, 1 ≤ t2 ∧
  t2 ≤ 32 ∧
  0 ≤ t ∧
  t ≤ 31 ∧
  sys_op2 ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  sys_op1 ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  sys_op0 = 1 ∧ 0 ≤ sys_crn ∧ sys_crn ≤ 15 ∧ 0 ≤ sys_crm ∧ sys_crm ≤ 15 -/
def execute_aarch64_instrs_system_sysops_128 (sys_crm : Nat) (sys_crn : Nat) (sys_op0 : Nat) (sys_op1 : Nat) (sys_op2 : Nat) (t : Nat) (t2 : Nat) : SailM Unit := do
  (AArch64_SysInstr128 sys_op0 sys_op1 sys_crn sys_crm sys_op2 t t2)

def decode_sysp_aarch64_instrs_system_sysops_128 (Rt : (BitVec 5)) (op2 : (BitVec 3)) (CRm : (BitVec 4)) (CRn : (BitVec 4)) (op1 : (BitVec 3)) (L : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveSysInstr128 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (((BitVec.join1 [(BitVec.access Rt 0)]) == (0b1 : (BitVec 1))) && (Rt != (0b11111 : (BitVec 5))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (AArch64_CheckSystemAccess (0b01 : (BitVec 2)) op1 CRn CRm op2 Rt L)
  let t := (BitVec.toNat Rt)
  let t2 :=
    bif (t == 31)
    then 31
    else (t +i 1)
  let sys_op0 := 1
  let sys_op1 := (BitVec.toNat op1)
  let sys_op2 := (BitVec.toNat op2)
  let sys_crn := (BitVec.toNat CRn)
  let sys_crm := (BitVec.toNat CRm)
  (execute_aarch64_instrs_system_sysops_128 sys_crm sys_crn sys_op0 sys_op1 sys_op2 t t2)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Nat, k_is_tbl : Bool, m : Nat, n__arg :
  Nat, regs : Nat, regs ∈ {1, 2, 3, 4} ∧
  0 ≤ n__arg ∧
  n__arg ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ elements ∈ {8, 16} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_vector_table (d : Nat) (datasize : Nat) (elements : Nat) (is_tbl : Bool) (m : Nat) (n__arg : Nat) (regs : Nat) : SailM Unit := do
  let n : Int := n__arg
  (CheckFPAdvSIMDEnabled64 ())
  let indices ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let table : (BitVec (128 * regs)) := (Zeros (n := (128 *i regs)))
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (n, table) ← (( do
    let loop_i_lower := 0
    let loop_i_upper := (regs -i 1)
    let mut loop_vars := (n, table)
    for i in [loop_i_lower:loop_i_upper:1]i do
      let (n, table) := loop_vars
      loop_vars ← do
        let table ←
          (pure (Sail.BitVec.updateSubrange table ((128 *i i) +i 127) (128 *i i)
              (← (V_read n 128))))
        let n : Int := (fmod_int (n +i 1) 32)
        (pure (n, table))
    (pure loop_vars) ) : SailM (Int × (BitVec (128 * regs))) )
  let result ← (( do
    bif is_tbl
    then (pure (Zeros (n := datasize)))
    else (V_read d datasize) ) : SailM (BitVec datasize) )
  let (index, result) ← (( do
    let loop_i_lower := 0
    let loop_i_upper := (elements -i 1)
    let mut loop_vars_1 := (index, result)
    for i in [loop_i_lower:loop_i_upper:1]i do
      let (index, result) := loop_vars_1
      loop_vars_1 ← do
        let index ← (pure (BitVec.toNat (← (Elem_read indices i 8))))
        let index := index
        let result ← (( do
          bif (index <b (16 *i regs))
          then
            (do
              (Elem_set result i 8 (← (Elem_read table index 8))))
          else (pure result) ) : SailM (BitVec datasize) )
        (pure (index, result))
    (pure loop_vars_1) ) : SailM (Int × (BitVec datasize)) )
  (V_set d datasize result)

def decode_tbl_advsimd_aarch64_instrs_vector_transfer_vector_table (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (len : (BitVec 2)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize 8)
  let regs := ((BitVec.toNat len) +i 1)
  let is_tbl : Bool := (op == (0b0 : (BitVec 1)))
  (execute_aarch64_instrs_vector_transfer_vector_table d datasize elements is_tbl m n regs)

def decode_tbx_advsimd_aarch64_instrs_vector_transfer_vector_table (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (len : (BitVec 2)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize 8)
  let regs := ((BitVec.toNat len) +i 1)
  let is_tbl : Bool := (op == (0b0 : (BitVec 1)))
  (execute_aarch64_instrs_vector_transfer_vector_table d datasize elements is_tbl m n regs)

/-- Type quantifiers: bit_pos : Nat, datasize : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ bit_pos ∧ bit_pos ≤ 63 -/
def execute_aarch64_instrs_branch_conditional_test (bit_pos : Nat) (bit_val : (BitVec 1)) (datasize : Nat) (offset : (BitVec 64)) (t : Nat) : SailM Unit := do
  let operand ← (( do (X_read t datasize) ) : SailM (BitVec datasize) )
  let branch_conditional : Bool := true
  assert (bit_pos <b datasize) "src/instrs64.sail:52130.43-52130.44"
  bif ((BitVec.join1 [(BitVec.access operand bit_pos)]) == bit_val)
  then (BranchTo ((← (PC_read ())) + offset) BranchType_DIR branch_conditional)
  else (BranchNotTaken BranchType_DIR branch_conditional)

def decode_tbnz_aarch64_instrs_branch_conditional_test (Rt : (BitVec 5)) (imm14 : (BitVec 14)) (b40 : (BitVec 5)) (op : (BitVec 1)) (b5 : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let datasize :=
    bif (b5 == (0b1 : (BitVec 1)))
    then 64
    else 32
  let bit_pos := (BitVec.toNat (b5 ++ b40))
  let bit_val : (BitVec 1) := op
  let offset : (BitVec 64) := (sign_extend (imm14 ++ (0b00 : (BitVec 2))) 64)
  (execute_aarch64_instrs_branch_conditional_test bit_pos bit_val datasize offset t)

def decode_tbz_aarch64_instrs_branch_conditional_test (Rt : (BitVec 5)) (imm14 : (BitVec 14)) (b40 : (BitVec 5)) (op : (BitVec 1)) (b5 : (BitVec 1)) : SailM Unit := do
  let t := (BitVec.toNat Rt)
  let datasize :=
    bif (b5 == (0b1 : (BitVec 1)))
    then 64
    else 32
  let bit_pos := (BitVec.toNat (b5 ++ b40))
  let bit_val : (BitVec 1) := op
  let offset : (BitVec 64) := (sign_extend (imm14 ++ (0b00 : (BitVec 2))) 64)
  (execute_aarch64_instrs_branch_conditional_test bit_pos bit_val datasize offset t)

/-- Type quantifiers: k_retry : Bool -/
def execute_aarch64_instrs_system_tme_tcancel (reason : (BitVec 15)) (retry : Bool) : SailM Unit := do
  bif (! (← (IsTMEEnabled ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((← readReg TSTATE).depth >b 0)
  then (FailTransaction__1 TMFailure_CNCL retry false reason)
  else (pure ())

def decode_tcancel_aarch64_instrs_system_tme_tcancel (imm16 : (BitVec 16)) : SailM Unit := do
  bif (! (← (HaveTME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let retry : Bool := ((BitVec.join1 [(BitVec.access imm16 15)]) == (0b1 : (BitVec 1)))
  let reason : (BitVec 15) := (Sail.BitVec.extractLsb imm16 14 0)
  (execute_aarch64_instrs_system_tme_tcancel reason retry)

def execute_aarch64_instrs_system_tme_tcommit (_ : Unit) : SailM Unit := do
  bif (! (← (IsTMEEnabled ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((← readReg TSTATE).depth == 0)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif ((← readReg TSTATE).depth == 1)
  then
    (let _ : Unit := (CommitTransactionalWrites ())
    (pure (ClearExclusiveLocal (ProcessorID ()))))
  else (pure ())
  writeReg TSTATE { (← readReg TSTATE) with depth := ((← readReg TSTATE).depth -i 1) }

def decode_tcommit_aarch64_instrs_system_tme_tcommit (_ : Unit) : SailM Unit := do
  bif (! (← (HaveTME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_system_tme_tcommit ())

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, m : Nat, n : Nat, pairs : Int, part :
  Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_vector_permute_transpose (d : Nat) (datasize : Nat) (esize : Nat) (m : Nat) (n : Nat) (pairs : Int) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand1 ((2 *i p) +i part) esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand2 ((2 *i p) +i part) esize)))
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_trn1_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let part := (BitVec.toNat op)
  let pairs := (Int.ediv elements 2)
  (execute_aarch64_instrs_vector_transfer_vector_permute_transpose d datasize esize m n pairs part)

def decode_trn2_advsimd_aarch64_instrs_vector_transfer_vector_permute_transpose (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let part := (BitVec.toNat op)
  let pairs := (Int.ediv elements 2)
  (execute_aarch64_instrs_vector_transfer_vector_permute_transpose d datasize esize m n pairs part)

/-- Type quantifiers: VL : Nat, t : Nat, 0 ≤ t ∧ t ≤ 31 ∧ is_VL(VL) -/
def execute_aarch64_instrs_system_tme_tstart (VL : Nat) (t : Nat) : SailM Unit := do
  bif (! (← (IsTMEEnabled ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let IsEL1Regime ← (( do (undefined_bool ()) ) : SailM Bool )
  let tme ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let tmt ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let questionMark ← do (pure (← readReg PSTATE).EL)
  bif (questionMark == EL0)
  then
    (do
      let IsEL1Regime ← (( do (pure ((← (S1TranslationRegime__1 ())) == EL1)) ) : SailM Bool )
      bif IsEL1Regime
      then
        (do
          let tme ← (pure (_get_SCTLR_EL1_Type_TME0 (← readReg SCTLR_EL1)))
          let tmt ← (pure (_get_SCTLR_EL1_Type_TMT0 (← readReg SCTLR_EL1)))
          (pure ()))
      else
        (do
          let tme ← (pure (_get_SCTLR_EL2_Type_TME0 (← readReg SCTLR_EL2)))
          let tmt ← (pure (_get_SCTLR_EL2_Type_TMT0 (← readReg SCTLR_EL2)))
          (pure ())))
  else
    (do
      bif (questionMark == EL1)
      then
        (do
          let tme ← (pure (_get_SCTLR_EL1_Type_TME (← readReg SCTLR_EL1)))
          let tmt ← (pure (_get_SCTLR_EL1_Type_TMT (← readReg SCTLR_EL1)))
          (pure ()))
      else
        (do
          bif (questionMark == EL2)
          then
            (do
              let tme ← (pure (_get_SCTLR_EL2_Type_TME (← readReg SCTLR_EL2)))
              let tmt ← (pure (_get_SCTLR_EL2_Type_TMT (← readReg SCTLR_EL2)))
              (pure ()))
          else
            (do
              bif (questionMark == EL3)
              then
                (do
                  let tme ← (pure (_get_SCTLR_EL3_Type_TME (← readReg SCTLR_EL3)))
                  let tmt ← (pure (_get_SCTLR_EL3_Type_TMT (← readReg SCTLR_EL3)))
                  (pure ()))
              else (Unreachable ()))))
  let enable : Bool := (tme == (0b1 : (BitVec 1)))
  let trivial : Bool := (tmt == (0b1 : (BitVec 1)))
  bif (! enable)
  then (TransactionStartTrap t)
  else
    (do
      bif trivial
      then
        (do
          writeReg TSTATE { (← readReg TSTATE) with nPC := (← (NextInstrAddr 64)) }
          writeReg TSTATE { (← readReg TSTATE) with Rt := t }
          (FailTransaction TMFailure_TRIVIAL false))
      else
        (do
          bif ((← (HaveSME ())) && ((← readReg PSTATE).SM == (0b1 : (BitVec 1))))
          then (FailTransaction TMFailure_ERR false)
          else
            (do
              bif ((← readReg TSTATE).depth == 255)
              then (FailTransaction TMFailure_NEST false)
              else
                (do
                  bif ((← readReg TSTATE).depth == 0)
                  then
                    (do
                      writeReg TSTATE { (← readReg TSTATE) with nPC := (← (NextInstrAddr 64)) }
                      writeReg TSTATE { (← readReg TSTATE) with Rt := t }
                      let _ : Unit := (ClearExclusiveLocal (ProcessorID ()))
                      (TakeTransactionCheckpoint VL (Int.ediv VL 8))
                      (pure (StartTrackingTransactionalReadsWrites ())))
                  else (pure ())))))
  writeReg TSTATE { (← readReg TSTATE) with depth := ((← readReg TSTATE).depth +i 1) }
  (X_set t 64 (Zeros (n := 64)))

def decode_tstart_aarch64_instrs_system_tme_tstart (Rt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (! (← (HaveTME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  match VL with
  | 128 => (execute_aarch64_instrs_system_tme_tstart 128 t)
  | 256 => (execute_aarch64_instrs_system_tme_tstart 256 t)
  | 512 => (execute_aarch64_instrs_system_tme_tstart 512 t)
  | 1024 => (execute_aarch64_instrs_system_tme_tstart 1024 t)
  | 2048 => (execute_aarch64_instrs_system_tme_tstart 2048 t)
  | _ => (pure ())

/-- Type quantifiers: t : Nat, 0 ≤ t ∧ t ≤ 31 -/
def execute_aarch64_instrs_system_tme_ttest (t : Nat) : SailM Unit := do
  bif (! (← (IsTMEEnabled ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (X_set t 64 (integer_subrange (← readReg TSTATE).depth 63 0))

def decode_ttest_aarch64_instrs_system_tme_ttest (Rt : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveTME ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Rt)
  (execute_aarch64_instrs_system_tme_ttest t)

def execute_aarch64_instrs_udf (_ : Unit) : Unit :=
  ()

def decode_udf_perm_undef_aarch64_instrs_udf (imm16 : (BitVec 16)) : SailM Unit := do
  sailThrow ((Error_Undefined ()))

/-- Type quantifiers: d : Nat, datasize : Nat, imm : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ imm ∧ imm ≤ 255 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_max_min_umax_imm (d : Nat) (datasize : Nat) (imm : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let result := (Max.max (BitVec.toNat operand1) imm)
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_umax_imm_aarch64_instrs_integer_arithmetic_max_min_umax_imm (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm8 : (BitVec 8)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  let imm := (BitVec.toNat imm8)
  (execute_aarch64_instrs_integer_arithmetic_max_min_umax_imm d datasize imm n)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_max_min_umax_reg (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let result := (Max.max (BitVec.toNat operand1) (BitVec.toNat operand2))
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_umax_reg_aarch64_instrs_integer_arithmetic_max_min_umax_reg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_integer_arithmetic_max_min_umax_reg d datasize m n)

/-- Type quantifiers: d : Nat, datasize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_max_min_umin_reg (d : Nat) (datasize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (X_read m datasize) ) : SailM (BitVec datasize) )
  let result := (Min.min (BitVec.toNat operand1) (BitVec.toNat operand2))
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_umin_reg_aarch64_instrs_integer_arithmetic_max_min_umin_reg (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_integer_arithmetic_max_min_umin_reg d datasize m n)

/-- Type quantifiers: d : Nat, datasize : Nat, imm : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ imm ∧ imm ≤ 255 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_arithmetic_max_min_umin_imm (d : Nat) (datasize : Nat) (imm : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← (( do (X_read n datasize) ) : SailM (BitVec datasize) )
  let result := (Min.min (BitVec.toNat operand1) imm)
  (X_set d datasize (integer_subrange result (datasize -i 1) 0))

def decode_umin_imm_aarch64_instrs_integer_arithmetic_max_min_umin_imm (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm8 : (BitVec 8)) (sf : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveCSSC ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let datasize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  let imm := (BitVec.toNat imm8)
  (execute_aarch64_instrs_integer_arithmetic_max_min_umin_imm d datasize imm n)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, idxdsize : Nat, index : Int, n : Nat, 0
  ≤ n ∧
  n ≤ 31 ∧
  idxdsize ∈ {64, 128} ∧
  esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_integer_move_unsigned (d : Nat) (datasize : Nat) (esize : Nat) (idxdsize : Nat) (index : Int) (n : Nat) : SailM Unit := do
  bif (index == 0)
  then (CheckFPEnabled64 ())
  else (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n idxdsize) ) : SailM (BitVec idxdsize) )
  assert (datasize ≥b esize) "src/instrs64.sail:52593.42-52593.43"
  (X_set d datasize (Sail.BitVec.zeroExtend (← (Elem_read operand index esize)) datasize))

def decode_umov_advsimd_aarch64_instrs_vector_transfer_integer_move_unsigned (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm5 : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let size : Int := 0
  let b__0 := (Q ++ imm5)
  bif (((Sail.BitVec.extractLsb b__0 5 5) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb b__0 0
           0) == (0b1 : (BitVec 1))))
  then
    (let size : Int := 0
    (pure ()))
  else
    (do
      bif (((Sail.BitVec.extractLsb b__0 5 5) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
               b__0 1 0) == (0b10 : (BitVec 2))))
      then
        (let size : Int := 1
        (pure ()))
      else
        (do
          bif (((Sail.BitVec.extractLsb b__0 5 5) == (0b0 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                   b__0 2 0) == (0b100 : (BitVec 3))))
          then
            (let size : Int := 2
            (pure ()))
          else
            (do
              bif (((Sail.BitVec.extractLsb b__0 5 5) == (0b1 : (BitVec 1))) && ((Sail.BitVec.extractLsb
                       b__0 3 0) == (0x8 : (BitVec 4))))
              then
                (let size : Int := 3
                (pure ()))
              else sailThrow ((Error_Undefined ())))))
  let size := size
  let idxdsize :=
    bif ((BitVec.join1 [(BitVec.access imm5 4)]) == (0b1 : (BitVec 1)))
    then 128
    else 64
  let index := (BitVec.toNat (Sail.BitVec.extractLsb imm5 4 (size +i 1)))
  let esize := (Int.shiftl 8 size)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 64
    else 32
  (execute_aarch64_instrs_vector_transfer_integer_move_unsigned d datasize esize idxdsize index n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_special_recip_int (d : Nat) (datasize : Nat) (elements : Int) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e 32)
        let result ← (Elem_set result e 32 (← (UnsignedRecipEstimate element)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_urecpe_advsimd_aarch64_instrs_vector_arithmetic_unary_special_recip_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_special_recip_int d datasize elements n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int (d : Nat) (datasize : Nat) (elements : Int) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e 32)
        let result ← (Elem_set result e 32 (← (UnsignedRSqrtEstimate element)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec datasize)) )
  (V_set d datasize result)

def decode_ursqrte_advsimd_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int (Rd : (BitVec 5)) (Rn : (BitVec 5)) (sz : (BitVec 1)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (sz == (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_special_sqrt_est_int d datasize elements n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ elements ∈ {2, 4} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_usdot (d : Nat) (datasize : Nat) (elements : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (V_read d datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let res ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let res ← (( do
          let loop_b_lower := 0
          let loop_b_upper := 3
          let mut loop_vars_1 := res
          for b in [loop_b_lower:loop_b_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((4 *i e) +i b) 8))))
              let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 ((4 *i e) +i b) 8))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec 32) )
        (Elem_set result e 32 res)
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_usdot_advsimd_vec_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_usdot (Rd : (BitVec 5)) (Rn : (BitVec 5)) (Rm : (BitVec 5)) (Q : (BitVec 1)) : SailM Unit := do
  bif (! (← (HaveInt8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Rd)
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize 32)
  (execute_aarch64_instrs_vector_arithmetic_binary_uniform_mat_mul_int_usdot d datasize elements m n)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, part :
  Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_vector_permute_unzip (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operandl ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operandh ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let zipped : (BitVec (datasize * 2)) := (operandh ++ operandl)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do (Elem_set result e esize (← (Elem_read zipped ((2 *i e) +i part) esize)))
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_uzp1_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let part := (BitVec.toNat op)
  (execute_aarch64_instrs_vector_transfer_vector_permute_unzip d datasize elements esize m n part)

def decode_uzp2_advsimd_aarch64_instrs_vector_transfer_vector_permute_unzip (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let part := (BitVec.toNat op)
  (execute_aarch64_instrs_vector_transfer_vector_permute_unzip d datasize elements esize m n part)

/-- Type quantifiers: d : Nat, 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_system_sysinstwithreg_wfet (d : Nat) : SailM Unit := do
  let localtimeout ← do (pure (BitVec.toNat (← (X_read d 64))))
  bif ((← (Halted ())) && (← (ConstrainUnpredictableBool Unpredictable_WFxTDEBUG)))
  then (EndOfInstruction ())
  else (pure ())
  (Hint_WFE localtimeout WFxType_WFET)

def decode_wfet_aarch64_instrs_system_sysinstwithreg_wfet (Rd : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveFeatWFxT ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_system_sysinstwithreg_wfet d)

/-- Type quantifiers: d : Nat, 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_system_sysinstwithreg_wfit (d : Nat) : SailM Unit := do
  let localtimeout ← do (pure (BitVec.toNat (← (X_read d 64))))
  bif ((← (Halted ())) && (← (ConstrainUnpredictableBool Unpredictable_WFxTDEBUG)))
  then (EndOfInstruction ())
  else (pure ())
  (Hint_WFI localtimeout WFxType_WFIT)

def decode_wfit_aarch64_instrs_system_sysinstwithreg_wfit (Rd : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveFeatWFxT ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  (execute_aarch64_instrs_system_sysinstwithreg_wfit d)

def execute_aarch64_instrs_integer_flags_xaflag (_ : Unit) : SailM Unit := do
  let n ← (( do
    (pure ((Complement.complement (← readReg PSTATE).C) &&& (Complement.complement
          (← readReg PSTATE).Z))) ) : SailM (BitVec 1) )
  let z ← (( do (pure ((← readReg PSTATE).Z &&& (← readReg PSTATE).C)) ) : SailM (BitVec 1) )
  let c ← (( do (pure ((← readReg PSTATE).C ||| (← readReg PSTATE).Z)) ) : SailM (BitVec 1) )
  let v ← (( do (pure ((Complement.complement (← readReg PSTATE).C) &&& (← readReg PSTATE).Z))
    ) : SailM (BitVec 1) )
  writeReg PSTATE { (← readReg PSTATE) with N := n }
  writeReg PSTATE { (← readReg PSTATE) with Z := z }
  writeReg PSTATE { (← readReg PSTATE) with C := c }
  writeReg PSTATE { (← readReg PSTATE) with V := v }

def decode_xaflag_aarch64_instrs_integer_flags_xaflag (CRm : (BitVec 4)) : SailM Unit := do
  bif (! (← (HaveFlagFormatExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_integer_flags_xaflag ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_crypto_sha3_xar (d : Nat) (imm6 : (BitVec 6)) (m : Nat) (n : Nat) : SailM Unit := do
  (AArch64_CheckFPAdvSIMDEnabled ())
  let Vm ← (( do (V_read m 128) ) : SailM (BitVec 128) )
  let Vn ← (( do (V_read n 128) ) : SailM (BitVec 128) )
  let tmp : (BitVec 128) := (Vn ^^^ Vm)
  (V_set d 128
    ((ROR (Sail.BitVec.extractLsb tmp 127 64) (BitVec.toNat imm6)) ++ (ROR
        (Sail.BitVec.extractLsb tmp 63 0) (BitVec.toNat imm6))))

def decode_xar_advsimd_aarch64_instrs_vector_crypto_sha3_xar (Rd : (BitVec 5)) (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rm : (BitVec 5)) : SailM Unit := do
  bif (! (← (HaveSHA3Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  (execute_aarch64_instrs_vector_crypto_sha3_xar d imm6 m n)

/-- Type quantifiers: d : Nat, k_data : Bool, 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_integer_pac_strip_dp_1src (d : Nat) (data : Bool) : SailM Unit := do
  bif (← (HavePACExt ()))
  then (X_set d 64 (← (Strip (← (X_read d 64)) data)))
  else (pure ())

def decode_xpac_aarch64_instrs_integer_pac_strip_dp_1src (Rd : (BitVec 5)) (Rn : (BitVec 5)) (D : (BitVec 1)) : SailM Unit := do
  let data : Bool := (D == (0b1 : (BitVec 1)))
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (! (← (HavePACExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (n != 31)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch64_instrs_integer_pac_strip_dp_1src d data)

def decode_xpac_aarch64_instrs_integer_pac_strip_hint (_ : Unit) : SailM Unit := do
  let d := 30
  let data : Bool := false
  (execute_aarch64_instrs_integer_pac_strip_dp_1src d data)

/-- Type quantifiers: d : Nat, datasize : Nat, elements : Int, esize : Nat, n : Nat, part : Nat, part
  ∈ {0, 1} ∧
  0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_arithmetic_unary_extract_nosat (d : Nat) (datasize : Nat) (elements : Int) (esize : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand ← (( do (V_read n (2 *i datasize)) ) : SailM (BitVec (2 * datasize)) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let element ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let (element, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand e (2 *i esize))
        let result ← (Elem_set result e esize (Sail.BitVec.extractLsb element (esize -i 1) 0))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec (2 * esize)) × (BitVec datasize)) )
  (Vpart_set d part datasize result)

def decode_xtn_advsimd_aarch64_instrs_vector_arithmetic_unary_extract_nosat (Rd : (BitVec 5)) (Rn : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  bif (size == (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize := 64
  let part := (BitVec.toNat Q)
  let elements := (Int.ediv datasize esize)
  (execute_aarch64_instrs_vector_arithmetic_unary_extract_nosat d datasize elements esize n part)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, m : Nat, n : Nat, pairs : Int, part :
  Nat, part ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ datasize ∈ {64, 128} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch64_instrs_vector_transfer_vector_permute_zip (d : Nat) (datasize : Nat) (esize : Nat) (m : Nat) (n : Nat) (pairs : Int) (part : Nat) : SailM Unit := do
  (CheckFPAdvSIMDEnabled64 ())
  let operand1 ← (( do (V_read n datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (V_read m datasize) ) : SailM (BitVec datasize) )
  let result ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let base := (part *i pairs)
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand1 (base +i p) esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand2 (base +i p) esize)))
    (pure loop_vars) ) : SailM (BitVec datasize) )
  (V_set d datasize result)

def decode_zip1_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let part := (BitVec.toNat op)
  let pairs := (Int.ediv elements 2)
  (execute_aarch64_instrs_vector_transfer_vector_permute_zip d datasize esize m n pairs part)

def decode_zip2_advsimd_aarch64_instrs_vector_transfer_vector_permute_zip (Rd : (BitVec 5)) (Rn : (BitVec 5)) (op : (BitVec 1)) (Rm : (BitVec 5)) (size : (BitVec 2)) (Q : (BitVec 1)) : SailM Unit := do
  let d := (BitVec.toNat Rd)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  bif ((size ++ Q) == (0b110 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let datasize :=
    bif (Q == (0b1 : (BitVec 1)))
    then 128
    else 64
  let elements := (Int.ediv datasize esize)
  let part := (BitVec.toNat op)
  let pairs := (Int.ediv elements 2)
  (execute_aarch64_instrs_vector_transfer_vector_permute_zip d datasize esize m n pairs part)

