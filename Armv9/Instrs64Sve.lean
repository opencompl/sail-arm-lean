import Armv9.Instrs64

set_option maxHeartbeats 1_000_000_000
set_option maxRecDepth 10_000
set_option linter.unusedVariables false
set_option match.ignoreUnusedAlts true

open Sail

noncomputable section

namespace Armv9.Functions

open signal
open option
open exception
open arm_acc_type
open __InstrEnc
open WFxType
open VFPNegMul
open VCGTtype
open VCGEType
open VBitOps
open VBitOp
open VARange
open Unpredictable
open TranslationStage
open TimeStamp
open TMFailure
open TLBIOp
open TLBIMemAttr
open TLBILevel
open TGx
open SystemHintOp
open Signal
open ShiftType
open Shareability
open SecurityState
open SVECmp
open SRType
open SMEExceptionType
open SDFType
open RestrictType
open Register
open Regime
open ReduceOp
open PrivilegeLevel
open PrefetchHint
open PSTATEField
open PGSe
open PASpace
open PARTIDspaceType
open OpType
open MoveWideOp
open MemType
open MemTagType
open MemOp
open MemAtomicOp
open MOPSStage
open MBReqTypes
open MBReqDomain
open LogicalOp
open InterruptID
open InstrSet
open ImmediateOp
open GPCF
open GCSInstruction
open Feature
open Fault
open FPUnaryOp
open FPType
open FPRounding
open FPMaxMinOp
open FPExc
open FPConvOp
open ExtendType
open ExceptionalOccurrenceTargetState
open Exception
open ErrorState
open DeviceType
open DescriptorType
open DSBAlias
open CrossTriggerIn
open CountOp
open Constraint
open CompareOp
open CacheType
open CachePASpace
open CacheOpScope
open CacheOp
open BranchType
open Barrier
open ArchVersion
open AccessType
open ATAccess

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FADD_Z_P_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:56.53-56.54"
            (Elem_set result e esize (← (FPAdd element1 imm (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FADD_Z_P_ZS__ (size : (BitVec 2)) (Pg : (BitVec 3)) (i1 : (BitVec 1)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do
    bif (BEq.beq i1 (0b0 : (BitVec 1)))
    then
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:79.49-79.50"
        (FPPointFive (0b0 : (BitVec 1)) esize))
    else
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:82.49-82.50"
        (FPOne (0b0 : (BitVec 1)) esize)) ) : SailM (BitVec esize) )
  match VL with
  | 128 => (execute_FADD_Z_P_ZS__ 128 dn esize g imm)
  | 256 => (execute_FADD_Z_P_ZS__ 256 dn esize g imm)
  | 512 => (execute_FADD_Z_P_ZS__ 512 dn esize g imm)
  | 1024 => (execute_FADD_Z_P_ZS__ 1024 dn esize g imm)
  | 2048 => (execute_FADD_Z_P_ZS__ 2048 dn esize g imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FSUB_Z_P_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:129.53-129.54"
            (Elem_set result e esize (← (FPSub element1 imm (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FSUB_Z_P_ZS__ (size : (BitVec 2)) (Pg : (BitVec 3)) (i1 : (BitVec 1)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do
    bif (BEq.beq i1 (0b0 : (BitVec 1)))
    then
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:152.49-152.50"
        (FPPointFive (0b0 : (BitVec 1)) esize))
    else
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:155.49-155.50"
        (FPOne (0b0 : (BitVec 1)) esize)) ) : SailM (BitVec esize) )
  match VL with
  | 128 => (execute_FSUB_Z_P_ZS__ 128 dn esize g imm)
  | 256 => (execute_FSUB_Z_P_ZS__ 256 dn esize g imm)
  | 512 => (execute_FSUB_Z_P_ZS__ 512 dn esize g imm)
  | 1024 => (execute_FSUB_Z_P_ZS__ 1024 dn esize g imm)
  | 2048 => (execute_FSUB_Z_P_ZS__ 2048 dn esize g imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMUL_Z_P_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:202.53-202.54"
            (Elem_set result e esize (← (FPMul element1 imm (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMUL_Z_P_ZS__ (size : (BitVec 2)) (Pg : (BitVec 3)) (i1 : (BitVec 1)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do
    bif (BEq.beq i1 (0b0 : (BitVec 1)))
    then
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:225.49-225.50"
        (FPPointFive (0b0 : (BitVec 1)) esize))
    else
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:228.49-228.50"
        (FPTwo (0b0 : (BitVec 1)) esize)) ) : SailM (BitVec esize) )
  match VL with
  | 128 => (execute_FMUL_Z_P_ZS__ 128 dn esize g imm)
  | 256 => (execute_FMUL_Z_P_ZS__ 256 dn esize g imm)
  | 512 => (execute_FMUL_Z_P_ZS__ 512 dn esize g imm)
  | 1024 => (execute_FMUL_Z_P_ZS__ 1024 dn esize g imm)
  | 2048 => (execute_FMUL_Z_P_ZS__ 2048 dn esize g imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FSUBR_Z_P_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:275.53-275.54"
            (Elem_set result e esize (← (FPSub imm element1 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FSUBR_Z_P_ZS__ (size : (BitVec 2)) (Pg : (BitVec 3)) (i1 : (BitVec 1)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do
    bif (BEq.beq i1 (0b0 : (BitVec 1)))
    then
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:298.49-298.50"
        (FPPointFive (0b0 : (BitVec 1)) esize))
    else
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:301.49-301.50"
        (FPOne (0b0 : (BitVec 1)) esize)) ) : SailM (BitVec esize) )
  match VL with
  | 128 => (execute_FSUBR_Z_P_ZS__ 128 dn esize g imm)
  | 256 => (execute_FSUBR_Z_P_ZS__ 256 dn esize g imm)
  | 512 => (execute_FSUBR_Z_P_ZS__ 512 dn esize g imm)
  | 1024 => (execute_FSUBR_Z_P_ZS__ 1024 dn esize g imm)
  | 2048 => (execute_FSUBR_Z_P_ZS__ 2048 dn esize g imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXNM_Z_P_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:348.53-348.54"
            (Elem_set result e esize (← (FPMaxNum element1 imm (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMAXNM_Z_P_ZS__ (size : (BitVec 2)) (Pg : (BitVec 3)) (i1 : (BitVec 1)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do
    bif (BEq.beq i1 (0b0 : (BitVec 1)))
    then (pure (Zeros (n := esize)))
    else
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:371.49-371.50"
        (FPOne (0b0 : (BitVec 1)) esize)) ) : SailM (BitVec esize) )
  match VL with
  | 128 => (execute_FMAXNM_Z_P_ZS__ 128 dn esize g imm)
  | 256 => (execute_FMAXNM_Z_P_ZS__ 256 dn esize g imm)
  | 512 => (execute_FMAXNM_Z_P_ZS__ 512 dn esize g imm)
  | 1024 => (execute_FMAXNM_Z_P_ZS__ 1024 dn esize g imm)
  | 2048 => (execute_FMAXNM_Z_P_ZS__ 2048 dn esize g imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMINNM_Z_P_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:418.53-418.54"
            (Elem_set result e esize (← (FPMinNum element1 imm (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMINNM_Z_P_ZS__ (size : (BitVec 2)) (Pg : (BitVec 3)) (i1 : (BitVec 1)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do
    bif (BEq.beq i1 (0b0 : (BitVec 1)))
    then (pure (Zeros (n := esize)))
    else
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:441.49-441.50"
        (FPOne (0b0 : (BitVec 1)) esize)) ) : SailM (BitVec esize) )
  match VL with
  | 128 => (execute_FMINNM_Z_P_ZS__ 128 dn esize g imm)
  | 256 => (execute_FMINNM_Z_P_ZS__ 256 dn esize g imm)
  | 512 => (execute_FMINNM_Z_P_ZS__ 512 dn esize g imm)
  | 1024 => (execute_FMINNM_Z_P_ZS__ 1024 dn esize g imm)
  | 2048 => (execute_FMINNM_Z_P_ZS__ 2048 dn esize g imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAX_Z_P_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:488.53-488.54"
            (Elem_set result e esize (← (FPMax element1 imm (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMAX_Z_P_ZS__ (size : (BitVec 2)) (Pg : (BitVec 3)) (i1 : (BitVec 1)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do
    bif (BEq.beq i1 (0b0 : (BitVec 1)))
    then (pure (Zeros (n := esize)))
    else
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:511.49-511.50"
        (FPOne (0b0 : (BitVec 1)) esize)) ) : SailM (BitVec esize) )
  match VL with
  | 128 => (execute_FMAX_Z_P_ZS__ 128 dn esize g imm)
  | 256 => (execute_FMAX_Z_P_ZS__ 256 dn esize g imm)
  | 512 => (execute_FMAX_Z_P_ZS__ 512 dn esize g imm)
  | 1024 => (execute_FMAX_Z_P_ZS__ 1024 dn esize g imm)
  | 2048 => (execute_FMAX_Z_P_ZS__ 2048 dn esize g imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMIN_Z_P_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:558.53-558.54"
            (Elem_set result e esize (← (FPMin element1 imm (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMIN_Z_P_ZS__ (size : (BitVec 2)) (Pg : (BitVec 3)) (i1 : (BitVec 1)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do
    bif (BEq.beq i1 (0b0 : (BitVec 1)))
    then (pure (Zeros (n := esize)))
    else
      (do
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:581.49-581.50"
        (FPOne (0b0 : (BitVec 1)) esize)) ) : SailM (BitVec esize) )
  match VL with
  | 128 => (execute_FMIN_Z_P_ZS__ 128 dn esize g imm)
  | 256 => (execute_FMIN_Z_P_ZS__ 256 dn esize g imm)
  | 512 => (execute_FMIN_Z_P_ZS__ 512 dn esize g imm)
  | 1024 => (execute_FMIN_Z_P_ZS__ 1024 dn esize g imm)
  | 2048 => (execute_FMIN_Z_P_ZS__ 2048 dn esize g imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMGE_P_P_Z0__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:635.59-635.60"
                  (FPCompareEQ element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:639.59-639.60"
                  (FPCompareGE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:643.59-643.60"
                  (FPCompareGT element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:647.59-647.60"
                  (FPCompareNE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:651.117-651.118"
                  (FPCompareGT (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:655.117-655.118"
                  (FPCompareGE (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | _ => (pure res) ) : SailM Bool )
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMGE_P_P_Z0__ (size : (BitVec 2)) (eq : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GE
  match VL with
  | 128 => (execute_FCMGE_P_P_Z0__ 128 d esize g n op)
  | 256 => (execute_FCMGE_P_P_Z0__ 256 d esize g n op)
  | 512 => (execute_FCMGE_P_P_Z0__ 512 d esize g n op)
  | 1024 => (execute_FCMGE_P_P_Z0__ 1024 d esize g n op)
  | 2048 => (execute_FCMGE_P_P_Z0__ 2048 d esize g n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMGT_P_P_Z0__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:738.59-738.60"
                  (FPCompareEQ element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:742.59-742.60"
                  (FPCompareGE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:746.59-746.60"
                  (FPCompareGT element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:750.59-750.60"
                  (FPCompareNE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:754.117-754.118"
                  (FPCompareGT (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:758.117-758.118"
                  (FPCompareGE (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | _ => (pure res) ) : SailM Bool )
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMGT_P_P_Z0__ (size : (BitVec 2)) (eq : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GT
  match VL with
  | 128 => (execute_FCMGT_P_P_Z0__ 128 d esize g n op)
  | 256 => (execute_FCMGT_P_P_Z0__ 256 d esize g n op)
  | 512 => (execute_FCMGT_P_P_Z0__ 512 d esize g n op)
  | 1024 => (execute_FCMGT_P_P_Z0__ 1024 d esize g n op)
  | 2048 => (execute_FCMGT_P_P_Z0__ 2048 d esize g n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMLT_P_P_Z0__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:841.59-841.60"
                  (FPCompareEQ element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:845.59-845.60"
                  (FPCompareGE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:849.59-849.60"
                  (FPCompareGT element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:853.59-853.60"
                  (FPCompareNE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:857.117-857.118"
                  (FPCompareGT (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:861.117-861.118"
                  (FPCompareGE (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | _ => (pure res) ) : SailM Bool )
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMLT_P_P_Z0__ (size : (BitVec 2)) (eq : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_LT
  match VL with
  | 128 => (execute_FCMLT_P_P_Z0__ 128 d esize g n op)
  | 256 => (execute_FCMLT_P_P_Z0__ 256 d esize g n op)
  | 512 => (execute_FCMLT_P_P_Z0__ 512 d esize g n op)
  | 1024 => (execute_FCMLT_P_P_Z0__ 1024 d esize g n op)
  | 2048 => (execute_FCMLT_P_P_Z0__ 2048 d esize g n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMLE_P_P_Z0__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:944.59-944.60"
                  (FPCompareEQ element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:948.59-948.60"
                  (FPCompareGE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:952.59-952.60"
                  (FPCompareGT element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:956.59-956.60"
                  (FPCompareNE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:960.117-960.118"
                  (FPCompareGT (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:964.117-964.118"
                  (FPCompareGE (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | _ => (pure res) ) : SailM Bool )
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMLE_P_P_Z0__ (size : (BitVec 2)) (eq : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_LE
  match VL with
  | 128 => (execute_FCMLE_P_P_Z0__ 128 d esize g n op)
  | 256 => (execute_FCMLE_P_P_Z0__ 256 d esize g n op)
  | 512 => (execute_FCMLE_P_P_Z0__ 512 d esize g n op)
  | 1024 => (execute_FCMLE_P_P_Z0__ 1024 d esize g n op)
  | 2048 => (execute_FCMLE_P_P_Z0__ 2048 d esize g n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMEQ_P_P_Z0__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:1047.59-1047.60"
                  (FPCompareEQ element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:1051.59-1051.60"
                  (FPCompareGE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:1055.59-1055.60"
                  (FPCompareGT element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:1059.59-1059.60"
                  (FPCompareNE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:1063.117-1063.118"
                  (FPCompareGT (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:1067.117-1067.118"
                  (FPCompareGE (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | _ => (pure res) ) : SailM Bool )
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMEQ_P_P_Z0__ (size : (BitVec 2)) (eq : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_EQ
  match VL with
  | 128 => (execute_FCMEQ_P_P_Z0__ 128 d esize g n op)
  | 256 => (execute_FCMEQ_P_P_Z0__ 256 d esize g n op)
  | 512 => (execute_FCMEQ_P_P_Z0__ 512 d esize g n op)
  | 1024 => (execute_FCMEQ_P_P_Z0__ 1024 d esize g n op)
  | 2048 => (execute_FCMEQ_P_P_Z0__ 2048 d esize g n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMNE_P_P_Z0__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:1150.59-1150.60"
                  (FPCompareEQ element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:1154.59-1154.60"
                  (FPCompareGE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:1158.59-1158.60"
                  (FPCompareGT element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:1162.59-1162.60"
                  (FPCompareNE element (integer_subrange 0 (esize -i 1) 0) (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:1166.117-1166.118"
                  (FPCompareGT (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 16)
                    (Bool.or (BEq.beq (((esize -i 1) -i 0) +i 1) 32)
                      (BEq.beq (((esize -i 1) -i 0) +i 1) 64))) "src/instrs64_sve.sail:1170.117-1170.118"
                  (FPCompareGE (integer_subrange 0 (esize -i 1) 0) element (← (FPCR_read ()))))
              | _ => (pure res) ) : SailM Bool )
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMNE_P_P_Z0__ (size : (BitVec 2)) (eq : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_NE
  match VL with
  | 128 => (execute_FCMNE_P_P_Z0__ 128 d esize g n op)
  | 256 => (execute_FCMNE_P_P_Z0__ 256 d esize g n op)
  | 512 => (execute_FCMNE_P_P_Z0__ 512 d esize g n op)
  | 1024 => (execute_FCMNE_P_P_Z0__ 1024 d esize g n op)
  | 2048 => (execute_FCMNE_P_P_Z0__ 2048 d esize g n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FADDA_V_P_Z__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (V_read dn esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec esize) := operand1
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:1250.53-1250.54"
            (FPAdd result element (← (FPCR_read ()))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec esize) )
  (V_set dn esize result)

def decode_FADDA_V_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Vdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Vdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FADDA_V_P_Z__ 128 dn esize g m)
  | 256 => (execute_FADDA_V_P_Z__ 256 dn esize g m)
  | 512 => (execute_FADDA_V_P_Z__ 512 dn esize g m)
  | 1024 => (execute_FADDA_V_P_Z__ 1024 dn esize g m)
  | 2048 => (execute_FADDA_V_P_Z__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZU_Z_P_Z_D2X (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZU_Z_P_Z_D2X (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 64
  let is_unsigned : Bool := true
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZU_Z_P_Z_D2X 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZU_Z_P_Z_D2X 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZU_Z_P_Z_D2X 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZU_Z_P_Z_D2X 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZU_Z_P_Z_D2X 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZU_Z_P_Z_D2W (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZU_Z_P_Z_D2W (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 32
  let is_unsigned : Bool := true
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZU_Z_P_Z_D2W 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZU_Z_P_Z_D2W 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZU_Z_P_Z_D2W 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZU_Z_P_Z_D2W 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZU_Z_P_Z_D2W 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZU_Z_P_Z_S2W (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZU_Z_P_Z_S2W (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 32
  let is_unsigned : Bool := true
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZU_Z_P_Z_S2W 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZU_Z_P_Z_S2W 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZU_Z_P_Z_S2W 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZU_Z_P_Z_S2W 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZU_Z_P_Z_S2W 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZU_Z_P_Z_S2X (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZU_Z_P_Z_S2X (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 64
  let is_unsigned : Bool := true
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZU_Z_P_Z_S2X 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZU_Z_P_Z_S2X 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZU_Z_P_Z_S2X 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZU_Z_P_Z_S2X 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZU_Z_P_Z_S2X 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZS_Z_P_Z_D2X (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZS_Z_P_Z_D2X (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 64
  let is_unsigned : Bool := false
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZS_Z_P_Z_D2X 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZS_Z_P_Z_D2X 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZS_Z_P_Z_D2X 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZS_Z_P_Z_D2X 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZS_Z_P_Z_D2X 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZS_Z_P_Z_D2W (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZS_Z_P_Z_D2W (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 32
  let is_unsigned : Bool := false
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZS_Z_P_Z_D2W 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZS_Z_P_Z_D2W 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZS_Z_P_Z_D2W 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZS_Z_P_Z_D2W 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZS_Z_P_Z_D2W 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZS_Z_P_Z_S2W (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZS_Z_P_Z_S2W (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 32
  let is_unsigned : Bool := false
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZS_Z_P_Z_S2W 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZS_Z_P_Z_S2W 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZS_Z_P_Z_S2W 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZS_Z_P_Z_S2W 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZS_Z_P_Z_S2W 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZS_Z_P_Z_S2X (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZS_Z_P_Z_S2X (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 64
  let is_unsigned : Bool := false
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZS_Z_P_Z_S2X 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZS_Z_P_Z_S2X 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZS_Z_P_Z_S2X 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZS_Z_P_Z_S2X 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZS_Z_P_Z_S2X 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 16 ∧ d_esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZS_Z_P_Z_FP162H (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZS_Z_P_Z_FP162H (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 16
  let d_esize := 16
  let is_unsigned : Bool := false
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZS_Z_P_Z_FP162H 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZS_Z_P_Z_FP162H 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZS_Z_P_Z_FP162H 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZS_Z_P_Z_FP162H 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZS_Z_P_Z_FP162H 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZS_Z_P_Z_FP162W (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZS_Z_P_Z_FP162W (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 16
  let d_esize := 32
  let is_unsigned : Bool := false
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZS_Z_P_Z_FP162W 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZS_Z_P_Z_FP162W 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZS_Z_P_Z_FP162W 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZS_Z_P_Z_FP162W 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZS_Z_P_Z_FP162W 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZS_Z_P_Z_FP162X (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZS_Z_P_Z_FP162X (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 16
  let d_esize := 64
  let is_unsigned : Bool := false
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZS_Z_P_Z_FP162X 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZS_Z_P_Z_FP162X 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZS_Z_P_Z_FP162X 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZS_Z_P_Z_FP162X 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZS_Z_P_Z_FP162X 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 16 ∧ d_esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZU_Z_P_Z_FP162H (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZU_Z_P_Z_FP162H (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 16
  let d_esize := 16
  let is_unsigned : Bool := true
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZU_Z_P_Z_FP162H 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZU_Z_P_Z_FP162H 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZU_Z_P_Z_FP162H 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZU_Z_P_Z_FP162H 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZU_Z_P_Z_FP162H 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZU_Z_P_Z_FP162W (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZU_Z_P_Z_FP162W (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 16
  let d_esize := 32
  let is_unsigned : Bool := true
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZU_Z_P_Z_FP162W 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZU_Z_P_Z_FP162W 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZU_Z_P_Z_FP162W 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZU_Z_P_Z_FP162W 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZU_Z_P_Z_FP162W 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTZU_Z_P_Z_FP162X (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPToFixed (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (← (Extend res esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTZU_Z_P_Z_FP162X (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 16
  let d_esize := 64
  let is_unsigned : Bool := true
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FCVTZU_Z_P_Z_FP162X 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_FCVTZU_Z_P_Z_FP162X 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_FCVTZU_Z_P_Z_FP162X 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_FCVTZU_Z_P_Z_FP162X 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_FCVTZU_Z_P_Z_FP162X 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 16 ∧ d_esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCVTF_Z_P_Z_H2FP16 (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SCVTF_Z_P_Z_H2FP16 (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 16
  let d_esize := 16
  let is_unsigned : Bool := false
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_SCVTF_Z_P_Z_H2FP16 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_SCVTF_Z_P_Z_H2FP16 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_SCVTF_Z_P_Z_H2FP16 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_SCVTF_Z_P_Z_H2FP16 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_SCVTF_Z_P_Z_H2FP16 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ d_esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCVTF_Z_P_Z_W2FP16 (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SCVTF_Z_P_Z_W2FP16 (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 16
  let is_unsigned : Bool := false
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_SCVTF_Z_P_Z_W2FP16 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_SCVTF_Z_P_Z_W2FP16 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_SCVTF_Z_P_Z_W2FP16 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_SCVTF_Z_P_Z_W2FP16 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_SCVTF_Z_P_Z_W2FP16 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCVTF_Z_P_Z_X2FP16 (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SCVTF_Z_P_Z_X2FP16 (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 16
  let is_unsigned : Bool := false
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_SCVTF_Z_P_Z_X2FP16 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_SCVTF_Z_P_Z_X2FP16 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_SCVTF_Z_P_Z_X2FP16 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_SCVTF_Z_P_Z_X2FP16 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_SCVTF_Z_P_Z_X2FP16 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 16 ∧ d_esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCVTF_Z_P_Z_H2FP16 (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UCVTF_Z_P_Z_H2FP16 (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 16
  let d_esize := 16
  let is_unsigned : Bool := true
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_UCVTF_Z_P_Z_H2FP16 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_UCVTF_Z_P_Z_H2FP16 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_UCVTF_Z_P_Z_H2FP16 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_UCVTF_Z_P_Z_H2FP16 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_UCVTF_Z_P_Z_H2FP16 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ d_esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCVTF_Z_P_Z_W2FP16 (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UCVTF_Z_P_Z_W2FP16 (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 16
  let is_unsigned : Bool := true
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_UCVTF_Z_P_Z_W2FP16 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_UCVTF_Z_P_Z_W2FP16 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_UCVTF_Z_P_Z_W2FP16 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_UCVTF_Z_P_Z_W2FP16 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_UCVTF_Z_P_Z_W2FP16 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCVTF_Z_P_Z_X2FP16 (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UCVTF_Z_P_Z_X2FP16 (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 16
  let is_unsigned : Bool := true
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_UCVTF_Z_P_Z_X2FP16 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_UCVTF_Z_P_Z_X2FP16 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_UCVTF_Z_P_Z_X2FP16 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_UCVTF_Z_P_Z_X2FP16 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_UCVTF_Z_P_Z_X2FP16 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, n : Nat, s_esize : Nat, s_esize
  = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVT_Z_P_Z_D2S (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPConvertSVE__1 (Sail.BitVec.extractLsb element (s_esize -i 1) 0)
                (← (FPCR_read ())) d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend res esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVT_Z_P_Z_D2S (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 32
  match VL with
  | 128 => (execute_FCVT_Z_P_Z_D2S 128 d d_esize esize g n s_esize)
  | 256 => (execute_FCVT_Z_P_Z_D2S 256 d d_esize esize g n s_esize)
  | 512 => (execute_FCVT_Z_P_Z_D2S 512 d d_esize esize g n s_esize)
  | 1024 => (execute_FCVT_Z_P_Z_D2S 1024 d d_esize esize g n s_esize)
  | 2048 => (execute_FCVT_Z_P_Z_D2S 2048 d d_esize esize g n s_esize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, n : Nat, s_esize : Nat, s_esize
  = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVT_Z_P_Z_D2H (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPConvertSVE__1 (Sail.BitVec.extractLsb element (s_esize -i 1) 0)
                (← (FPCR_read ())) d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend res esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVT_Z_P_Z_D2H (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 16
  match VL with
  | 128 => (execute_FCVT_Z_P_Z_D2H 128 d d_esize esize g n s_esize)
  | 256 => (execute_FCVT_Z_P_Z_D2H 256 d d_esize esize g n s_esize)
  | 512 => (execute_FCVT_Z_P_Z_D2H 512 d d_esize esize g n s_esize)
  | 1024 => (execute_FCVT_Z_P_Z_D2H 1024 d d_esize esize g n s_esize)
  | 2048 => (execute_FCVT_Z_P_Z_D2H 2048 d d_esize esize g n s_esize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, n : Nat, s_esize : Nat, s_esize
  = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVT_Z_P_Z_S2D (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPConvertSVE__1 (Sail.BitVec.extractLsb element (s_esize -i 1) 0)
                (← (FPCR_read ())) d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend res esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVT_Z_P_Z_S2D (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 64
  match VL with
  | 128 => (execute_FCVT_Z_P_Z_S2D 128 d d_esize esize g n s_esize)
  | 256 => (execute_FCVT_Z_P_Z_S2D 256 d d_esize esize g n s_esize)
  | 512 => (execute_FCVT_Z_P_Z_S2D 512 d d_esize esize g n s_esize)
  | 1024 => (execute_FCVT_Z_P_Z_S2D 1024 d d_esize esize g n s_esize)
  | 2048 => (execute_FCVT_Z_P_Z_S2D 2048 d d_esize esize g n s_esize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, n : Nat, s_esize : Nat, s_esize
  = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVT_Z_P_Z_H2D (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPConvertSVE__1 (Sail.BitVec.extractLsb element (s_esize -i 1) 0)
                (← (FPCR_read ())) d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend res esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVT_Z_P_Z_H2D (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 16
  let d_esize := 64
  match VL with
  | 128 => (execute_FCVT_Z_P_Z_H2D 128 d d_esize esize g n s_esize)
  | 256 => (execute_FCVT_Z_P_Z_H2D 256 d d_esize esize g n s_esize)
  | 512 => (execute_FCVT_Z_P_Z_H2D 512 d d_esize esize g n s_esize)
  | 1024 => (execute_FCVT_Z_P_Z_H2D 1024 d d_esize esize g n s_esize)
  | 2048 => (execute_FCVT_Z_P_Z_H2D 2048 d d_esize esize g n s_esize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, n : Nat, s_esize : Nat, s_esize
  = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVT_Z_P_Z_H2S (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPConvertSVE__1 (Sail.BitVec.extractLsb element (s_esize -i 1) 0)
                (← (FPCR_read ())) d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend res esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVT_Z_P_Z_H2S (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 16
  let d_esize := 32
  match VL with
  | 128 => (execute_FCVT_Z_P_Z_H2S 128 d d_esize esize g n s_esize)
  | 256 => (execute_FCVT_Z_P_Z_H2S 256 d d_esize esize g n s_esize)
  | 512 => (execute_FCVT_Z_P_Z_H2S 512 d d_esize esize g n s_esize)
  | 1024 => (execute_FCVT_Z_P_Z_H2S 1024 d d_esize esize g n s_esize)
  | 2048 => (execute_FCVT_Z_P_Z_H2S 2048 d d_esize esize g n s_esize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, n : Nat, s_esize : Nat, s_esize
  = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ d_esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVT_Z_P_Z_S2H (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPConvertSVE__1 (Sail.BitVec.extractLsb element (s_esize -i 1) 0)
                (← (FPCR_read ())) d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend res esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVT_Z_P_Z_S2H (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 16
  match VL with
  | 128 => (execute_FCVT_Z_P_Z_S2H 128 d d_esize esize g n s_esize)
  | 256 => (execute_FCVT_Z_P_Z_S2H 256 d d_esize esize g n s_esize)
  | 512 => (execute_FCVT_Z_P_Z_S2H 512 d d_esize esize g n s_esize)
  | 1024 => (execute_FCVT_Z_P_Z_S2H 1024 d d_esize esize g n s_esize)
  | 2048 => (execute_FCVT_Z_P_Z_S2H 2048 d d_esize esize g n s_esize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRECPE_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3116.49-3116.50"
        (Elem_set result e esize (← (FPRecipEstimate element (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRECPE_Z_Z__ (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FRECPE_Z_Z__ 128 d esize n)
  | 256 => (execute_FRECPE_Z_Z__ 256 d esize n)
  | 512 => (execute_FRECPE_Z_Z__ 512 d esize n)
  | 1024 => (execute_FRECPE_Z_Z__ 1024 d esize n)
  | 2048 => (execute_FRECPE_Z_Z__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRSQRTE_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3176.49-3176.50"
        (Elem_set result e esize (← (FPRSqrtEstimate element (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRSQRTE_Z_Z__ (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FRSQRTE_Z_Z__ 128 d esize n)
  | 256 => (execute_FRSQRTE_Z_Z__ 256 d esize n)
  | 512 => (execute_FRSQRTE_Z_Z__ 512 d esize n)
  | 1024 => (execute_FRSQRTE_Z_Z__ 1024 d esize n)
  | 2048 => (execute_FRSQRTE_Z_Z__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRECPX_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3241.53-3241.54"
            (Elem_set result e esize (← (FPRecpX element (← (FPCR_read ()))))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRECPX_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FRECPX_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_FRECPX_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_FRECPX_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_FRECPX_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FRECPX_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FSQRT_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3310.53-3310.54"
            (Elem_set result e esize (← (FPSqrt element (← (FPCR_read ()))))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FSQRT_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FSQRT_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_FSQRT_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_FSQRT_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_FSQRT_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FSQRT_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_exact : Bool, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTA_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (exact : Bool) (g : Nat) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3379.53-3379.54"
            (Elem_set result e esize (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRINTA_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_TIEAWAY
  match VL with
  | 128 => (execute_FRINTA_Z_P_Z__ 128 d esize exact g n rounding)
  | 256 => (execute_FRINTA_Z_P_Z__ 256 d esize exact g n rounding)
  | 512 => (execute_FRINTA_Z_P_Z__ 512 d esize exact g n rounding)
  | 1024 => (execute_FRINTA_Z_P_Z__ 1024 d esize exact g n rounding)
  | 2048 => (execute_FRINTA_Z_P_Z__ 2048 d esize exact g n rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_exact : Bool, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTI_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (exact : Bool) (g : Nat) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3450.53-3450.54"
            (Elem_set result e esize (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRINTI_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let exact : Bool := false
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_FRINTI_Z_P_Z__ 128 d esize exact g n rounding)
  | 256 => (execute_FRINTI_Z_P_Z__ 256 d esize exact g n rounding)
  | 512 => (execute_FRINTI_Z_P_Z__ 512 d esize exact g n rounding)
  | 1024 => (execute_FRINTI_Z_P_Z__ 1024 d esize exact g n rounding)
  | 2048 => (execute_FRINTI_Z_P_Z__ 2048 d esize exact g n rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_exact : Bool, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTM_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (exact : Bool) (g : Nat) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3521.53-3521.54"
            (Elem_set result e esize (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRINTM_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_NEGINF
  match VL with
  | 128 => (execute_FRINTM_Z_P_Z__ 128 d esize exact g n rounding)
  | 256 => (execute_FRINTM_Z_P_Z__ 256 d esize exact g n rounding)
  | 512 => (execute_FRINTM_Z_P_Z__ 512 d esize exact g n rounding)
  | 1024 => (execute_FRINTM_Z_P_Z__ 1024 d esize exact g n rounding)
  | 2048 => (execute_FRINTM_Z_P_Z__ 2048 d esize exact g n rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_exact : Bool, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTN_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (exact : Bool) (g : Nat) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3592.53-3592.54"
            (Elem_set result e esize (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRINTN_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_TIEEVEN
  match VL with
  | 128 => (execute_FRINTN_Z_P_Z__ 128 d esize exact g n rounding)
  | 256 => (execute_FRINTN_Z_P_Z__ 256 d esize exact g n rounding)
  | 512 => (execute_FRINTN_Z_P_Z__ 512 d esize exact g n rounding)
  | 1024 => (execute_FRINTN_Z_P_Z__ 1024 d esize exact g n rounding)
  | 2048 => (execute_FRINTN_Z_P_Z__ 2048 d esize exact g n rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_exact : Bool, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTP_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (exact : Bool) (g : Nat) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3663.53-3663.54"
            (Elem_set result e esize (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRINTP_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_POSINF
  match VL with
  | 128 => (execute_FRINTP_Z_P_Z__ 128 d esize exact g n rounding)
  | 256 => (execute_FRINTP_Z_P_Z__ 256 d esize exact g n rounding)
  | 512 => (execute_FRINTP_Z_P_Z__ 512 d esize exact g n rounding)
  | 1024 => (execute_FRINTP_Z_P_Z__ 1024 d esize exact g n rounding)
  | 2048 => (execute_FRINTP_Z_P_Z__ 2048 d esize exact g n rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_exact : Bool, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTX_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (exact : Bool) (g : Nat) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3734.53-3734.54"
            (Elem_set result e esize (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRINTX_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let exact : Bool := true
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_FRINTX_Z_P_Z__ 128 d esize exact g n rounding)
  | 256 => (execute_FRINTX_Z_P_Z__ 256 d esize exact g n rounding)
  | 512 => (execute_FRINTX_Z_P_Z__ 512 d esize exact g n rounding)
  | 1024 => (execute_FRINTX_Z_P_Z__ 1024 d esize exact g n rounding)
  | 2048 => (execute_FRINTX_Z_P_Z__ 2048 d esize exact g n rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_exact : Bool, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRINTZ_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (exact : Bool) (g : Nat) (n : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:3805.53-3805.54"
            (Elem_set result e esize (← (FPRoundInt element (← (FPCR_read ())) rounding exact))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRINTZ_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let exact : Bool := false
  let rounding : FPRounding := FPRounding_ZERO
  match VL with
  | 128 => (execute_FRINTZ_Z_P_Z__ 128 d esize exact g n rounding)
  | 256 => (execute_FRINTZ_Z_P_Z__ 256 d esize exact g n rounding)
  | 512 => (execute_FRINTZ_Z_P_Z__ 512 d esize exact g n rounding)
  | 1024 => (execute_FRINTZ_Z_P_Z__ 1024 d esize exact g n rounding)
  | 2048 => (execute_FRINTZ_Z_P_Z__ 2048 d esize exact g n rounding)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCVTF_Z_P_Z_X2S (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UCVTF_Z_P_Z_X2S (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 32
  let is_unsigned : Bool := true
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_UCVTF_Z_P_Z_X2S 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_UCVTF_Z_P_Z_X2S 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_UCVTF_Z_P_Z_X2S 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_UCVTF_Z_P_Z_X2S 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_UCVTF_Z_P_Z_X2S 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCVTF_Z_P_Z_X2D (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UCVTF_Z_P_Z_X2D (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 64
  let is_unsigned : Bool := true
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_UCVTF_Z_P_Z_X2D 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_UCVTF_Z_P_Z_X2D 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_UCVTF_Z_P_Z_X2D 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_UCVTF_Z_P_Z_X2D 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_UCVTF_Z_P_Z_X2D 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCVTF_Z_P_Z_W2S (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UCVTF_Z_P_Z_W2S (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 32
  let is_unsigned : Bool := true
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_UCVTF_Z_P_Z_W2S 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_UCVTF_Z_P_Z_W2S 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_UCVTF_Z_P_Z_W2S 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_UCVTF_Z_P_Z_W2S 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_UCVTF_Z_P_Z_W2S 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCVTF_Z_P_Z_W2D (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UCVTF_Z_P_Z_W2D (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 64
  let is_unsigned : Bool := true
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_UCVTF_Z_P_Z_W2D 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_UCVTF_Z_P_Z_W2D 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_UCVTF_Z_P_Z_W2D 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_UCVTF_Z_P_Z_W2D 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_UCVTF_Z_P_Z_W2D 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCVTF_Z_P_Z_X2S (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SCVTF_Z_P_Z_X2S (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 32
  let is_unsigned : Bool := false
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_SCVTF_Z_P_Z_X2S 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_SCVTF_Z_P_Z_X2S 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_SCVTF_Z_P_Z_X2S 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_SCVTF_Z_P_Z_X2S 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_SCVTF_Z_P_Z_X2S 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCVTF_Z_P_Z_X2D (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SCVTF_Z_P_Z_X2D (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 64
  let is_unsigned : Bool := false
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_SCVTF_Z_P_Z_X2D 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_SCVTF_Z_P_Z_X2D 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_SCVTF_Z_P_Z_X2D 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_SCVTF_Z_P_Z_X2D 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_SCVTF_Z_P_Z_X2D 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 32 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCVTF_Z_P_Z_W2S (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SCVTF_Z_P_Z_W2S (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 32
  let is_unsigned : Bool := false
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_SCVTF_Z_P_Z_W2S 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_SCVTF_Z_P_Z_W2S 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_SCVTF_Z_P_Z_W2S 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_SCVTF_Z_P_Z_W2S 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_SCVTF_Z_P_Z_W2S 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n
  : Nat, s_esize : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCVTF_Z_P_Z_W2D (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (rounding : FPRounding) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let fpval ← (( do
              (FixedToFP (Sail.BitVec.extractLsb element (s_esize -i 1) 0) 0 is_unsigned
                (← (FPCR_read ())) rounding d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend fpval esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SCVTF_Z_P_Z_W2D (int_U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 32
  let d_esize := 64
  let is_unsigned : Bool := false
  let rounding ← (( do (FPRoundingMode (← (FPCR_read ()))) ) : SailM FPRounding )
  match VL with
  | 128 => (execute_SCVTF_Z_P_Z_W2D 128 d d_esize esize g n rounding s_esize is_unsigned)
  | 256 => (execute_SCVTF_Z_P_Z_W2D 256 d d_esize esize g n rounding s_esize is_unsigned)
  | 512 => (execute_SCVTF_Z_P_Z_W2D 512 d d_esize esize g n rounding s_esize is_unsigned)
  | 1024 => (execute_SCVTF_Z_P_Z_W2D 1024 d d_esize esize g n rounding s_esize is_unsigned)
  | 2048 => (execute_SCVTF_Z_P_Z_W2D 2048 d d_esize esize g n rounding s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FABD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:4438.53-4438.54"
            (Elem_set result e esize
              (← (FPAbs (← (FPSub element1 element2 (← (FPCR_read ()))))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FABD_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FABD_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FABD_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FABD_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FABD_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FABD_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:4510.53-4510.54"
            (Elem_set result e esize (← (FPAdd element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FADD_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FADD_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FADD_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FADD_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FADD_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FADD_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FDIV_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:4579.53-4579.54"
            (Elem_set result e esize (← (FPDiv element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FDIV_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FDIV_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FDIV_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FDIV_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FDIV_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FDIV_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FDIVR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:4651.53-4651.54"
            (Elem_set result e esize (← (FPDiv element2 element1 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FDIVR_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FDIVR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FDIVR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FDIVR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FDIVR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FDIVR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXNM_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:4723.53-4723.54"
            (Elem_set result e esize (← (FPMaxNum element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMAXNM_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FMAXNM_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FMAXNM_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FMAXNM_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FMAXNM_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FMAXNM_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMINNM_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:4792.53-4792.54"
            (Elem_set result e esize (← (FPMinNum element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMINNM_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FMINNM_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FMINNM_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FMINNM_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FMINNM_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FMINNM_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAX_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:4861.53-4861.54"
            (Elem_set result e esize (← (FPMax element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMAX_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FMAX_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FMAX_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FMAX_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FMAX_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FMAX_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMIN_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:4930.53-4930.54"
            (Elem_set result e esize (← (FPMin element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMIN_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FMIN_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FMIN_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FMIN_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FMIN_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FMIN_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMUL_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:4999.53-4999.54"
            (Elem_set result e esize (← (FPMul element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMUL_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FMUL_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FMUL_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FMUL_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FMUL_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FMUL_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMULX_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5068.53-5068.54"
            (Elem_set result e esize (← (FPMulX element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMULX_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FMULX_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FMULX_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FMULX_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FMULX_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FMULX_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FSCALE_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5140.53-5140.54"
            (Elem_set result e esize (← (FPScale element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FSCALE_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FSCALE_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FSCALE_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FSCALE_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FSCALE_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FSCALE_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FSUB_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5212.53-5212.54"
            (Elem_set result e esize (← (FPSub element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FSUB_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FSUB_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FSUB_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FSUB_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FSUB_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FSUB_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FSUBR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5281.53-5281.54"
            (Elem_set result e esize (← (FPSub element2 element1 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FSUBR_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_FSUBR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FSUBR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FSUBR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FSUBR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FSUBR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FADDV_V_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5346.45-5346.46"
  let identity ← (( do (FPZero (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
  (V_set d esize (← (ReducePredicated ReduceOp_FADD operand mask identity)))

def decode_FADDV_V_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_FADDV_V_P_Z__ 128 d esize g n)
  | 256 => (execute_FADDV_V_P_Z__ 256 d esize g n)
  | 512 => (execute_FADDV_V_P_Z__ 512 d esize g n)
  | 1024 => (execute_FADDV_V_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FADDV_V_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXNMV_V_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5407.45-5407.46"
  let identity ← (( do (FPDefaultNaN esize) ) : SailM (BitVec esize) )
  (V_set d esize (← (ReducePredicated ReduceOp_FMAXNUM operand mask identity)))

def decode_FMAXNMV_V_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_FMAXNMV_V_P_Z__ 128 d esize g n)
  | 256 => (execute_FMAXNMV_V_P_Z__ 256 d esize g n)
  | 512 => (execute_FMAXNMV_V_P_Z__ 512 d esize g n)
  | 1024 => (execute_FMAXNMV_V_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FMAXNMV_V_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMINNMV_V_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5468.45-5468.46"
  let identity ← (( do (FPDefaultNaN esize) ) : SailM (BitVec esize) )
  (V_set d esize (← (ReducePredicated ReduceOp_FMINNUM operand mask identity)))

def decode_FMINNMV_V_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_FMINNMV_V_P_Z__ 128 d esize g n)
  | 256 => (execute_FMINNMV_V_P_Z__ 256 d esize g n)
  | 512 => (execute_FMINNMV_V_P_Z__ 512 d esize g n)
  | 1024 => (execute_FMINNMV_V_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FMINNMV_V_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXV_V_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5529.45-5529.46"
  let identity ← (( do (FPInfinity (0b1 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
  (V_set d esize (← (ReducePredicated ReduceOp_FMAX operand mask identity)))

def decode_FMAXV_V_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_FMAXV_V_P_Z__ 128 d esize g n)
  | 256 => (execute_FMAXV_V_P_Z__ 256 d esize g n)
  | 512 => (execute_FMAXV_V_P_Z__ 512 d esize g n)
  | 1024 => (execute_FMAXV_V_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FMAXV_V_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMINV_V_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5590.45-5590.46"
  let identity ← (( do (FPInfinity (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
  (V_set d esize (← (ReducePredicated ReduceOp_FMIN operand mask identity)))

def decode_FMINV_V_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_FMINV_V_P_Z__ 128 d esize g n)
  | 256 => (execute_FMINV_V_P_Z__ 256 d esize g n)
  | 512 => (execute_FMINV_V_P_Z__ 512 d esize g n)
  | 1024 => (execute_FMINV_V_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FMINV_V_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FACGE_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5665.59-5665.60"
                  (FPCompareGE (← (FPAbs element1)) (← (FPAbs element2)) (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5669.59-5669.60"
                  (FPCompareGT (← (FPAbs element1)) (← (FPAbs element2)) (← (FPCR_read ()))))
              | _ => (pure res) ) : SailM Bool )
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FACGE_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GE
  match VL with
  | 128 => (execute_FACGE_P_P_ZZ__ 128 d esize g m n op)
  | 256 => (execute_FACGE_P_P_ZZ__ 256 d esize g m n op)
  | 512 => (execute_FACGE_P_P_ZZ__ 512 d esize g m n op)
  | 1024 => (execute_FACGE_P_P_ZZ__ 1024 d esize g m n op)
  | 2048 => (execute_FACGE_P_P_ZZ__ 2048 d esize g m n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FACGT_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5756.59-5756.60"
                  (FPCompareGE (← (FPAbs element1)) (← (FPAbs element2)) (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5760.59-5760.60"
                  (FPCompareGT (← (FPAbs element1)) (← (FPAbs element2)) (← (FPCR_read ()))))
              | _ => (pure res) ) : SailM Bool )
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FACGT_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GT
  match VL with
  | 128 => (execute_FACGT_P_P_ZZ__ 128 d esize g m n op)
  | 256 => (execute_FACGT_P_P_ZZ__ 256 d esize g m n op)
  | 512 => (execute_FACGT_P_P_ZZ__ 512 d esize g m n op)
  | 1024 => (execute_FACGT_P_P_ZZ__ 1024 d esize g m n op)
  | 2048 => (execute_FACGT_P_P_ZZ__ 2048 d esize g m n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMUO_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5847.59-5847.60"
                  (FPCompareEQ element1 element2 (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5851.59-5851.60"
                  (FPCompareGE element1 element2 (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5855.59-5855.60"
                  (FPCompareGT element1 element2 (← (FPCR_read ()))))
              | Cmp_UN => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5859.59-5859.60"
                  (FPCompareUN element1 element2 (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5863.59-5863.60"
                  (FPCompareNE element1 element2 (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5867.59-5867.60"
                  (FPCompareGT element2 element1 (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5871.59-5871.60"
                  (FPCompareGE element2 element1 (← (FPCR_read ())))) ) : SailM Bool )
            let res := res
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMUO_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_UN
  match VL with
  | 128 => (execute_FCMUO_P_P_ZZ__ 128 d esize g m n op)
  | 256 => (execute_FCMUO_P_P_ZZ__ 256 d esize g m n op)
  | 512 => (execute_FCMUO_P_P_ZZ__ 512 d esize g m n op)
  | 1024 => (execute_FCMUO_P_P_ZZ__ 1024 d esize g m n op)
  | 2048 => (execute_FCMUO_P_P_ZZ__ 2048 d esize g m n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMGE_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5958.59-5958.60"
                  (FPCompareEQ element1 element2 (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5962.59-5962.60"
                  (FPCompareGE element1 element2 (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5966.59-5966.60"
                  (FPCompareGT element1 element2 (← (FPCR_read ()))))
              | Cmp_UN => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5970.59-5970.60"
                  (FPCompareUN element1 element2 (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5974.59-5974.60"
                  (FPCompareNE element1 element2 (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5978.59-5978.60"
                  (FPCompareGT element2 element1 (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:5982.59-5982.60"
                  (FPCompareGE element2 element1 (← (FPCR_read ())))) ) : SailM Bool )
            let res := res
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMGE_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (cmph : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (cmpl : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GE
  match VL with
  | 128 => (execute_FCMGE_P_P_ZZ__ 128 d esize g m n op)
  | 256 => (execute_FCMGE_P_P_ZZ__ 256 d esize g m n op)
  | 512 => (execute_FCMGE_P_P_ZZ__ 512 d esize g m n op)
  | 1024 => (execute_FCMGE_P_P_ZZ__ 1024 d esize g m n op)
  | 2048 => (execute_FCMGE_P_P_ZZ__ 2048 d esize g m n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMGT_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6071.59-6071.60"
                  (FPCompareEQ element1 element2 (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6075.59-6075.60"
                  (FPCompareGE element1 element2 (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6079.59-6079.60"
                  (FPCompareGT element1 element2 (← (FPCR_read ()))))
              | Cmp_UN => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6083.59-6083.60"
                  (FPCompareUN element1 element2 (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6087.59-6087.60"
                  (FPCompareNE element1 element2 (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6091.59-6091.60"
                  (FPCompareGT element2 element1 (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6095.59-6095.60"
                  (FPCompareGE element2 element1 (← (FPCR_read ())))) ) : SailM Bool )
            let res := res
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMGT_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (cmph : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (cmpl : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GT
  match VL with
  | 128 => (execute_FCMGT_P_P_ZZ__ 128 d esize g m n op)
  | 256 => (execute_FCMGT_P_P_ZZ__ 256 d esize g m n op)
  | 512 => (execute_FCMGT_P_P_ZZ__ 512 d esize g m n op)
  | 1024 => (execute_FCMGT_P_P_ZZ__ 1024 d esize g m n op)
  | 2048 => (execute_FCMGT_P_P_ZZ__ 2048 d esize g m n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMEQ_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6184.59-6184.60"
                  (FPCompareEQ element1 element2 (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6188.59-6188.60"
                  (FPCompareGE element1 element2 (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6192.59-6192.60"
                  (FPCompareGT element1 element2 (← (FPCR_read ()))))
              | Cmp_UN => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6196.59-6196.60"
                  (FPCompareUN element1 element2 (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6200.59-6200.60"
                  (FPCompareNE element1 element2 (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6204.59-6204.60"
                  (FPCompareGT element2 element1 (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6208.59-6208.60"
                  (FPCompareGE element2 element1 (← (FPCR_read ())))) ) : SailM Bool )
            let res := res
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMEQ_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (cmph : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (cmpl : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_EQ
  match VL with
  | 128 => (execute_FCMEQ_P_P_ZZ__ 128 d esize g m n op)
  | 256 => (execute_FCMEQ_P_P_ZZ__ 256 d esize g m n op)
  | 512 => (execute_FCMEQ_P_P_ZZ__ 512 d esize g m n op)
  | 1024 => (execute_FCMEQ_P_P_ZZ__ 1024 d esize g m n op)
  | 2048 => (execute_FCMEQ_P_P_ZZ__ 2048 d esize g m n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_FCMNE_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let res ← (( do (undefined_bool ()) ) : SailM Bool )
            let res ← (( do
              match op with
              | Cmp_EQ => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6297.59-6297.60"
                  (FPCompareEQ element1 element2 (← (FPCR_read ()))))
              | Cmp_GE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6301.59-6301.60"
                  (FPCompareGE element1 element2 (← (FPCR_read ()))))
              | Cmp_GT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6305.59-6305.60"
                  (FPCompareGT element1 element2 (← (FPCR_read ()))))
              | Cmp_UN => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6309.59-6309.60"
                  (FPCompareUN element1 element2 (← (FPCR_read ()))))
              | Cmp_NE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6313.59-6313.60"
                  (FPCompareNE element1 element2 (← (FPCR_read ()))))
              | Cmp_LT => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6317.59-6317.60"
                  (FPCompareGT element2 element1 (← (FPCR_read ()))))
              | Cmp_LE => (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6321.59-6321.60"
                  (FPCompareGE element2 element1 (← (FPCR_read ())))) ) : SailM Bool )
            let res := res
            let pbit : (BitVec 1) :=
              bif res
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_FCMNE_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (cmph : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (cmpl : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_NE
  match VL with
  | 128 => (execute_FCMNE_P_P_ZZ__ 128 d esize g m n op)
  | 256 => (execute_FCMNE_P_P_ZZ__ 256 d esize g m n op)
  | 512 => (execute_FCMNE_P_P_ZZ__ 512 d esize g m n op)
  | 1024 => (execute_FCMNE_P_P_ZZ__ 1024 d esize g m n op)
  | 2048 => (execute_FCMNE_P_P_ZZ__ 2048 d esize g m n op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_op1_neg : Bool, k_op3_neg
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLA_Z_P_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
            let element1 ← (( do
              bif op1_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6409.57-6409.58"
                  (FPNeg element1))
              else (pure element1) ) : SailM (BitVec esize) )
            let element3 ← (( do
              bif op3_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6413.57-6413.58"
                  (FPNeg element3))
              else (pure element3) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6416.53-6416.54"
            (Elem_set result e esize
              (← (FPMulAdd element3 element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand3 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLA_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (N : (BitVec 1)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := false
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_FMLA_Z_P_ZZZ__ 128 da esize g m n op1_neg op3_neg)
  | 256 => (execute_FMLA_Z_P_ZZZ__ 256 da esize g m n op1_neg op3_neg)
  | 512 => (execute_FMLA_Z_P_ZZZ__ 512 da esize g m n op1_neg op3_neg)
  | 1024 => (execute_FMLA_Z_P_ZZZ__ 1024 da esize g m n op1_neg op3_neg)
  | 2048 => (execute_FMLA_Z_P_ZZZ__ 2048 da esize g m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_op1_neg : Bool, k_op3_neg
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLS_Z_P_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
            let element1 ← (( do
              bif op1_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6497.57-6497.58"
                  (FPNeg element1))
              else (pure element1) ) : SailM (BitVec esize) )
            let element3 ← (( do
              bif op3_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6501.57-6501.58"
                  (FPNeg element3))
              else (pure element3) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6504.53-6504.54"
            (Elem_set result e esize
              (← (FPMulAdd element3 element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand3 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLS_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (N : (BitVec 1)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_FMLS_Z_P_ZZZ__ 128 da esize g m n op1_neg op3_neg)
  | 256 => (execute_FMLS_Z_P_ZZZ__ 256 da esize g m n op1_neg op3_neg)
  | 512 => (execute_FMLS_Z_P_ZZZ__ 512 da esize g m n op1_neg op3_neg)
  | 1024 => (execute_FMLS_Z_P_ZZZ__ 1024 da esize g m n op1_neg op3_neg)
  | 2048 => (execute_FMLS_Z_P_ZZZ__ 2048 da esize g m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_op1_neg : Bool, k_op3_neg
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FNMLA_Z_P_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
            let element1 ← (( do
              bif op1_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6585.57-6585.58"
                  (FPNeg element1))
              else (pure element1) ) : SailM (BitVec esize) )
            let element3 ← (( do
              bif op3_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6589.57-6589.58"
                  (FPNeg element3))
              else (pure element3) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6592.53-6592.54"
            (Elem_set result e esize
              (← (FPMulAdd element3 element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand3 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FNMLA_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (N : (BitVec 1)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  let op3_neg : Bool := true
  match VL with
  | 128 => (execute_FNMLA_Z_P_ZZZ__ 128 da esize g m n op1_neg op3_neg)
  | 256 => (execute_FNMLA_Z_P_ZZZ__ 256 da esize g m n op1_neg op3_neg)
  | 512 => (execute_FNMLA_Z_P_ZZZ__ 512 da esize g m n op1_neg op3_neg)
  | 1024 => (execute_FNMLA_Z_P_ZZZ__ 1024 da esize g m n op1_neg op3_neg)
  | 2048 => (execute_FNMLA_Z_P_ZZZ__ 2048 da esize g m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_op1_neg : Bool, k_op3_neg
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FNMLS_Z_P_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
            let element1 ← (( do
              bif op1_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6676.57-6676.58"
                  (FPNeg element1))
              else (pure element1) ) : SailM (BitVec esize) )
            let element3 ← (( do
              bif op3_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6680.57-6680.58"
                  (FPNeg element3))
              else (pure element3) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6683.53-6683.54"
            (Elem_set result e esize
              (← (FPMulAdd element3 element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand3 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FNMLS_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (N : (BitVec 1)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := false
  let op3_neg : Bool := true
  match VL with
  | 128 => (execute_FNMLS_Z_P_ZZZ__ 128 da esize g m n op1_neg op3_neg)
  | 256 => (execute_FNMLS_Z_P_ZZZ__ 256 da esize g m n op1_neg op3_neg)
  | 512 => (execute_FNMLS_Z_P_ZZZ__ 512 da esize g m n op1_neg op3_neg)
  | 1024 => (execute_FNMLS_Z_P_ZZZ__ 1024 da esize g m n op1_neg op3_neg)
  | 2048 => (execute_FNMLS_Z_P_ZZZ__ 2048 da esize g m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, k_op1_neg : Bool, k_op3_neg
  : Bool, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 ∧ is_VL(VL) -/
def execute_FMAD_Z_P_ZZZ__ (VL : Nat) (a : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read a VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
            let element1 ← (( do
              bif op1_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6767.57-6767.58"
                  (FPNeg element1))
              else (pure element1) ) : SailM (BitVec esize) )
            let element3 ← (( do
              bif op3_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6771.57-6771.58"
                  (FPNeg element3))
              else (pure element3) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6774.53-6774.54"
            (Elem_set result e esize
              (← (FPMulAdd element3 element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMAD_Z_P_ZZZ__ (size : (BitVec 2)) (Za : (BitVec 5)) (N : (BitVec 1)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let a := (BitVec.toNat Za)
  let op1_neg : Bool := false
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_FMAD_Z_P_ZZZ__ 128 a dn esize g m op1_neg op3_neg)
  | 256 => (execute_FMAD_Z_P_ZZZ__ 256 a dn esize g m op1_neg op3_neg)
  | 512 => (execute_FMAD_Z_P_ZZZ__ 512 a dn esize g m op1_neg op3_neg)
  | 1024 => (execute_FMAD_Z_P_ZZZ__ 1024 a dn esize g m op1_neg op3_neg)
  | 2048 => (execute_FMAD_Z_P_ZZZ__ 2048 a dn esize g m op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, k_op1_neg : Bool, k_op3_neg
  : Bool, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 ∧ is_VL(VL) -/
def execute_FMSB_Z_P_ZZZ__ (VL : Nat) (a : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read a VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
            let element1 ← (( do
              bif op1_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6858.57-6858.58"
                  (FPNeg element1))
              else (pure element1) ) : SailM (BitVec esize) )
            let element3 ← (( do
              bif op3_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6862.57-6862.58"
                  (FPNeg element3))
              else (pure element3) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6865.53-6865.54"
            (Elem_set result e esize
              (← (FPMulAdd element3 element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FMSB_Z_P_ZZZ__ (size : (BitVec 2)) (Za : (BitVec 5)) (N : (BitVec 1)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let a := (BitVec.toNat Za)
  let op1_neg : Bool := true
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_FMSB_Z_P_ZZZ__ 128 a dn esize g m op1_neg op3_neg)
  | 256 => (execute_FMSB_Z_P_ZZZ__ 256 a dn esize g m op1_neg op3_neg)
  | 512 => (execute_FMSB_Z_P_ZZZ__ 512 a dn esize g m op1_neg op3_neg)
  | 1024 => (execute_FMSB_Z_P_ZZZ__ 1024 a dn esize g m op1_neg op3_neg)
  | 2048 => (execute_FMSB_Z_P_ZZZ__ 2048 a dn esize g m op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, k_op1_neg : Bool, k_op3_neg
  : Bool, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 ∧ is_VL(VL) -/
def execute_FNMAD_Z_P_ZZZ__ (VL : Nat) (a : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read a VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
            let element1 ← (( do
              bif op1_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6949.57-6949.58"
                  (FPNeg element1))
              else (pure element1) ) : SailM (BitVec esize) )
            let element3 ← (( do
              bif op3_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6953.57-6953.58"
                  (FPNeg element3))
              else (pure element3) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:6956.53-6956.54"
            (Elem_set result e esize
              (← (FPMulAdd element3 element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FNMAD_Z_P_ZZZ__ (size : (BitVec 2)) (Za : (BitVec 5)) (N : (BitVec 1)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let a := (BitVec.toNat Za)
  let op1_neg : Bool := true
  let op3_neg : Bool := true
  match VL with
  | 128 => (execute_FNMAD_Z_P_ZZZ__ 128 a dn esize g m op1_neg op3_neg)
  | 256 => (execute_FNMAD_Z_P_ZZZ__ 256 a dn esize g m op1_neg op3_neg)
  | 512 => (execute_FNMAD_Z_P_ZZZ__ 512 a dn esize g m op1_neg op3_neg)
  | 1024 => (execute_FNMAD_Z_P_ZZZ__ 1024 a dn esize g m op1_neg op3_neg)
  | 2048 => (execute_FNMAD_Z_P_ZZZ__ 2048 a dn esize g m op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, k_op1_neg : Bool, k_op3_neg
  : Bool, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 ∧ is_VL(VL) -/
def execute_FNMSB_Z_P_ZZZ__ (VL : Nat) (a : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read a VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
            let element1 ← (( do
              bif op1_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7040.57-7040.58"
                  (FPNeg element1))
              else (pure element1) ) : SailM (BitVec esize) )
            let element3 ← (( do
              bif op3_neg
              then
                (do
                  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7044.57-7044.58"
                  (FPNeg element3))
              else (pure element3) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7047.53-7047.54"
            (Elem_set result e esize
              (← (FPMulAdd element3 element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FNMSB_Z_P_ZZZ__ (size : (BitVec 2)) (Za : (BitVec 5)) (N : (BitVec 1)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let a := (BitVec.toNat Za)
  let op1_neg : Bool := false
  let op3_neg : Bool := true
  match VL with
  | 128 => (execute_FNMSB_Z_P_ZZZ__ 128 a dn esize g m op1_neg op3_neg)
  | 256 => (execute_FNMSB_Z_P_ZZZ__ 256 a dn esize g m op1_neg op3_neg)
  | 512 => (execute_FNMSB_Z_P_ZZZ__ 512 a dn esize g m op1_neg op3_neg)
  | 1024 => (execute_FNMSB_Z_P_ZZZ__ 1024 a dn esize g m op1_neg op3_neg)
  | 2048 => (execute_FNMSB_Z_P_ZZZ__ 2048 a dn esize g m op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FADD_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7120.49-7120.50"
        (Elem_set result e esize (← (FPAdd element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FADD_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FADD_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_FADD_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_FADD_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_FADD_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_FADD_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMUL_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7181.49-7181.50"
        (Elem_set result e esize (← (FPMul element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FMUL_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FMUL_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_FMUL_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_FMUL_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_FMUL_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_FMUL_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FSUB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7242.49-7242.50"
        (Elem_set result e esize (← (FPSub element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FSUB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FSUB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_FSUB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_FSUB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_FSUB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_FSUB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FTSMUL_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7303.49-7303.50"
        (Elem_set result e esize (← (FPTrigSMul element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FTSMUL_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FTSMUL_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_FTSMUL_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_FTSMUL_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_FTSMUL_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_FTSMUL_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRECPS_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7367.49-7367.50"
        (Elem_set result e esize (← (FPRecipStepFused element1 element2)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRECPS_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FRECPS_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_FRECPS_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_FRECPS_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_FRECPS_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_FRECPS_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FRSQRTS_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7431.49-7431.50"
        (Elem_set result e esize (← (FPRSqrtStepFused element1 element2)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FRSQRTS_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FRSQRTS_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_FRSQRTS_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_FRSQRTS_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_FRSQRTS_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_FRSQRTS_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FTSSEL_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7495.49-7495.50"
        (Elem_set result e esize (← (FPTrigSSel element1 element2)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FTSSEL_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FTSSEL_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_FTSSEL_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_FTSSEL_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_FTSSEL_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_FTSSEL_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FEXPA_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7557.49-7557.50"
        (Elem_set result e esize (← (FPExpA element)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FEXPA_Z_Z__ (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FEXPA_Z_Z__ 128 d esize n)
  | 256 => (execute_FEXPA_Z_Z__ 256 d esize n)
  | 512 => (execute_FEXPA_Z_Z__ 512 d esize n)
  | 1024 => (execute_FEXPA_Z_Z__ 1024 d esize n)
  | 2048 => (execute_FEXPA_Z_Z__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  imm ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FTMAD_Z_ZZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (m : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7619.49-7619.50"
        (Elem_set result e esize (← (FPTrigMAdd imm element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_FTMAD_Z_ZZI__ (size : (BitVec 2)) (imm3 : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let imm := (BitVec.toNat imm3)
  match VL with
  | 128 => (execute_FTMAD_Z_ZZI__ 128 dn esize imm m)
  | 256 => (execute_FTMAD_Z_ZZI__ 256 dn esize imm m)
  | 512 => (execute_FTMAD_Z_ZZI__ 512 dn esize imm m)
  | 1024 => (execute_FTMAD_Z_ZZI__ 1024 dn esize imm m)
  | 2048 => (execute_FTMAD_Z_ZZI__ 2048 dn esize imm m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, k_sub_i : Bool, k_sub_r :
  Bool, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FCADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (sub_i : Bool) (sub_r : Bool) : SailM Unit := do
  let acc_i ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let acc_r ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let elt2_i ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let elt2_r ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (acc_i, acc_r, elt2_i, elt2_r, result) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (acc_i, acc_r, elt2_i, elt2_r, result)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (acc_i, acc_r, elt2_i, elt2_r, result) := loop_vars
      loop_vars ← do
        let acc_r ← (Elem_read operand1 ((2 *i p) +i 0) esize)
        let acc_i ← (Elem_read operand1 ((2 *i p) +i 1) esize)
        let (acc_r, elt2_i) ← (( do
          bif (← (ActivePredicateElement mask ((2 *i p) +i 0) esize))
          then
            (do
              let elt2_i ← (Elem_read operand2 ((2 *i p) +i 1) esize)
              let elt2_i ← (( do
                bif sub_i
                then
                  (do
                    assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                      (BEq.beq esize 64)) "src/instrs64_sve.sail:7694.57-7694.58"
                    (FPNeg elt2_i))
                else (pure elt2_i) ) : SailM (BitVec esize) )
              assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7697.53-7697.54"
              let acc_r ← (FPAdd acc_r elt2_i (← (FPCR_read ())))
              (pure (acc_r, elt2_i)))
          else (pure (acc_r, elt2_i)) ) : SailM ((BitVec esize) × (BitVec esize)) )
        let (acc_i, elt2_r) ← (( do
          bif (← (ActivePredicateElement mask ((2 *i p) +i 1) esize))
          then
            (do
              let elt2_r ← (Elem_read operand2 ((2 *i p) +i 0) esize)
              let elt2_r ← (( do
                bif sub_r
                then
                  (do
                    assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                      (BEq.beq esize 64)) "src/instrs64_sve.sail:7703.57-7703.58"
                    (FPNeg elt2_r))
                else (pure elt2_r) ) : SailM (BitVec esize) )
              assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7706.53-7706.54"
              let acc_i ← (FPAdd acc_i elt2_r (← (FPCR_read ())))
              (pure (acc_i, elt2_r)))
          else (pure (acc_i, elt2_r)) ) : SailM ((BitVec esize) × (BitVec esize)) )
        let result ← (Elem_set result ((2 *i p) +i 0) esize acc_r)
        let result ← (Elem_set result ((2 *i p) +i 1) esize acc_i)
        (pure (acc_i, acc_r, elt2_i, elt2_r, result))
    (pure loop_vars) ) : SailM
    ((BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec VL)) )
  (Z_set dn VL result)

def decode_FCADD_Z_P_ZZ__ (size : (BitVec 2)) (rot : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let sub_i : Bool := (BEq.beq rot (0b0 : (BitVec 1)))
  let sub_r : Bool := (BEq.beq rot (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_FCADD_Z_P_ZZ__ 128 dn esize g m sub_i sub_r)
  | 256 => (execute_FCADD_Z_P_ZZ__ 256 dn esize g m sub_i sub_r)
  | 512 => (execute_FCADD_Z_P_ZZ__ 512 dn esize g m sub_i sub_r)
  | 1024 => (execute_FCADD_Z_P_ZZ__ 1024 dn esize g m sub_i sub_r)
  | 2048 => (execute_FCADD_Z_P_ZZ__ 2048 dn esize g m sub_i sub_r)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_neg_i : Bool, k_neg_r
  : Bool, sel_a : Nat, sel_b : Nat, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FCMLA_Z_P_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (neg_i : Bool) (neg_r : Bool) (sel_a : Nat) (sel_b : Nat) : SailM Unit := do
  let addend_i ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let addend_r ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (addend_i, addend_r, result) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (addend_i, addend_r, result)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (addend_i, addend_r, result) := loop_vars
      loop_vars ← do
        let addend_r ← (Elem_read operand3 ((2 *i p) +i 0) esize)
        let addend_i ← (Elem_read operand3 ((2 *i p) +i 1) esize)
        let addend_r ← (( do
          bif (← (ActivePredicateElement mask ((2 *i p) +i 0) esize))
          then
            (do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i p) +i sel_a) esize) ) : SailM
                (BitVec esize) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i p) +i sel_a) esize) ) : SailM
                (BitVec esize) )
              let elt2_a ← (( do
                bif neg_r
                then
                  (do
                    assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                      (BEq.beq esize 64)) "src/instrs64_sve.sail:7790.57-7790.58"
                    (FPNeg elt2_a))
                else (pure elt2_a) ) : SailM (BitVec esize) )
              assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7793.53-7793.54"
              (FPMulAdd addend_r elt1_a elt2_a (← (FPCR_read ()))))
          else (pure addend_r) ) : SailM (BitVec esize) )
        let addend_i ← (( do
          bif (← (ActivePredicateElement mask ((2 *i p) +i 1) esize))
          then
            (do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i p) +i sel_a) esize) ) : SailM
                (BitVec esize) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i p) +i sel_b) esize) ) : SailM
                (BitVec esize) )
              let elt2_b ← (( do
                bif neg_i
                then
                  (do
                    assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                      (BEq.beq esize 64)) "src/instrs64_sve.sail:7800.57-7800.58"
                    (FPNeg elt2_b))
                else (pure elt2_b) ) : SailM (BitVec esize) )
              assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:7803.53-7803.54"
              (FPMulAdd addend_i elt1_a elt2_b (← (FPCR_read ()))))
          else (pure addend_i) ) : SailM (BitVec esize) )
        let result ← (Elem_set result ((2 *i p) +i 0) esize addend_r)
        let result ← (Elem_set result ((2 *i p) +i 1) esize addend_i)
        (pure (addend_i, addend_r, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
  (Z_set da VL result)

def decode_FCMLA_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (rot : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let neg_i : Bool := (BEq.beq (BitVec.join1 [(BitVec.access rot 1)]) (0b1 : (BitVec 1)))
  let neg_r : Bool :=
    (bne (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  match VL with
  | 128 => (execute_FCMLA_Z_P_ZZZ__ 128 da esize g m n neg_i neg_r sel_a sel_b)
  | 256 => (execute_FCMLA_Z_P_ZZZ__ 256 da esize g m n neg_i neg_r sel_a sel_b)
  | 512 => (execute_FCMLA_Z_P_ZZZ__ 512 da esize g m n neg_i neg_r sel_a sel_b)
  | 1024 => (execute_FCMLA_Z_P_ZZZ__ 1024 da esize g m n neg_i neg_r sel_a sel_b)
  | 2048 => (execute_FCMLA_Z_P_ZZZ__ 2048 da esize g m n neg_i neg_r sel_a sel_b)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_neg_i : Bool, k_neg_r
  : Bool, sel_a : Nat, sel_b : Nat, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FCMLA_Z_ZZZi_H (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (neg_i : Bool) (neg_r : Bool) (sel_a : Nat) (sel_b : Nat) : SailM Unit := do
  let addend_i ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let addend_r ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let elt1_a ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let elt2_a ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let elt2_b ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let s ← (( do (undefined_int ()) ) : SailM Int )
  let segmentbase ← (( do (undefined_int ()) ) : SailM Int )
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let pairspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (addend_i, addend_r, elt1_a, elt2_a, elt2_b, result, s, segmentbase) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (addend_i, addend_r, elt1_a, elt2_a, elt2_b, result, s, segmentbase)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (addend_i, addend_r, elt1_a, elt2_a, elt2_b, result, s, segmentbase) := loop_vars
      loop_vars ← do
        let segmentbase : Int := (p -i (Nat.div p pairspersegment))
        let s : Int := (segmentbase +i index)
        let addend_r ← (Elem_read operand3 ((2 *i p) +i 0) esize)
        let addend_i ← (Elem_read operand3 ((2 *i p) +i 1) esize)
        let elt1_a ← (Elem_read operand1 ((2 *i p) +i sel_a) esize)
        let s := s
        let elt2_a ← (Elem_read operand2 ((2 *i s) +i sel_a) esize)
        (pure ())
        let s := s
        let elt2_b ← (Elem_read operand2 ((2 *i s) +i sel_b) esize)
        (pure ())
        let elt2_a ← (( do
          bif neg_r
          then
            (do
              (FPNeg elt2_a))
          else (pure elt2_a) ) : SailM (BitVec esize) )
        let elt2_b ← (( do
          bif neg_i
          then
            (do
              (FPNeg elt2_b))
          else (pure elt2_b) ) : SailM (BitVec esize) )
        let addend_r ← (FPMulAdd addend_r elt1_a elt2_a (← (FPCR_read ())))
        let addend_i ← (FPMulAdd addend_i elt1_a elt2_b (← (FPCR_read ())))
        let result ← (Elem_set result ((2 *i p) +i 0) esize addend_r)
        let result ← (Elem_set result ((2 *i p) +i 1) esize addend_i)
        (pure (addend_i, addend_r, elt1_a, elt2_a, elt2_b, result, s, segmentbase))
    (pure loop_vars) ) : SailM
    ((BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec VL) × Int × Int)
    )
  (Z_set da VL result)

def decode_FCMLA_Z_ZZZi_H (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let neg_i : Bool := (BEq.beq (BitVec.join1 [(BitVec.access rot 1)]) (0b1 : (BitVec 1)))
  let neg_r : Bool :=
    (bne (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  match VL with
  | 128 => (execute_FCMLA_Z_ZZZi_H 128 da esize index m n neg_i neg_r sel_a sel_b)
  | 256 => (execute_FCMLA_Z_ZZZi_H 256 da esize index m n neg_i neg_r sel_a sel_b)
  | 512 => (execute_FCMLA_Z_ZZZi_H 512 da esize index m n neg_i neg_r sel_a sel_b)
  | 1024 => (execute_FCMLA_Z_ZZZi_H 1024 da esize index m n neg_i neg_r sel_a sel_b)
  | 2048 => (execute_FCMLA_Z_ZZZi_H 2048 da esize index m n neg_i neg_r sel_a sel_b)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_neg_i : Bool, k_neg_r
  : Bool, sel_a : Nat, sel_b : Nat, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FCMLA_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (neg_i : Bool) (neg_r : Bool) (sel_a : Nat) (sel_b : Nat) : SailM Unit := do
  let addend_i ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let addend_r ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let elt1_a ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let elt2_a ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let elt2_b ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let s ← (( do (undefined_int ()) ) : SailM Int )
  let segmentbase ← (( do (undefined_int ()) ) : SailM Int )
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let pairspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (addend_i, addend_r, elt1_a, elt2_a, elt2_b, result, s, segmentbase) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (addend_i, addend_r, elt1_a, elt2_a, elt2_b, result, s, segmentbase)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (addend_i, addend_r, elt1_a, elt2_a, elt2_b, result, s, segmentbase) := loop_vars
      loop_vars ← do
        let segmentbase : Int := (p -i (Nat.div p pairspersegment))
        let s : Int := (segmentbase +i index)
        let addend_r ← (Elem_read operand3 ((2 *i p) +i 0) esize)
        let addend_i ← (Elem_read operand3 ((2 *i p) +i 1) esize)
        let elt1_a ← (Elem_read operand1 ((2 *i p) +i sel_a) esize)
        let s := s
        let elt2_a ← (Elem_read operand2 ((2 *i s) +i sel_a) esize)
        (pure ())
        let s := s
        let elt2_b ← (Elem_read operand2 ((2 *i s) +i sel_b) esize)
        (pure ())
        let elt2_a ← (( do
          bif neg_r
          then
            (do
              (FPNeg elt2_a))
          else (pure elt2_a) ) : SailM (BitVec esize) )
        let elt2_b ← (( do
          bif neg_i
          then
            (do
              (FPNeg elt2_b))
          else (pure elt2_b) ) : SailM (BitVec esize) )
        let addend_r ← (FPMulAdd addend_r elt1_a elt2_a (← (FPCR_read ())))
        let addend_i ← (FPMulAdd addend_i elt1_a elt2_b (← (FPCR_read ())))
        let result ← (Elem_set result ((2 *i p) +i 0) esize addend_r)
        let result ← (Elem_set result ((2 *i p) +i 1) esize addend_i)
        (pure (addend_i, addend_r, elt1_a, elt2_a, elt2_b, result, s, segmentbase))
    (pure loop_vars) ) : SailM
    ((BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec esize) × (BitVec VL) × Int × Int)
    )
  (Z_set da VL result)

def decode_FCMLA_Z_ZZZi_S (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let neg_i : Bool := (BEq.beq (BitVec.join1 [(BitVec.access rot 1)]) (0b1 : (BitVec 1)))
  let neg_r : Bool :=
    (bne (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  match VL with
  | 128 => (execute_FCMLA_Z_ZZZi_S 128 da esize index m n neg_i neg_r sel_a sel_b)
  | 256 => (execute_FCMLA_Z_ZZZi_S 256 da esize index m n neg_i neg_r sel_a sel_b)
  | 512 => (execute_FCMLA_Z_ZZZi_S 512 da esize index m n neg_i neg_r sel_a sel_b)
  | 1024 => (execute_FCMLA_Z_ZZZi_S 1024 da esize index m n neg_i neg_r sel_a sel_b)
  | 2048 => (execute_FCMLA_Z_ZZZi_S 2048 da esize index m n neg_i neg_r sel_a sel_b)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMUL_Z_ZZi_H (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize (← (FPMul element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FMUL_Z_ZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FMUL_Z_ZZi_H 128 d esize index m n)
  | 256 => (execute_FMUL_Z_ZZi_H 256 d esize index m n)
  | 512 => (execute_FMUL_Z_ZZi_H 512 d esize index m n)
  | 1024 => (execute_FMUL_Z_ZZi_H 1024 d esize index m n)
  | 2048 => (execute_FMUL_Z_ZZi_H 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg :
  Bool, k_op3_neg : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLA_Z_ZZZi_H (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
        let element3 ← (( do (Elem_read result e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec esize) )
        let element3 ← (( do
          bif op3_neg
          then
            (do
              (FPNeg element3))
          else (pure element3) ) : SailM (BitVec esize) )
        (Elem_set result e esize (← (FPMulAdd element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLA_Z_ZZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := false
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_FMLA_Z_ZZZi_H 128 da esize index m n op1_neg op3_neg)
  | 256 => (execute_FMLA_Z_ZZZi_H 256 da esize index m n op1_neg op3_neg)
  | 512 => (execute_FMLA_Z_ZZZi_H 512 da esize index m n op1_neg op3_neg)
  | 1024 => (execute_FMLA_Z_ZZZi_H 1024 da esize index m n op1_neg op3_neg)
  | 2048 => (execute_FMLA_Z_ZZZi_H 2048 da esize index m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg :
  Bool, k_op3_neg : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLS_Z_ZZZi_H (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
        let element3 ← (( do (Elem_read result e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec esize) )
        let element3 ← (( do
          bif op3_neg
          then
            (do
              (FPNeg element3))
          else (pure element3) ) : SailM (BitVec esize) )
        (Elem_set result e esize (← (FPMulAdd element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLS_Z_ZZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_FMLS_Z_ZZZi_H 128 da esize index m n op1_neg op3_neg)
  | 256 => (execute_FMLS_Z_ZZZi_H 256 da esize index m n op1_neg op3_neg)
  | 512 => (execute_FMLS_Z_ZZZi_H 512 da esize index m n op1_neg op3_neg)
  | 1024 => (execute_FMLS_Z_ZZZi_H 1024 da esize index m n op1_neg op3_neg)
  | 2048 => (execute_FMLS_Z_ZZZi_H 2048 da esize index m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMUL_Z_ZZi_S (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize (← (FPMul element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FMUL_Z_ZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FMUL_Z_ZZi_S 128 d esize index m n)
  | 256 => (execute_FMUL_Z_ZZi_S 256 d esize index m n)
  | 512 => (execute_FMUL_Z_ZZi_S 512 d esize index m n)
  | 1024 => (execute_FMUL_Z_ZZi_S 1024 d esize index m n)
  | 2048 => (execute_FMUL_Z_ZZi_S 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg :
  Bool, k_op3_neg : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLA_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
        let element3 ← (( do (Elem_read result e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec esize) )
        let element3 ← (( do
          bif op3_neg
          then
            (do
              (FPNeg element3))
          else (pure element3) ) : SailM (BitVec esize) )
        (Elem_set result e esize (← (FPMulAdd element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLA_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := false
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_FMLA_Z_ZZZi_S 128 da esize index m n op1_neg op3_neg)
  | 256 => (execute_FMLA_Z_ZZZi_S 256 da esize index m n op1_neg op3_neg)
  | 512 => (execute_FMLA_Z_ZZZi_S 512 da esize index m n op1_neg op3_neg)
  | 1024 => (execute_FMLA_Z_ZZZi_S 1024 da esize index m n op1_neg op3_neg)
  | 2048 => (execute_FMLA_Z_ZZZi_S 2048 da esize index m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg :
  Bool, k_op3_neg : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLS_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
        let element3 ← (( do (Elem_read result e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec esize) )
        let element3 ← (( do
          bif op3_neg
          then
            (do
              (FPNeg element3))
          else (pure element3) ) : SailM (BitVec esize) )
        (Elem_set result e esize (← (FPMulAdd element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLS_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_FMLS_Z_ZZZi_S 128 da esize index m n op1_neg op3_neg)
  | 256 => (execute_FMLS_Z_ZZZi_S 256 da esize index m n op1_neg op3_neg)
  | 512 => (execute_FMLS_Z_ZZZi_S 512 da esize index m n op1_neg op3_neg)
  | 1024 => (execute_FMLS_Z_ZZZi_S 1024 da esize index m n op1_neg op3_neg)
  | 2048 => (execute_FMLS_Z_ZZZi_S 2048 da esize index m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMUL_Z_ZZi_D (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize (← (FPMul element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FMUL_Z_ZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FMUL_Z_ZZi_D 128 d esize index m n)
  | 256 => (execute_FMUL_Z_ZZi_D 256 d esize index m n)
  | 512 => (execute_FMUL_Z_ZZi_D 512 d esize index m n)
  | 1024 => (execute_FMUL_Z_ZZi_D 1024 d esize index m n)
  | 2048 => (execute_FMUL_Z_ZZi_D 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg :
  Bool, k_op3_neg : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLA_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
        let element3 ← (( do (Elem_read result e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec esize) )
        let element3 ← (( do
          bif op3_neg
          then
            (do
              (FPNeg element3))
          else (pure element3) ) : SailM (BitVec esize) )
        (Elem_set result e esize (← (FPMulAdd element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLA_Z_ZZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (op : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := false
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_FMLA_Z_ZZZi_D 128 da esize index m n op1_neg op3_neg)
  | 256 => (execute_FMLA_Z_ZZZi_D 256 da esize index m n op1_neg op3_neg)
  | 512 => (execute_FMLA_Z_ZZZi_D 512 da esize index m n op1_neg op3_neg)
  | 1024 => (execute_FMLA_Z_ZZZi_D 1024 da esize index m n op1_neg op3_neg)
  | 2048 => (execute_FMLA_Z_ZZZi_D 2048 da esize index m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg :
  Bool, k_op3_neg : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLS_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 s esize) ) : SailM (BitVec esize) )
        let element3 ← (( do (Elem_read result e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec esize) )
        let element3 ← (( do
          bif op3_neg
          then
            (do
              (FPNeg element3))
          else (pure element3) ) : SailM (BitVec esize) )
        (Elem_set result e esize (← (FPMulAdd element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLS_Z_ZZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (op : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_FMLS_Z_ZZZi_D 128 da esize index m n op1_neg op3_neg)
  | 256 => (execute_FMLS_Z_ZZZi_D 256 da esize index m n op1_neg op3_neg)
  | 512 => (execute_FMLS_Z_ZZZi_D 512 da esize index m n op1_neg op3_neg)
  | 1024 => (execute_FMLS_Z_ZZZi_D 1024 da esize index m n op1_neg op3_neg)
  | 2048 => (execute_FMLS_Z_ZZZi_D 2048 da esize index m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FADDP_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let (element1, element2) ← (( do
                bif (IsEven e)
                then
                  (do
                    let element1 ← (Elem_read operand1 (e +i 0) esize)
                    let element2 ← (Elem_read operand1 (e +i 1) esize)
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ← (Elem_read operand2 (e -i 1) esize)
                    let element2 ← (Elem_read operand2 (e +i 0) esize)
                    (pure (element1, element2))) ) : SailM ((BitVec esize) × (BitVec esize)) )
              assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:8726.53-8726.54"
              let result ←
                (Elem_set result e esize (← (FPAdd element1 element2 (← (FPCR_read ())))))
              (pure (element1, element2, result)))
          else (pure (element1, element2, result)) ) : SailM
          ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
  (Z_set dn VL result)

def decode_FADDP_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_FADDP_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FADDP_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FADDP_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FADDP_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FADDP_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXNMP_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let (element1, element2) ← (( do
                bif (IsEven e)
                then
                  (do
                    let element1 ← (Elem_read operand1 (e +i 0) esize)
                    let element2 ← (Elem_read operand1 (e +i 1) esize)
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ← (Elem_read operand2 (e -i 1) esize)
                    let element2 ← (Elem_read operand2 (e +i 0) esize)
                    (pure (element1, element2))) ) : SailM ((BitVec esize) × (BitVec esize)) )
              assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:8804.53-8804.54"
              let result ←
                (Elem_set result e esize (← (FPMaxNum element1 element2 (← (FPCR_read ())))))
              (pure (element1, element2, result)))
          else (pure (element1, element2, result)) ) : SailM
          ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
  (Z_set dn VL result)

def decode_FMAXNMP_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_FMAXNMP_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FMAXNMP_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FMAXNMP_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FMAXNMP_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FMAXNMP_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXP_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let (element1, element2) ← (( do
                bif (IsEven e)
                then
                  (do
                    let element1 ← (Elem_read operand1 (e +i 0) esize)
                    let element2 ← (Elem_read operand1 (e +i 1) esize)
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ← (Elem_read operand2 (e -i 1) esize)
                    let element2 ← (Elem_read operand2 (e +i 0) esize)
                    (pure (element1, element2))) ) : SailM ((BitVec esize) × (BitVec esize)) )
              assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:8882.53-8882.54"
              let result ←
                (Elem_set result e esize (← (FPMax element1 element2 (← (FPCR_read ())))))
              (pure (element1, element2, result)))
          else (pure (element1, element2, result)) ) : SailM
          ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
  (Z_set dn VL result)

def decode_FMAXP_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_FMAXP_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FMAXP_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FMAXP_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FMAXP_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FMAXP_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMINNMP_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let (element1, element2) ← (( do
                bif (IsEven e)
                then
                  (do
                    let element1 ← (Elem_read operand1 (e +i 0) esize)
                    let element2 ← (Elem_read operand1 (e +i 1) esize)
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ← (Elem_read operand2 (e -i 1) esize)
                    let element2 ← (Elem_read operand2 (e +i 0) esize)
                    (pure (element1, element2))) ) : SailM ((BitVec esize) × (BitVec esize)) )
              assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:8960.53-8960.54"
              let result ←
                (Elem_set result e esize (← (FPMinNum element1 element2 (← (FPCR_read ())))))
              (pure (element1, element2, result)))
          else (pure (element1, element2, result)) ) : SailM
          ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
  (Z_set dn VL result)

def decode_FMINNMP_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_FMINNMP_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FMINNMP_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FMINNMP_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FMINNMP_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FMINNMP_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_FMINP_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let (element1, element2) ← (( do
                bif (IsEven e)
                then
                  (do
                    let element1 ← (Elem_read operand1 (e +i 0) esize)
                    let element2 ← (Elem_read operand1 (e +i 1) esize)
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ← (Elem_read operand2 (e -i 1) esize)
                    let element2 ← (Elem_read operand2 (e +i 0) esize)
                    (pure (element1, element2))) ) : SailM ((BitVec esize) × (BitVec esize)) )
              assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:9038.53-9038.54"
              let result ←
                (Elem_set result e esize (← (FPMin element1 element2 (← (FPCR_read ())))))
              (pure (element1, element2, result)))
          else (pure (element1, element2, result)) ) : SailM
          ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × (BitVec VL)) )
  (Z_set dn VL result)

def decode_FMINP_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_FMINP_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_FMINP_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_FMINP_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_FMINP_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_FMINP_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, k_op1_neg : Bool, 0 ≤ n
  ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLALB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec (esize / 2)) )
        (Elem_set result e esize (← (FPMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLALB_Z_ZZZ__ (o2 : (BitVec 1)) (Zm : (BitVec 5)) (op : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := false
  match VL with
  | 128 => (execute_FMLALB_Z_ZZZ__ 128 da esize m n op1_neg)
  | 256 => (execute_FMLALB_Z_ZZZ__ 256 da esize m n op1_neg)
  | 512 => (execute_FMLALB_Z_ZZZ__ 512 da esize m n op1_neg)
  | 1024 => (execute_FMLALB_Z_ZZZ__ 1024 da esize m n op1_neg)
  | 2048 => (execute_FMLALB_Z_ZZZ__ 2048 da esize m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, k_op1_neg : Bool, 0 ≤ n
  ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLALT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec (esize / 2)) )
        (Elem_set result e esize (← (FPMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLALT_Z_ZZZ__ (o2 : (BitVec 1)) (Zm : (BitVec 5)) (op : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := false
  match VL with
  | 128 => (execute_FMLALT_Z_ZZZ__ 128 da esize m n op1_neg)
  | 256 => (execute_FMLALT_Z_ZZZ__ 256 da esize m n op1_neg)
  | 512 => (execute_FMLALT_Z_ZZZ__ 512 da esize m n op1_neg)
  | 1024 => (execute_FMLALT_Z_ZZZ__ 1024 da esize m n op1_neg)
  | 2048 => (execute_FMLALT_Z_ZZZ__ 2048 da esize m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, k_op1_neg : Bool, 0 ≤ n
  ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLSLB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec (esize / 2)) )
        (Elem_set result e esize (← (FPMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLSLB_Z_ZZZ__ (o2 : (BitVec 1)) (Zm : (BitVec 5)) (op : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  match VL with
  | 128 => (execute_FMLSLB_Z_ZZZ__ 128 da esize m n op1_neg)
  | 256 => (execute_FMLSLB_Z_ZZZ__ 256 da esize m n op1_neg)
  | 512 => (execute_FMLSLB_Z_ZZZ__ 512 da esize m n op1_neg)
  | 1024 => (execute_FMLSLB_Z_ZZZ__ 1024 da esize m n op1_neg)
  | 2048 => (execute_FMLSLB_Z_ZZZ__ 2048 da esize m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, k_op1_neg : Bool, 0 ≤ n
  ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLSLT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec (esize / 2)) )
        (Elem_set result e esize (← (FPMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLSLT_Z_ZZZ__ (o2 : (BitVec 1)) (Zm : (BitVec 5)) (op : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  match VL with
  | 128 => (execute_FMLSLT_Z_ZZZ__ 128 da esize m n op1_neg)
  | 256 => (execute_FMLSLT_Z_ZZZ__ 256 da esize m n op1_neg)
  | 512 => (execute_FMLSLT_Z_ZZZ__ 512 da esize m n op1_neg)
  | 1024 => (execute_FMLSLT_Z_ZZZ__ 1024 da esize m n op1_neg)
  | 2048 => (execute_FMLSLT_Z_ZZZ__ 2048 da esize m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg :
  Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLALB_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := ((2 *i segmentbase) +i index)
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 s (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec (esize / 2)) )
        (Elem_set result e esize (← (FPMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLALB_Z_ZZZi_S (o2 : (BitVec 1)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let index := (BitVec.toNat (i3h ++ i3l))
  let op1_neg : Bool := false
  match VL with
  | 128 => (execute_FMLALB_Z_ZZZi_S 128 da esize index m n op1_neg)
  | 256 => (execute_FMLALB_Z_ZZZi_S 256 da esize index m n op1_neg)
  | 512 => (execute_FMLALB_Z_ZZZi_S 512 da esize index m n op1_neg)
  | 1024 => (execute_FMLALB_Z_ZZZi_S 1024 da esize index m n op1_neg)
  | 2048 => (execute_FMLALB_Z_ZZZi_S 2048 da esize index m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg :
  Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLALT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := ((2 *i segmentbase) +i index)
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 s (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec (esize / 2)) )
        (Elem_set result e esize (← (FPMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLALT_Z_ZZZi_S (o2 : (BitVec 1)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let index := (BitVec.toNat (i3h ++ i3l))
  let op1_neg : Bool := false
  match VL with
  | 128 => (execute_FMLALT_Z_ZZZi_S 128 da esize index m n op1_neg)
  | 256 => (execute_FMLALT_Z_ZZZi_S 256 da esize index m n op1_neg)
  | 512 => (execute_FMLALT_Z_ZZZi_S 512 da esize index m n op1_neg)
  | 1024 => (execute_FMLALT_Z_ZZZi_S 1024 da esize index m n op1_neg)
  | 2048 => (execute_FMLALT_Z_ZZZi_S 2048 da esize index m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg :
  Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLSLB_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := ((2 *i segmentbase) +i index)
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 s (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec (esize / 2)) )
        (Elem_set result e esize (← (FPMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLSLB_Z_ZZZi_S (o2 : (BitVec 1)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let index := (BitVec.toNat (i3h ++ i3l))
  let op1_neg : Bool := true
  match VL with
  | 128 => (execute_FMLSLB_Z_ZZZi_S 128 da esize index m n op1_neg)
  | 256 => (execute_FMLSLB_Z_ZZZi_S 256 da esize index m n op1_neg)
  | 512 => (execute_FMLSLB_Z_ZZZi_S 512 da esize index m n op1_neg)
  | 1024 => (execute_FMLSLB_Z_ZZZi_S 1024 da esize index m n op1_neg)
  | 2048 => (execute_FMLSLB_Z_ZZZi_S 2048 da esize index m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg :
  Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMLSLT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := ((2 *i segmentbase) +i index)
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 s (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (FPNeg element1))
          else (pure element1) ) : SailM (BitVec (esize / 2)) )
        (Elem_set result e esize (← (FPMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FMLSLT_Z_ZZZi_S (o2 : (BitVec 1)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let index := (BitVec.toNat (i3h ++ i3l))
  let op1_neg : Bool := true
  match VL with
  | 128 => (execute_FMLSLT_Z_ZZZi_S 128 da esize index m n op1_neg)
  | 256 => (execute_FMLSLT_Z_ZZZi_S 256 da esize index m n op1_neg)
  | 512 => (execute_FMLSLT_Z_ZZZi_S 512 da esize index m n op1_neg)
  | 1024 => (execute_FMLSLT_Z_ZZZi_S 1024 da esize index m n op1_neg)
  | 2048 => (execute_FMLSLT_Z_ZZZi_S 2048 da esize index m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLALB_Z_ZZZ__ (VL : Nat) (da : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        (Elem_set result e 32 (← (BFMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLALB_Z_ZZZ__ (o2 : (BitVec 1)) (Zm : (BitVec 5)) (op : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveBF16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_BFMLALB_Z_ZZZ__ 128 da m n)
  | 256 => (execute_BFMLALB_Z_ZZZ__ 256 da m n)
  | 512 => (execute_BFMLALB_Z_ZZZ__ 512 da m n)
  | 1024 => (execute_BFMLALB_Z_ZZZ__ 1024 da m n)
  | 2048 => (execute_BFMLALB_Z_ZZZ__ 2048 da m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLALT_Z_ZZZ__ (VL : Nat) (da : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        (Elem_set result e 32 (← (BFMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLALT_Z_ZZZ__ (o2 : (BitVec 1)) (Zm : (BitVec 5)) (op : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveBF16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_BFMLALT_Z_ZZZ__ 128 da m n)
  | 256 => (execute_BFMLALT_Z_ZZZ__ 256 da m n)
  | 512 => (execute_BFMLALT_Z_ZZZ__ 512 da m n)
  | 1024 => (execute_BFMLALT_Z_ZZZ__ 1024 da m n)
  | 2048 => (execute_BFMLALT_Z_ZZZ__ 2048 da m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, m : Nat, n : Nat, k_op1_neg : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLSLB_Z_ZZZ__ (VL : Nat) (da : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (BFNeg element1))
          else (pure element1) ) : SailM (BitVec 16) )
        (Elem_set result e 32 (← (BFMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLSLB_Z_ZZZ__ (o2 : (BitVec 1)) (Zm : (BitVec 5)) (op : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  match VL with
  | 128 => (execute_BFMLSLB_Z_ZZZ__ 128 da m n op1_neg)
  | 256 => (execute_BFMLSLB_Z_ZZZ__ 256 da m n op1_neg)
  | 512 => (execute_BFMLSLB_Z_ZZZ__ 512 da m n op1_neg)
  | 1024 => (execute_BFMLSLB_Z_ZZZ__ 1024 da m n op1_neg)
  | 2048 => (execute_BFMLSLB_Z_ZZZ__ 2048 da m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, m : Nat, n : Nat, k_op1_neg : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLSLT_Z_ZZZ__ (VL : Nat) (da : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (BFNeg element1))
          else (pure element1) ) : SailM (BitVec 16) )
        (Elem_set result e 32 (← (BFMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLSLT_Z_ZZZ__ (o2 : (BitVec 1)) (Zm : (BitVec 5)) (op : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  match VL with
  | 128 => (execute_BFMLSLT_Z_ZZZ__ 128 da m n op1_neg)
  | 256 => (execute_BFMLSLT_Z_ZZZ__ 256 da m n op1_neg)
  | 512 => (execute_BFMLSLT_Z_ZZZ__ 512 da m n op1_neg)
  | 1024 => (execute_BFMLSLT_Z_ZZZ__ 1024 da m n op1_neg)
  | 2048 => (execute_BFMLSLT_Z_ZZZ__ 2048 da m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLALB_Z_ZZZi__ (VL : Nat) (da : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let eltspersegment := (Int.ediv 128 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := ((2 *i segmentbase) +i index)
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        (Elem_set result e 32 (← (BFMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLALB_Z_ZZZi__ (o2 : (BitVec 1)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveBF16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let index := (BitVec.toNat (i3h ++ i3l))
  match VL with
  | 128 => (execute_BFMLALB_Z_ZZZi__ 128 da index m n)
  | 256 => (execute_BFMLALB_Z_ZZZi__ 256 da index m n)
  | 512 => (execute_BFMLALB_Z_ZZZi__ 512 da index m n)
  | 1024 => (execute_BFMLALB_Z_ZZZi__ 1024 da index m n)
  | 2048 => (execute_BFMLALB_Z_ZZZi__ 2048 da index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLALT_Z_ZZZi__ (VL : Nat) (da : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let eltspersegment := (Int.ediv 128 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := ((2 *i segmentbase) +i index)
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        (Elem_set result e 32 (← (BFMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLALT_Z_ZZZi__ (o2 : (BitVec 1)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveBF16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let index := (BitVec.toNat (i3h ++ i3l))
  match VL with
  | 128 => (execute_BFMLALT_Z_ZZZi__ 128 da index m n)
  | 256 => (execute_BFMLALT_Z_ZZZi__ 256 da index m n)
  | 512 => (execute_BFMLALT_Z_ZZZi__ 512 da index m n)
  | 1024 => (execute_BFMLALT_Z_ZZZi__ 1024 da index m n)
  | 2048 => (execute_BFMLALT_Z_ZZZi__ 2048 da index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg : Bool, 0 ≤ n
  ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLSLB_Z_ZZZi__ (VL : Nat) (da : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let eltspersegment := (Int.ediv 128 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := ((2 *i segmentbase) +i index)
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (BFNeg element1))
          else (pure element1) ) : SailM (BitVec 16) )
        (Elem_set result e 32 (← (BFMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLSLB_Z_ZZZi__ (o2 : (BitVec 1)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let index := (BitVec.toNat (i3h ++ i3l))
  let op1_neg : Bool := true
  match VL with
  | 128 => (execute_BFMLSLB_Z_ZZZi__ 128 da index m n op1_neg)
  | 256 => (execute_BFMLSLB_Z_ZZZi__ 256 da index m n op1_neg)
  | 512 => (execute_BFMLSLB_Z_ZZZi__ 512 da index m n op1_neg)
  | 1024 => (execute_BFMLSLB_Z_ZZZi__ 1024 da index m n op1_neg)
  | 2048 => (execute_BFMLSLB_Z_ZZZi__ 2048 da index m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg : Bool, 0 ≤ n
  ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLSLT_Z_ZZZi__ (VL : Nat) (da : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let eltspersegment := (Int.ediv 128 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := ((2 *i segmentbase) +i index)
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (BFNeg element1))
          else (pure element1) ) : SailM (BitVec 16) )
        (Elem_set result e 32 (← (BFMulAddH element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLSLT_Z_ZZZi__ (o2 : (BitVec 1)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let index := (BitVec.toNat (i3h ++ i3l))
  let op1_neg : Bool := true
  match VL with
  | 128 => (execute_BFMLSLT_Z_ZZZi__ 128 da index m n op1_neg)
  | 256 => (execute_BFMLSLT_Z_ZZZi__ 256 da index m n op1_neg)
  | 512 => (execute_BFMLSLT_Z_ZZZi__ 512 da index m n op1_neg)
  | 1024 => (execute_BFMLSLT_Z_ZZZi__ 1024 da index m n op1_neg)
  | 2048 => (execute_BFMLSLT_Z_ZZZi__ 2048 da index m n op1_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFDOT_Z_ZZZ__ (VL : Nat) (da : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) : SailM
          (BitVec 32) )
        (Elem_set result e 32 sum)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFDOT_Z_ZZZ__ (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveBF16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_BFDOT_Z_ZZZ__ 128 da m n)
  | 256 => (execute_BFDOT_Z_ZZZ__ 256 da m n)
  | 512 => (execute_BFDOT_Z_ZZZ__ 512 da m n)
  | 1024 => (execute_BFDOT_Z_ZZZ__ 1024 da m n)
  | 2048 => (execute_BFDOT_Z_ZZZ__ 2048 da m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ index ∈ {0, 1, 2, 3} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFDOT_Z_ZZZi__ (VL : Nat) (da : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let eltspersegment := (Int.ediv 128 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let elt2_a ← (( do (Elem_read operand2 ((2 *i s) +i 0) 16) ) : SailM (BitVec 16) )
        let elt2_b ← (( do (Elem_read operand2 ((2 *i s) +i 1) 16) ) : SailM (BitVec 16) )
        let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let sum ← (( do (BFDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) : SailM
          (BitVec 32) )
        (Elem_set result e 32 sum)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFDOT_Z_ZZZi__ (i2 : (BitVec 2)) (Zm : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveBF16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let index := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_BFDOT_Z_ZZZi__ 128 da index m n)
  | 256 => (execute_BFDOT_Z_ZZZi__ 256 da index m n)
  | 512 => (execute_BFDOT_Z_ZZZi__ 512 da index m n)
  | 1024 => (execute_BFDOT_Z_ZZZi__ 1024 da index m n)
  | 2048 => (execute_BFDOT_Z_ZZZi__ 2048 da index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FDOT_Z_ZZZ__ (VL : Nat) (da : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let sum ← (( do (FPDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) : SailM
          (BitVec 32) )
        (Elem_set result e 32 sum)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FDOT_Z_ZZZ__ (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_FDOT_Z_ZZZ__ 128 da m n)
  | 256 => (execute_FDOT_Z_ZZZ__ 256 da m n)
  | 512 => (execute_FDOT_Z_ZZZ__ 512 da m n)
  | 1024 => (execute_FDOT_Z_ZZZ__ 1024 da m n)
  | 2048 => (execute_FDOT_Z_ZZZ__ 2048 da m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ index ∈ {0, 1, 2, 3} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FDOT_Z_ZZZi__ (VL : Nat) (da : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let eltspersegment := (Int.ediv 128 32)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
        let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
        let elt2_a ← (( do (Elem_read operand2 ((2 *i s) +i 0) 16) ) : SailM (BitVec 16) )
        let elt2_b ← (( do (Elem_read operand2 ((2 *i s) +i 1) 16) ) : SailM (BitVec 16) )
        let sum ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        let sum ← (( do (FPDotAdd sum elt1_a elt1_b elt2_a elt2_b (← (FPCR_read ()))) ) : SailM
          (BitVec 32) )
        (Elem_set result e 32 sum)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_FDOT_Z_ZZZi__ (i2 : (BitVec 2)) (Zm : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let index := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_FDOT_Z_ZZZi__ 128 da index m n)
  | 256 => (execute_FDOT_Z_ZZZi__ 256 da index m n)
  | 512 => (execute_FDOT_Z_ZZZi__ 512 da index m n)
  | 1024 => (execute_FDOT_Z_ZZZi__ 1024 da index m n)
  | 2048 => (execute_FDOT_Z_ZZZi__ 2048 da index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFCVT_Z_P_Z_S2BF (VL : Nat) (d : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask 32))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e 32))
        then
          (do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            let result ←
              (Elem_set result (2 *i e) 16 (← (FPConvertBF__1 element (← (FPCR_read ())))))
            (Elem_set result ((2 *i e) +i 1) 16 (Zeros (n := 16))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BFCVT_Z_P_Z_S2BF (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveBF16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BFCVT_Z_P_Z_S2BF 128 d g n)
  | 256 => (execute_BFCVT_Z_P_Z_S2BF 256 d g n)
  | 512 => (execute_BFCVT_Z_P_Z_S2BF 512 d g n)
  | 1024 => (execute_BFCVT_Z_P_Z_S2BF 1024 d g n)
  | 2048 => (execute_BFCVT_Z_P_Z_S2BF 2048 d g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFCVTNT_Z_P_Z_S2BF (VL : Nat) (d : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 32)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask 32))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e 32))
        then
          (do
            let element ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (Elem_set result ((2 *i e) +i 1) 16 (← (FPConvertBF__1 element (← (FPCR_read ()))))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BFCVTNT_Z_P_Z_S2BF (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveBF16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BFCVTNT_Z_P_Z_S2BF 128 d g n)
  | 256 => (execute_BFCVTNT_Z_P_Z_S2BF 256 d g n)
  | 512 => (execute_BFCVTNT_Z_P_Z_S2BF 512 d g n)
  | 1024 => (execute_BFCVTNT_Z_P_Z_S2BF 1024 d g n)
  | 2048 => (execute_BFCVTNT_Z_P_Z_S2BF 2048 d g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMMLA_Z_ZZZ_S (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL (4 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let op1 ← (( do (undefined_bitvector (4 *i esize)) ) : SailM (BitVec (4 * esize)) )
  let op2 ← (( do (undefined_bitvector (4 *i esize)) ) : SailM (BitVec (4 * esize)) )
  let addend ← (( do (undefined_bitvector (4 *i esize)) ) : SailM (BitVec (4 * esize)) )
  let res ← (( do (undefined_bitvector (4 *i esize)) ) : SailM (BitVec (4 * esize)) )
  let (addend, op1, op2, res, result) ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := (addend, op1, op2, res, result)
    for s in [loop_s_lower:loop_s_upper:1]i do
      let (addend, op1, op2, res, result) := loop_vars
      loop_vars ← do
        let op1 ← (Elem_read operand1 s (4 *i esize))
        let op2 ← (Elem_read operand2 s (4 *i esize))
        let addend ← (Elem_read operand3 s (4 *i esize))
        let res ← (FPMatMulAdd addend op1 op2 esize (← (FPCR_read ())))
        let result ← (Elem_set result s (4 *i esize) res)
        (pure (addend, op1, op2, res, result))
    (pure loop_vars) ) : SailM
    ((BitVec (4 * esize)) × (BitVec (4 * esize)) × (BitVec (4 * esize)) × (BitVec (4 * esize)) × (BitVec VL))
    )
  (Z_set da VL result)

def decode_FMMLA_Z_ZZZ_S (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP32MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_FMMLA_Z_ZZZ_S 128 da esize m n)
  | 256 => (execute_FMMLA_Z_ZZZ_S 256 da esize m n)
  | 512 => (execute_FMMLA_Z_ZZZ_S 512 da esize m n)
  | 1024 => (execute_FMMLA_Z_ZZZ_S 1024 da esize m n)
  | 2048 => (execute_FMMLA_Z_ZZZ_S 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 64 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_FMMLA_Z_ZZZ_D (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  bif (VL <b (esize *i 4))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let segments := (Int.ediv VL (4 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let op1 ← (( do (undefined_bitvector (4 *i esize)) ) : SailM (BitVec (4 * esize)) )
  let op2 ← (( do (undefined_bitvector (4 *i esize)) ) : SailM (BitVec (4 * esize)) )
  let addend ← (( do (undefined_bitvector (4 *i esize)) ) : SailM (BitVec (4 * esize)) )
  let res ← (( do (undefined_bitvector (4 *i esize)) ) : SailM (BitVec (4 * esize)) )
  let (addend, op1, op2, res, result) ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := (addend, op1, op2, res, result)
    for s in [loop_s_lower:loop_s_upper:1]i do
      let (addend, op1, op2, res, result) := loop_vars
      loop_vars ← do
        let op1 ← (Elem_read operand1 s (4 *i esize))
        let op2 ← (Elem_read operand2 s (4 *i esize))
        let addend ← (Elem_read operand3 s (4 *i esize))
        let res ← (FPMatMulAdd addend op1 op2 esize (← (FPCR_read ())))
        let result ← (Elem_set result s (4 *i esize) res)
        (pure (addend, op1, op2, res, result))
    (pure loop_vars) ) : SailM
    ((BitVec (4 * esize)) × (BitVec (4 * esize)) × (BitVec (4 * esize)) × (BitVec (4 * esize)) × (BitVec VL))
    )
  (Z_set da VL result)

def decode_FMMLA_Z_ZZZ_D (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_FMMLA_Z_ZZZ_D 128 da esize m n)
  | 256 => (execute_FMMLA_Z_ZZZ_D 256 da esize m n)
  | 512 => (execute_FMMLA_Z_ZZZ_D 512 da esize m n)
  | 1024 => (execute_FMMLA_Z_ZZZ_D 1024 da esize m n)
  | 2048 => (execute_FMMLA_Z_ZZZ_D 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMMLA_Z_ZZZ__ (VL : Nat) (da : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let op1 ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let op2 ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let addend ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let res ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let (addend, op1, op2, res, result) ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := (addend, op1, op2, res, result)
    for s in [loop_s_lower:loop_s_upper:1]i do
      let (addend, op1, op2, res, result) := loop_vars
      loop_vars ← do
        let op1 ← (Elem_read operand1 s 128)
        let op2 ← (Elem_read operand2 s 128)
        let addend ← (Elem_read operand3 s 128)
        let res ← (BFMatMulAdd addend op1 op2)
        let result ← (Elem_set result s 128 res)
        (pure (addend, op1, op2, res, result))
    (pure loop_vars) ) : SailM
    ((BitVec 128) × (BitVec 128) × (BitVec 128) × (BitVec 128) × (BitVec VL)) )
  (Z_set da VL result)

def decode_BFMMLA_Z_ZZZ__ (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveBF16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_BFMMLA_Z_ZZZ__ 128 da m n)
  | 256 => (execute_BFMMLA_Z_ZZZ__ 256 da m n)
  | 512 => (execute_BFMMLA_Z_ZZZ__ 512 da m n)
  | 1024 => (execute_BFMMLA_Z_ZZZ__ 1024 da m n)
  | 2048 => (execute_BFMMLA_Z_ZZZ__ 2048 da m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FLOGB_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:10809.53-10809.54"
            (Elem_set result e esize (← (FPLogB element (← (FPCR_read ()))))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FLOGB_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FLOGB_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_FLOGB_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_FLOGB_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_FLOGB_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FLOGB_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTNT_Z_P_Z_D2S (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result ((2 *i e) +i 1) (Int.ediv esize 2)
              (← (FPConvertSVE__1 element (← (FPCR_read ())) (Int.ediv esize 2)))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTNT_Z_P_Z_D2S (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FCVTNT_Z_P_Z_D2S 128 d esize g n)
  | 256 => (execute_FCVTNT_Z_P_Z_D2S 256 d esize g n)
  | 512 => (execute_FCVTNT_Z_P_Z_D2S 512 d esize g n)
  | 1024 => (execute_FCVTNT_Z_P_Z_D2S 1024 d esize g n)
  | 2048 => (execute_FCVTNT_Z_P_Z_D2S 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTNT_Z_P_Z_S2H (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result ((2 *i e) +i 1) (Int.ediv esize 2)
              (← (FPConvertSVE__1 element (← (FPCR_read ())) (Int.ediv esize 2)))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTNT_Z_P_Z_S2H (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FCVTNT_Z_P_Z_S2H 128 d esize g n)
  | 256 => (execute_FCVTNT_Z_P_Z_S2H 256 d esize g n)
  | 512 => (execute_FCVTNT_Z_P_Z_S2H 512 d esize g n)
  | 1024 => (execute_FCVTNT_Z_P_Z_S2H 1024 d esize g n)
  | 2048 => (execute_FCVTNT_Z_P_Z_S2H 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTLT_Z_P_Z_S2D (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
              (BitVec (esize / 2)) )
            (Elem_set result e esize (← (FPConvertSVE__1 element (← (FPCR_read ())) esize))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTLT_Z_P_Z_S2D (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FCVTLT_Z_P_Z_S2D 128 d esize g n)
  | 256 => (execute_FCVTLT_Z_P_Z_S2D 256 d esize g n)
  | 512 => (execute_FCVTLT_Z_P_Z_S2D 512 d esize g n)
  | 1024 => (execute_FCVTLT_Z_P_Z_S2D 1024 d esize g n)
  | 2048 => (execute_FCVTLT_Z_P_Z_S2D 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTLT_Z_P_Z_H2S (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
              (BitVec (esize / 2)) )
            (Elem_set result e esize (← (FPConvertSVE__1 element (← (FPCR_read ())) esize))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTLT_Z_P_Z_H2S (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FCVTLT_Z_P_Z_H2S 128 d esize g n)
  | 256 => (execute_FCVTLT_Z_P_Z_H2S 256 d esize g n)
  | 512 => (execute_FCVTLT_Z_P_Z_H2S 512 d esize g n)
  | 1024 => (execute_FCVTLT_Z_P_Z_H2S 1024 d esize g n)
  | 2048 => (execute_FCVTLT_Z_P_Z_H2S 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, d_esize : Nat, esize : Nat, g : Nat, n : Nat, s_esize : Nat, s_esize
  = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize = 64 ∧ d_esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTX_Z_P_Z_D2S (VL : Nat) (d : Nat) (d_esize : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            let res ← (( do
              (FPConvertSVE (Sail.BitVec.extractLsb element (s_esize -i 1) 0) (← (FPCR_read ()))
                FPRounding_ODD d_esize) ) : SailM (BitVec d_esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend res esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTX_Z_P_Z_D2S (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let s_esize := 64
  let d_esize := 32
  match VL with
  | 128 => (execute_FCVTX_Z_P_Z_D2S 128 d d_esize esize g n s_esize)
  | 256 => (execute_FCVTX_Z_P_Z_D2S 256 d d_esize esize g n s_esize)
  | 512 => (execute_FCVTX_Z_P_Z_D2S 512 d d_esize esize g n s_esize)
  | 1024 => (execute_FCVTX_Z_P_Z_D2S 1024 d d_esize esize g n s_esize)
  | 2048 => (execute_FCVTX_Z_P_Z_D2S 2048 d d_esize esize g n s_esize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCVTXNT_Z_P_Z_D2S (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result ((2 *i e) +i 1) (Int.ediv esize 2)
              (← (FPConvertSVE element (← (FPCR_read ())) FPRounding_ODD (Int.ediv esize 2)))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCVTXNT_Z_P_Z_D2S (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FCVTXNT_Z_P_Z_D2S 128 d esize g n)
  | 256 => (execute_FCVTXNT_Z_P_Z_D2S 256 d esize g n)
  | 512 => (execute_FCVTXNT_Z_P_Z_D2S 512 d esize g n)
  | 1024 => (execute_FCVTXNT_Z_P_Z_D2S 1024 d esize g n)
  | 2048 => (execute_FCVTXNT_Z_P_Z_D2S 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCLAMP_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        let element3 ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:11265.49-11265.50"
        (Elem_set result e esize
          (← (FPMinNum (← (FPMaxNum element1 element3 (← (FPCR_read ())))) element2
              (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCLAMP_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FCLAMP_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_FCLAMP_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_FCLAMP_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_FCLAMP_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_FCLAMP_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FADDQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:11326.45-11326.46"
  let identity ← (( do (FPZero (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let p2bits ← do (CeilPow2 (segments *i esize))
  let p2elems := (Int.ediv p2bits esize)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let stmp ← (( do (undefined_bitvector p2bits) ) : SailM (BitVec p2bits) )
        let stmp ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (p2elems -i 1)
          let mut loop_vars_1 := stmp
          for s in [loop_s_lower:loop_s_upper:1]i do
            let stmp := loop_vars_1
            loop_vars_1 ← do
              bif (Bool.and (s <b segments)
                   (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize)))
              then
                (do
                  (Elem_set stmp s esize
                    (← (Elem_read operand ((s *i elempersegment) +i e) esize))))
              else
                (do
                  (Elem_set stmp s esize identity))
          (pure loop_vars_1) ) : SailM (BitVec p2bits) )
        assert (Bool.or
          (Bool.and
            (Bool.or
              (Bool.or
                (Bool.or
                  (Bool.or
                    (Bool.or
                      (Bool.or (Bool.or (BEq.beq p2bits 16) (BEq.beq p2bits 32)) (BEq.beq p2bits 64))
                      (BEq.beq p2bits 128)) (BEq.beq p2bits 256)) (BEq.beq p2bits 512))
                (BEq.beq p2bits 1024)) (BEq.beq p2bits 2048)) (p2bits ≥b esize))
          (Bool.not (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)))) "src/instrs64_sve.sail:11340.129-11340.130"
        let dtmp ← (( do (Reduce ReduceOp_FADD stmp esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize dtmp)
    (pure loop_vars) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_FADDQV_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_FADDQV_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_FADDQV_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_FADDQV_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_FADDQV_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FADDQV_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXNMQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:11405.45-11405.46"
  let identity ← (( do (FPDefaultNaN esize) ) : SailM (BitVec esize) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let p2bits ← do (CeilPow2 (segments *i esize))
  let p2elems := (Int.ediv p2bits esize)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let stmp ← (( do (undefined_bitvector p2bits) ) : SailM (BitVec p2bits) )
        let stmp ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (p2elems -i 1)
          let mut loop_vars_1 := stmp
          for s in [loop_s_lower:loop_s_upper:1]i do
            let stmp := loop_vars_1
            loop_vars_1 ← do
              bif (Bool.and (s <b segments)
                   (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize)))
              then
                (do
                  (Elem_set stmp s esize
                    (← (Elem_read operand ((s *i elempersegment) +i e) esize))))
              else
                (do
                  (Elem_set stmp s esize identity))
          (pure loop_vars_1) ) : SailM (BitVec p2bits) )
        assert (Bool.or
          (Bool.and
            (Bool.or
              (Bool.or
                (Bool.or
                  (Bool.or
                    (Bool.or
                      (Bool.or (Bool.or (BEq.beq p2bits 16) (BEq.beq p2bits 32)) (BEq.beq p2bits 64))
                      (BEq.beq p2bits 128)) (BEq.beq p2bits 256)) (BEq.beq p2bits 512))
                (BEq.beq p2bits 1024)) (BEq.beq p2bits 2048)) (p2bits ≥b esize))
          (Bool.not (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)))) "src/instrs64_sve.sail:11419.129-11419.130"
        let dtmp ← (( do (Reduce ReduceOp_FMAXNUM stmp esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize dtmp)
    (pure loop_vars) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_FMAXNMQV_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_FMAXNMQV_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_FMAXNMQV_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_FMAXNMQV_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_FMAXNMQV_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FMAXNMQV_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMINNMQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:11484.45-11484.46"
  let identity ← (( do (FPDefaultNaN esize) ) : SailM (BitVec esize) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let p2bits ← do (CeilPow2 (segments *i esize))
  let p2elems := (Int.ediv p2bits esize)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let stmp ← (( do (undefined_bitvector p2bits) ) : SailM (BitVec p2bits) )
        let stmp ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (p2elems -i 1)
          let mut loop_vars_1 := stmp
          for s in [loop_s_lower:loop_s_upper:1]i do
            let stmp := loop_vars_1
            loop_vars_1 ← do
              bif (Bool.and (s <b segments)
                   (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize)))
              then
                (do
                  (Elem_set stmp s esize
                    (← (Elem_read operand ((s *i elempersegment) +i e) esize))))
              else
                (do
                  (Elem_set stmp s esize identity))
          (pure loop_vars_1) ) : SailM (BitVec p2bits) )
        assert (Bool.or
          (Bool.and
            (Bool.or
              (Bool.or
                (Bool.or
                  (Bool.or
                    (Bool.or
                      (Bool.or (Bool.or (BEq.beq p2bits 16) (BEq.beq p2bits 32)) (BEq.beq p2bits 64))
                      (BEq.beq p2bits 128)) (BEq.beq p2bits 256)) (BEq.beq p2bits 512))
                (BEq.beq p2bits 1024)) (BEq.beq p2bits 2048)) (p2bits ≥b esize))
          (Bool.not (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)))) "src/instrs64_sve.sail:11498.129-11498.130"
        let dtmp ← (( do (Reduce ReduceOp_FMINNUM stmp esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize dtmp)
    (pure loop_vars) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_FMINNMQV_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_FMINNMQV_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_FMINNMQV_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_FMINNMQV_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_FMINNMQV_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FMINNMQV_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMAXQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:11563.45-11563.46"
  let identity ← (( do (FPInfinity (0b1 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let p2bits ← do (CeilPow2 (segments *i esize))
  let p2elems := (Int.ediv p2bits esize)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let stmp ← (( do (undefined_bitvector p2bits) ) : SailM (BitVec p2bits) )
        let stmp ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (p2elems -i 1)
          let mut loop_vars_1 := stmp
          for s in [loop_s_lower:loop_s_upper:1]i do
            let stmp := loop_vars_1
            loop_vars_1 ← do
              bif (Bool.and (s <b segments)
                   (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize)))
              then
                (do
                  (Elem_set stmp s esize
                    (← (Elem_read operand ((s *i elempersegment) +i e) esize))))
              else
                (do
                  (Elem_set stmp s esize identity))
          (pure loop_vars_1) ) : SailM (BitVec p2bits) )
        assert (Bool.or
          (Bool.and
            (Bool.or
              (Bool.or
                (Bool.or
                  (Bool.or
                    (Bool.or
                      (Bool.or (Bool.or (BEq.beq p2bits 16) (BEq.beq p2bits 32)) (BEq.beq p2bits 64))
                      (BEq.beq p2bits 128)) (BEq.beq p2bits 256)) (BEq.beq p2bits 512))
                (BEq.beq p2bits 1024)) (BEq.beq p2bits 2048)) (p2bits ≥b esize))
          (Bool.not (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)))) "src/instrs64_sve.sail:11577.129-11577.130"
        let dtmp ← (( do (Reduce ReduceOp_FMAX stmp esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize dtmp)
    (pure loop_vars) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_FMAXQV_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_FMAXQV_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_FMAXQV_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_FMAXQV_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_FMAXQV_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FMAXQV_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FMINQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:11642.45-11642.46"
  let identity ← (( do (FPInfinity (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let p2bits ← do (CeilPow2 (segments *i esize))
  let p2elems := (Int.ediv p2bits esize)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let stmp ← (( do (undefined_bitvector p2bits) ) : SailM (BitVec p2bits) )
        let stmp ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (p2elems -i 1)
          let mut loop_vars_1 := stmp
          for s in [loop_s_lower:loop_s_upper:1]i do
            let stmp := loop_vars_1
            loop_vars_1 ← do
              bif (Bool.and (s <b segments)
                   (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize)))
              then
                (do
                  (Elem_set stmp s esize
                    (← (Elem_read operand ((s *i elempersegment) +i e) esize))))
              else
                (do
                  (Elem_set stmp s esize identity))
          (pure loop_vars_1) ) : SailM (BitVec p2bits) )
        assert (Bool.or
          (Bool.and
            (Bool.or
              (Bool.or
                (Bool.or
                  (Bool.or
                    (Bool.or
                      (Bool.or (Bool.or (BEq.beq p2bits 16) (BEq.beq p2bits 32)) (BEq.beq p2bits 64))
                      (BEq.beq p2bits 128)) (BEq.beq p2bits 256)) (BEq.beq p2bits 512))
                (BEq.beq p2bits 1024)) (BEq.beq p2bits 2048)) (p2bits ≥b esize))
          (Bool.not (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)))) "src/instrs64_sve.sail:11656.129-11656.130"
        let dtmp ← (( do (Reduce ReduceOp_FMIN stmp esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize dtmp)
    (pure loop_vars) ) : SailM (BitVec 128) )
  (V_set d 128 result)

def decode_FMINQV_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_FMINQV_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_FMINQV_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_FMINQV_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_FMINQV_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FMINQV_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFADD_Z_ZZ__ (VL : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
        (Elem_set result e 16 (← (BFAdd element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BFADD_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BFADD_Z_ZZ__ 128 d m n)
  | 256 => (execute_BFADD_Z_ZZ__ 256 d m n)
  | 512 => (execute_BFADD_Z_ZZ__ 512 d m n)
  | 1024 => (execute_BFADD_Z_ZZ__ 1024 d m n)
  | 2048 => (execute_BFADD_Z_ZZ__ 2048 d m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFMUL_Z_ZZ__ (VL : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
        (Elem_set result e 16 (← (BFMul element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BFMUL_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BFMUL_Z_ZZ__ 128 d m n)
  | 256 => (execute_BFMUL_Z_ZZ__ 256 d m n)
  | 512 => (execute_BFMUL_Z_ZZ__ 512 d m n)
  | 1024 => (execute_BFMUL_Z_ZZ__ 1024 d m n)
  | 2048 => (execute_BFMUL_Z_ZZ__ 2048 d m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFSUB_Z_ZZ__ (VL : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 16)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
        (Elem_set result e 16 (← (BFSub element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BFSUB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BFSUB_Z_ZZ__ 128 d m n)
  | 256 => (execute_BFSUB_Z_ZZ__ 256 d m n)
  | 512 => (execute_BFSUB_Z_ZZ__ 512 d m n)
  | 1024 => (execute_BFSUB_Z_ZZ__ 1024 d m n)
  | 2048 => (execute_BFSUB_Z_ZZ__ 2048 d m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        bif (← (ActivePredicateElement mask e 16))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (Elem_set result e 16 (← (BFAdd element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e 16 element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_BFADD_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_BFADD_Z_P_ZZ__ 128 dn g m)
  | 256 => (execute_BFADD_Z_P_ZZ__ 256 dn g m)
  | 512 => (execute_BFADD_Z_P_ZZ__ 512 dn g m)
  | 1024 => (execute_BFADD_Z_P_ZZ__ 1024 dn g m)
  | 2048 => (execute_BFADD_Z_P_ZZ__ 2048 dn g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMUL_Z_P_ZZ__ (VL : Nat) (dn : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        bif (← (ActivePredicateElement mask e 16))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (Elem_set result e 16 (← (BFMul element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e 16 element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_BFMUL_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_BFMUL_Z_P_ZZ__ 128 dn g m)
  | 256 => (execute_BFMUL_Z_P_ZZ__ 256 dn g m)
  | 512 => (execute_BFMUL_Z_P_ZZ__ 512 dn g m)
  | 1024 => (execute_BFMUL_Z_P_ZZ__ 1024 dn g m)
  | 2048 => (execute_BFMUL_Z_P_ZZ__ 2048 dn g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFSUB_Z_P_ZZ__ (VL : Nat) (dn : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        bif (← (ActivePredicateElement mask e 16))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (Elem_set result e 16 (← (BFSub element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e 16 element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_BFSUB_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_BFSUB_Z_P_ZZ__ 128 dn g m)
  | 256 => (execute_BFSUB_Z_P_ZZ__ 256 dn g m)
  | 512 => (execute_BFSUB_Z_P_ZZ__ 512 dn g m)
  | 1024 => (execute_BFSUB_Z_P_ZZ__ 1024 dn g m)
  | 2048 => (execute_BFSUB_Z_P_ZZ__ 2048 dn g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, g : Nat, m : Nat, n : Nat, k_op1_neg : Bool, k_op3_neg :
  Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLA_Z_P_ZZZ__ (VL : Nat) (da : Nat) (g : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e 16))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
            let element1 ← (( do
              bif op1_neg
              then
                (do
                  (BFNeg element1))
              else (pure element1) ) : SailM (BitVec 16) )
            let element3 ← (( do
              bif op3_neg
              then
                (do
                  (BFNeg element3))
              else (pure element3) ) : SailM (BitVec 16) )
            (Elem_set result e 16 (← (BFMulAdd element3 element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e 16 (← (Elem_read operand3 e 16))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLA_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := false
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_BFMLA_Z_P_ZZZ__ 128 da g m n op1_neg op3_neg)
  | 256 => (execute_BFMLA_Z_P_ZZZ__ 256 da g m n op1_neg op3_neg)
  | 512 => (execute_BFMLA_Z_P_ZZZ__ 512 da g m n op1_neg op3_neg)
  | 1024 => (execute_BFMLA_Z_P_ZZZ__ 1024 da g m n op1_neg op3_neg)
  | 2048 => (execute_BFMLA_Z_P_ZZZ__ 2048 da g m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, g : Nat, m : Nat, n : Nat, k_op1_neg : Bool, k_op3_neg :
  Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLS_Z_P_ZZZ__ (VL : Nat) (da : Nat) (g : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e 16))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
            let element1 ← (( do
              bif op1_neg
              then
                (do
                  (BFNeg element1))
              else (pure element1) ) : SailM (BitVec 16) )
            let element3 ← (( do
              bif op3_neg
              then
                (do
                  (BFNeg element3))
              else (pure element3) ) : SailM (BitVec 16) )
            (Elem_set result e 16 (← (BFMulAdd element3 element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e 16 (← (Elem_read operand3 e 16))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLS_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_BFMLS_Z_P_ZZZ__ 128 da g m n op1_neg op3_neg)
  | 256 => (execute_BFMLS_Z_P_ZZZ__ 256 da g m n op1_neg op3_neg)
  | 512 => (execute_BFMLS_Z_P_ZZZ__ 512 da g m n op1_neg op3_neg)
  | 1024 => (execute_BFMLS_Z_P_ZZZ__ 1024 da g m n op1_neg op3_neg)
  | 2048 => (execute_BFMLS_Z_P_ZZZ__ 2048 da g m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg : Bool, k_op3_neg
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLA_Z_ZZZi_H (VL : Nat) (da : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let eltspersegment := (Int.ediv 128 16)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read result e 16) ) : SailM (BitVec 16) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (BFNeg element1))
          else (pure element1) ) : SailM (BitVec 16) )
        let element3 ← (( do
          bif op3_neg
          then
            (do
              (BFNeg element3))
          else (pure element3) ) : SailM (BitVec 16) )
        (Elem_set result e 16 (← (BFMulAdd element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLA_Z_ZZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := false
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_BFMLA_Z_ZZZi_H 128 da index m n op1_neg op3_neg)
  | 256 => (execute_BFMLA_Z_ZZZi_H 256 da index m n op1_neg op3_neg)
  | 512 => (execute_BFMLA_Z_ZZZi_H 512 da index m n op1_neg op3_neg)
  | 1024 => (execute_BFMLA_Z_ZZZi_H 1024 da index m n op1_neg op3_neg)
  | 2048 => (execute_BFMLA_Z_ZZZi_H 2048 da index m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, index : Nat, m : Nat, n : Nat, k_op1_neg : Bool, k_op3_neg
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_BFMLS_Z_ZZZi_H (VL : Nat) (da : Nat) (index : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (op3_neg : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let eltspersegment := (Int.ediv 128 16)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read result e 16) ) : SailM (BitVec 16) )
        let element1 ← (( do
          bif op1_neg
          then
            (do
              (BFNeg element1))
          else (pure element1) ) : SailM (BitVec 16) )
        let element3 ← (( do
          bif op3_neg
          then
            (do
              (BFNeg element3))
          else (pure element3) ) : SailM (BitVec 16) )
        (Elem_set result e 16 (← (BFMulAdd element3 element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_BFMLS_Z_ZZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (op : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_neg : Bool := true
  let op3_neg : Bool := false
  match VL with
  | 128 => (execute_BFMLS_Z_ZZZi_H 128 da index m n op1_neg op3_neg)
  | 256 => (execute_BFMLS_Z_ZZZi_H 256 da index m n op1_neg op3_neg)
  | 512 => (execute_BFMLS_Z_ZZZi_H 512 da index m n op1_neg op3_neg)
  | 1024 => (execute_BFMLS_Z_ZZZi_H 1024 da index m n op1_neg op3_neg)
  | 2048 => (execute_BFMLS_Z_ZZZi_H 2048 da index m n op1_neg op3_neg)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFMUL_Z_ZZi_H (VL : Nat) (d : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let eltspersegment := (Int.ediv 128 16)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 s 16) ) : SailM (BitVec 16) )
        (Elem_set result e 16 (← (BFMul element1 element2 (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BFMUL_Z_ZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BFMUL_Z_ZZi_H 128 d index m n)
  | 256 => (execute_BFMUL_Z_ZZi_H 256 d index m n)
  | 512 => (execute_BFMUL_Z_ZZi_H 512 d index m n)
  | 1024 => (execute_BFMUL_Z_ZZi_H 1024 d index m n)
  | 2048 => (execute_BFMUL_Z_ZZi_H 2048 d index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMAXNM_Z_P_ZZ__ (VL : Nat) (dn : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        bif (← (ActivePredicateElement mask e 16))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (Elem_set result e 16 (← (BFMaxNum element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e 16 element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_BFMAXNM_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_BFMAXNM_Z_P_ZZ__ 128 dn g m)
  | 256 => (execute_BFMAXNM_Z_P_ZZ__ 256 dn g m)
  | 512 => (execute_BFMAXNM_Z_P_ZZ__ 512 dn g m)
  | 1024 => (execute_BFMAXNM_Z_P_ZZ__ 1024 dn g m)
  | 2048 => (execute_BFMAXNM_Z_P_ZZ__ 2048 dn g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMINNM_Z_P_ZZ__ (VL : Nat) (dn : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        bif (← (ActivePredicateElement mask e 16))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (Elem_set result e 16 (← (BFMinNum element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e 16 element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_BFMINNM_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_BFMINNM_Z_P_ZZ__ 128 dn g m)
  | 256 => (execute_BFMINNM_Z_P_ZZ__ 256 dn g m)
  | 512 => (execute_BFMINNM_Z_P_ZZ__ 512 dn g m)
  | 1024 => (execute_BFMINNM_Z_P_ZZ__ 1024 dn g m)
  | 2048 => (execute_BFMINNM_Z_P_ZZ__ 2048 dn g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMAX_Z_P_ZZ__ (VL : Nat) (dn : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        bif (← (ActivePredicateElement mask e 16))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (Elem_set result e 16 (← (BFMax element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e 16 element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_BFMAX_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_BFMAX_Z_P_ZZ__ 128 dn g m)
  | 256 => (execute_BFMAX_Z_P_ZZ__ 256 dn g m)
  | 512 => (execute_BFMAX_Z_P_ZZ__ 512 dn g m)
  | 1024 => (execute_BFMAX_Z_P_ZZ__ 1024 dn g m)
  | 2048 => (execute_BFMAX_Z_P_ZZ__ 2048 dn g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BFMIN_Z_P_ZZ__ (VL : Nat) (dn : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask 16))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        bif (← (ActivePredicateElement mask e 16))
        then
          (do
            let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
            (Elem_set result e 16 (← (BFMin element1 element2 (← (FPCR_read ()))))))
        else
          (do
            (Elem_set result e 16 element1))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_BFMIN_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_BFMIN_Z_P_ZZ__ 128 dn g m)
  | 256 => (execute_BFMIN_Z_P_ZZ__ 256 dn g m)
  | 512 => (execute_BFMIN_Z_P_ZZ__ 512 dn g m)
  | 1024 => (execute_BFMIN_Z_P_ZZ__ 1024 dn g m)
  | 2048 => (execute_BFMIN_Z_P_ZZ__ 2048 dn g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BFCLAMP_Z_ZZ__ (VL : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 16)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 16) ) : SailM (BitVec 16) )
        let element2 ← (( do (Elem_read operand2 e 16) ) : SailM (BitVec 16) )
        let element3 ← (( do (Elem_read operand3 e 16) ) : SailM (BitVec 16) )
        (Elem_set result e 16
          (← (BFMinNum (← (BFMaxNum element1 element3 (← (FPCR_read ())))) element2
              (← (FPCR_read ())))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BFCLAMP_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVEB16B16 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BFCLAMP_Z_ZZ__ 128 d m n)
  | 256 => (execute_BFCLAMP_Z_ZZ__ 256 d m n)
  | 512 => (execute_BFCLAMP_Z_ZZ__ 512 d m n)
  | 1024 => (execute_BFCLAMP_Z_ZZ__ 1024 d m n)
  | 2048 => (execute_BFCLAMP_Z_ZZ__ 2048 d m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, mbytes : Nat, n
  : Nat, osize : Nat, osize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  mbytes ∈ {1, 2, 4, 8} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ADR_Z_AZ_D_u32_scaled (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (mbytes : Nat) (n : Nat) (osize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let base ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let offs ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let addr ← (( do (Elem_read base e esize) ) : SailM (BitVec esize) )
        let offset ← do
          (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offs e esize)) (osize -i 1) 0)
            is_unsigned)
        (Elem_set result e esize (BitVec.addInt addr (offset *i mbytes)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ADR_Z_AZ_D_u32_scaled (Zm : (BitVec 5)) (msz : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let osize := 32
  let is_unsigned : Bool := true
  let mbytes := (Int.shiftl 1 (BitVec.toNat msz))
  match VL with
  | 128 => (execute_ADR_Z_AZ_D_u32_scaled 128 d esize m mbytes n osize is_unsigned)
  | 256 => (execute_ADR_Z_AZ_D_u32_scaled 256 d esize m mbytes n osize is_unsigned)
  | 512 => (execute_ADR_Z_AZ_D_u32_scaled 512 d esize m mbytes n osize is_unsigned)
  | 1024 => (execute_ADR_Z_AZ_D_u32_scaled 1024 d esize m mbytes n osize is_unsigned)
  | 2048 => (execute_ADR_Z_AZ_D_u32_scaled 2048 d esize m mbytes n osize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, mbytes : Nat, n
  : Nat, osize : Nat, osize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  mbytes ∈ {1, 2, 4, 8} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ADR_Z_AZ_D_s32_scaled (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (mbytes : Nat) (n : Nat) (osize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let base ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let offs ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let addr ← (( do (Elem_read base e esize) ) : SailM (BitVec esize) )
        let offset ← do
          (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offs e esize)) (osize -i 1) 0)
            is_unsigned)
        (Elem_set result e esize (BitVec.addInt addr (offset *i mbytes)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ADR_Z_AZ_D_s32_scaled (Zm : (BitVec 5)) (msz : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let osize := 32
  let is_unsigned : Bool := false
  let mbytes := (Int.shiftl 1 (BitVec.toNat msz))
  match VL with
  | 128 => (execute_ADR_Z_AZ_D_s32_scaled 128 d esize m mbytes n osize is_unsigned)
  | 256 => (execute_ADR_Z_AZ_D_s32_scaled 256 d esize m mbytes n osize is_unsigned)
  | 512 => (execute_ADR_Z_AZ_D_s32_scaled 512 d esize m mbytes n osize is_unsigned)
  | 1024 => (execute_ADR_Z_AZ_D_s32_scaled 1024 d esize m mbytes n osize is_unsigned)
  | 2048 => (execute_ADR_Z_AZ_D_s32_scaled 2048 d esize m mbytes n osize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, mbytes : Nat, n
  : Nat, osize : Nat, osize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  mbytes ∈ {1, 2, 4, 8} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ADR_Z_AZ_SD_same_scaled (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (mbytes : Nat) (n : Nat) (osize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let base ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let offs ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let addr ← (( do (Elem_read base e esize) ) : SailM (BitVec esize) )
        assert ((osize -i 1) <b esize) "src/instrs64_sve.sail:12914.46-12914.47"
        let offset ← do
          (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offs e esize)) (osize -i 1) 0)
            is_unsigned)
        (Elem_set result e esize (BitVec.addInt addr (offset *i mbytes)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ADR_Z_AZ_SD_same_scaled (sz : (BitVec 1)) (Zm : (BitVec 5)) (msz : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let osize := esize
  let is_unsigned : Bool := true
  let mbytes := (Int.shiftl 1 (BitVec.toNat msz))
  match VL with
  | 128 => (execute_ADR_Z_AZ_SD_same_scaled 128 d esize m mbytes n osize is_unsigned)
  | 256 => (execute_ADR_Z_AZ_SD_same_scaled 256 d esize m mbytes n osize is_unsigned)
  | 512 => (execute_ADR_Z_AZ_SD_same_scaled 512 d esize m mbytes n osize is_unsigned)
  | 1024 => (execute_ADR_Z_AZ_SD_same_scaled 1024 d esize m mbytes n osize is_unsigned)
  | 2048 => (execute_ADR_Z_AZ_SD_same_scaled 2048 d esize m mbytes n osize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, esize ∈ {8, 16, 32, 64} ∧
  0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ADD_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize (BitVec.addInt element1 imm))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_ADD_Z_ZI__ (size : (BitVec 2)) (sh : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (size ++ sh) (0b001 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let imm : Int := (BitVec.toNat imm8)
  let imm : Int :=
    bif (BEq.beq sh (0b1 : (BitVec 1)))
    then (Int.shiftl imm 8)
    else imm
  let imm := imm
  match VL with
  | 128 => (execute_ADD_Z_ZI__ 128 dn esize imm)
  | 256 => (execute_ADD_Z_ZI__ 256 dn esize imm)
  | 512 => (execute_ADD_Z_ZI__ 512 dn esize imm)
  | 1024 => (execute_ADD_Z_ZI__ 1024 dn esize imm)
  | 2048 => (execute_ADD_Z_ZI__ 2048 dn esize imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, esize ∈ {8, 16, 32, 64} ∧
  0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SUB_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize (BitVec.subInt element1 imm))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SUB_Z_ZI__ (size : (BitVec 2)) (sh : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (size ++ sh) (0b001 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let imm : Int := (BitVec.toNat imm8)
  let imm : Int :=
    bif (BEq.beq sh (0b1 : (BitVec 1)))
    then (Int.shiftl imm 8)
    else imm
  let imm := imm
  match VL with
  | 128 => (execute_SUB_Z_ZI__ 128 dn esize imm)
  | 256 => (execute_SUB_Z_ZI__ 256 dn esize imm)
  | 512 => (execute_SUB_Z_ZI__ 512 dn esize imm)
  | 1024 => (execute_SUB_Z_ZI__ 1024 dn esize imm)
  | 2048 => (execute_SUB_Z_ZI__ 2048 dn esize imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, esize ∈ {8, 16, 32, 64} ∧
  0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SUBR_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        (Elem_set result e esize (integer_subrange (imm -i element1) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SUBR_Z_ZI__ (size : (BitVec 2)) (sh : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (size ++ sh) (0b001 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let imm : Int := (BitVec.toNat imm8)
  let imm : Int :=
    bif (BEq.beq sh (0b1 : (BitVec 1)))
    then (Int.shiftl imm 8)
    else imm
  let imm := imm
  match VL with
  | 128 => (execute_SUBR_Z_ZI__ 128 dn esize imm)
  | 256 => (execute_SUBR_Z_ZI__ 256 dn esize imm)
  | 512 => (execute_SUBR_Z_ZI__ 512 dn esize imm)
  | 1024 => (execute_SUBR_Z_ZI__ 1024 dn esize imm)
  | 2048 => (execute_SUBR_Z_ZI__ 2048 dn esize imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, esize ∈ {8, 16, 32, 64} ∧
  0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_MUL_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        (Elem_set result e esize (integer_subrange (element1 *i imm) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_MUL_Z_ZI__ (size : (BitVec 2)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let imm := (BitVec.toInt imm8)
  match VL with
  | 128 => (execute_MUL_Z_ZI__ 128 dn esize imm)
  | 256 => (execute_MUL_Z_ZI__ 256 dn esize imm)
  | 512 => (execute_MUL_Z_ZI__ 512 dn esize imm)
  | 1024 => (execute_MUL_Z_ZI__ 1024 dn esize imm)
  | 2048 => (execute_MUL_Z_ZI__ 2048 dn esize imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, k_is_unsigned : Bool, esize ∈
  {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMAX_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        (Elem_set result e esize (integer_subrange (Max.max element1 imm) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UMAX_Z_ZI__ (size : (BitVec 2)) (U : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let is_unsigned : Bool := true
  let imm ← do (asl_Int imm8 is_unsigned)
  match VL with
  | 128 => (execute_UMAX_Z_ZI__ 128 dn esize imm is_unsigned)
  | 256 => (execute_UMAX_Z_ZI__ 256 dn esize imm is_unsigned)
  | 512 => (execute_UMAX_Z_ZI__ 512 dn esize imm is_unsigned)
  | 1024 => (execute_UMAX_Z_ZI__ 1024 dn esize imm is_unsigned)
  | 2048 => (execute_UMAX_Z_ZI__ 2048 dn esize imm is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, k_is_unsigned : Bool, esize ∈
  {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMAX_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        (Elem_set result e esize (integer_subrange (Max.max element1 imm) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SMAX_Z_ZI__ (size : (BitVec 2)) (U : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let is_unsigned : Bool := false
  let imm ← do (asl_Int imm8 is_unsigned)
  match VL with
  | 128 => (execute_SMAX_Z_ZI__ 128 dn esize imm is_unsigned)
  | 256 => (execute_SMAX_Z_ZI__ 256 dn esize imm is_unsigned)
  | 512 => (execute_SMAX_Z_ZI__ 512 dn esize imm is_unsigned)
  | 1024 => (execute_SMAX_Z_ZI__ 1024 dn esize imm is_unsigned)
  | 2048 => (execute_SMAX_Z_ZI__ 2048 dn esize imm is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, k_is_unsigned : Bool, esize ∈
  {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMIN_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        (Elem_set result e esize (integer_subrange (Min.min element1 imm) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UMIN_Z_ZI__ (size : (BitVec 2)) (U : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let is_unsigned : Bool := true
  let imm ← do (asl_Int imm8 is_unsigned)
  match VL with
  | 128 => (execute_UMIN_Z_ZI__ 128 dn esize imm is_unsigned)
  | 256 => (execute_UMIN_Z_ZI__ 256 dn esize imm is_unsigned)
  | 512 => (execute_UMIN_Z_ZI__ 512 dn esize imm is_unsigned)
  | 1024 => (execute_UMIN_Z_ZI__ 1024 dn esize imm is_unsigned)
  | 2048 => (execute_UMIN_Z_ZI__ 2048 dn esize imm is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, k_is_unsigned : Bool, esize ∈
  {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMIN_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        (Elem_set result e esize (integer_subrange (Min.min element1 imm) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SMIN_Z_ZI__ (size : (BitVec 2)) (U : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let is_unsigned : Bool := false
  let imm ← do (asl_Int imm8 is_unsigned)
  match VL with
  | 128 => (execute_SMIN_Z_ZI__ 128 dn esize imm is_unsigned)
  | 256 => (execute_SMIN_Z_ZI__ 256 dn esize imm is_unsigned)
  | 512 => (execute_SMIN_Z_ZI__ 512 dn esize imm is_unsigned)
  | 1024 => (execute_SMIN_Z_ZI__ 1024 dn esize imm is_unsigned)
  | 2048 => (execute_SMIN_Z_ZI__ 2048 dn esize imm is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, imm : Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ADDPL_R_RI__ (VL : Nat) (d : Nat) (imm : Int) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let operand1 ← (( do
    bif (BEq.beq n 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let result : (BitVec 64) := (BitVec.addInt operand1 (imm *i (Int.ediv PL 8)))
  bif (BEq.beq d 31)
  then (SP_set result)
  else (X_set d 64 result)

def decode_ADDPL_R_RI__ (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  let imm := (BitVec.toInt imm6)
  match VL with
  | 128 => (execute_ADDPL_R_RI__ 128 d imm n)
  | 256 => (execute_ADDPL_R_RI__ 256 d imm n)
  | 512 => (execute_ADDPL_R_RI__ 512 d imm n)
  | 1024 => (execute_ADDPL_R_RI__ 1024 d imm n)
  | 2048 => (execute_ADDPL_R_RI__ 2048 d imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, imm : Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ADDVL_R_RI__ (VL : Nat) (d : Nat) (imm : Int) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let operand1 ← (( do
    bif (BEq.beq n 31)
    then (SP_read ())
    else (X_read n 64) ) : SailM (BitVec 64) )
  let result : (BitVec 64) := (BitVec.addInt operand1 (imm *i (Int.ediv VL 8)))
  bif (BEq.beq d 31)
  then (SP_set result)
  else (X_set d 64 result)

def decode_ADDVL_R_RI__ (Rn : (BitVec 5)) (imm6 : (BitVec 6)) (Rd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Rd)
  let imm := (BitVec.toInt imm6)
  match VL with
  | 128 => (execute_ADDVL_R_RI__ 128 d imm n)
  | 256 => (execute_ADDVL_R_RI__ 256 d imm n)
  | 512 => (execute_ADDVL_R_RI__ 512 d imm n)
  | 1024 => (execute_ADDVL_R_RI__ 1024 d imm n)
  | 2048 => (execute_ADDVL_R_RI__ 2048 d imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ADD_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize (element1 + element2))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ADD_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_ADD_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_ADD_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_ADD_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_ADD_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_ADD_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_AND_Z_ZZ__ (VL : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  (Z_set d VL (operand1 &&& operand2))

def decode_AND_Z_ZZ__ (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_AND_Z_ZZ__ 128 d m n)
  | 256 => (execute_AND_Z_ZZ__ 256 d m n)
  | 512 => (execute_AND_Z_ZZ__ 512 d m n)
  | 1024 => (execute_AND_Z_ZZ__ 1024 d m n)
  | 2048 => (execute_AND_Z_ZZ__ 2048 d m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BIC_Z_ZZ__ (VL : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  (Z_set d VL (operand1 &&& (Complement.complement operand2)))

def decode_BIC_Z_ZZ__ (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BIC_Z_ZZ__ 128 d m n)
  | 256 => (execute_BIC_Z_ZZ__ 256 d m n)
  | 512 => (execute_BIC_Z_ZZ__ 512 d m n)
  | 1024 => (execute_BIC_Z_ZZ__ 1024 d m n)
  | 2048 => (execute_BIC_Z_ZZ__ 2048 d m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_EOR_Z_ZZ__ (VL : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  (Z_set d VL (operand1 ^^^ operand2))

def decode_EOR_Z_ZZ__ (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_EOR_Z_ZZ__ 128 d m n)
  | 256 => (execute_EOR_Z_ZZ__ 256 d m n)
  | 512 => (execute_EOR_Z_ZZ__ 512 d m n)
  | 1024 => (execute_EOR_Z_ZZ__ 1024 d m n)
  | 2048 => (execute_EOR_Z_ZZ__ 2048 d m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ORR_Z_ZZ__ (VL : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  (Z_set d VL (operand1 ||| operand2))

def decode_ORR_Z_ZZ__ (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_ORR_Z_ZZ__ 128 d m n)
  | 256 => (execute_ORR_Z_ZZ__ 256 d m n)
  | 512 => (execute_ORR_Z_ZZ__ 512 d m n)
  | 1024 => (execute_ORR_Z_ZZ__ 1024 d m n)
  | 2048 => (execute_ORR_Z_ZZ__ 2048 d m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SUB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize (element1 - element2))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SUB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SUB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SUB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SUB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SUB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SUB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (element1 + element2)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_ADD_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_ADD_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_ADD_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_ADD_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_ADD_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_ADD_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_AND_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (element1 &&& element2)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_AND_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_AND_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_AND_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_AND_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_AND_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_AND_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BIC_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (element1 &&& (Complement.complement element2))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_BIC_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_BIC_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_BIC_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_BIC_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_BIC_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_BIC_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_EOR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (element1 ^^^ element2)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_EOR_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_EOR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_EOR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_EOR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_EOR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_EOR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_LSL_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let shift := (Min.min (BitVec.toNat element2) esize)
            (Elem_set result e esize (element1 <<< shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_LSL_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_LSL_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_LSL_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_LSL_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_LSL_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_LSL_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_LSLR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let shift := (Min.min (BitVec.toNat element1) esize)
            (Elem_set result e esize (element2 <<< shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_LSLR_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_LSLR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_LSLR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_LSLR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_LSLR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_LSLR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_MUL_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let product := (element1 *i element2)
            (Elem_set result e esize (integer_subrange product (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_MUL_Z_P_ZZ__ (size : (BitVec 2)) (H : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_MUL_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_MUL_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_MUL_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_MUL_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_MUL_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ORR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (element1 ||| element2)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_ORR_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_ORR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_ORR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_ORR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_ORR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_ORR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SUB_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (element1 - element2)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SUB_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_SUB_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SUB_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SUB_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SUB_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SUB_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SUBR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (element2 - element1)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SUBR_Z_P_ZZ__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_SUBR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SUBR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SUBR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SUBR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SUBR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_LSR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let shift := (Min.min (BitVec.toNat element2) esize)
            (Elem_set result e esize (element1 >>> shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_LSR_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_LSR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_LSR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_LSR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_LSR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_LSR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ASR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let shift := (Min.min (BitVec.toNat element2) esize)
            (Elem_set result e esize (BitVec.rotateRight element1 shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_ASR_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_ASR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_ASR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_ASR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_ASR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_ASR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_LSRR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let shift := (Min.min (BitVec.toNat element1) esize)
            (Elem_set result e esize (element2 >>> shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_LSRR_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_LSRR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_LSRR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_LSRR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_LSRR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_LSRR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ASRR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
            let shift := (Min.min (BitVec.toNat element1) esize)
            (Elem_set result e esize (BitVec.rotateRight element2 shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_ASRR_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_ASRR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_ASRR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_ASRR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_ASRR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_ASRR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UABD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let absdiff := (Int.natAbs (element1 -i element2))
            (Elem_set result e esize (integer_subrange absdiff (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UABD_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UABD_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_UABD_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_UABD_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_UABD_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_UABD_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SABD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let absdiff := (Int.natAbs (element1 -i element2))
            (Elem_set result e esize (integer_subrange absdiff (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SABD_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SABD_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_SABD_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_SABD_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_SABD_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_SABD_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UDIV_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let quotient ← (( do (undefined_int ()) ) : SailM Int )
            let quotient : Int :=
              bif (BEq.beq element2 0)
              then 0
              else (RoundTowardsZero (div_real (to_real element1) (to_real element2)))
            let quotient := quotient
            (Elem_set result e esize (integer_subrange quotient (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UDIV_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UDIV_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_UDIV_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_UDIV_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_UDIV_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_UDIV_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SDIV_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let quotient ← (( do (undefined_int ()) ) : SailM Int )
            let quotient : Int :=
              bif (BEq.beq element2 0)
              then 0
              else (RoundTowardsZero (div_real (to_real element1) (to_real element2)))
            let quotient := quotient
            (Elem_set result e esize (integer_subrange quotient (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SDIV_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SDIV_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_SDIV_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_SDIV_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_SDIV_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_SDIV_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UDIVR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let quotient ← (( do (undefined_int ()) ) : SailM Int )
            let quotient : Int :=
              bif (BEq.beq element1 0)
              then 0
              else (RoundTowardsZero (div_real (to_real element2) (to_real element1)))
            let quotient := quotient
            (Elem_set result e esize (integer_subrange quotient (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UDIVR_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UDIVR_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_UDIVR_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_UDIVR_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_UDIVR_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_UDIVR_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SDIVR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let quotient ← (( do (undefined_int ()) ) : SailM Int )
            let quotient : Int :=
              bif (BEq.beq element1 0)
              then 0
              else (RoundTowardsZero (div_real (to_real element2) (to_real element1)))
            let quotient := quotient
            (Elem_set result e esize (integer_subrange quotient (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SDIVR_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SDIVR_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_SDIVR_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_SDIVR_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_SDIVR_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_SDIVR_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMAX_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let maximum := (Max.max element1 element2)
            (Elem_set result e esize (integer_subrange maximum (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UMAX_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMAX_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_UMAX_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_UMAX_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_UMAX_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_UMAX_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMAX_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let maximum := (Max.max element1 element2)
            (Elem_set result e esize (integer_subrange maximum (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SMAX_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMAX_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_SMAX_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_SMAX_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_SMAX_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_SMAX_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMIN_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let minimum := (Min.min element1 element2)
            (Elem_set result e esize (integer_subrange minimum (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UMIN_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMIN_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_UMIN_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_UMIN_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_UMIN_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_UMIN_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMIN_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let minimum := (Min.min element1 element2)
            (Elem_set result e esize (integer_subrange minimum (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SMIN_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMIN_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_SMIN_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_SMIN_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_SMIN_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_SMIN_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMULH_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let product := (Int.shiftr (element1 *i element2) esize)
            (Elem_set result e esize (integer_subrange product (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UMULH_Z_P_ZZ__ (size : (BitVec 2)) (H : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMULH_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_UMULH_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_UMULH_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_UMULH_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_UMULH_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMULH_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let product := (Int.shiftr (element1 *i element2) esize)
            (Elem_set result e esize (integer_subrange product (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SMULH_Z_P_ZZ__ (size : (BitVec 2)) (H : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMULH_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_SMULH_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_SMULH_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_SMULH_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_SMULH_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, rsize
  : Nat, rsize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELO_P_P_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec PL) := (Ones (n := PL))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec PL)) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILELO_P_P_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Pd)
  let is_unsigned : Bool := true
  let op : SVECmp := Cmp_LT
  match VL with
  | 128 => (execute_WHILELO_P_P_RR__ 128 d esize m n op rsize is_unsigned)
  | 256 => (execute_WHILELO_P_P_RR__ 256 d esize m n op rsize is_unsigned)
  | 512 => (execute_WHILELO_P_P_RR__ 512 d esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILELO_P_P_RR__ 1024 d esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILELO_P_P_RR__ 2048 d esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, rsize
  : Nat, rsize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELS_P_P_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec PL) := (Ones (n := PL))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec PL)) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILELS_P_P_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Pd)
  let is_unsigned : Bool := true
  let op : SVECmp := Cmp_LE
  match VL with
  | 128 => (execute_WHILELS_P_P_RR__ 128 d esize m n op rsize is_unsigned)
  | 256 => (execute_WHILELS_P_P_RR__ 256 d esize m n op rsize is_unsigned)
  | 512 => (execute_WHILELS_P_P_RR__ 512 d esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILELS_P_P_RR__ 1024 d esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILELS_P_P_RR__ 2048 d esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, rsize
  : Nat, rsize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELT_P_P_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec PL) := (Ones (n := PL))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec PL)) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILELT_P_P_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Pd)
  let is_unsigned : Bool := false
  let op : SVECmp := Cmp_LT
  match VL with
  | 128 => (execute_WHILELT_P_P_RR__ 128 d esize m n op rsize is_unsigned)
  | 256 => (execute_WHILELT_P_P_RR__ 256 d esize m n op rsize is_unsigned)
  | 512 => (execute_WHILELT_P_P_RR__ 512 d esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILELT_P_P_RR__ 1024 d esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILELT_P_P_RR__ 2048 d esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, rsize
  : Nat, rsize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELE_P_P_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec PL) := (Ones (n := PL))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec PL)) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILELE_P_P_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Pd)
  let is_unsigned : Bool := false
  let op : SVECmp := Cmp_LE
  match VL with
  | 128 => (execute_WHILELE_P_P_RR__ 128 d esize m n op rsize is_unsigned)
  | 256 => (execute_WHILELE_P_P_RR__ 256 d esize m n op rsize is_unsigned)
  | 512 => (execute_WHILELE_P_P_RR__ 512 d esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILELE_P_P_RR__ 1024 d esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILELE_P_P_RR__ 2048 d esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, rsize
  : Nat, rsize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEHI_P_P_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec PL) := (Ones (n := PL))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec PL)) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILEHI_P_P_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Pd)
  let is_unsigned : Bool := true
  let op : SVECmp := Cmp_GT
  match VL with
  | 128 => (execute_WHILEHI_P_P_RR__ 128 d esize m n op rsize is_unsigned)
  | 256 => (execute_WHILEHI_P_P_RR__ 256 d esize m n op rsize is_unsigned)
  | 512 => (execute_WHILEHI_P_P_RR__ 512 d esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILEHI_P_P_RR__ 1024 d esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILEHI_P_P_RR__ 2048 d esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, rsize
  : Nat, rsize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEHS_P_P_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec PL) := (Ones (n := PL))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec PL)) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILEHS_P_P_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Pd)
  let is_unsigned : Bool := true
  let op : SVECmp := Cmp_GE
  match VL with
  | 128 => (execute_WHILEHS_P_P_RR__ 128 d esize m n op rsize is_unsigned)
  | 256 => (execute_WHILEHS_P_P_RR__ 256 d esize m n op rsize is_unsigned)
  | 512 => (execute_WHILEHS_P_P_RR__ 512 d esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILEHS_P_P_RR__ 1024 d esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILEHS_P_P_RR__ 2048 d esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, rsize
  : Nat, rsize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEGT_P_P_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec PL) := (Ones (n := PL))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec PL)) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILEGT_P_P_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Pd)
  let is_unsigned : Bool := false
  let op : SVECmp := Cmp_GT
  match VL with
  | 128 => (execute_WHILEGT_P_P_RR__ 128 d esize m n op rsize is_unsigned)
  | 256 => (execute_WHILEGT_P_P_RR__ 256 d esize m n op rsize is_unsigned)
  | 512 => (execute_WHILEGT_P_P_RR__ 512 d esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILEGT_P_P_RR__ 1024 d esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILEGT_P_P_RR__ 2048 d esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, rsize
  : Nat, rsize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEGE_P_P_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec PL) := (Ones (n := PL))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec PL)) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILEGE_P_P_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (sf : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := (Int.shiftl 32 (BitVec.toNat sf))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Pd)
  let is_unsigned : Bool := false
  let op : SVECmp := Cmp_GE
  match VL with
  | 128 => (execute_WHILEGE_P_P_RR__ 128 d esize m n op rsize is_unsigned)
  | 256 => (execute_WHILEGE_P_P_RR__ 256 d esize m n op rsize is_unsigned)
  | 512 => (execute_WHILEGE_P_P_RR__ 512 d esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILEGE_P_P_RR__ 1024 d esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILEGE_P_P_RR__ 2048 d esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Int, k_is_unsigned : Bool, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPEQ_P_P_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Int) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 imm)
              | Cmp_NE => (bne element1 imm)
              | Cmp_GE => (element1 ≥b imm)
              | Cmp_LT => (element1 <b imm)
              | Cmp_GT => (element1 >b imm)
              | Cmp_LE => (element1 ≤b imm)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPEQ_P_P_ZI__ (size : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_EQ
  let imm := (BitVec.toInt imm5)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPEQ_P_P_ZI__ 128 d esize g imm n op is_unsigned)
  | 256 => (execute_CMPEQ_P_P_ZI__ 256 d esize g imm n op is_unsigned)
  | 512 => (execute_CMPEQ_P_P_ZI__ 512 d esize g imm n op is_unsigned)
  | 1024 => (execute_CMPEQ_P_P_ZI__ 1024 d esize g imm n op is_unsigned)
  | 2048 => (execute_CMPEQ_P_P_ZI__ 2048 d esize g imm n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Int, k_is_unsigned : Bool, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPNE_P_P_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Int) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 imm)
              | Cmp_NE => (bne element1 imm)
              | Cmp_GE => (element1 ≥b imm)
              | Cmp_LT => (element1 <b imm)
              | Cmp_GT => (element1 >b imm)
              | Cmp_LE => (element1 ≤b imm)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPNE_P_P_ZI__ (size : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_NE
  let imm := (BitVec.toInt imm5)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPNE_P_P_ZI__ 128 d esize g imm n op is_unsigned)
  | 256 => (execute_CMPNE_P_P_ZI__ 256 d esize g imm n op is_unsigned)
  | 512 => (execute_CMPNE_P_P_ZI__ 512 d esize g imm n op is_unsigned)
  | 1024 => (execute_CMPNE_P_P_ZI__ 1024 d esize g imm n op is_unsigned)
  | 2048 => (execute_CMPNE_P_P_ZI__ 2048 d esize g imm n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Nat, k_is_unsigned : Bool, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ imm ∧
  imm ≤ 127 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPHS_P_P_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 imm)
              | Cmp_NE => (bne element1 imm)
              | Cmp_GE => (element1 ≥b imm)
              | Cmp_LT => (element1 <b imm)
              | Cmp_GT => (element1 >b imm)
              | Cmp_LE => (element1 ≤b imm)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPHS_P_P_ZI__ (size : (BitVec 2)) (imm7 : (BitVec 7)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GE
  let imm := (BitVec.toNat imm7)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_CMPHS_P_P_ZI__ 128 d esize g imm n op is_unsigned)
  | 256 => (execute_CMPHS_P_P_ZI__ 256 d esize g imm n op is_unsigned)
  | 512 => (execute_CMPHS_P_P_ZI__ 512 d esize g imm n op is_unsigned)
  | 1024 => (execute_CMPHS_P_P_ZI__ 1024 d esize g imm n op is_unsigned)
  | 2048 => (execute_CMPHS_P_P_ZI__ 2048 d esize g imm n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Nat, k_is_unsigned : Bool, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ imm ∧
  imm ≤ 127 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPHI_P_P_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 imm)
              | Cmp_NE => (bne element1 imm)
              | Cmp_GE => (element1 ≥b imm)
              | Cmp_LT => (element1 <b imm)
              | Cmp_GT => (element1 >b imm)
              | Cmp_LE => (element1 ≤b imm)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPHI_P_P_ZI__ (size : (BitVec 2)) (imm7 : (BitVec 7)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GT
  let imm := (BitVec.toNat imm7)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_CMPHI_P_P_ZI__ 128 d esize g imm n op is_unsigned)
  | 256 => (execute_CMPHI_P_P_ZI__ 256 d esize g imm n op is_unsigned)
  | 512 => (execute_CMPHI_P_P_ZI__ 512 d esize g imm n op is_unsigned)
  | 1024 => (execute_CMPHI_P_P_ZI__ 1024 d esize g imm n op is_unsigned)
  | 2048 => (execute_CMPHI_P_P_ZI__ 2048 d esize g imm n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Nat, k_is_unsigned : Bool, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ imm ∧
  imm ≤ 127 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPLO_P_P_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 imm)
              | Cmp_NE => (bne element1 imm)
              | Cmp_GE => (element1 ≥b imm)
              | Cmp_LT => (element1 <b imm)
              | Cmp_GT => (element1 >b imm)
              | Cmp_LE => (element1 ≤b imm)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPLO_P_P_ZI__ (size : (BitVec 2)) (imm7 : (BitVec 7)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_LT
  let imm := (BitVec.toNat imm7)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_CMPLO_P_P_ZI__ 128 d esize g imm n op is_unsigned)
  | 256 => (execute_CMPLO_P_P_ZI__ 256 d esize g imm n op is_unsigned)
  | 512 => (execute_CMPLO_P_P_ZI__ 512 d esize g imm n op is_unsigned)
  | 1024 => (execute_CMPLO_P_P_ZI__ 1024 d esize g imm n op is_unsigned)
  | 2048 => (execute_CMPLO_P_P_ZI__ 2048 d esize g imm n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Nat, k_is_unsigned : Bool, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ imm ∧
  imm ≤ 127 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPLS_P_P_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 imm)
              | Cmp_NE => (bne element1 imm)
              | Cmp_GE => (element1 ≥b imm)
              | Cmp_LT => (element1 <b imm)
              | Cmp_GT => (element1 >b imm)
              | Cmp_LE => (element1 ≤b imm)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPLS_P_P_ZI__ (size : (BitVec 2)) (imm7 : (BitVec 7)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_LE
  let imm := (BitVec.toNat imm7)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_CMPLS_P_P_ZI__ 128 d esize g imm n op is_unsigned)
  | 256 => (execute_CMPLS_P_P_ZI__ 256 d esize g imm n op is_unsigned)
  | 512 => (execute_CMPLS_P_P_ZI__ 512 d esize g imm n op is_unsigned)
  | 1024 => (execute_CMPLS_P_P_ZI__ 1024 d esize g imm n op is_unsigned)
  | 2048 => (execute_CMPLS_P_P_ZI__ 2048 d esize g imm n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Int, k_is_unsigned : Bool, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPGE_P_P_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Int) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 imm)
              | Cmp_NE => (bne element1 imm)
              | Cmp_GE => (element1 ≥b imm)
              | Cmp_LT => (element1 <b imm)
              | Cmp_GT => (element1 >b imm)
              | Cmp_LE => (element1 ≤b imm)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPGE_P_P_ZI__ (size : (BitVec 2)) (imm5 : (BitVec 5)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GE
  let imm := (BitVec.toInt imm5)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPGE_P_P_ZI__ 128 d esize g imm n op is_unsigned)
  | 256 => (execute_CMPGE_P_P_ZI__ 256 d esize g imm n op is_unsigned)
  | 512 => (execute_CMPGE_P_P_ZI__ 512 d esize g imm n op is_unsigned)
  | 1024 => (execute_CMPGE_P_P_ZI__ 1024 d esize g imm n op is_unsigned)
  | 2048 => (execute_CMPGE_P_P_ZI__ 2048 d esize g imm n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Int, k_is_unsigned : Bool, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPGT_P_P_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Int) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 imm)
              | Cmp_NE => (bne element1 imm)
              | Cmp_GE => (element1 ≥b imm)
              | Cmp_LT => (element1 <b imm)
              | Cmp_GT => (element1 >b imm)
              | Cmp_LE => (element1 ≤b imm)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPGT_P_P_ZI__ (size : (BitVec 2)) (imm5 : (BitVec 5)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GT
  let imm := (BitVec.toInt imm5)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPGT_P_P_ZI__ 128 d esize g imm n op is_unsigned)
  | 256 => (execute_CMPGT_P_P_ZI__ 256 d esize g imm n op is_unsigned)
  | 512 => (execute_CMPGT_P_P_ZI__ 512 d esize g imm n op is_unsigned)
  | 1024 => (execute_CMPGT_P_P_ZI__ 1024 d esize g imm n op is_unsigned)
  | 2048 => (execute_CMPGT_P_P_ZI__ 2048 d esize g imm n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Int, k_is_unsigned : Bool, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPLT_P_P_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Int) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 imm)
              | Cmp_NE => (bne element1 imm)
              | Cmp_GE => (element1 ≥b imm)
              | Cmp_LT => (element1 <b imm)
              | Cmp_GT => (element1 >b imm)
              | Cmp_LE => (element1 ≤b imm)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPLT_P_P_ZI__ (size : (BitVec 2)) (imm5 : (BitVec 5)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_LT
  let imm := (BitVec.toInt imm5)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPLT_P_P_ZI__ 128 d esize g imm n op is_unsigned)
  | 256 => (execute_CMPLT_P_P_ZI__ 256 d esize g imm n op is_unsigned)
  | 512 => (execute_CMPLT_P_P_ZI__ 512 d esize g imm n op is_unsigned)
  | 1024 => (execute_CMPLT_P_P_ZI__ 1024 d esize g imm n op is_unsigned)
  | 2048 => (execute_CMPLT_P_P_ZI__ 2048 d esize g imm n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Int, k_is_unsigned : Bool, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPLE_P_P_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Int) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 imm)
              | Cmp_NE => (bne element1 imm)
              | Cmp_GE => (element1 ≥b imm)
              | Cmp_LT => (element1 <b imm)
              | Cmp_GT => (element1 >b imm)
              | Cmp_LE => (element1 ≤b imm)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPLE_P_P_ZI__ (size : (BitVec 2)) (imm5 : (BitVec 5)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_LE
  let imm := (BitVec.toInt imm5)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPLE_P_P_ZI__ 128 d esize g imm n op is_unsigned)
  | 256 => (execute_CMPLE_P_P_ZI__ 256 d esize g imm n op is_unsigned)
  | 512 => (execute_CMPLE_P_P_ZI__ 512 d esize g imm n op is_unsigned)
  | 1024 => (execute_CMPLE_P_P_ZI__ 1024 d esize g imm n op is_unsigned)
  | 2048 => (execute_CMPLE_P_P_ZI__ 2048 d esize g imm n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPEQ_P_P_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do
              (asl_Int (← (Elem_read operand2 (Int.ediv (e *i esize) 64) 64)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPEQ_P_P_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_EQ
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPEQ_P_P_ZW__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPEQ_P_P_ZW__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPEQ_P_P_ZW__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPEQ_P_P_ZW__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPEQ_P_P_ZW__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPNE_P_P_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do
              (asl_Int (← (Elem_read operand2 (Int.ediv (e *i esize) 64) 64)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPNE_P_P_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_NE
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPNE_P_P_ZW__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPNE_P_P_ZW__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPNE_P_P_ZW__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPNE_P_P_ZW__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPNE_P_P_ZW__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPHS_P_P_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do
              (asl_Int (← (Elem_read operand2 (Int.ediv (e *i esize) 64) 64)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPHS_P_P_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GE
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_CMPHS_P_P_ZW__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPHS_P_P_ZW__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPHS_P_P_ZW__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPHS_P_P_ZW__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPHS_P_P_ZW__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPHI_P_P_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do
              (asl_Int (← (Elem_read operand2 (Int.ediv (e *i esize) 64) 64)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPHI_P_P_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GT
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_CMPHI_P_P_ZW__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPHI_P_P_ZW__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPHI_P_P_ZW__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPHI_P_P_ZW__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPHI_P_P_ZW__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPLO_P_P_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do
              (asl_Int (← (Elem_read operand2 (Int.ediv (e *i esize) 64) 64)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPLO_P_P_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_LT
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_CMPLO_P_P_ZW__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPLO_P_P_ZW__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPLO_P_P_ZW__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPLO_P_P_ZW__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPLO_P_P_ZW__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPLS_P_P_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do
              (asl_Int (← (Elem_read operand2 (Int.ediv (e *i esize) 64) 64)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPLS_P_P_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_LE
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_CMPLS_P_P_ZW__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPLS_P_P_ZW__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPLS_P_P_ZW__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPLS_P_P_ZW__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPLS_P_P_ZW__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPGE_P_P_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do
              (asl_Int (← (Elem_read operand2 (Int.ediv (e *i esize) 64) 64)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPGE_P_P_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GE
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPGE_P_P_ZW__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPGE_P_P_ZW__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPGE_P_P_ZW__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPGE_P_P_ZW__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPGE_P_P_ZW__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPGT_P_P_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do
              (asl_Int (← (Elem_read operand2 (Int.ediv (e *i esize) 64) 64)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPGT_P_P_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GT
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPGT_P_P_ZW__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPGT_P_P_ZW__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPGT_P_P_ZW__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPGT_P_P_ZW__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPGT_P_P_ZW__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPLT_P_P_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do
              (asl_Int (← (Elem_read operand2 (Int.ediv (e *i esize) 64) 64)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPLT_P_P_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_LT
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPLT_P_P_ZW__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPLT_P_P_ZW__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPLT_P_P_ZW__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPLT_P_P_ZW__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPLT_P_P_ZW__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPLE_P_P_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do
              (asl_Int (← (Elem_read operand2 (Int.ediv (e *i esize) 64) 64)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPLE_P_P_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_LE
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPLE_P_P_ZW__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPLE_P_P_ZW__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPLE_P_P_ZW__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPLE_P_P_ZW__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPLE_P_P_ZW__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPEQ_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPEQ_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_EQ
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPEQ_P_P_ZZ__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPEQ_P_P_ZZ__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPEQ_P_P_ZZ__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPEQ_P_P_ZZ__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPEQ_P_P_ZZ__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPNE_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPNE_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_NE
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPNE_P_P_ZZ__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPNE_P_P_ZZ__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPNE_P_P_ZZ__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPNE_P_P_ZZ__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPNE_P_P_ZZ__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPGE_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPGE_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GE
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPGE_P_P_ZZ__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPGE_P_P_ZZ__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPGE_P_P_ZZ__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPGE_P_P_ZZ__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPGE_P_P_ZZ__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPGT_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPGT_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GT
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_CMPGT_P_P_ZZ__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPGT_P_P_ZZ__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPGT_P_P_ZZ__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPGT_P_P_ZZ__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPGT_P_P_ZZ__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPHS_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPHS_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GE
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_CMPHS_P_P_ZZ__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPHS_P_P_ZZ__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPHS_P_P_ZZ__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPHS_P_P_ZZ__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPHS_P_P_ZZ__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_CMPHI_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (op : SVECmp) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let cond ← (( do (undefined_bool ()) ) : SailM Bool )
            let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
            let cond : Bool :=
              match op with
              | Cmp_EQ => (BEq.beq element1 element2)
              | Cmp_NE => (bne element1 element2)
              | Cmp_GE => (element1 ≥b element2)
              | Cmp_LT => (element1 <b element2)
              | Cmp_GT => (element1 >b element2)
              | Cmp_LE => (element1 ≤b element2)
              | _ => cond
            let pbit : (BitVec 1) :=
              bif cond
              then (0b1 : (BitVec 1))
              else (0b0 : (BitVec 1))
            (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_CMPHI_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (ne : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Pd)
  let op : SVECmp := Cmp_GT
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_CMPHI_P_P_ZZ__ 128 d esize g m n op is_unsigned)
  | 256 => (execute_CMPHI_P_P_ZZ__ 256 d esize g m n op is_unsigned)
  | 512 => (execute_CMPHI_P_P_ZZ__ 512 d esize g m n op is_unsigned)
  | 1024 => (execute_CMPHI_P_P_ZZ__ 1024 d esize g m n op is_unsigned)
  | 2048 => (execute_CMPHI_P_P_ZZ__ 2048 d esize g m n op is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_DECP_R_P_R__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read dn 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  (X_set dn 64 (BitVec.subInt operand1 count))

def decode_DECP_R_P_R__ (size : (BitVec 2)) (D : (BitVec 1)) (Pm : (BitVec 4)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Rdn)
  match VL with
  | 128 => (execute_DECP_R_P_R__ 128 dn esize m)
  | 256 => (execute_DECP_R_P_R__ 256 dn esize m)
  | 512 => (execute_DECP_R_P_R__ 512 dn esize m)
  | 1024 => (execute_DECP_R_P_R__ 1024 dn esize m)
  | 2048 => (execute_DECP_R_P_R__ 2048 dn esize m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INCP_R_P_R__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read dn 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  (X_set dn 64 (BitVec.addInt operand1 count))

def decode_INCP_R_P_R__ (size : (BitVec 2)) (D : (BitVec 1)) (Pm : (BitVec 4)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Rdn)
  match VL with
  | 128 => (execute_INCP_R_P_R__ 128 dn esize m)
  | 256 => (execute_INCP_R_P_R__ 256 dn esize m)
  | 512 => (execute_INCP_R_P_R__ 512 dn esize m)
  | 1024 => (execute_INCP_R_P_R__ 1024 dn esize m)
  | 2048 => (execute_INCP_R_P_R__ 2048 dn esize m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, ssize : Nat, ssize
  = 32 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQINCP_R_P_R_UW (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let element ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element +i count) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQINCP_R_P_R_UW (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (sf : (BitVec 1)) (Pm : (BitVec 4)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Rdn)
  let is_unsigned : Bool := true
  let ssize := 32
  match VL with
  | 128 => (execute_UQINCP_R_P_R_UW 128 dn esize m ssize is_unsigned)
  | 256 => (execute_UQINCP_R_P_R_UW 256 dn esize m ssize is_unsigned)
  | 512 => (execute_UQINCP_R_P_R_UW 512 dn esize m ssize is_unsigned)
  | 1024 => (execute_UQINCP_R_P_R_UW 1024 dn esize m ssize is_unsigned)
  | 2048 => (execute_UQINCP_R_P_R_UW 2048 dn esize m ssize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, ssize : Nat, ssize
  = 32 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQINCP_R_P_R_SX (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let element ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element +i count) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQINCP_R_P_R_SX (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (sf : (BitVec 1)) (Pm : (BitVec 4)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Rdn)
  let is_unsigned : Bool := false
  let ssize := 32
  match VL with
  | 128 => (execute_SQINCP_R_P_R_SX 128 dn esize m ssize is_unsigned)
  | 256 => (execute_SQINCP_R_P_R_SX 256 dn esize m ssize is_unsigned)
  | 512 => (execute_SQINCP_R_P_R_SX 512 dn esize m ssize is_unsigned)
  | 1024 => (execute_SQINCP_R_P_R_SX 1024 dn esize m ssize is_unsigned)
  | 2048 => (execute_SQINCP_R_P_R_SX 2048 dn esize m ssize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, ssize : Nat, ssize
  = 64 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQINCP_R_P_R_X (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let element ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element +i count) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQINCP_R_P_R_X (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (sf : (BitVec 1)) (Pm : (BitVec 4)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Rdn)
  let is_unsigned : Bool := true
  let ssize := 64
  match VL with
  | 128 => (execute_UQINCP_R_P_R_X 128 dn esize m ssize is_unsigned)
  | 256 => (execute_UQINCP_R_P_R_X 256 dn esize m ssize is_unsigned)
  | 512 => (execute_UQINCP_R_P_R_X 512 dn esize m ssize is_unsigned)
  | 1024 => (execute_UQINCP_R_P_R_X 1024 dn esize m ssize is_unsigned)
  | 2048 => (execute_UQINCP_R_P_R_X 2048 dn esize m ssize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, ssize : Nat, ssize
  = 64 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQINCP_R_P_R_X (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let element ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element +i count) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQINCP_R_P_R_X (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (sf : (BitVec 1)) (Pm : (BitVec 4)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Rdn)
  let is_unsigned : Bool := false
  let ssize := 64
  match VL with
  | 128 => (execute_SQINCP_R_P_R_X 128 dn esize m ssize is_unsigned)
  | 256 => (execute_SQINCP_R_P_R_X 256 dn esize m ssize is_unsigned)
  | 512 => (execute_SQINCP_R_P_R_X 512 dn esize m ssize is_unsigned)
  | 1024 => (execute_SQINCP_R_P_R_X 1024 dn esize m ssize is_unsigned)
  | 2048 => (execute_SQINCP_R_P_R_X 2048 dn esize m ssize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, ssize : Nat, ssize
  = 32 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQDECP_R_P_R_UW (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let element ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element -i count) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQDECP_R_P_R_UW (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (sf : (BitVec 1)) (Pm : (BitVec 4)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Rdn)
  let is_unsigned : Bool := true
  let ssize := 32
  match VL with
  | 128 => (execute_UQDECP_R_P_R_UW 128 dn esize m ssize is_unsigned)
  | 256 => (execute_UQDECP_R_P_R_UW 256 dn esize m ssize is_unsigned)
  | 512 => (execute_UQDECP_R_P_R_UW 512 dn esize m ssize is_unsigned)
  | 1024 => (execute_UQDECP_R_P_R_UW 1024 dn esize m ssize is_unsigned)
  | 2048 => (execute_UQDECP_R_P_R_UW 2048 dn esize m ssize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, ssize : Nat, ssize
  = 32 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQDECP_R_P_R_SX (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let element ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element -i count) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQDECP_R_P_R_SX (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (sf : (BitVec 1)) (Pm : (BitVec 4)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Rdn)
  let is_unsigned : Bool := false
  let ssize := 32
  match VL with
  | 128 => (execute_SQDECP_R_P_R_SX 128 dn esize m ssize is_unsigned)
  | 256 => (execute_SQDECP_R_P_R_SX 256 dn esize m ssize is_unsigned)
  | 512 => (execute_SQDECP_R_P_R_SX 512 dn esize m ssize is_unsigned)
  | 1024 => (execute_SQDECP_R_P_R_SX 1024 dn esize m ssize is_unsigned)
  | 2048 => (execute_SQDECP_R_P_R_SX 2048 dn esize m ssize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, ssize : Nat, ssize
  = 64 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQDECP_R_P_R_X (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let element ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element -i count) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQDECP_R_P_R_X (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (sf : (BitVec 1)) (Pm : (BitVec 4)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Rdn)
  let is_unsigned : Bool := true
  let ssize := 64
  match VL with
  | 128 => (execute_UQDECP_R_P_R_X 128 dn esize m ssize is_unsigned)
  | 256 => (execute_UQDECP_R_P_R_X 256 dn esize m ssize is_unsigned)
  | 512 => (execute_UQDECP_R_P_R_X 512 dn esize m ssize is_unsigned)
  | 1024 => (execute_UQDECP_R_P_R_X 1024 dn esize m ssize is_unsigned)
  | 2048 => (execute_UQDECP_R_P_R_X 2048 dn esize m ssize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, ssize : Nat, ssize
  = 64 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQDECP_R_P_R_X (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let element ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element -i count) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQDECP_R_P_R_X (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (sf : (BitVec 1)) (Pm : (BitVec 4)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Rdn)
  let is_unsigned : Bool := false
  let ssize := 64
  match VL with
  | 128 => (execute_SQDECP_R_P_R_X 128 dn esize m ssize is_unsigned)
  | 256 => (execute_SQDECP_R_P_R_X 256 dn esize m ssize is_unsigned)
  | 512 => (execute_SQDECP_R_P_R_X 512 dn esize m ssize is_unsigned)
  | 1024 => (execute_SQDECP_R_P_R_X 1024 dn esize m ssize is_unsigned)
  | 2048 => (execute_SQDECP_R_P_R_X 2048 dn esize m ssize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_DECP_Z_P_Z__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars_1 := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        (Elem_set result e esize (BitVec.subInt (← (Elem_read operand1 e esize)) count))
    (pure loop_vars_1) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_DECP_Z_P_Z__ (size : (BitVec 2)) (D : (BitVec 1)) (Pm : (BitVec 4)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_DECP_Z_P_Z__ 128 dn esize m)
  | 256 => (execute_DECP_Z_P_Z__ 256 dn esize m)
  | 512 => (execute_DECP_Z_P_Z__ 512 dn esize m)
  | 1024 => (execute_DECP_Z_P_Z__ 1024 dn esize m)
  | 2048 => (execute_DECP_Z_P_Z__ 2048 dn esize m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INCP_Z_P_Z__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars_1 := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        (Elem_set result e esize (BitVec.addInt (← (Elem_read operand1 e esize)) count))
    (pure loop_vars_1) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_INCP_Z_P_Z__ (size : (BitVec 2)) (D : (BitVec 1)) (Pm : (BitVec 4)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_INCP_Z_P_Z__ 128 dn esize m)
  | 256 => (execute_INCP_Z_P_Z__ 256 dn esize m)
  | 512 => (execute_INCP_Z_P_Z__ 512 dn esize m)
  | 1024 => (execute_INCP_Z_P_Z__ 1024 dn esize m)
  | 2048 => (execute_INCP_Z_P_Z__ 2048 dn esize m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤ m ∧
  m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQINCP_Z_P_Z__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars_1 := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        let element ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element +i count) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars_1) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQINCP_Z_P_Z__ (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (Pm : (BitVec 4)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Zdn)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQINCP_Z_P_Z__ 128 dn esize m is_unsigned)
  | 256 => (execute_UQINCP_Z_P_Z__ 256 dn esize m is_unsigned)
  | 512 => (execute_UQINCP_Z_P_Z__ 512 dn esize m is_unsigned)
  | 1024 => (execute_UQINCP_Z_P_Z__ 1024 dn esize m is_unsigned)
  | 2048 => (execute_UQINCP_Z_P_Z__ 2048 dn esize m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤ m ∧
  m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQINCP_Z_P_Z__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars_1 := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        let element ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element +i count) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars_1) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQINCP_Z_P_Z__ (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (Pm : (BitVec 4)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Zdn)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQINCP_Z_P_Z__ 128 dn esize m is_unsigned)
  | 256 => (execute_SQINCP_Z_P_Z__ 256 dn esize m is_unsigned)
  | 512 => (execute_SQINCP_Z_P_Z__ 512 dn esize m is_unsigned)
  | 1024 => (execute_SQINCP_Z_P_Z__ 1024 dn esize m is_unsigned)
  | 2048 => (execute_SQINCP_Z_P_Z__ 2048 dn esize m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤ m ∧
  m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQDECP_Z_P_Z__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars_1 := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        let element ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element -i count) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars_1) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQDECP_Z_P_Z__ (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (Pm : (BitVec 4)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Zdn)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQDECP_Z_P_Z__ 128 dn esize m is_unsigned)
  | 256 => (execute_UQDECP_Z_P_Z__ 256 dn esize m is_unsigned)
  | 512 => (execute_UQDECP_Z_P_Z__ 512 dn esize m is_unsigned)
  | 1024 => (execute_UQDECP_Z_P_Z__ 1024 dn esize m is_unsigned)
  | 2048 => (execute_UQDECP_Z_P_Z__ 2048 dn esize m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤ m ∧
  m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQDECP_Z_P_Z__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let count : Int := 0
  let count ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := count
    for e in [loop_e_lower:loop_e_upper:1]i do
      let count := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement operand2 e esize))
        then (pure (count +i 1))
        else (pure count)
    (pure loop_vars) ) : SailM Int )
  let count := count
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars_1 := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        let element ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element -i count) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars_1) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQDECP_Z_P_Z__ (size : (BitVec 2)) (D : (BitVec 1)) (U : (BitVec 1)) (Pm : (BitVec 4)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Pm)
  let dn := (BitVec.toNat Zdn)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQDECP_Z_P_Z__ 128 dn esize m is_unsigned)
  | 256 => (execute_SQDECP_Z_P_Z__ 256 dn esize m is_unsigned)
  | 512 => (execute_SQDECP_Z_P_Z__ 512 dn esize m is_unsigned)
  | 1024 => (execute_SQDECP_Z_P_Z__ 1024 dn esize m is_unsigned)
  | 2048 => (execute_SQDECP_Z_P_Z__ 2048 dn esize m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_DECB_R_RS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let VL := VL
  let operand1 ← (( do (X_read dn 64) ) : SailM (BitVec 64) )
  (X_set dn 64 (BitVec.subInt operand1 (count *i imm)))

def decode_DECB_R_RS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_DECB_R_RS__ 128 dn esize imm pat)
  | 256 => (execute_DECB_R_RS__ 256 dn esize imm pat)
  | 512 => (execute_DECB_R_RS__ 512 dn esize imm pat)
  | 1024 => (execute_DECB_R_RS__ 1024 dn esize imm pat)
  | 2048 => (execute_DECB_R_RS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_DECH_R_RS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let VL := VL
  let operand1 ← (( do (X_read dn 64) ) : SailM (BitVec 64) )
  (X_set dn 64 (BitVec.subInt operand1 (count *i imm)))

def decode_DECH_R_RS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_DECH_R_RS__ 128 dn esize imm pat)
  | 256 => (execute_DECH_R_RS__ 256 dn esize imm pat)
  | 512 => (execute_DECH_R_RS__ 512 dn esize imm pat)
  | 1024 => (execute_DECH_R_RS__ 1024 dn esize imm pat)
  | 2048 => (execute_DECH_R_RS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_DECW_R_RS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let VL := VL
  let operand1 ← (( do (X_read dn 64) ) : SailM (BitVec 64) )
  (X_set dn 64 (BitVec.subInt operand1 (count *i imm)))

def decode_DECW_R_RS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_DECW_R_RS__ 128 dn esize imm pat)
  | 256 => (execute_DECW_R_RS__ 256 dn esize imm pat)
  | 512 => (execute_DECW_R_RS__ 512 dn esize imm pat)
  | 1024 => (execute_DECW_R_RS__ 1024 dn esize imm pat)
  | 2048 => (execute_DECW_R_RS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_DECD_R_RS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let VL := VL
  let operand1 ← (( do (X_read dn 64) ) : SailM (BitVec 64) )
  (X_set dn 64 (BitVec.subInt operand1 (count *i imm)))

def decode_DECD_R_RS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_DECD_R_RS__ 128 dn esize imm pat)
  | 256 => (execute_DECD_R_RS__ 256 dn esize imm pat)
  | 512 => (execute_DECD_R_RS__ 512 dn esize imm pat)
  | 1024 => (execute_DECD_R_RS__ 1024 dn esize imm pat)
  | 2048 => (execute_DECD_R_RS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INCB_R_RS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let VL := VL
  let operand1 ← (( do (X_read dn 64) ) : SailM (BitVec 64) )
  (X_set dn 64 (BitVec.addInt operand1 (count *i imm)))

def decode_INCB_R_RS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_INCB_R_RS__ 128 dn esize imm pat)
  | 256 => (execute_INCB_R_RS__ 256 dn esize imm pat)
  | 512 => (execute_INCB_R_RS__ 512 dn esize imm pat)
  | 1024 => (execute_INCB_R_RS__ 1024 dn esize imm pat)
  | 2048 => (execute_INCB_R_RS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INCH_R_RS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let VL := VL
  let operand1 ← (( do (X_read dn 64) ) : SailM (BitVec 64) )
  (X_set dn 64 (BitVec.addInt operand1 (count *i imm)))

def decode_INCH_R_RS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_INCH_R_RS__ 128 dn esize imm pat)
  | 256 => (execute_INCH_R_RS__ 256 dn esize imm pat)
  | 512 => (execute_INCH_R_RS__ 512 dn esize imm pat)
  | 1024 => (execute_INCH_R_RS__ 1024 dn esize imm pat)
  | 2048 => (execute_INCH_R_RS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INCW_R_RS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let VL := VL
  let operand1 ← (( do (X_read dn 64) ) : SailM (BitVec 64) )
  (X_set dn 64 (BitVec.addInt operand1 (count *i imm)))

def decode_INCW_R_RS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_INCW_R_RS__ 128 dn esize imm pat)
  | 256 => (execute_INCW_R_RS__ 256 dn esize imm pat)
  | 512 => (execute_INCW_R_RS__ 512 dn esize imm pat)
  | 1024 => (execute_INCW_R_RS__ 1024 dn esize imm pat)
  | 2048 => (execute_INCW_R_RS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INCD_R_RS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let VL := VL
  let operand1 ← (( do (X_read dn 64) ) : SailM (BitVec 64) )
  (X_set dn 64 (BitVec.addInt operand1 (count *i imm)))

def decode_INCD_R_RS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_INCD_R_RS__ 128 dn esize imm pat)
  | 256 => (execute_INCD_R_RS__ 256 dn esize imm pat)
  | 512 => (execute_INCD_R_RS__ 512 dn esize imm pat)
  | 1024 => (execute_INCD_R_RS__ 1024 dn esize imm pat)
  | 2048 => (execute_INCD_R_RS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQINCB_R_RS_UW (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQINCB_R_RS_UW (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 32
  (execute_UQINCB_R_RS_UW dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQINCH_R_RS_UW (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQINCH_R_RS_UW (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 32
  (execute_UQINCH_R_RS_UW dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQINCW_R_RS_UW (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQINCW_R_RS_UW (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 32
  (execute_UQINCW_R_RS_UW dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQINCD_R_RS_UW (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQINCD_R_RS_UW (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 32
  (execute_UQINCD_R_RS_UW dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQINCB_R_RS_SX (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQINCB_R_RS_SX (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 32
  (execute_SQINCB_R_RS_SX dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQINCH_R_RS_SX (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQINCH_R_RS_SX (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 32
  (execute_SQINCH_R_RS_SX dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQINCW_R_RS_SX (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQINCW_R_RS_SX (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 32
  (execute_SQINCW_R_RS_SX dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQINCD_R_RS_SX (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQINCD_R_RS_SX (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 32
  (execute_SQINCD_R_RS_SX dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQINCB_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQINCB_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 64
  (execute_UQINCB_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQINCH_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQINCH_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 64
  (execute_UQINCH_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQINCW_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQINCW_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 64
  (execute_UQINCW_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQINCD_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQINCD_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 64
  (execute_UQINCD_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQINCB_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQINCB_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 64
  (execute_SQINCB_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQINCH_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQINCH_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 64
  (execute_SQINCH_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQINCW_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQINCW_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 64
  (execute_SQINCW_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQINCD_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQINCD_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 64
  (execute_SQINCD_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQDECB_R_RS_UW (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQDECB_R_RS_UW (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 32
  (execute_UQDECB_R_RS_UW dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQDECH_R_RS_UW (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQDECH_R_RS_UW (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 32
  (execute_UQDECH_R_RS_UW dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQDECW_R_RS_UW (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQDECW_R_RS_UW (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 32
  (execute_UQDECW_R_RS_UW dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQDECD_R_RS_UW (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQDECD_R_RS_UW (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 32
  (execute_UQDECD_R_RS_UW dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQDECB_R_RS_SX (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQDECB_R_RS_SX (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 32
  (execute_SQDECB_R_RS_SX dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQDECH_R_RS_SX (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQDECH_R_RS_SX (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 32
  (execute_SQDECH_R_RS_SX dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQDECW_R_RS_SX (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQDECW_R_RS_SX (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 32
  (execute_SQDECW_R_RS_SX dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  32 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQDECD_R_RS_SX (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQDECD_R_RS_SX (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 32
  (execute_SQDECD_R_RS_SX dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQDECB_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQDECB_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 64
  (execute_UQDECB_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQDECH_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQDECH_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 64
  (execute_UQDECH_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQDECW_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQDECW_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 64
  (execute_UQDECW_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_UQDECD_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_UQDECD_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  let ssize := 64
  (execute_UQDECD_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQDECB_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQDECB_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 64
  (execute_SQDECB_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQDECH_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQDECH_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 64
  (execute_SQDECH_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQDECW_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQDECW_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 64
  (execute_SQDECW_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, ssize : Nat, ssize =
  64 ∧ 1 ≤ imm ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 -/
def execute_SQDECD_R_RS_X (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (ssize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (X_read dn ssize) ) : SailM (BitVec ssize) )
  let result ← (( do (undefined_bitvector ssize) ) : SailM (BitVec ssize) )
  let element1 ← do (asl_Int operand1 is_unsigned)
  let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) ssize is_unsigned)
  let result : (BitVec ssize) := __tup_0
  (pure ())
  (X_set dn 64 (← (Extend result 64 is_unsigned)))

def decode_SQDECD_R_RS_X (size : (BitVec 2)) (sf : (BitVec 1)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Rdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  let ssize := 64
  (execute_SQDECD_R_RS_X dn esize imm pat ssize is_unsigned)

/-- Type quantifiers: d : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_CNTB_R_S__ (d : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  (X_set d 64 (integer_subrange (count *i imm) 63 0))

def decode_CNTB_R_S__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (pattern : (BitVec 5)) (Rd : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let d := (BitVec.toNat Rd)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  (execute_CNTB_R_S__ d esize imm pat)

/-- Type quantifiers: d : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_CNTH_R_S__ (d : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  (X_set d 64 (integer_subrange (count *i imm) 63 0))

def decode_CNTH_R_S__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (pattern : (BitVec 5)) (Rd : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let d := (BitVec.toNat Rd)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  (execute_CNTH_R_S__ d esize imm pat)

/-- Type quantifiers: d : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_CNTW_R_S__ (d : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  (X_set d 64 (integer_subrange (count *i imm) 63 0))

def decode_CNTW_R_S__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (pattern : (BitVec 5)) (Rd : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let d := (BitVec.toNat Rd)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  (execute_CNTW_R_S__ d esize imm pat)

/-- Type quantifiers: d : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_CNTD_R_S__ (d : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let count ← do (DecodePredCount pat esize)
  (X_set d 64 (integer_subrange (count *i imm) 63 0))

def decode_CNTD_R_S__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (pattern : (BitVec 5)) (Rd : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let d := (BitVec.toNat Rd)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  (execute_CNTD_R_S__ d esize imm pat)

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_DECH_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize (BitVec.subInt (← (Elem_read operand1 e esize)) (count *i imm)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_DECH_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_DECH_Z_ZS__ 128 dn esize imm pat)
  | 256 => (execute_DECH_Z_ZS__ 256 dn esize imm pat)
  | 512 => (execute_DECH_Z_ZS__ 512 dn esize imm pat)
  | 1024 => (execute_DECH_Z_ZS__ 1024 dn esize imm pat)
  | 2048 => (execute_DECH_Z_ZS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_DECW_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize (BitVec.subInt (← (Elem_read operand1 e esize)) (count *i imm)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_DECW_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_DECW_Z_ZS__ 128 dn esize imm pat)
  | 256 => (execute_DECW_Z_ZS__ 256 dn esize imm pat)
  | 512 => (execute_DECW_Z_ZS__ 512 dn esize imm pat)
  | 1024 => (execute_DECW_Z_ZS__ 1024 dn esize imm pat)
  | 2048 => (execute_DECW_Z_ZS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_DECD_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize (BitVec.subInt (← (Elem_read operand1 e esize)) (count *i imm)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_DECD_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_DECD_Z_ZS__ 128 dn esize imm pat)
  | 256 => (execute_DECD_Z_ZS__ 256 dn esize imm pat)
  | 512 => (execute_DECD_Z_ZS__ 512 dn esize imm pat)
  | 1024 => (execute_DECD_Z_ZS__ 1024 dn esize imm pat)
  | 2048 => (execute_DECD_Z_ZS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INCH_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize (BitVec.addInt (← (Elem_read operand1 e esize)) (count *i imm)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_INCH_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_INCH_Z_ZS__ 128 dn esize imm pat)
  | 256 => (execute_INCH_Z_ZS__ 256 dn esize imm pat)
  | 512 => (execute_INCH_Z_ZS__ 512 dn esize imm pat)
  | 1024 => (execute_INCH_Z_ZS__ 1024 dn esize imm pat)
  | 2048 => (execute_INCH_Z_ZS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INCW_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize (BitVec.addInt (← (Elem_read operand1 e esize)) (count *i imm)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_INCW_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_INCW_Z_ZS__ 128 dn esize imm pat)
  | 256 => (execute_INCW_Z_ZS__ 256 dn esize imm pat)
  | 512 => (execute_INCW_Z_ZS__ 512 dn esize imm pat)
  | 1024 => (execute_INCW_Z_ZS__ 1024 dn esize imm pat)
  | 2048 => (execute_INCW_Z_ZS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, 1 ≤ imm ∧
  imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INCD_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize (BitVec.addInt (← (Elem_read operand1 e esize)) (count *i imm)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_INCD_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  match VL with
  | 128 => (execute_INCD_Z_ZS__ 128 dn esize imm pat)
  | 256 => (execute_INCD_Z_ZS__ 256 dn esize imm pat)
  | 512 => (execute_INCD_Z_ZS__ 512 dn esize imm pat)
  | 1024 => (execute_INCD_Z_ZS__ 1024 dn esize imm pat)
  | 2048 => (execute_INCD_Z_ZS__ 2048 dn esize imm pat)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQINCH_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQINCH_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQINCH_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_UQINCH_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_UQINCH_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_UQINCH_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_UQINCH_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQINCW_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQINCW_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQINCW_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_UQINCW_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_UQINCW_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_UQINCW_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_UQINCW_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQINCD_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQINCD_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQINCD_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_UQINCD_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_UQINCD_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_UQINCD_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_UQINCD_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQINCH_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQINCH_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQINCH_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_SQINCH_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_SQINCH_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_SQINCH_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_SQINCH_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQINCW_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQINCW_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQINCW_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_SQINCW_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_SQINCW_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_SQINCW_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_SQINCW_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQINCD_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 +i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQINCD_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQINCD_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_SQINCD_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_SQINCD_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_SQINCD_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_SQINCD_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQDECH_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQDECH_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQDECH_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_UQDECH_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_UQDECH_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_UQDECH_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_UQDECH_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQDECW_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQDECW_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQDECW_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_UQDECW_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_UQDECW_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_UQDECW_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_UQDECW_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQDECD_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQDECD_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQDECD_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_UQDECD_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_UQDECD_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_UQDECD_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_UQDECD_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 16 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQDECH_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQDECH_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQDECH_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_SQDECH_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_SQDECH_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_SQDECH_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_SQDECH_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 32 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQDECW_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQDECW_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQDECW_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_SQDECW_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_SQDECW_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_SQDECW_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_SQDECW_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Nat, k_is_unsigned : Bool, 1 ≤ imm
  ∧ imm ≤ 16 ∧ esize = 64 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQDECD_Z_ZS__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Nat) (pat : (BitVec 5)) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 -i (count *i imm)) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQDECD_Z_ZS__ (size : (BitVec 2)) (imm4 : (BitVec 4)) (D : (BitVec 1)) (U : (BitVec 1)) (pattern : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let dn := (BitVec.toNat Zdn)
  let pat : (BitVec 5) := pattern
  let imm := ((BitVec.toNat imm4) +i 1)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQDECD_Z_ZS__ 128 dn esize imm pat is_unsigned)
  | 256 => (execute_SQDECD_Z_ZS__ 256 dn esize imm pat is_unsigned)
  | 512 => (execute_SQDECD_Z_ZS__ 512 dn esize imm pat is_unsigned)
  | 1024 => (execute_SQDECD_Z_ZS__ 1024 dn esize imm pat is_unsigned)
  | 2048 => (execute_SQDECD_Z_ZS__ 2048 dn esize imm pat is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} -/
def execute_CTERMEQ_RR__ (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let operand1 ← (( do (X_read n esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (X_read m esize) ) : SailM (BitVec esize) )
  let element1 := (BitVec.toNat operand1)
  let element2 := (BitVec.toNat operand2)
  let term ← (( do (undefined_bool ()) ) : SailM Bool )
  let term : Bool :=
    match op with
    | Cmp_EQ => (BEq.beq element1 element2)
    | Cmp_NE => (bne element1 element2)
    | _ => term
  bif term
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (0b1 : (BitVec 1)) }
      writeReg PSTATE { (← readReg PSTATE) with V := (0b0 : (BitVec 1)) })
  else
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (0b0 : (BitVec 1)) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Complement.complement (← readReg PSTATE).C) })

def decode_CTERMEQ_RR__ (sz : (BitVec 1)) (Rm : (BitVec 5)) (Rn : (BitVec 5)) (ne : (BitVec 1)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let op : SVECmp := Cmp_EQ
  (execute_CTERMEQ_RR__ esize m n op)

/-- Type quantifiers: esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} -/
def execute_CTERMNE_RR__ (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) : SailM Unit := do
  (CheckSVEEnabled ())
  let operand1 ← (( do (X_read n esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (X_read m esize) ) : SailM (BitVec esize) )
  let element1 := (BitVec.toNat operand1)
  let element2 := (BitVec.toNat operand2)
  let term ← (( do (undefined_bool ()) ) : SailM Bool )
  let term : Bool :=
    match op with
    | Cmp_EQ => (BEq.beq element1 element2)
    | Cmp_NE => (bne element1 element2)
    | _ => term
  bif term
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (0b1 : (BitVec 1)) }
      writeReg PSTATE { (← readReg PSTATE) with V := (0b0 : (BitVec 1)) })
  else
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (0b0 : (BitVec 1)) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Complement.complement (← readReg PSTATE).C) })

def decode_CTERMNE_RR__ (sz : (BitVec 1)) (Rm : (BitVec 5)) (Rn : (BitVec 5)) (ne : (BitVec 1)) : SailM Unit := do
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let op : SVECmp := Cmp_NE
  (execute_CTERMNE_RR__ esize m n op)

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, esize ∈ {8, 16, 32, 64} ∧
  0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FDUP_Z_I__ (VL : Nat) (d : Nat) (esize : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do (Elem_set result e esize imm)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FDUP_Z_I__ (size : (BitVec 2)) (imm8 : (BitVec 8)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let d := (BitVec.toNat Zd)
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:23403.45-23403.46"
  let imm ← (( do (VFPExpandImm imm8 esize) ) : SailM (BitVec esize) )
  match VL with
  | 128 => (execute_FDUP_Z_I__ 128 d esize imm)
  | 256 => (execute_FDUP_Z_I__ 256 d esize imm)
  | 512 => (execute_FDUP_Z_I__ 512 d esize imm)
  | 1024 => (execute_FDUP_Z_I__ 1024 d esize imm)
  | 2048 => (execute_FDUP_Z_I__ 2048 d esize imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, 0 ≤ g ∧
  g ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FCPY_Z_P_I__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize imm))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FCPY_Z_P_I__ (size : (BitVec 2)) (Pg : (BitVec 4)) (imm8 : (BitVec 8)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let d := (BitVec.toNat Zd)
  assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:23466.45-23466.46"
  let imm ← (( do (VFPExpandImm imm8 esize) ) : SailM (BitVec esize) )
  match VL with
  | 128 => (execute_FCPY_Z_P_I__ 128 d esize g imm)
  | 256 => (execute_FCPY_Z_P_I__ 256 d esize g imm)
  | 512 => (execute_FCPY_Z_P_I__ 512 d esize g imm)
  | 1024 => (execute_FCPY_Z_P_I__ 1024 d esize g imm)
  | 2048 => (execute_FCPY_Z_P_I__ 2048 d esize g imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Int, esize ∈ {8, 16, 32, 64} ∧
  0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_DUP_Z_I__ (VL : Nat) (d : Nat) (esize : Nat) (imm : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let result : (BitVec VL) := (Replicate__1 (n := VL) (integer_subrange imm (esize -i 1) 0))
  (Z_set d VL result)

def decode_DUP_Z_I__ (size : (BitVec 2)) (sh : (BitVec 1)) (imm8 : (BitVec 8)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (size ++ sh) (0b001 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let d := (BitVec.toNat Zd)
  let imm : Int := (BitVec.toInt imm8)
  let imm : Int :=
    bif (BEq.beq sh (0b1 : (BitVec 1)))
    then (Int.shiftl imm 8)
    else imm
  let imm := imm
  match VL with
  | 128 => (execute_DUP_Z_I__ 128 d esize imm)
  | 256 => (execute_DUP_Z_I__ 256 d esize imm)
  | 512 => (execute_DUP_Z_I__ 512 d esize imm)
  | 1024 => (execute_DUP_Z_I__ 1024 d esize imm)
  | 2048 => (execute_DUP_Z_I__ 2048 d esize imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Int, k_merging : Bool, 0 ≤ g
  ∧ g ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_CPY_Z_P_I__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Int) (merging : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let dest ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (integer_subrange imm (esize -i 1) 0)))
        else
          (do
            bif merging
            then
              (do
                (Elem_set result e esize (← (Elem_read dest e esize))))
            else
              (do
                (Elem_set result e esize (Zeros (n := esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_CPY_Z_P_I__ (size : (BitVec 2)) (Pg : (BitVec 4)) (M : (BitVec 1)) (sh : (BitVec 1)) (imm8 : (BitVec 8)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (size ++ sh) (0b001 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let d := (BitVec.toNat Zd)
  let merging : Bool := true
  let imm : Int := (BitVec.toInt imm8)
  let imm : Int :=
    bif (BEq.beq sh (0b1 : (BitVec 1)))
    then (Int.shiftl imm 8)
    else imm
  let imm := imm
  match VL with
  | 128 => (execute_CPY_Z_P_I__ 128 d esize g imm merging)
  | 256 => (execute_CPY_Z_P_I__ 256 d esize g imm merging)
  | 512 => (execute_CPY_Z_P_I__ 512 d esize g imm merging)
  | 1024 => (execute_CPY_Z_P_I__ 1024 d esize g imm merging)
  | 2048 => (execute_CPY_Z_P_I__ 2048 d esize g imm merging)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, imm : Int, k_merging : Bool, 0 ≤ g
  ∧ g ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_CPY_Z_O_I__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (imm : Int) (merging : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let dest ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (integer_subrange imm (esize -i 1) 0)))
        else
          (do
            bif merging
            then
              (do
                (Elem_set result e esize (← (Elem_read dest e esize))))
            else
              (do
                (Elem_set result e esize (Zeros (n := esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_CPY_Z_O_I__ (size : (BitVec 2)) (Pg : (BitVec 4)) (M : (BitVec 1)) (sh : (BitVec 1)) (imm8 : (BitVec 8)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (size ++ sh) (0b001 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let d := (BitVec.toNat Zd)
  let merging : Bool := false
  let imm : Int := (BitVec.toInt imm8)
  let imm : Int :=
    bif (BEq.beq sh (0b1 : (BitVec 1)))
    then (Int.shiftl imm 8)
    else imm
  let imm := imm
  match VL with
  | 128 => (execute_CPY_Z_O_I__ 128 d esize g imm merging)
  | 256 => (execute_CPY_Z_O_I__ 256 d esize g imm merging)
  | 512 => (execute_CPY_Z_O_I__ 512 d esize g imm merging)
  | 1024 => (execute_CPY_Z_O_I__ 1024 d esize g imm merging)
  | 2048 => (execute_CPY_Z_O_I__ 2048 d esize g imm merging)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, esize = 64 ∧
  0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_DUPM_Z_I__ (VL : Nat) (d : Nat) (esize : Nat) (imm : (BitVec esize)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let result : (BitVec VL) := (BitVec.replicateBits imm (Int.ediv VL esize))
  (Z_set d VL result)

def decode_DUPM_Z_I__ (imm13 : (BitVec 13)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let d := (BitVec.toNat Zd)
  let imm ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (__tup_0, _) ← do
    (DecodeBitMasks (BitVec.join1 [(BitVec.access imm13 12)]) (Sail.BitVec.extractLsb imm13 5 0)
      (Sail.BitVec.extractLsb imm13 11 6) true esize)
  let imm : (BitVec esize) := __tup_0
  (pure ())
  match VL with
  | 128 => (execute_DUPM_Z_I__ 128 d esize imm)
  | 256 => (execute_DUPM_Z_I__ 256 d esize imm)
  | 512 => (execute_DUPM_Z_I__ 512 d esize imm)
  | 1024 => (execute_DUPM_Z_I__ 1024 d esize imm)
  | 2048 => (execute_DUPM_Z_I__ 2048 d esize imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, s_esize
  : Nat, s_esize = 8 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UXTB_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize
              (← (Extend (Sail.BitVec.extractLsb element (s_esize -i 1) 0) esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UXTB_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let s_esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UXTB_Z_P_Z__ 128 d esize g n s_esize is_unsigned)
  | 256 => (execute_UXTB_Z_P_Z__ 256 d esize g n s_esize is_unsigned)
  | 512 => (execute_UXTB_Z_P_Z__ 512 d esize g n s_esize is_unsigned)
  | 1024 => (execute_UXTB_Z_P_Z__ 1024 d esize g n s_esize is_unsigned)
  | 2048 => (execute_UXTB_Z_P_Z__ 2048 d esize g n s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, s_esize
  : Nat, s_esize = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UXTH_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.and (0 ≤b (s_esize -i 1)) ((s_esize -i 1) <b esize)) "src/instrs64_sve.sail:23846.74-23846.75"
            (Elem_set result e esize
              (← (Extend (Sail.BitVec.extractLsb element (s_esize -i 1) 0) esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UXTH_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let s_esize := 16
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UXTH_Z_P_Z__ 128 d esize g n s_esize is_unsigned)
  | 256 => (execute_UXTH_Z_P_Z__ 256 d esize g n s_esize is_unsigned)
  | 512 => (execute_UXTH_Z_P_Z__ 512 d esize g n s_esize is_unsigned)
  | 1024 => (execute_UXTH_Z_P_Z__ 1024 d esize g n s_esize is_unsigned)
  | 2048 => (execute_UXTH_Z_P_Z__ 2048 d esize g n s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, s_esize
  : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UXTW_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.and (0 ≤b (s_esize -i 1)) ((s_esize -i 1) <b esize)) "src/instrs64_sve.sail:23921.74-23921.75"
            (Elem_set result e esize
              (← (Extend (Sail.BitVec.extractLsb element (s_esize -i 1) 0) esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UXTW_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (bne size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let s_esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UXTW_Z_P_Z__ 128 d esize g n s_esize is_unsigned)
  | 256 => (execute_UXTW_Z_P_Z__ 256 d esize g n s_esize is_unsigned)
  | 512 => (execute_UXTW_Z_P_Z__ 512 d esize g n s_esize is_unsigned)
  | 1024 => (execute_UXTW_Z_P_Z__ 1024 d esize g n s_esize is_unsigned)
  | 2048 => (execute_UXTW_Z_P_Z__ 2048 d esize g n s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, s_esize
  : Nat, s_esize = 8 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SXTB_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize
              (← (Extend (Sail.BitVec.extractLsb element (s_esize -i 1) 0) esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SXTB_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let s_esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SXTB_Z_P_Z__ 128 d esize g n s_esize is_unsigned)
  | 256 => (execute_SXTB_Z_P_Z__ 256 d esize g n s_esize is_unsigned)
  | 512 => (execute_SXTB_Z_P_Z__ 512 d esize g n s_esize is_unsigned)
  | 1024 => (execute_SXTB_Z_P_Z__ 1024 d esize g n s_esize is_unsigned)
  | 2048 => (execute_SXTB_Z_P_Z__ 2048 d esize g n s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, s_esize
  : Nat, s_esize = 16 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SXTH_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.and (0 ≤b (s_esize -i 1)) ((s_esize -i 1) <b esize)) "src/instrs64_sve.sail:24064.74-24064.75"
            (Elem_set result e esize
              (← (Extend (Sail.BitVec.extractLsb element (s_esize -i 1) 0) esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SXTH_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let s_esize := 16
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SXTH_Z_P_Z__ 128 d esize g n s_esize is_unsigned)
  | 256 => (execute_SXTH_Z_P_Z__ 256 d esize g n s_esize is_unsigned)
  | 512 => (execute_SXTH_Z_P_Z__ 512 d esize g n s_esize is_unsigned)
  | 1024 => (execute_SXTH_Z_P_Z__ 1024 d esize g n s_esize is_unsigned)
  | 2048 => (execute_SXTH_Z_P_Z__ 2048 d esize g n s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, s_esize
  : Nat, s_esize = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SXTW_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (s_esize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.and (0 ≤b (s_esize -i 1)) ((s_esize -i 1) <b esize)) "src/instrs64_sve.sail:24139.74-24139.75"
            (Elem_set result e esize
              (← (Extend (Sail.BitVec.extractLsb element (s_esize -i 1) 0) esize is_unsigned))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SXTW_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (bne size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let s_esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SXTW_Z_P_Z__ 128 d esize g n s_esize is_unsigned)
  | 256 => (execute_SXTW_Z_P_Z__ 256 d esize g n s_esize is_unsigned)
  | 512 => (execute_SXTW_Z_P_Z__ 512 d esize g n s_esize is_unsigned)
  | 1024 => (execute_SXTW_Z_P_Z__ 1024 d esize g n s_esize is_unsigned)
  | 2048 => (execute_SXTW_Z_P_Z__ 2048 d esize g n s_esize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ANDV_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec esize) := (Ones (n := esize))
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (pure (result &&& (← (Elem_read operand e esize)))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec esize) )
  (V_set d esize result)

def decode_ANDV_R_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_ANDV_R_P_Z__ 128 d esize g n)
  | 256 => (execute_ANDV_R_P_Z__ 256 d esize g n)
  | 512 => (execute_ANDV_R_P_Z__ 512 d esize g n)
  | 1024 => (execute_ANDV_R_P_Z__ 1024 d esize g n)
  | 2048 => (execute_ANDV_R_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_EORV_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec esize) := (Zeros (n := esize))
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (pure (result ^^^ (← (Elem_read operand e esize)))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec esize) )
  (V_set d esize result)

def decode_EORV_R_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_EORV_R_P_Z__ 128 d esize g n)
  | 256 => (execute_EORV_R_P_Z__ 256 d esize g n)
  | 512 => (execute_EORV_R_P_Z__ 512 d esize g n)
  | 1024 => (execute_EORV_R_P_Z__ 1024 d esize g n)
  | 2048 => (execute_EORV_R_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ORV_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec esize) := (Zeros (n := esize))
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (pure (result ||| (← (Elem_read operand e esize)))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec esize) )
  (V_set d esize result)

def decode_ORV_R_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_ORV_R_P_Z__ 128 d esize g n)
  | 256 => (execute_ORV_R_P_Z__ 256 d esize g n)
  | 512 => (execute_ORV_R_P_Z__ 512 d esize g n)
  | 1024 => (execute_ORV_R_P_Z__ 1024 d esize g n)
  | 2048 => (execute_ORV_R_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SADDV_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let sum : Int := 0
  let sum ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := sum
    for e in [loop_e_lower:loop_e_upper:1]i do
      let sum := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand e esize))))
            (pure (sum +i element)))
        else (pure sum)
    (pure loop_vars) ) : SailM Int )
  let sum := sum
  (V_set d 64 (integer_subrange sum 63 0))

def decode_SADDV_R_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_SADDV_R_P_Z__ 128 d esize g n)
  | 256 => (execute_SADDV_R_P_Z__ 256 d esize g n)
  | 512 => (execute_SADDV_R_P_Z__ 512 d esize g n)
  | 1024 => (execute_SADDV_R_P_Z__ 1024 d esize g n)
  | 2048 => (execute_SADDV_R_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UADDV_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let sum : Int := 0
  let sum ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := sum
    for e in [loop_e_lower:loop_e_upper:1]i do
      let sum := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand e esize))))
            (pure (sum +i element)))
        else (pure sum)
    (pure loop_vars) ) : SailM Int )
  let sum := sum
  (V_set d 64 (integer_subrange sum 63 0))

def decode_UADDV_R_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_UADDV_R_P_Z__ 128 d esize g n)
  | 256 => (execute_UADDV_R_P_Z__ 256 d esize g n)
  | 512 => (execute_UADDV_R_P_Z__ 512 d esize g n)
  | 1024 => (execute_UADDV_R_P_Z__ 1024 d esize g n)
  | 2048 => (execute_UADDV_R_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMAXV_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let maximum : Int :=
    bif is_unsigned
    then 0
    else (Neg.neg (2 ^i (esize -i 1)))
  let maximum ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := maximum
    for e in [loop_e_lower:loop_e_upper:1]i do
      let maximum := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (asl_Int (← (Elem_read operand e esize)) is_unsigned)
            (pure (Max.max maximum element)))
        else (pure maximum)
    (pure loop_vars) ) : SailM Int )
  let maximum := maximum
  (V_set d esize (integer_subrange maximum (esize -i 1) 0))

def decode_UMAXV_R_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMAXV_R_P_Z__ 128 d esize g n is_unsigned)
  | 256 => (execute_UMAXV_R_P_Z__ 256 d esize g n is_unsigned)
  | 512 => (execute_UMAXV_R_P_Z__ 512 d esize g n is_unsigned)
  | 1024 => (execute_UMAXV_R_P_Z__ 1024 d esize g n is_unsigned)
  | 2048 => (execute_UMAXV_R_P_Z__ 2048 d esize g n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMAXV_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let maximum : Int :=
    bif is_unsigned
    then 0
    else (Neg.neg (2 ^i (esize -i 1)))
  let maximum ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := maximum
    for e in [loop_e_lower:loop_e_upper:1]i do
      let maximum := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (asl_Int (← (Elem_read operand e esize)) is_unsigned)
            (pure (Max.max maximum element)))
        else (pure maximum)
    (pure loop_vars) ) : SailM Int )
  let maximum := maximum
  (V_set d esize (integer_subrange maximum (esize -i 1) 0))

def decode_SMAXV_R_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMAXV_R_P_Z__ 128 d esize g n is_unsigned)
  | 256 => (execute_SMAXV_R_P_Z__ 256 d esize g n is_unsigned)
  | 512 => (execute_SMAXV_R_P_Z__ 512 d esize g n is_unsigned)
  | 1024 => (execute_SMAXV_R_P_Z__ 1024 d esize g n is_unsigned)
  | 2048 => (execute_SMAXV_R_P_Z__ 2048 d esize g n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMINV_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let minimum : Int :=
    bif is_unsigned
    then ((2 ^i esize) -i 1)
    else ((2 ^i (esize -i 1)) -i 1)
  let minimum ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := minimum
    for e in [loop_e_lower:loop_e_upper:1]i do
      let minimum := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (asl_Int (← (Elem_read operand e esize)) is_unsigned)
            (pure (Min.min minimum element)))
        else (pure minimum)
    (pure loop_vars) ) : SailM Int )
  let minimum := minimum
  (V_set d esize (integer_subrange minimum (esize -i 1) 0))

def decode_UMINV_R_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMINV_R_P_Z__ 128 d esize g n is_unsigned)
  | 256 => (execute_UMINV_R_P_Z__ 256 d esize g n is_unsigned)
  | 512 => (execute_UMINV_R_P_Z__ 512 d esize g n is_unsigned)
  | 1024 => (execute_UMINV_R_P_Z__ 1024 d esize g n is_unsigned)
  | 2048 => (execute_UMINV_R_P_Z__ 2048 d esize g n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMINV_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let minimum : Int :=
    bif is_unsigned
    then ((2 ^i esize) -i 1)
    else ((2 ^i (esize -i 1)) -i 1)
  let minimum ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := minimum
    for e in [loop_e_lower:loop_e_upper:1]i do
      let minimum := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (asl_Int (← (Elem_read operand e esize)) is_unsigned)
            (pure (Min.min minimum element)))
        else (pure minimum)
    (pure loop_vars) ) : SailM Int )
  let minimum := minimum
  (V_set d esize (integer_subrange minimum (esize -i 1) 0))

def decode_SMINV_R_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMINV_R_P_Z__ 128 d esize g n is_unsigned)
  | 256 => (execute_SMINV_R_P_Z__ 256 d esize g n is_unsigned)
  | 512 => (execute_SMINV_R_P_Z__ 512 d esize g n is_unsigned)
  | 1024 => (execute_SMINV_R_P_Z__ 1024 d esize g n is_unsigned)
  | 2048 => (execute_SMINV_R_P_Z__ 2048 d esize g n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm1 : Int, imm2 : Int, esize ∈
  {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_INDEX_Z_II__ (VL : Nat) (d : Nat) (esize : Nat) (imm1 : Int) (imm2 : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let index := (imm1 +i (e *i imm2))
        (Elem_set result e esize (integer_subrange index (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_INDEX_Z_II__ (size : (BitVec 2)) (imm5b : (BitVec 5)) (imm5 : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let d := (BitVec.toNat Zd)
  let imm1 := (BitVec.toInt imm5)
  let imm2 := (BitVec.toInt imm5b)
  match VL with
  | 128 => (execute_INDEX_Z_II__ 128 d esize imm1 imm2)
  | 256 => (execute_INDEX_Z_II__ 256 d esize imm1 imm2)
  | 512 => (execute_INDEX_Z_II__ 512 d esize imm1 imm2)
  | 1024 => (execute_INDEX_Z_II__ 1024 d esize imm1 imm2)
  | 2048 => (execute_INDEX_Z_II__ 2048 d esize imm1 imm2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Int, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_INDEX_Z_IR__ (VL : Nat) (d : Nat) (esize : Nat) (imm : Int) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand2 ← (( do (X_read m esize) ) : SailM (BitVec esize) )
  let element2 := (BitVec.toInt operand2)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let index := (imm +i (e *i element2))
        (Elem_set result e esize (integer_subrange index (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_INDEX_Z_IR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (imm5 : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Zd)
  let imm := (BitVec.toInt imm5)
  match VL with
  | 128 => (execute_INDEX_Z_IR__ 128 d esize imm m)
  | 256 => (execute_INDEX_Z_IR__ 256 d esize imm m)
  | 512 => (execute_INDEX_Z_IR__ 512 d esize imm m)
  | 1024 => (execute_INDEX_Z_IR__ 1024 d esize imm m)
  | 2048 => (execute_INDEX_Z_IR__ 2048 d esize imm m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Int, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_INDEX_Z_RI__ (VL : Nat) (d : Nat) (esize : Nat) (imm : Int) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read n esize) ) : SailM (BitVec esize) )
  let element1 := (BitVec.toInt operand1)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let index := (element1 +i (e *i imm))
        (Elem_set result e esize (integer_subrange index (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_INDEX_Z_RI__ (size : (BitVec 2)) (imm5 : (BitVec 5)) (Rn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Zd)
  let imm := (BitVec.toInt imm5)
  match VL with
  | 128 => (execute_INDEX_Z_RI__ 128 d esize imm n)
  | 256 => (execute_INDEX_Z_RI__ 256 d esize imm n)
  | 512 => (execute_INDEX_Z_RI__ 512 d esize imm n)
  | 1024 => (execute_INDEX_Z_RI__ 1024 d esize imm n)
  | 2048 => (execute_INDEX_Z_RI__ 2048 d esize imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_INDEX_Z_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (X_read n esize) ) : SailM (BitVec esize) )
  let element1 := (BitVec.toInt operand1)
  let operand2 ← (( do (X_read m esize) ) : SailM (BitVec esize) )
  let element2 := (BitVec.toInt operand2)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let index := (element1 +i (e *i element2))
        (Elem_set result e esize (integer_subrange index (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_INDEX_Z_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (Rn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_INDEX_Z_RR__ 128 d esize m n)
  | 256 => (execute_INDEX_Z_RR__ 256 d esize m n)
  | 512 => (execute_INDEX_Z_RR__ 512 d esize m n)
  | 1024 => (execute_INDEX_Z_RR__ 1024 d esize m n)
  | 2048 => (execute_INDEX_Z_RR__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_AND_Z_ZI__ (VL : Nat) (dn : Nat) (imm : (BitVec 64)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 64)
  let operand ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand e 64) ) : SailM (BitVec 64) )
        (Elem_set result e 64 (element1 &&& imm))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_AND_Z_ZI__ (imm13 : (BitVec 13)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let (__tup_0, _) ← do
    (DecodeBitMasks (BitVec.join1 [(BitVec.access imm13 12)]) (Sail.BitVec.extractLsb imm13 5 0)
      (Sail.BitVec.extractLsb imm13 11 6) true 64)
  let imm : (BitVec 64) := __tup_0
  (pure ())
  match VL with
  | 128 => (execute_AND_Z_ZI__ 128 dn imm)
  | 256 => (execute_AND_Z_ZI__ 256 dn imm)
  | 512 => (execute_AND_Z_ZI__ 512 dn imm)
  | 1024 => (execute_AND_Z_ZI__ 1024 dn imm)
  | 2048 => (execute_AND_Z_ZI__ 2048 dn imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_EOR_Z_ZI__ (VL : Nat) (dn : Nat) (imm : (BitVec 64)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 64)
  let operand ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand e 64) ) : SailM (BitVec 64) )
        (Elem_set result e 64 (element1 ^^^ imm))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_EOR_Z_ZI__ (imm13 : (BitVec 13)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let (__tup_0, _) ← do
    (DecodeBitMasks (BitVec.join1 [(BitVec.access imm13 12)]) (Sail.BitVec.extractLsb imm13 5 0)
      (Sail.BitVec.extractLsb imm13 11 6) true 64)
  let imm : (BitVec 64) := __tup_0
  (pure ())
  match VL with
  | 128 => (execute_EOR_Z_ZI__ 128 dn imm)
  | 256 => (execute_EOR_Z_ZI__ 256 dn imm)
  | 512 => (execute_EOR_Z_ZI__ 512 dn imm)
  | 1024 => (execute_EOR_Z_ZI__ 1024 dn imm)
  | 2048 => (execute_EOR_Z_ZI__ 2048 dn imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ORR_Z_ZI__ (VL : Nat) (dn : Nat) (imm : (BitVec 64)) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 64)
  let operand ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand e 64) ) : SailM (BitVec 64) )
        (Elem_set result e 64 (element1 ||| imm))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_ORR_Z_ZI__ (imm13 : (BitVec 13)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat Zdn)
  let imm ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let (__tup_0, _) ← do
    (DecodeBitMasks (BitVec.join1 [(BitVec.access imm13 12)]) (Sail.BitVec.extractLsb imm13 5 0)
      (Sail.BitVec.extractLsb imm13 11 6) true 64)
  let imm : (BitVec 64) := __tup_0
  (pure ())
  match VL with
  | 128 => (execute_ORR_Z_ZI__ 128 dn imm)
  | 256 => (execute_ORR_Z_ZI__ 256 dn imm)
  | 512 => (execute_ORR_Z_ZI__ 512 dn imm)
  | 1024 => (execute_ORR_Z_ZI__ 1024 dn imm)
  | 2048 => (execute_ORR_Z_ZI__ 2048 dn imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, k_sub_op : Bool, 0
  ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 ∧ is_VL(VL) -/
def execute_MAD_Z_P_ZZZ__ (VL : Nat) (a : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read a VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
            let product := (element1 *i element2)
            bif sub_op
            then
              (do
                (Elem_set result e esize (BitVec.subInt (← (Elem_read operand3 e esize)) product)))
            else
              (do
                (Elem_set result e esize (BitVec.addInt (← (Elem_read operand3 e esize)) product))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_MAD_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Za : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let a := (BitVec.toNat Za)
  let sub_op : Bool := false
  match VL with
  | 128 => (execute_MAD_Z_P_ZZZ__ 128 a dn esize g m sub_op)
  | 256 => (execute_MAD_Z_P_ZZZ__ 256 a dn esize g m sub_op)
  | 512 => (execute_MAD_Z_P_ZZZ__ 512 a dn esize g m sub_op)
  | 1024 => (execute_MAD_Z_P_ZZZ__ 1024 a dn esize g m sub_op)
  | 2048 => (execute_MAD_Z_P_ZZZ__ 2048 a dn esize g m sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, a : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, k_sub_op : Bool, 0
  ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ 0 ≤ a ∧ a ≤ 31 ∧ is_VL(VL) -/
def execute_MSB_Z_P_ZZZ__ (VL : Nat) (a : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read a VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
            let product := (element1 *i element2)
            bif sub_op
            then
              (do
                (Elem_set result e esize (BitVec.subInt (← (Elem_read operand3 e esize)) product)))
            else
              (do
                (Elem_set result e esize (BitVec.addInt (← (Elem_read operand3 e esize)) product))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_MSB_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Za : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let a := (BitVec.toNat Za)
  let sub_op : Bool := true
  match VL with
  | 128 => (execute_MSB_Z_P_ZZZ__ 128 a dn esize g m sub_op)
  | 256 => (execute_MSB_Z_P_ZZZ__ 256 a dn esize g m sub_op)
  | 512 => (execute_MSB_Z_P_ZZZ__ 512 a dn esize g m sub_op)
  | 1024 => (execute_MSB_Z_P_ZZZ__ 1024 a dn esize g m sub_op)
  | 2048 => (execute_MSB_Z_P_ZZZ__ 2048 a dn esize g m sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_sub_op : Bool, 0
  ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_MLA_Z_P_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
            let product := (element1 *i element2)
            bif sub_op
            then
              (do
                (Elem_set result e esize (BitVec.subInt (← (Elem_read operand3 e esize)) product)))
            else
              (do
                (Elem_set result e esize (BitVec.addInt (← (Elem_read operand3 e esize)) product))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand3 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_MLA_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sub_op : Bool := false
  match VL with
  | 128 => (execute_MLA_Z_P_ZZZ__ 128 da esize g m n sub_op)
  | 256 => (execute_MLA_Z_P_ZZZ__ 256 da esize g m n sub_op)
  | 512 => (execute_MLA_Z_P_ZZZ__ 512 da esize g m n sub_op)
  | 1024 => (execute_MLA_Z_P_ZZZ__ 1024 da esize g m n sub_op)
  | 2048 => (execute_MLA_Z_P_ZZZ__ 2048 da esize g m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_sub_op : Bool, 0
  ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_MLS_Z_P_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
            let product := (element1 *i element2)
            bif sub_op
            then
              (do
                (Elem_set result e esize (BitVec.subInt (← (Elem_read operand3 e esize)) product)))
            else
              (do
                (Elem_set result e esize (BitVec.addInt (← (Elem_read operand3 e esize)) product))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand3 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_MLS_Z_P_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (op : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sub_op : Bool := true
  match VL with
  | 128 => (execute_MLS_Z_P_ZZZ__ 128 da esize g m n sub_op)
  | 256 => (execute_MLS_Z_P_ZZZ__ 256 da esize g m n sub_op)
  | 512 => (execute_MLS_Z_P_ZZZ__ 512 da esize g m n sub_op)
  | 1024 => (execute_MLS_Z_P_ZZZ__ 1024 da esize g m n sub_op)
  | 2048 => (execute_MLS_Z_P_ZZZ__ 2048 da esize g m n sub_op)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVPRFX_Z_Z__ (VL : Nat) (d : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let result ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MOVPRFX_Z_Z__ (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_MOVPRFX_Z_Z__ 128 d n)
  | 256 => (execute_MOVPRFX_Z_Z__ 256 d n)
  | 512 => (execute_MOVPRFX_Z_Z__ 512 d n)
  | 1024 => (execute_MOVPRFX_Z_Z__ 1024 d n)
  | 2048 => (execute_MOVPRFX_Z_Z__ 2048 d n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_merging : Bool, n : Nat, 0 ≤ n
  ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MOVPRFX_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (merging : Bool) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let dest ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize element))
        else
          (do
            bif merging
            then
              (do
                (Elem_set result e esize (← (Elem_read dest e esize))))
            else
              (do
                (Elem_set result e esize (Zeros (n := esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MOVPRFX_Z_P_Z__ (size : (BitVec 2)) (M : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let merging : Bool := (BEq.beq M (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_MOVPRFX_Z_P_Z__ 128 d esize g merging n)
  | 256 => (execute_MOVPRFX_Z_P_Z__ 256 d esize g merging n)
  | 512 => (execute_MOVPRFX_Z_P_Z__ 512 d esize g merging n)
  | 1024 => (execute_MOVPRFX_Z_P_Z__ 1024 d esize g merging n)
  | 2048 => (execute_MOVPRFX_Z_P_Z__ 2048 d esize g merging n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ g ∧ g ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_CNTP_R_P_P__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let sum : (BitVec 64) := (Zeros (n := 64))
  let sum ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := sum
    for e in [loop_e_lower:loop_e_upper:1]i do
      let sum := loop_vars
      loop_vars ← do
        bif (Bool.and (← (ActivePredicateElement mask e esize))
             (← (ActivePredicateElement operand e esize)))
        then (pure (BitVec.addInt sum 1))
        else (pure sum)
    (pure loop_vars) ) : SailM (BitVec 64) )
  (X_set d 64 sum)

def decode_CNTP_R_P_P__ (size : (BitVec 2)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Rd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Rd)
  match VL with
  | 128 => (execute_CNTP_R_P_P__ 128 d esize g n)
  | 256 => (execute_CNTP_R_P_P__ 256 d esize g n)
  | 512 => (execute_CNTP_R_P_P__ 512 d esize g n)
  | 1024 => (execute_CNTP_R_P_P__ 1024 d esize g n)
  | 2048 => (execute_CNTP_R_P_P__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_REV_P_P__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let result ← (( do (Reverse operand (Int.ediv esize 8)) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_REV_P_P__ (size : (BitVec 2)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Pd)
  match VL with
  | 128 => (execute_REV_P_P__ 128 d esize n)
  | 256 => (execute_REV_P_P__ 256 d esize n)
  | 512 => (execute_REV_P_P__ 512 d esize n)
  | 1024 => (execute_REV_P_P__ 1024 d esize n)
  | 2048 => (execute_REV_P_P__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_TRN1_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) (Int.ediv esize 8)
            (← (Elem_read operand1 ((2 *i p) +i part) (Int.ediv esize 8))))
        (Elem_set result ((2 *i p) +i 1) (Int.ediv esize 8)
          (← (Elem_read operand2 ((2 *i p) +i part) (Int.ediv esize 8))))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_TRN1_P_PP__ (size : (BitVec 2)) (Pm : (BitVec 4)) (H : (BitVec 1)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let part := 0
  match VL with
  | 128 => (execute_TRN1_P_PP__ 128 d esize m n part)
  | 256 => (execute_TRN1_P_PP__ 256 d esize m n part)
  | 512 => (execute_TRN1_P_PP__ 512 d esize m n part)
  | 1024 => (execute_TRN1_P_PP__ 1024 d esize m n part)
  | 2048 => (execute_TRN1_P_PP__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_TRN2_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) (Int.ediv esize 8)
            (← (Elem_read operand1 ((2 *i p) +i part) (Int.ediv esize 8))))
        (Elem_set result ((2 *i p) +i 1) (Int.ediv esize 8)
          (← (Elem_read operand2 ((2 *i p) +i part) (Int.ediv esize 8))))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_TRN2_P_PP__ (size : (BitVec 2)) (Pm : (BitVec 4)) (H : (BitVec 1)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let part := 1
  match VL with
  | 128 => (execute_TRN2_P_PP__ 128 d esize m n part)
  | 256 => (execute_TRN2_P_PP__ 256 d esize m n part)
  | 512 => (execute_TRN2_P_PP__ 512 d esize m n part)
  | 1024 => (execute_TRN2_P_PP__ 1024 d esize m n part)
  | 2048 => (execute_TRN2_P_PP__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_UZP1_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result p (Int.ediv esize 8)
          (← (Elem_read operand1 ((2 *i p) +i part) (Int.ediv esize 8))))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars_1 := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        (Elem_set result (pairs +i p) (Int.ediv esize 8)
          (← (Elem_read operand2 ((2 *i p) +i part) (Int.ediv esize 8))))
    (pure loop_vars_1) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_UZP1_P_PP__ (size : (BitVec 2)) (Pm : (BitVec 4)) (H : (BitVec 1)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let part := 0
  match VL with
  | 128 => (execute_UZP1_P_PP__ 128 d esize m n part)
  | 256 => (execute_UZP1_P_PP__ 256 d esize m n part)
  | 512 => (execute_UZP1_P_PP__ 512 d esize m n part)
  | 1024 => (execute_UZP1_P_PP__ 1024 d esize m n part)
  | 2048 => (execute_UZP1_P_PP__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_UZP2_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result p (Int.ediv esize 8)
          (← (Elem_read operand1 ((2 *i p) +i part) (Int.ediv esize 8))))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars_1 := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        (Elem_set result (pairs +i p) (Int.ediv esize 8)
          (← (Elem_read operand2 ((2 *i p) +i part) (Int.ediv esize 8))))
    (pure loop_vars_1) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_UZP2_P_PP__ (size : (BitVec 2)) (Pm : (BitVec 4)) (H : (BitVec 1)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let part := 1
  match VL with
  | 128 => (execute_UZP2_P_PP__ 128 d esize m n part)
  | 256 => (execute_UZP2_P_PP__ 256 d esize m n part)
  | 512 => (execute_UZP2_P_PP__ 512 d esize m n part)
  | 1024 => (execute_UZP2_P_PP__ 1024 d esize m n part)
  | 2048 => (execute_UZP2_P_PP__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_ZIP1_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let base := (part *i pairs)
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) (Int.ediv esize 8)
            (← (Elem_read operand1 (base +i p) (Int.ediv esize 8))))
        (Elem_set result ((2 *i p) +i 1) (Int.ediv esize 8)
          (← (Elem_read operand2 (base +i p) (Int.ediv esize 8))))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_ZIP1_P_PP__ (size : (BitVec 2)) (Pm : (BitVec 4)) (H : (BitVec 1)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let part := 0
  match VL with
  | 128 => (execute_ZIP1_P_PP__ 128 d esize m n part)
  | 256 => (execute_ZIP1_P_PP__ 256 d esize m n part)
  | 512 => (execute_ZIP1_P_PP__ 512 d esize m n part)
  | 1024 => (execute_ZIP1_P_PP__ 1024 d esize m n part)
  | 2048 => (execute_ZIP1_P_PP__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_ZIP2_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let base := (part *i pairs)
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) (Int.ediv esize 8)
            (← (Elem_read operand1 (base +i p) (Int.ediv esize 8))))
        (Elem_set result ((2 *i p) +i 1) (Int.ediv esize 8)
          (← (Elem_read operand2 (base +i p) (Int.ediv esize 8))))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_ZIP2_P_PP__ (size : (BitVec 2)) (Pm : (BitVec 4)) (H : (BitVec 1)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let part := 1
  match VL with
  | 128 => (execute_ZIP2_P_PP__ 128 d esize m n part)
  | 256 => (execute_ZIP2_P_PP__ 256 d esize m n part)
  | 512 => (execute_ZIP2_P_PP__ 512 d esize m n part)
  | 1024 => (execute_ZIP2_P_PP__ 1024 d esize m n part)
  | 2048 => (execute_ZIP2_P_PP__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_REV_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Reverse operand esize) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_REV_Z_Z__ (size : (BitVec 2)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_REV_Z_Z__ 128 d esize n)
  | 256 => (execute_REV_Z_Z__ 256 d esize n)
  | 512 => (execute_REV_Z_Z__ 512 d esize n)
  | 1024 => (execute_REV_Z_Z__ 1024 d esize n)
  | 2048 => (execute_REV_Z_Z__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_double_table : Bool, esize : Nat, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_TBL_Z_ZZ_1 (VL : Nat) (d : Nat) (double_table : Bool) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let indexes ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let table_size :=
    bif double_table
    then (VL *i 2)
    else VL
  let table_elems := (Int.ediv table_size esize)
  let table ← (( do (undefined_bitvector table_size) ) : SailM (BitVec table_size) )
  let table ← (( do
    bif double_table
    then
      (do
        let top ← (( do (Z_read (Nat.div (n +i 1) 32) VL) ) : SailM (BitVec VL) )
        let bottom ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        (pure (Sail.BitVec.extractLsb (top ++ bottom) (table_size -i 1) 0)))
    else
      (do
        (Z_read n table_size)) ) : SailM (BitVec table_size) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let idx ← do (pure (BitVec.toNat (← (Elem_read indexes e esize))))
        (Elem_set result e esize
          (← do
            bif (idx <b table_elems)
            then (Elem_read table idx esize)
            else (pure (Zeros (n := esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_TBL_Z_ZZ_1 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let double_table : Bool := false
  match VL with
  | 128 => (execute_TBL_Z_ZZ_1 128 d double_table esize m n)
  | 256 => (execute_TBL_Z_ZZ_1 256 d double_table esize m n)
  | 512 => (execute_TBL_Z_ZZ_1 512 d double_table esize m n)
  | 1024 => (execute_TBL_Z_ZZ_1 1024 d double_table esize m n)
  | 2048 => (execute_TBL_Z_ZZ_1 2048 d double_table esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, k_double_table : Bool, esize : Nat, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_TBL_Z_ZZ_2 (VL : Nat) (d : Nat) (double_table : Bool) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let indexes ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let table_size :=
    bif double_table
    then (VL *i 2)
    else VL
  let table_elems := (Int.ediv table_size esize)
  let table ← (( do (undefined_bitvector table_size) ) : SailM (BitVec table_size) )
  let table ← (( do
    bif double_table
    then
      (do
        let top ← (( do (Z_read (Nat.div (n +i 1) 32) VL) ) : SailM (BitVec VL) )
        let bottom ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
        (pure (Sail.BitVec.extractLsb (top ++ bottom) (table_size -i 1) 0)))
    else
      (do
        (Z_read n table_size)) ) : SailM (BitVec table_size) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let idx ← do (pure (BitVec.toNat (← (Elem_read indexes e esize))))
        (Elem_set result e esize
          (← do
            bif (idx <b table_elems)
            then (Elem_read table idx esize)
            else (pure (Zeros (n := esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_TBL_Z_ZZ_2 (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let double_table : Bool := true
  match VL with
  | 128 => (execute_TBL_Z_ZZ_2 128 d double_table esize m n)
  | 256 => (execute_TBL_Z_ZZ_2 256 d double_table esize m n)
  | 512 => (execute_TBL_Z_ZZ_2 512 d double_table esize m n)
  | 1024 => (execute_TBL_Z_ZZ_2 1024 d double_table esize m n)
  | 2048 => (execute_TBL_Z_ZZ_2 2048 d double_table esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_TRN1_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand1 ((2 *i p) +i part) esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand2 ((2 *i p) +i part) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_TRN1_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 0
  match VL with
  | 128 => (execute_TRN1_Z_ZZ__ 128 d esize m n part)
  | 256 => (execute_TRN1_Z_ZZ__ 256 d esize m n part)
  | 512 => (execute_TRN1_Z_ZZ__ 512 d esize m n part)
  | 1024 => (execute_TRN1_Z_ZZ__ 1024 d esize m n part)
  | 2048 => (execute_TRN1_Z_ZZ__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_TRN2_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand1 ((2 *i p) +i part) esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand2 ((2 *i p) +i part) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_TRN2_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 1
  match VL with
  | 128 => (execute_TRN2_Z_ZZ__ 128 d esize m n part)
  | 256 => (execute_TRN2_Z_ZZ__ 256 d esize m n part)
  | 512 => (execute_TRN2_Z_ZZ__ 512 d esize m n part)
  | 1024 => (execute_TRN2_Z_ZZ__ 1024 d esize m n part)
  | 2048 => (execute_TRN2_Z_ZZ__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UZP1_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do (Elem_set result p esize (← (Elem_read operand1 ((2 *i p) +i part) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars_1 := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        (Elem_set result (pairs +i p) esize (← (Elem_read operand2 ((2 *i p) +i part) esize)))
    (pure loop_vars_1) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UZP1_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 0
  match VL with
  | 128 => (execute_UZP1_Z_ZZ__ 128 d esize m n part)
  | 256 => (execute_UZP1_Z_ZZ__ 256 d esize m n part)
  | 512 => (execute_UZP1_Z_ZZ__ 512 d esize m n part)
  | 1024 => (execute_UZP1_Z_ZZ__ 1024 d esize m n part)
  | 2048 => (execute_UZP1_Z_ZZ__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UZP2_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do (Elem_set result p esize (← (Elem_read operand1 ((2 *i p) +i part) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars_1 := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        (Elem_set result (pairs +i p) esize (← (Elem_read operand2 ((2 *i p) +i part) esize)))
    (pure loop_vars_1) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UZP2_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 1
  match VL with
  | 128 => (execute_UZP2_Z_ZZ__ 128 d esize m n part)
  | 256 => (execute_UZP2_Z_ZZ__ 256 d esize m n part)
  | 512 => (execute_UZP2_Z_ZZ__ 512 d esize m n part)
  | 1024 => (execute_UZP2_Z_ZZ__ 1024 d esize m n part)
  | 2048 => (execute_UZP2_Z_ZZ__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ZIP1_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let base := (part *i pairs)
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand1 (base +i p) esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand2 (base +i p) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ZIP1_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 0
  match VL with
  | 128 => (execute_ZIP1_Z_ZZ__ 128 d esize m n part)
  | 256 => (execute_ZIP1_Z_ZZ__ 256 d esize m n part)
  | 512 => (execute_ZIP1_Z_ZZ__ 512 d esize m n part)
  | 1024 => (execute_ZIP1_Z_ZZ__ 1024 d esize m n part)
  | 2048 => (execute_ZIP1_Z_ZZ__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ZIP2_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let base := (part *i pairs)
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand1 (base +i p) esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand2 (base +i p) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ZIP2_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 1
  match VL with
  | 128 => (execute_ZIP2_Z_ZZ__ 128 d esize m n part)
  | 256 => (execute_ZIP2_Z_ZZ__ 256 d esize m n part)
  | 512 => (execute_ZIP2_Z_ZZ__ 512 d esize m n part)
  | 1024 => (execute_ZIP2_Z_ZZ__ 1024 d esize m n part)
  | 2048 => (execute_ZIP2_Z_ZZ__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_TRN1_Z_ZZ_Q (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 2))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand1 ((2 *i p) +i part) esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand2 ((2 *i p) +i part) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_TRN1_Z_ZZ_Q (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 0
  match VL with
  | 128 => (execute_TRN1_Z_ZZ_Q 128 d esize m n part)
  | 256 => (execute_TRN1_Z_ZZ_Q 256 d esize m n part)
  | 512 => (execute_TRN1_Z_ZZ_Q 512 d esize m n part)
  | 1024 => (execute_TRN1_Z_ZZ_Q 1024 d esize m n part)
  | 2048 => (execute_TRN1_Z_ZZ_Q 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_TRN2_Z_ZZ_Q (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 2))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand1 ((2 *i p) +i part) esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand2 ((2 *i p) +i part) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_TRN2_Z_ZZ_Q (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 1
  match VL with
  | 128 => (execute_TRN2_Z_ZZ_Q 128 d esize m n part)
  | 256 => (execute_TRN2_Z_ZZ_Q 256 d esize m n part)
  | 512 => (execute_TRN2_Z_ZZ_Q 512 d esize m n part)
  | 1024 => (execute_TRN2_Z_ZZ_Q 1024 d esize m n part)
  | 2048 => (execute_TRN2_Z_ZZ_Q 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ZIP1_Z_ZZ_Q (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 2))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let base := (part *i pairs)
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand1 (base +i p) esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand2 (base +i p) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ZIP1_Z_ZZ_Q (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 0
  match VL with
  | 128 => (execute_ZIP1_Z_ZZ_Q 128 d esize m n part)
  | 256 => (execute_ZIP1_Z_ZZ_Q 256 d esize m n part)
  | 512 => (execute_ZIP1_Z_ZZ_Q 512 d esize m n part)
  | 1024 => (execute_ZIP1_Z_ZZ_Q 1024 d esize m n part)
  | 2048 => (execute_ZIP1_Z_ZZ_Q 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ZIP2_Z_ZZ_Q (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 2))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let base := (part *i pairs)
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (← (Elem_read operand1 (base +i p) esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (Elem_read operand2 (base +i p) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ZIP2_Z_ZZ_Q (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 1
  match VL with
  | 128 => (execute_ZIP2_Z_ZZ_Q 128 d esize m n part)
  | 256 => (execute_ZIP2_Z_ZZ_Q 256 d esize m n part)
  | 512 => (execute_ZIP2_Z_ZZ_Q 512 d esize m n part)
  | 1024 => (execute_ZIP2_Z_ZZ_Q 1024 d esize m n part)
  | 2048 => (execute_ZIP2_Z_ZZ_Q 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UZP1_Z_ZZ_Q (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 2))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do (Elem_set result p esize (← (Elem_read operand1 ((2 *i p) +i part) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars_1 := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        (Elem_set result (pairs +i p) esize (← (Elem_read operand2 ((2 *i p) +i part) esize)))
    (pure loop_vars_1) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UZP1_Z_ZZ_Q (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 0
  match VL with
  | 128 => (execute_UZP1_Z_ZZ_Q 128 d esize m n part)
  | 256 => (execute_UZP1_Z_ZZ_Q 256 d esize m n part)
  | 512 => (execute_UZP1_Z_ZZ_Q 512 d esize m n part)
  | 1024 => (execute_UZP1_Z_ZZ_Q 1024 d esize m n part)
  | 2048 => (execute_UZP1_Z_ZZ_Q 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UZP2_Z_ZZ_Q (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  bif (VL <b (esize *i 2))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let pairs := (Int.ediv VL (esize *i 2))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do (Elem_set result p esize (← (Elem_read operand1 ((2 *i p) +i part) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars_1 := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars_1
      loop_vars_1 ← do
        (Elem_set result (pairs +i p) esize (← (Elem_read operand2 ((2 *i p) +i part) esize)))
    (pure loop_vars_1) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UZP2_Z_ZZ_Q (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 1
  match VL with
  | 128 => (execute_UZP2_Z_ZZ_Q 128 d esize m n part)
  | 256 => (execute_UZP2_Z_ZZ_Q 256 d esize m n part)
  | 512 => (execute_UZP2_Z_ZZ_Q 512 d esize m n part)
  | 1024 => (execute_UZP2_Z_ZZ_Q 1024 d esize m n part)
  | 2048 => (execute_UZP2_Z_ZZ_Q 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, csize : Nat, dn : Nat, esize : Nat, g : Nat, k_isBefore : Bool, m :
  Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ csize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_CLASTA_R_P_Z__ (VL : Nat) (csize : Nat) (dn : Nat) (esize : Nat) (g : Nat) (isBefore : Bool) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (X_read dn esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector csize) ) : SailM (BitVec csize) )
  let last ← (( do (LastActiveElement mask esize) ) : SailM Int )
  let result ← (( do
    bif (last <b 0)
    then
      (do
        assert (Bool.and (esize ≥b 0) (csize ≥b esize)) "src/instrs64_sve.sail:27154.59-27154.60"
        (pure (Sail.BitVec.zeroExtend operand1 csize)))
    else
      (do
        let last : Int :=
          bif (Bool.not isBefore)
          then
            (let last : Int := (last +i 1)
            bif (last ≥b elements)
            then 0
            else last)
          else last
        let last := last
        assert (Bool.and (esize ≥b 0) (csize ≥b esize)) "src/instrs64_sve.sail:27165.59-27165.60"
        (pure (Sail.BitVec.zeroExtend (← (Elem_read operand2 last esize)) csize))) ) : SailM
    (BitVec csize) )
  (X_set dn csize result)

def decode_CLASTA_R_P_Z__ (size : (BitVec 2)) (B : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Rdn)
  let m := (BitVec.toNat Zm)
  let csize :=
    bif (esize <b 64)
    then 32
    else 64
  let isBefore : Bool := false
  match VL with
  | 128 => (execute_CLASTA_R_P_Z__ 128 csize dn esize g isBefore m)
  | 256 => (execute_CLASTA_R_P_Z__ 256 csize dn esize g isBefore m)
  | 512 => (execute_CLASTA_R_P_Z__ 512 csize dn esize g isBefore m)
  | 1024 => (execute_CLASTA_R_P_Z__ 1024 csize dn esize g isBefore m)
  | 2048 => (execute_CLASTA_R_P_Z__ 2048 csize dn esize g isBefore m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, csize : Nat, dn : Nat, esize : Nat, g : Nat, k_isBefore : Bool, m :
  Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ csize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_CLASTB_R_P_Z__ (VL : Nat) (csize : Nat) (dn : Nat) (esize : Nat) (g : Nat) (isBefore : Bool) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (X_read dn esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector csize) ) : SailM (BitVec csize) )
  let last ← (( do (LastActiveElement mask esize) ) : SailM Int )
  let result ← (( do
    bif (last <b 0)
    then
      (do
        assert (Bool.and (esize ≥b 0) (csize ≥b esize)) "src/instrs64_sve.sail:27229.59-27229.60"
        (pure (Sail.BitVec.zeroExtend operand1 csize)))
    else
      (do
        let last : Int :=
          bif (Bool.not isBefore)
          then
            (let last : Int := (last +i 1)
            bif (last ≥b elements)
            then 0
            else last)
          else last
        let last := last
        assert (Bool.and (esize ≥b 0) (csize ≥b esize)) "src/instrs64_sve.sail:27240.59-27240.60"
        (pure (Sail.BitVec.zeroExtend (← (Elem_read operand2 last esize)) csize))) ) : SailM
    (BitVec csize) )
  (X_set dn csize result)

def decode_CLASTB_R_P_Z__ (size : (BitVec 2)) (B : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Rdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Rdn)
  let m := (BitVec.toNat Zm)
  let csize :=
    bif (esize <b 64)
    then 32
    else 64
  let isBefore : Bool := true
  match VL with
  | 128 => (execute_CLASTB_R_P_Z__ 128 csize dn esize g isBefore m)
  | 256 => (execute_CLASTB_R_P_Z__ 256 csize dn esize g isBefore m)
  | 512 => (execute_CLASTB_R_P_Z__ 512 csize dn esize g isBefore m)
  | 1024 => (execute_CLASTB_R_P_Z__ 1024 csize dn esize g isBefore m)
  | 2048 => (execute_CLASTB_R_P_Z__ 2048 csize dn esize g isBefore m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_isBefore : Bool, m : Nat, 0 ≤ m
  ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_CLASTA_V_P_Z__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (isBefore : Bool) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (V_read dn esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let last ← (( do (LastActiveElement mask esize) ) : SailM Int )
  let result ← (( do
    bif (last <b 0)
    then (pure (Sail.BitVec.zeroExtend operand1 esize))
    else
      (do
        let last : Int :=
          bif (Bool.not isBefore)
          then
            (let last : Int := (last +i 1)
            bif (last ≥b elements)
            then 0
            else last)
          else last
        let last := last
        (Elem_read operand2 last esize)) ) : SailM (BitVec esize) )
  (V_set dn esize result)

def decode_CLASTA_V_P_Z__ (size : (BitVec 2)) (B : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Vdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Vdn)
  let m := (BitVec.toNat Zm)
  let isBefore : Bool := false
  match VL with
  | 128 => (execute_CLASTA_V_P_Z__ 128 dn esize g isBefore m)
  | 256 => (execute_CLASTA_V_P_Z__ 256 dn esize g isBefore m)
  | 512 => (execute_CLASTA_V_P_Z__ 512 dn esize g isBefore m)
  | 1024 => (execute_CLASTA_V_P_Z__ 1024 dn esize g isBefore m)
  | 2048 => (execute_CLASTA_V_P_Z__ 2048 dn esize g isBefore m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_isBefore : Bool, m : Nat, 0 ≤ m
  ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_CLASTB_V_P_Z__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (isBefore : Bool) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (V_read dn esize) ) : SailM (BitVec esize) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let last ← (( do (LastActiveElement mask esize) ) : SailM Int )
  let result ← (( do
    bif (last <b 0)
    then (pure (Sail.BitVec.zeroExtend operand1 esize))
    else
      (do
        let last : Int :=
          bif (Bool.not isBefore)
          then
            (let last : Int := (last +i 1)
            bif (last ≥b elements)
            then 0
            else last)
          else last
        let last := last
        (Elem_read operand2 last esize)) ) : SailM (BitVec esize) )
  (V_set dn esize result)

def decode_CLASTB_V_P_Z__ (size : (BitVec 2)) (B : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Vdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Vdn)
  let m := (BitVec.toNat Zm)
  let isBefore : Bool := true
  match VL with
  | 128 => (execute_CLASTB_V_P_Z__ 128 dn esize g isBefore m)
  | 256 => (execute_CLASTB_V_P_Z__ 256 dn esize g isBefore m)
  | 512 => (execute_CLASTB_V_P_Z__ 512 dn esize g isBefore m)
  | 1024 => (execute_CLASTB_V_P_Z__ 1024 dn esize g isBefore m)
  | 2048 => (execute_CLASTB_V_P_Z__ 2048 dn esize g isBefore m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_isBefore : Bool, m : Nat, 0 ≤ m
  ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_CLASTA_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (isBefore : Bool) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let last ← (( do (LastActiveElement mask esize) ) : SailM Int )
  let result ← (( do
    bif (last <b 0)
    then (pure operand1)
    else
      (do
        let last : Int :=
          bif (Bool.not isBefore)
          then
            (let last : Int := (last +i 1)
            bif (last ≥b elements)
            then 0
            else last)
          else last
        let last := last
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars
          loop_vars ← do (Elem_set result e esize (← (Elem_read operand2 last esize)))
        (pure loop_vars)) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_CLASTA_Z_P_ZZ__ (size : (BitVec 2)) (B : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let isBefore : Bool := false
  match VL with
  | 128 => (execute_CLASTA_Z_P_ZZ__ 128 dn esize g isBefore m)
  | 256 => (execute_CLASTA_Z_P_ZZ__ 256 dn esize g isBefore m)
  | 512 => (execute_CLASTA_Z_P_ZZ__ 512 dn esize g isBefore m)
  | 1024 => (execute_CLASTA_Z_P_ZZ__ 1024 dn esize g isBefore m)
  | 2048 => (execute_CLASTA_Z_P_ZZ__ 2048 dn esize g isBefore m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_isBefore : Bool, m : Nat, 0 ≤ m
  ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_CLASTB_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (isBefore : Bool) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let last ← (( do (LastActiveElement mask esize) ) : SailM Int )
  let result ← (( do
    bif (last <b 0)
    then (pure operand1)
    else
      (do
        let last : Int :=
          bif (Bool.not isBefore)
          then
            (let last : Int := (last +i 1)
            bif (last ≥b elements)
            then 0
            else last)
          else last
        let last := last
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars
          loop_vars ← do (Elem_set result e esize (← (Elem_read operand2 last esize)))
        (pure loop_vars)) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_CLASTB_Z_P_ZZ__ (size : (BitVec 2)) (B : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let isBefore : Bool := true
  match VL with
  | 128 => (execute_CLASTB_Z_P_ZZ__ 128 dn esize g isBefore m)
  | 256 => (execute_CLASTB_Z_P_ZZ__ 256 dn esize g isBefore m)
  | 512 => (execute_CLASTB_Z_P_ZZ__ 512 dn esize g isBefore m)
  | 1024 => (execute_CLASTB_Z_P_ZZ__ 1024 dn esize g isBefore m)
  | 2048 => (execute_CLASTB_Z_P_ZZ__ 2048 dn esize g isBefore m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_COMPACT_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let x : Int := 0
  let (result, x) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (result, x)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (result, x) := loop_vars
      loop_vars ← do
        let (result, x) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let element ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let x := x
              let result ← (Elem_set result x esize element)
              (pure ())
              let x : Int := (x +i 1)
              (pure (result, x)))
          else (pure (result, x)) ) : SailM ((BitVec VL) × Int) )
        (pure (result, x))
    (pure loop_vars) ) : SailM ((BitVec VL) × Int) )
  (Z_set d VL result)

def decode_COMPACT_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_COMPACT_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_COMPACT_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_COMPACT_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_COMPACT_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_COMPACT_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dst : Nat, esize : Nat, s1 : Nat, s2 : Nat, v : Nat, v ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ s2 ∧
  s2 ≤ 31 ∧
  0 ≤ s1 ∧ s1 ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dst ∧ dst ≤ 31 ∧ is_VL(VL) -/
def execute_SPLICE_Z_P_ZZ_Des (VL : Nat) (dst : Nat) (esize : Nat) (s1 : Nat) (s2 : Nat) (v : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read v PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read s1 VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read s2 VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let x : Int := 0
  let active : Bool := false
  let lastnum ← do (LastActiveElement mask esize)
  let (result, x) ← (( do
    bif (lastnum ≥b 0)
    then
      (do
        let (active, result, x) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := lastnum
          let mut loop_vars := (active, result, x)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (active, result, x) := loop_vars
            loop_vars ← do
              let active ← (pure (Bool.or active (← (ActivePredicateElement mask e esize))))
              let (result, x) ← (( do
                bif active
                then
                  (do
                    let x := x
                    let result ← (Elem_set result x esize (← (Elem_read operand1 e esize)))
                    (pure ())
                    let x : Int := (x +i 1)
                    (pure (result, x)))
                else (pure (result, x)) ) : SailM ((BitVec VL) × Int) )
              (pure (active, result, x))
          (pure loop_vars) ) : SailM (Bool × (BitVec VL) × Int) )
        (pure (result, x)))
    else (pure (result, x)) ) : SailM ((BitVec VL) × Int) )
  let nelements := ((elements -i x) -i 1)
  let (result, x) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := nelements
    let mut loop_vars_1 := (result, x)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (result, x) := loop_vars_1
      loop_vars_1 ← do
        let x := x
        let result ← (Elem_set result x esize (← (Elem_read operand2 e esize)))
        (pure ())
        let x : Int := (x +i 1)
        (pure (result, x))
    (pure loop_vars_1) ) : SailM ((BitVec VL) × Int) )
  (Z_set dst VL result)

def decode_SPLICE_Z_P_ZZ_Des (size : (BitVec 2)) (Pv : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let v := (BitVec.toNat Pv)
  let dst := (BitVec.toNat Zdn)
  let s1 := dst
  let s2 := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_SPLICE_Z_P_ZZ_Des 128 dst esize s1 s2 v)
  | 256 => (execute_SPLICE_Z_P_ZZ_Des 256 dst esize s1 s2 v)
  | 512 => (execute_SPLICE_Z_P_ZZ_Des 512 dst esize s1 s2 v)
  | 1024 => (execute_SPLICE_Z_P_ZZ_Des 1024 dst esize s1 s2 v)
  | 2048 => (execute_SPLICE_Z_P_ZZ_Des 2048 dst esize s1 s2 v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dst : Nat, esize : Nat, s1 : Nat, s2 : Int, v : Nat, v ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧
  0 ≤ s1 ∧ s1 ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dst ∧ dst ≤ 31 ∧ is_VL(VL) -/
def execute_SPLICE_Z_P_ZZ_Con (VL : Nat) (dst : Nat) (esize : Nat) (s1 : Nat) (s2 : Int) (v : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read v PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read s1 VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read s2 VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let x : Int := 0
  let active : Bool := false
  let lastnum ← do (LastActiveElement mask esize)
  let (result, x) ← (( do
    bif (lastnum ≥b 0)
    then
      (do
        let (active, result, x) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := lastnum
          let mut loop_vars := (active, result, x)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (active, result, x) := loop_vars
            loop_vars ← do
              let active ← (pure (Bool.or active (← (ActivePredicateElement mask e esize))))
              let (result, x) ← (( do
                bif active
                then
                  (do
                    let x := x
                    let result ← (Elem_set result x esize (← (Elem_read operand1 e esize)))
                    (pure ())
                    let x : Int := (x +i 1)
                    (pure (result, x)))
                else (pure (result, x)) ) : SailM ((BitVec VL) × Int) )
              (pure (active, result, x))
          (pure loop_vars) ) : SailM (Bool × (BitVec VL) × Int) )
        (pure (result, x)))
    else (pure (result, x)) ) : SailM ((BitVec VL) × Int) )
  let nelements := ((elements -i x) -i 1)
  let (result, x) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := nelements
    let mut loop_vars_1 := (result, x)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (result, x) := loop_vars_1
      loop_vars_1 ← do
        let x := x
        let result ← (Elem_set result x esize (← (Elem_read operand2 e esize)))
        (pure ())
        let x : Int := (x +i 1)
        (pure (result, x))
    (pure loop_vars_1) ) : SailM ((BitVec VL) × Int) )
  (Z_set dst VL result)

def decode_SPLICE_Z_P_ZZ_Con (size : (BitVec 2)) (Pv : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let v := (BitVec.toNat Pv)
  let dst := (BitVec.toNat Zd)
  let s1 := (BitVec.toNat Zn)
  let s2 := (Nat.div (s1 +i 1) 32)
  match VL with
  | 128 => (execute_SPLICE_Z_P_ZZ_Con 128 dst esize s1 s2 v)
  | 256 => (execute_SPLICE_Z_P_ZZ_Con 256 dst esize s1 s2 v)
  | 512 => (execute_SPLICE_Z_P_ZZ_Con 512 dst esize s1 s2 v)
  | 1024 => (execute_SPLICE_Z_P_ZZ_Con 1024 dst esize s1 s2 v)
  | 2048 => (execute_SPLICE_Z_P_ZZ_Con 2048 dst esize s1 s2 v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dst : Nat, esize : Nat, position__arg : Nat, s1 : Nat, s2 : Nat, 0
  ≤ s2 ∧
  s2 ≤ 31 ∧
  0 ≤ s1 ∧
  s1 ≤ 31 ∧
  0 ≤ position__arg ∧
  position__arg ≤ 255 ∧ esize = 8 ∧ 0 ≤ dst ∧ dst ≤ 31 ∧ is_VL(VL) -/
def execute_EXT_Z_ZI_Des (VL : Nat) (dst : Nat) (esize : Nat) (position__arg : Nat) (s1 : Nat) (s2 : Nat) : SailM Unit := do
  let position : Int := position__arg
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read s1 VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read s2 VL) ) : SailM (BitVec VL) )
  let position : Int :=
    bif (position ≥b elements)
    then 0
    else position
  let position := (Int.shiftl position 3)
  let concat : (BitVec (VL * 2)) := (operand2 ++ operand1)
  assert (Bool.and (0 ≤b position) (((position +i VL) -i 1) <b (VL *i 2))) "src/instrs64_sve.sail:27842.71-27842.72"
  let result : (BitVec VL) := (Sail.BitVec.extractLsb concat ((position +i VL) -i 1) position)
  (Z_set dst VL result)

def decode_EXT_Z_ZI_Des (imm8h : (BitVec 5)) (imm8l : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dst := (BitVec.toNat Zdn)
  let s1 := dst
  let s2 := (BitVec.toNat Zm)
  let position := (BitVec.toNat (imm8h ++ imm8l))
  match VL with
  | 128 => (execute_EXT_Z_ZI_Des 128 dst esize position s1 s2)
  | 256 => (execute_EXT_Z_ZI_Des 256 dst esize position s1 s2)
  | 512 => (execute_EXT_Z_ZI_Des 512 dst esize position s1 s2)
  | 1024 => (execute_EXT_Z_ZI_Des 1024 dst esize position s1 s2)
  | 2048 => (execute_EXT_Z_ZI_Des 2048 dst esize position s1 s2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dst : Nat, esize : Nat, position__arg : Nat, s1 : Nat, s2 : Int, 0
  ≤ s1 ∧
  s1 ≤ 31 ∧
  0 ≤ position__arg ∧
  position__arg ≤ 255 ∧ esize = 8 ∧ 0 ≤ dst ∧ dst ≤ 31 ∧ is_VL(VL) -/
def execute_EXT_Z_ZI_Con (VL : Nat) (dst : Nat) (esize : Nat) (position__arg : Nat) (s1 : Nat) (s2 : Int) : SailM Unit := do
  let position : Int := position__arg
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read s1 VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read s2 VL) ) : SailM (BitVec VL) )
  let position : Int :=
    bif (position ≥b elements)
    then 0
    else position
  let position := (Int.shiftl position 3)
  let concat : (BitVec (VL * 2)) := (operand2 ++ operand1)
  assert (Bool.and (0 ≤b position) (((position +i VL) -i 1) <b (VL *i 2))) "src/instrs64_sve.sail:27905.71-27905.72"
  let result : (BitVec VL) := (Sail.BitVec.extractLsb concat ((position +i VL) -i 1) position)
  (Z_set dst VL result)

def decode_EXT_Z_ZI_Con (imm8h : (BitVec 5)) (imm8l : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let dst := (BitVec.toNat Zd)
  let s1 := (BitVec.toNat Zn)
  let s2 := (Nat.div (s1 +i 1) 32)
  let position := (BitVec.toNat (imm8h ++ imm8l))
  match VL with
  | 128 => (execute_EXT_Z_ZI_Con 128 dst esize position s1 s2)
  | 256 => (execute_EXT_Z_ZI_Con 256 dst esize position s1 s2)
  | 512 => (execute_EXT_Z_ZI_Con 512 dst esize position s1 s2)
  | 1024 => (execute_EXT_Z_ZI_Con 1024 dst esize position s1 s2)
  | 2048 => (execute_EXT_Z_ZI_Con 2048 dst esize position s1 s2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_CPY_Z_P_R__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let operand1 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
        let operand1 ← (( do
          bif (BEq.beq n 31)
          then
            (do
              (SP_read ()))
          else
            (do
              (X_read n 64)) ) : SailM (BitVec 64) )
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars
          loop_vars ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                (Elem_set result e esize (Sail.BitVec.extractLsb operand1 (esize -i 1) 0)))
            else (pure result)
        (pure loop_vars))
    else (pure result) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_CPY_Z_P_R__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_CPY_Z_P_R__ 128 d esize g n)
  | 256 => (execute_CPY_Z_P_R__ 256 d esize g n)
  | 512 => (execute_CPY_Z_P_R__ 512 d esize g n)
  | 1024 => (execute_CPY_Z_P_R__ 1024 d esize g n)
  | 2048 => (execute_CPY_Z_P_R__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_CPY_Z_P_V__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (V_read n esize)
    else (pure (Zeros (n := esize))) ) : SailM (BitVec esize) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize operand1))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_CPY_Z_P_V__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Vn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Vn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_CPY_Z_P_V__ 128 d esize g n)
  | 256 => (execute_CPY_Z_P_V__ 256 d esize g n)
  | 512 => (execute_CPY_Z_P_V__ 512 d esize g n)
  | 1024 => (execute_CPY_Z_P_V__ 1024 d esize g n)
  | 2048 => (execute_CPY_Z_P_V__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ index ∧
  index ≤ 63 ∧ esize ∈ {8, 16, 32, 64, 128} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_DUP_Z_Zi__ (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let element ← (( do
    bif (index ≥b elements)
    then (pure (Zeros (n := esize)))
    else
      (do
        (Elem_read operand1 index esize)) ) : SailM (BitVec esize) )
  let result : (BitVec VL) := (BitVec.replicateBits element (Int.ediv VL esize))
  (Z_set d VL result)

def decode_DUP_Z_Zi__ (imm2 : (BitVec 2)) (tsz : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let imm : (BitVec 7) := (imm2 ++ tsz)
  let esize : Int := 8
  let index ← (( do (undefined_range 0 63) ) : SailM Nat )
  let b__0 := tsz
  bif (BEq.beq b__0 (0b00000 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b10000 : (BitVec 5)))
    then
      (let esize : Int := 128
      let index : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm 6 5))
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 0) (0x8 : (BitVec 4)))
      then
        (let esize : Int := 64
        let index : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm 6 4))
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 0) (0b100 : (BitVec 3)))
        then
          (let esize : Int := 32
          let index : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm 6 3))
          (pure ()))
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 0) (0b10 : (BitVec 2)))
          then
            (let esize : Int := 16
            let index : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm 6 2))
            (pure ()))
          else
            (let esize : Int := 8
            let index : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm 6 1))
            (pure ()))))))
  let index := index
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_DUP_Z_Zi__ 128 d esize index n)
  | 256 => (execute_DUP_Z_Zi__ 256 d esize index n)
  | 512 => (execute_DUP_Z_Zi__ 512 d esize index n)
  | 1024 => (execute_DUP_Z_Zi__ 1024 d esize index n)
  | 2048 => (execute_DUP_Z_Zi__ 2048 d esize index n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_DUP_Z_R__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let PL := (Int.ediv VL 8)
  let operand ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand ← (( do
    bif (BEq.beq n 31)
    then
      (do
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do (Elem_set result e esize (Sail.BitVec.extractLsb operand (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_DUP_Z_R__ (size : (BitVec 2)) (Rn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Rn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_DUP_Z_R__ 128 d esize n)
  | 256 => (execute_DUP_Z_R__ 256 d esize n)
  | 512 => (execute_DUP_Z_R__ 512 d esize n)
  | 1024 => (execute_DUP_Z_R__ 1024 d esize n)
  | 2048 => (execute_DUP_Z_R__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_isBefore : Bool, n : Nat, rsize :
  Nat, rsize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_LASTA_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (isBefore : Bool) (n : Nat) (rsize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let last ← (( do (LastActiveElement mask esize) ) : SailM Int )
  let last : Int :=
    bif isBefore
    then
      (bif (last <b 0)
      then (elements -i 1)
      else last)
    else
      (let last : Int := (last +i 1)
      bif (last ≥b elements)
      then 0
      else last)
  let last := last
  assert (rsize ≥b esize) "src/instrs64_sve.sail:28256.39-28256.40"
  let result ← (( do (pure (Sail.BitVec.zeroExtend (← (Elem_read operand last esize)) rsize)) )
    : SailM (BitVec rsize) )
  (X_set d rsize result)

def decode_LASTA_R_P_Z__ (size : (BitVec 2)) (B : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Rd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize :=
    bif (esize <b 64)
    then 32
    else 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Rd)
  let isBefore : Bool := false
  match VL with
  | 128 => (execute_LASTA_R_P_Z__ 128 d esize g isBefore n rsize)
  | 256 => (execute_LASTA_R_P_Z__ 256 d esize g isBefore n rsize)
  | 512 => (execute_LASTA_R_P_Z__ 512 d esize g isBefore n rsize)
  | 1024 => (execute_LASTA_R_P_Z__ 1024 d esize g isBefore n rsize)
  | 2048 => (execute_LASTA_R_P_Z__ 2048 d esize g isBefore n rsize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_isBefore : Bool, n : Nat, rsize :
  Nat, rsize ∈ {32, 64} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_LASTB_R_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (isBefore : Bool) (n : Nat) (rsize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let last ← (( do (LastActiveElement mask esize) ) : SailM Int )
  let last : Int :=
    bif isBefore
    then
      (bif (last <b 0)
      then (elements -i 1)
      else last)
    else
      (let last : Int := (last +i 1)
      bif (last ≥b elements)
      then 0
      else last)
  let last := last
  assert (rsize ≥b esize) "src/instrs64_sve.sail:28329.39-28329.40"
  let result ← (( do (pure (Sail.BitVec.zeroExtend (← (Elem_read operand last esize)) rsize)) )
    : SailM (BitVec rsize) )
  (X_set d rsize result)

def decode_LASTB_R_P_Z__ (size : (BitVec 2)) (B : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Rd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize :=
    bif (esize <b 64)
    then 32
    else 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Rd)
  let isBefore : Bool := true
  match VL with
  | 128 => (execute_LASTB_R_P_Z__ 128 d esize g isBefore n rsize)
  | 256 => (execute_LASTB_R_P_Z__ 256 d esize g isBefore n rsize)
  | 512 => (execute_LASTB_R_P_Z__ 512 d esize g isBefore n rsize)
  | 1024 => (execute_LASTB_R_P_Z__ 1024 d esize g isBefore n rsize)
  | 2048 => (execute_LASTB_R_P_Z__ 2048 d esize g isBefore n rsize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_isBefore : Bool, n : Nat, 0 ≤ n
  ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_LASTA_V_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (isBefore : Bool) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let last ← (( do (LastActiveElement mask esize) ) : SailM Int )
  let last : Int :=
    bif isBefore
    then
      (bif (last <b 0)
      then (elements -i 1)
      else last)
    else
      (let last : Int := (last +i 1)
      bif (last ≥b elements)
      then 0
      else last)
  let last := last
  (V_set d esize (← (Elem_read operand last esize)))

def decode_LASTA_V_P_Z__ (size : (BitVec 2)) (B : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let isBefore : Bool := false
  match VL with
  | 128 => (execute_LASTA_V_P_Z__ 128 d esize g isBefore n)
  | 256 => (execute_LASTA_V_P_Z__ 256 d esize g isBefore n)
  | 512 => (execute_LASTA_V_P_Z__ 512 d esize g isBefore n)
  | 1024 => (execute_LASTA_V_P_Z__ 1024 d esize g isBefore n)
  | 2048 => (execute_LASTA_V_P_Z__ 2048 d esize g isBefore n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_isBefore : Bool, n : Nat, 0 ≤ n
  ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_LASTB_V_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (isBefore : Bool) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let last ← (( do (LastActiveElement mask esize) ) : SailM Int )
  let last : Int :=
    bif isBefore
    then
      (bif (last <b 0)
      then (elements -i 1)
      else last)
    else
      (let last : Int := (last +i 1)
      bif (last ≥b elements)
      then 0
      else last)
  let last := last
  (V_set d esize (← (Elem_read operand last esize)))

def decode_LASTB_V_P_Z__ (size : (BitVec 2)) (B : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let isBefore : Bool := true
  match VL with
  | 128 => (execute_LASTB_V_P_Z__ 128 d esize g isBefore n)
  | 256 => (execute_LASTB_V_P_Z__ 256 d esize g isBefore n)
  | 512 => (execute_LASTB_V_P_Z__ 512 d esize g isBefore n)
  | 1024 => (execute_LASTB_V_P_Z__ 1024 d esize g isBefore n)
  | 2048 => (execute_LASTB_V_P_Z__ 2048 d esize g isBefore n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_hi : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PUNPKLO_P_P__ (VL : Nat) (d : Nat) (esize : Nat) (hi : Bool) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let pbit ← (( do
          (PredicateElement operand
            (bif hi
            then (e +i elements)
            else e) (Int.ediv esize 2)) ) : SailM (BitVec 1) )
        (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_PUNPKLO_P_P__ (H : (BitVec 1)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Pd)
  let hi : Bool := false
  match VL with
  | 128 => (execute_PUNPKLO_P_P__ 128 d esize hi n)
  | 256 => (execute_PUNPKLO_P_P__ 256 d esize hi n)
  | 512 => (execute_PUNPKLO_P_P__ 512 d esize hi n)
  | 1024 => (execute_PUNPKLO_P_P__ 1024 d esize hi n)
  | 2048 => (execute_PUNPKLO_P_P__ 2048 d esize hi n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_hi : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PUNPKHI_P_P__ (VL : Nat) (d : Nat) (esize : Nat) (hi : Bool) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let pbit ← (( do
          (PredicateElement operand
            (bif hi
            then (e +i elements)
            else e) (Int.ediv esize 2)) ) : SailM (BitVec 1) )
        (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_PUNPKHI_P_P__ (H : (BitVec 1)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Pd)
  let hi : Bool := true
  match VL with
  | 128 => (execute_PUNPKHI_P_P__ 128 d esize hi n)
  | 256 => (execute_PUNPKHI_P_P__ 256 d esize hi n)
  | 512 => (execute_PUNPKHI_P_P__ 512 d esize hi n)
  | 1024 => (execute_PUNPKHI_P_P__ 1024 d esize hi n)
  | 2048 => (execute_PUNPKHI_P_P__ 2048 d esize hi n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, swsize : Nat, swsize = 32
  ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_REVW_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (swsize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize (← (Reverse element swsize))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_REVW_Z_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (bne size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let swsize := 32
  match VL with
  | 128 => (execute_REVW_Z_Z__ 128 d esize g n swsize)
  | 256 => (execute_REVW_Z_Z__ 256 d esize g n swsize)
  | 512 => (execute_REVW_Z_Z__ 512 d esize g n swsize)
  | 1024 => (execute_REVW_Z_Z__ 1024 d esize g n swsize)
  | 2048 => (execute_REVW_Z_Z__ 2048 d esize g n swsize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, swsize : Nat, swsize = 16
  ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_REVH_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (swsize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize (← (Reverse element swsize))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_REVH_Z_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let swsize := 16
  match VL with
  | 128 => (execute_REVH_Z_Z__ 128 d esize g n swsize)
  | 256 => (execute_REVH_Z_Z__ 256 d esize g n swsize)
  | 512 => (execute_REVH_Z_Z__ 512 d esize g n swsize)
  | 1024 => (execute_REVH_Z_Z__ 1024 d esize g n swsize)
  | 2048 => (execute_REVH_Z_Z__ 2048 d esize g n swsize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, swsize : Nat, swsize = 8 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_REVB_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (swsize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize (← (Reverse element swsize))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_REVB_Z_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let swsize := 8
  match VL with
  | 128 => (execute_REVB_Z_Z__ 128 d esize g n swsize)
  | 256 => (execute_REVB_Z_Z__ 256 d esize g n swsize)
  | 512 => (execute_REVB_Z_Z__ 512 d esize g n swsize)
  | 1024 => (execute_REVB_Z_Z__ 1024 d esize g n swsize)
  | 2048 => (execute_REVB_Z_Z__ 2048 d esize g n swsize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_hi : Bool, k_is_unsigned : Bool, n : Nat, 0
  ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UUNPKLO_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (hi : Bool) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let hsize := (Int.ediv esize 2)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do
          bif hi
          then (Elem_read operand (e +i elements) hsize)
          else (Elem_read operand e hsize) ) : SailM (BitVec hsize) )
        (Elem_set result e esize (← (Extend element esize is_unsigned)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UUNPKLO_Z_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := true
  let hi : Bool := false
  match VL with
  | 128 => (execute_UUNPKLO_Z_Z__ 128 d esize hi n is_unsigned)
  | 256 => (execute_UUNPKLO_Z_Z__ 256 d esize hi n is_unsigned)
  | 512 => (execute_UUNPKLO_Z_Z__ 512 d esize hi n is_unsigned)
  | 1024 => (execute_UUNPKLO_Z_Z__ 1024 d esize hi n is_unsigned)
  | 2048 => (execute_UUNPKLO_Z_Z__ 2048 d esize hi n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_hi : Bool, k_is_unsigned : Bool, n : Nat, 0
  ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UUNPKHI_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (hi : Bool) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let hsize := (Int.ediv esize 2)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do
          bif hi
          then (Elem_read operand (e +i elements) hsize)
          else (Elem_read operand e hsize) ) : SailM (BitVec hsize) )
        (Elem_set result e esize (← (Extend element esize is_unsigned)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UUNPKHI_Z_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := true
  let hi : Bool := true
  match VL with
  | 128 => (execute_UUNPKHI_Z_Z__ 128 d esize hi n is_unsigned)
  | 256 => (execute_UUNPKHI_Z_Z__ 256 d esize hi n is_unsigned)
  | 512 => (execute_UUNPKHI_Z_Z__ 512 d esize hi n is_unsigned)
  | 1024 => (execute_UUNPKHI_Z_Z__ 1024 d esize hi n is_unsigned)
  | 2048 => (execute_UUNPKHI_Z_Z__ 2048 d esize hi n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_hi : Bool, k_is_unsigned : Bool, n : Nat, 0
  ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SUNPKLO_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (hi : Bool) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let hsize := (Int.ediv esize 2)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do
          bif hi
          then (Elem_read operand (e +i elements) hsize)
          else (Elem_read operand e hsize) ) : SailM (BitVec hsize) )
        (Elem_set result e esize (← (Extend element esize is_unsigned)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SUNPKLO_Z_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := false
  let hi : Bool := false
  match VL with
  | 128 => (execute_SUNPKLO_Z_Z__ 128 d esize hi n is_unsigned)
  | 256 => (execute_SUNPKLO_Z_Z__ 256 d esize hi n is_unsigned)
  | 512 => (execute_SUNPKLO_Z_Z__ 512 d esize hi n is_unsigned)
  | 1024 => (execute_SUNPKLO_Z_Z__ 1024 d esize hi n is_unsigned)
  | 2048 => (execute_SUNPKLO_Z_Z__ 2048 d esize hi n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_hi : Bool, k_is_unsigned : Bool, n : Nat, 0
  ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SUNPKHI_Z_Z__ (VL : Nat) (d : Nat) (esize : Nat) (hi : Bool) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let hsize := (Int.ediv esize 2)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do
          bif hi
          then (Elem_read operand (e +i elements) hsize)
          else (Elem_read operand e hsize) ) : SailM (BitVec hsize) )
        (Elem_set result e esize (← (Extend element esize is_unsigned)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SUNPKHI_Z_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := false
  let hi : Bool := true
  match VL with
  | 128 => (execute_SUNPKHI_Z_Z__ 128 d esize hi n is_unsigned)
  | 256 => (execute_SUNPKHI_Z_Z__ 256 d esize hi n is_unsigned)
  | 512 => (execute_SUNPKHI_Z_Z__ 512 d esize hi n is_unsigned)
  | 1024 => (execute_SUNPKHI_Z_Z__ 1024 d esize hi n is_unsigned)
  | 2048 => (execute_SUNPKHI_Z_Z__ 2048 d esize hi n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, is_VL(VL) -/
def execute_SETFFR_F__ (VL : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  (FFR_set PL (Ones (n := PL)))

def decode_SETFFR_F__ (_ : Unit) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  match VL with
  | 128 => (execute_SETFFR_F__ 128)
  | 256 => (execute_SETFFR_F__ 256)
  | 512 => (execute_SETFFR_F__ 512)
  | 1024 => (execute_SETFFR_F__ 1024)
  | 2048 => (execute_SETFFR_F__ 2048)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_setflags : Bool, esize ∈ {8, 16, 32, 64}
  ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PTRUE_P_S__ (VL : Nat) (d : Nat) (esize : Nat) (pat : (BitVec 5)) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let pbit : (BitVec 1) :=
          bif (e <b count)
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest result result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_PTRUE_P_S__ (size : (BitVec 2)) (S : (BitVec 1)) (pattern : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  let pat : (BitVec 5) := pattern
  match VL with
  | 128 => (execute_PTRUE_P_S__ 128 d esize pat setflags)
  | 256 => (execute_PTRUE_P_S__ 256 d esize pat setflags)
  | 512 => (execute_PTRUE_P_S__ 512 d esize pat setflags)
  | 1024 => (execute_PTRUE_P_S__ 1024 d esize pat setflags)
  | 2048 => (execute_PTRUE_P_S__ 2048 d esize pat setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_setflags : Bool, esize ∈ {8, 16, 32, 64}
  ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PTRUES_P_S__ (VL : Nat) (d : Nat) (esize : Nat) (pat : (BitVec 5)) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let count ← do (DecodePredCount pat esize)
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let pbit : (BitVec 1) :=
          bif (e <b count)
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest result result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_PTRUES_P_S__ (size : (BitVec 2)) (S : (BitVec 1)) (pattern : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  let pat : (BitVec 5) := pattern
  match VL with
  | 128 => (execute_PTRUES_P_S__ 128 d esize pat setflags)
  | 256 => (execute_PTRUES_P_S__ 256 d esize pat setflags)
  | 512 => (execute_PTRUES_P_S__ 512 d esize pat setflags)
  | 1024 => (execute_PTRUES_P_S__ 1024 d esize pat setflags)
  | 2048 => (execute_PTRUES_P_S__ 2048 d esize pat setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PFALSE_P__ (VL : Nat) (d : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  (P_set d PL (Zeros (n := PL)))

def decode_PFALSE_P__ (S : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Pd)
  match VL with
  | 128 => (execute_PFALSE_P__ 128 d)
  | 256 => (execute_PFALSE_P__ 256 d)
  | 512 => (execute_PFALSE_P__ 512 d)
  | 1024 => (execute_PFALSE_P__ 1024 d)
  | 2048 => (execute_PFALSE_P__ 2048 d)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_RDFFR_P_F__ (VL : Nat) (d : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let ffr ← (( do (FFR_read PL) ) : SailM (BitVec PL) )
  (P_set d PL ffr)

def decode_RDFFR_P_F__ (S : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Pd)
  match VL with
  | 128 => (execute_RDFFR_P_F__ 128 d)
  | 256 => (execute_RDFFR_P_F__ 256 d)
  | 512 => (execute_RDFFR_P_F__ 512 d)
  | 1024 => (execute_RDFFR_P_F__ 1024 d)
  | 2048 => (execute_RDFFR_P_F__ 2048 d)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, n : Nat, 0 ≤ n ∧ n ≤ 15 ∧ is_VL(VL) -/
def execute_WRFFR_F_P__ (VL : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let hsb := (HighestSetBit operand)
  bif (Bool.or (hsb <b 0) (is_ones_subrange operand hsb 0))
  then (FFR_set PL operand)
  else (FFR_set PL (← (__UNKNOWN_bits PL)))

def decode_WRFFR_F_P__ (Pn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Pn)
  match VL with
  | 128 => (execute_WRFFR_F_P__ 128 n)
  | 256 => (execute_WRFFR_F_P__ 256 n)
  | 512 => (execute_WRFFR_F_P__ 512 n)
  | 1024 => (execute_WRFFR_F_P__ 1024 n)
  | 2048 => (execute_WRFFR_F_P__ 2048 n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, g : Nat, k_setflags : Bool, 0 ≤ g ∧
  g ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_RDFFR_P_P_F__ (VL : Nat) (d : Nat) (g : Nat) (setflags : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let ffr ← (( do (FFR_read PL) ) : SailM (BitVec PL) )
  let result : (BitVec PL) := (ffr &&& mask)
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result 8)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_RDFFR_P_P_F__ (S : (BitVec 1)) (Pg : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_RDFFR_P_P_F__ 128 d g setflags)
  | 256 => (execute_RDFFR_P_P_F__ 256 d g setflags)
  | 512 => (execute_RDFFR_P_P_F__ 512 d g setflags)
  | 1024 => (execute_RDFFR_P_P_F__ 1024 d g setflags)
  | 2048 => (execute_RDFFR_P_P_F__ 2048 d g setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, g : Nat, k_setflags : Bool, 0 ≤ g ∧
  g ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_RDFFRS_P_P_F__ (VL : Nat) (d : Nat) (g : Nat) (setflags : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let ffr ← (( do (FFR_read PL) ) : SailM (BitVec PL) )
  let result : (BitVec PL) := (ffr &&& mask)
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result 8)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_RDFFRS_P_P_F__ (S : (BitVec 1)) (Pg : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_RDFFRS_P_P_F__ 128 d g setflags)
  | 256 => (execute_RDFFRS_P_P_F__ 256 d g setflags)
  | 512 => (execute_RDFFRS_P_P_F__ 512 d g setflags)
  | 1024 => (execute_RDFFRS_P_P_F__ 1024 d g setflags)
  | 2048 => (execute_RDFFRS_P_P_F__ 2048 d g setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_PTEST__P_P__ (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }

def decode_PTEST__P_P__ (S : (BitVec 1)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  match VL with
  | 128 => (execute_PTEST__P_P__ 128 esize g n)
  | 256 => (execute_PTEST__P_P__ 256 esize g n)
  | 512 => (execute_PTEST__P_P__ 512 esize g n)
  | 1024 => (execute_PTEST__P_P__ 1024 esize g n)
  | 2048 => (execute_PTEST__P_P__ 2048 esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_merging : Bool, n : Nat, k_setflags
  : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_BRKA_P_P_P__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (merging : Bool) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read d PL) ) : SailM (BitVec PL) )
  let break : Bool := false
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let (break, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (break, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (break, result) := loop_vars
      loop_vars ← do
        let element ← (( do (ActivePredicateElement operand e esize) ) : SailM Bool )
        let (break, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let pbit : (BitVec 1) :=
                bif (Bool.not break)
                then (0b1 : (BitVec 1))
                else (0b0 : (BitVec 1))
              let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
              let break : Bool := (Bool.or break element)
              (pure (break, result)))
          else
            (do
              let result ← (( do
                bif merging
                then
                  (do
                    let pbit ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
                    (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
                else
                  (do
                    (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize))) ) :
                SailM (BitVec PL) )
              (pure (break, result))) ) : SailM (Bool × (BitVec PL)) )
        (pure (break, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec PL)) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_BRKA_P_P_P__ (B : (BitVec 1)) (S : (BitVec 1)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (M : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Pd)
  let merging : Bool := (BEq.beq M (0b1 : (BitVec 1)))
  let setflags : Bool := false
  match VL with
  | 128 => (execute_BRKA_P_P_P__ 128 d esize g merging n setflags)
  | 256 => (execute_BRKA_P_P_P__ 256 d esize g merging n setflags)
  | 512 => (execute_BRKA_P_P_P__ 512 d esize g merging n setflags)
  | 1024 => (execute_BRKA_P_P_P__ 1024 d esize g merging n setflags)
  | 2048 => (execute_BRKA_P_P_P__ 2048 d esize g merging n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_merging : Bool, n : Nat, k_setflags
  : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_BRKAS_P_P_P_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (merging : Bool) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read d PL) ) : SailM (BitVec PL) )
  let break : Bool := false
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let (break, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (break, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (break, result) := loop_vars
      loop_vars ← do
        let element ← (( do (ActivePredicateElement operand e esize) ) : SailM Bool )
        let (break, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let pbit : (BitVec 1) :=
                bif (Bool.not break)
                then (0b1 : (BitVec 1))
                else (0b0 : (BitVec 1))
              let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
              let break : Bool := (Bool.or break element)
              (pure (break, result)))
          else
            (do
              let result ← (( do
                bif merging
                then
                  (do
                    let pbit ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
                    (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
                else
                  (do
                    (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize))) ) :
                SailM (BitVec PL) )
              (pure (break, result))) ) : SailM (Bool × (BitVec PL)) )
        (pure (break, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec PL)) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_BRKAS_P_P_P_Z (B : (BitVec 1)) (S : (BitVec 1)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (M : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Pd)
  let merging : Bool := false
  let setflags : Bool := true
  match VL with
  | 128 => (execute_BRKAS_P_P_P_Z 128 d esize g merging n setflags)
  | 256 => (execute_BRKAS_P_P_P_Z 256 d esize g merging n setflags)
  | 512 => (execute_BRKAS_P_P_P_Z 512 d esize g merging n setflags)
  | 1024 => (execute_BRKAS_P_P_P_Z 1024 d esize g merging n setflags)
  | 2048 => (execute_BRKAS_P_P_P_Z 2048 d esize g merging n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_merging : Bool, n : Nat, k_setflags
  : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_BRKB_P_P_P__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (merging : Bool) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read d PL) ) : SailM (BitVec PL) )
  let break : Bool := false
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let (break, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (break, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (break, result) := loop_vars
      loop_vars ← do
        let element ← (( do (ActivePredicateElement operand e esize) ) : SailM Bool )
        let (break, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let break : Bool := (Bool.or break element)
              let pbit : (BitVec 1) :=
                bif (Bool.not break)
                then (0b1 : (BitVec 1))
                else (0b0 : (BitVec 1))
              let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
              (pure (break, result)))
          else
            (do
              let result ← (( do
                bif merging
                then
                  (do
                    let pbit ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
                    (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
                else
                  (do
                    (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize))) ) :
                SailM (BitVec PL) )
              (pure (break, result))) ) : SailM (Bool × (BitVec PL)) )
        (pure (break, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec PL)) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_BRKB_P_P_P__ (B : (BitVec 1)) (S : (BitVec 1)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (M : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Pd)
  let merging : Bool := (BEq.beq M (0b1 : (BitVec 1)))
  let setflags : Bool := false
  match VL with
  | 128 => (execute_BRKB_P_P_P__ 128 d esize g merging n setflags)
  | 256 => (execute_BRKB_P_P_P__ 256 d esize g merging n setflags)
  | 512 => (execute_BRKB_P_P_P__ 512 d esize g merging n setflags)
  | 1024 => (execute_BRKB_P_P_P__ 1024 d esize g merging n setflags)
  | 2048 => (execute_BRKB_P_P_P__ 2048 d esize g merging n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_merging : Bool, n : Nat, k_setflags
  : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_BRKBS_P_P_P_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (merging : Bool) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read d PL) ) : SailM (BitVec PL) )
  let break : Bool := false
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let (break, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (break, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (break, result) := loop_vars
      loop_vars ← do
        let element ← (( do (ActivePredicateElement operand e esize) ) : SailM Bool )
        let (break, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let break : Bool := (Bool.or break element)
              let pbit : (BitVec 1) :=
                bif (Bool.not break)
                then (0b1 : (BitVec 1))
                else (0b0 : (BitVec 1))
              let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
              (pure (break, result)))
          else
            (do
              let result ← (( do
                bif merging
                then
                  (do
                    let pbit ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
                    (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize)))
                else
                  (do
                    (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize))) ) :
                SailM (BitVec PL) )
              (pure (break, result))) ) : SailM (Bool × (BitVec PL)) )
        (pure (break, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec PL)) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_BRKBS_P_P_P_Z (B : (BitVec 1)) (S : (BitVec 1)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (M : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Pd)
  let merging : Bool := false
  let setflags : Bool := true
  match VL with
  | 128 => (execute_BRKBS_P_P_P_Z 128 d esize g merging n setflags)
  | 256 => (execute_BRKBS_P_P_P_Z 256 d esize g merging n setflags)
  | 512 => (execute_BRKBS_P_P_P_Z 512 d esize g merging n setflags)
  | 1024 => (execute_BRKBS_P_P_P_Z 1024 d esize g merging n setflags)
  | 2048 => (execute_BRKBS_P_P_P_Z 2048 d esize g merging n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_AND_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (element1 &&& element2) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_AND_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_AND_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_AND_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_AND_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_AND_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_AND_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_ANDS_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (element1 &&& element2) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_ANDS_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_ANDS_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_ANDS_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_ANDS_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_ANDS_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_ANDS_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_BIC_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize
              (Sail.BitVec.zeroExtend (element1 &&& (Complement.complement element2)) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_BIC_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_BIC_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_BIC_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_BIC_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_BIC_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_BIC_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_BICS_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize
              (Sail.BitVec.zeroExtend (element1 &&& (Complement.complement element2)) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_BICS_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_BICS_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_BICS_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_BICS_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_BICS_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_BICS_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_EOR_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (element1 ^^^ element2) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_EOR_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_EOR_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_EOR_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_EOR_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_EOR_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_EOR_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_EORS_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (element1 ^^^ element2) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_EORS_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_EORS_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_EORS_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_EORS_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_EORS_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_EORS_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_NAND_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize
              (Sail.BitVec.zeroExtend (Complement.complement (element1 &&& element2)) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_NAND_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_NAND_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_NAND_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_NAND_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_NAND_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_NAND_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_NANDS_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize
              (Sail.BitVec.zeroExtend (Complement.complement (element1 &&& element2)) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_NANDS_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_NANDS_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_NANDS_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_NANDS_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_NANDS_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_NANDS_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_NOR_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize
              (Sail.BitVec.zeroExtend (Complement.complement (element1 ||| element2)) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_NOR_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_NOR_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_NOR_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_NOR_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_NOR_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_NOR_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_NORS_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize
              (Sail.BitVec.zeroExtend (Complement.complement (element1 ||| element2)) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_NORS_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_NORS_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_NORS_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_NORS_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_NORS_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_NORS_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_ORN_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize
              (Sail.BitVec.zeroExtend (element1 ||| (Complement.complement element2)) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_ORN_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_ORN_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_ORN_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_ORN_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_ORN_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_ORN_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_ORNS_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize
              (Sail.BitVec.zeroExtend (element1 ||| (Complement.complement element2)) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_ORNS_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_ORNS_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_ORNS_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_ORNS_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_ORNS_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_ORNS_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_ORR_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (element1 ||| element2) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_ORR_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_ORR_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_ORR_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_ORR_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_ORR_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_ORR_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_ORRS_P_P_PP_Z (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (element1 ||| element2) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_ORRS_P_P_PP_Z (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_ORRS_P_P_PP_Z 128 d esize g m n setflags)
  | 256 => (execute_ORRS_P_P_PP_Z 256 d esize g m n setflags)
  | 512 => (execute_ORRS_P_P_PP_Z 512 d esize g m n setflags)
  | 1024 => (execute_ORRS_P_P_PP_Z 1024 d esize g m n setflags)
  | 2048 => (execute_ORRS_P_P_PP_Z 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_SEL_P_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (PredicateElement operand1 e esize) ) : SailM (BitVec 1) )
        let element2 ← (( do (PredicateElement operand2 e esize) ) : SailM (BitVec 1) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend element1 psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend element2 psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_SEL_P_P_PP__ (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  match VL with
  | 128 => (execute_SEL_P_P_PP__ 128 d esize g m n)
  | 256 => (execute_SEL_P_P_PP__ 256 d esize g m n)
  | 512 => (execute_SEL_P_P_PP__ 512 d esize g m n)
  | 1024 => (execute_SEL_P_P_PP__ 1024 d esize g m n)
  | 2048 => (execute_SEL_P_P_PP__ 2048 d esize g m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, 0 ≤ g ∧
  g ≤ 15 ∧ esize = 8 ∧ 0 ≤ dn ∧ dn ≤ 15 ∧ is_VL(VL) -/
def execute_PFIRST_P_P_P__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (P_read dn PL) ) : SailM (BitVec PL) )
  let first : Int := (Neg.neg 1)
  let psize := (Int.ediv esize 8)
  let first ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := first
    for e in [loop_e_lower:loop_e_upper:1]i do
      let first := loop_vars
      loop_vars ← do
        bif (Bool.and (← (ActivePredicateElement mask e esize)) (BEq.beq first (Neg.neg 1)))
        then (pure e)
        else (pure first)
    (pure loop_vars) ) : SailM Int )
  let first := first
  let result ← (( do
    bif (first ≥b 0)
    then
      (do
        (Elem_set result first psize (Sail.BitVec.zeroExtend (0b1 : (BitVec 1)) psize)))
    else (pure result) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set dn PL result)

def decode_PFIRST_P_P_P__ (S : (BitVec 1)) (Pg : (BitVec 4)) (Pdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Pdn)
  match VL with
  | 128 => (execute_PFIRST_P_P_P__ 128 dn esize g)
  | 256 => (execute_PFIRST_P_P_P__ 256 dn esize g)
  | 512 => (execute_PFIRST_P_P_P__ 512 dn esize g)
  | 1024 => (execute_PFIRST_P_P_P__ 1024 dn esize g)
  | 2048 => (execute_PFIRST_P_P_P__ 2048 dn esize g)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 15 ∧ is_VL(VL) -/
def execute_PNEXT_P_P_P__ (VL : Nat) (dn : Nat) (esize : Nat) (v : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read v PL) ) : SailM (BitVec PL) )
  let operand ← (( do (P_read dn PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let next ← (( do (pure ((← (LastActiveElement operand esize)) +i 1)) ) : SailM Int )
  let next ← (( do
    let mut loop_vars := next
    while
    (← (λ next => do
        (pure (Bool.and (next <b elements) (Bool.not (← (ActivePredicateElement mask next esize))))))
      loop_vars) do
      let next := loop_vars
      loop_vars := ((next +i 1) : Int)
    (pure loop_vars) ) : SailM Int )
  let next := next
  let result : (BitVec PL) := (Zeros (n := PL))
  let result ← (( do
    bif (next <b elements)
    then
      (do
        (Elem_set result next psize (Sail.BitVec.zeroExtend (0b1 : (BitVec 1)) psize)))
    else (pure result) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set dn PL result)

def decode_PNEXT_P_P_P__ (size : (BitVec 2)) (Pv : (BitVec 4)) (Pdn : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let v := (BitVec.toNat Pv)
  let dn := (BitVec.toNat Pdn)
  match VL with
  | 128 => (execute_PNEXT_P_P_P__ 128 dn esize v)
  | 256 => (execute_PNEXT_P_P_P__ 256 dn esize v)
  | 512 => (execute_PNEXT_P_P_P__ 512 dn esize v)
  | 1024 => (execute_PNEXT_P_P_P__ 1024 dn esize v)
  | 2048 => (execute_PNEXT_P_P_P__ 2048 dn esize v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, imm : Int, 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_RDVL_R_I__ (VL : Nat) (d : Nat) (imm : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let len := (imm *i (Int.ediv VL 8))
  (X_set d 64 (integer_subrange len 63 0))

def decode_RDVL_R_I__ (imm6 : (BitVec 6)) (Rd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (BitVec.toNat Rd)
  let imm := (BitVec.toInt imm6)
  match VL with
  | 128 => (execute_RDVL_R_I__ 128 d imm)
  | 256 => (execute_RDVL_R_I__ 256 d imm)
  | 512 => (execute_RDVL_R_I__ 512 d imm)
  | 1024 => (execute_RDVL_R_I__ 1024 d imm)
  | 2048 => (execute_RDVL_R_I__ 2048 d imm)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, v : Nat, 0 ≤ v ∧
  v ≤ 15 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SEL_Z_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (v : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read v PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement (Complement.complement mask) esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand2 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SEL_Z_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pv : (BitVec 4)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let v := (BitVec.toNat Pv)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SEL_Z_P_ZZ__ 128 d esize m n v)
  | 256 => (execute_SEL_Z_P_ZZ__ 256 d esize m n v)
  | 512 => (execute_SEL_Z_P_ZZ__ 512 d esize m n v)
  | 1024 => (execute_SEL_Z_P_ZZ__ 1024 d esize m n v)
  | 2048 => (execute_SEL_Z_P_ZZ__ 2048 d esize m n v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_LSL_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize (element1 <<< shift))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_LSL_Z_ZI__ (tszh : (BitVec 2)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((BitVec.toNat (tsize ++ imm3)) -i esize)
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_LSL_Z_ZI__ 128 d 8 n shift)
      | 256 => (execute_LSL_Z_ZI__ 256 d 8 n shift)
      | 512 => (execute_LSL_Z_ZI__ 512 d 8 n shift)
      | 1024 => (execute_LSL_Z_ZI__ 1024 d 8 n shift)
      | 2048 => (execute_LSL_Z_ZI__ 2048 d 8 n shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_LSL_Z_ZI__ 128 d 16 n shift)
      | 256 => (execute_LSL_Z_ZI__ 256 d 16 n shift)
      | 512 => (execute_LSL_Z_ZI__ 512 d 16 n shift)
      | 1024 => (execute_LSL_Z_ZI__ 1024 d 16 n shift)
      | 2048 => (execute_LSL_Z_ZI__ 2048 d 16 n shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_LSL_Z_ZI__ 128 d 32 n shift)
      | 256 => (execute_LSL_Z_ZI__ 256 d 32 n shift)
      | 512 => (execute_LSL_Z_ZI__ 512 d 32 n shift)
      | 1024 => (execute_LSL_Z_ZI__ 1024 d 32 n shift)
      | 2048 => (execute_LSL_Z_ZI__ 2048 d 32 n shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_LSL_Z_ZI__ 128 d 64 n shift)
      | 256 => (execute_LSL_Z_ZI__ 256 d 64 n shift)
      | 512 => (execute_LSL_Z_ZI__ 512 d 64 n shift)
      | 1024 => (execute_LSL_Z_ZI__ 1024 d 64 n shift)
      | 2048 => (execute_LSL_Z_ZI__ 2048 d 64 n shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:31348.22-31348.23"

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_LSR_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize (element1 >>> shift))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_LSR_Z_ZI__ (tszh : (BitVec 2)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_LSR_Z_ZI__ 128 d 8 n shift)
      | 256 => (execute_LSR_Z_ZI__ 256 d 8 n shift)
      | 512 => (execute_LSR_Z_ZI__ 512 d 8 n shift)
      | 1024 => (execute_LSR_Z_ZI__ 1024 d 8 n shift)
      | 2048 => (execute_LSR_Z_ZI__ 2048 d 8 n shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_LSR_Z_ZI__ 128 d 16 n shift)
      | 256 => (execute_LSR_Z_ZI__ 256 d 16 n shift)
      | 512 => (execute_LSR_Z_ZI__ 512 d 16 n shift)
      | 1024 => (execute_LSR_Z_ZI__ 1024 d 16 n shift)
      | 2048 => (execute_LSR_Z_ZI__ 2048 d 16 n shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_LSR_Z_ZI__ 128 d 32 n shift)
      | 256 => (execute_LSR_Z_ZI__ 256 d 32 n shift)
      | 512 => (execute_LSR_Z_ZI__ 512 d 32 n shift)
      | 1024 => (execute_LSR_Z_ZI__ 1024 d 32 n shift)
      | 2048 => (execute_LSR_Z_ZI__ 2048 d 32 n shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_LSR_Z_ZI__ 128 d 64 n shift)
      | 256 => (execute_LSR_Z_ZI__ 256 d 64 n shift)
      | 512 => (execute_LSR_Z_ZI__ 512 d 64 n shift)
      | 1024 => (execute_LSR_Z_ZI__ 1024 d 64 n shift)
      | 2048 => (execute_LSR_Z_ZI__ 2048 d 64 n shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:31492.22-31492.23"

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ASR_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize (BitVec.rotateRight element1 shift))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ASR_Z_ZI__ (tszh : (BitVec 2)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_ASR_Z_ZI__ 128 d 8 n shift)
      | 256 => (execute_ASR_Z_ZI__ 256 d 8 n shift)
      | 512 => (execute_ASR_Z_ZI__ 512 d 8 n shift)
      | 1024 => (execute_ASR_Z_ZI__ 1024 d 8 n shift)
      | 2048 => (execute_ASR_Z_ZI__ 2048 d 8 n shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_ASR_Z_ZI__ 128 d 16 n shift)
      | 256 => (execute_ASR_Z_ZI__ 256 d 16 n shift)
      | 512 => (execute_ASR_Z_ZI__ 512 d 16 n shift)
      | 1024 => (execute_ASR_Z_ZI__ 1024 d 16 n shift)
      | 2048 => (execute_ASR_Z_ZI__ 2048 d 16 n shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_ASR_Z_ZI__ 128 d 32 n shift)
      | 256 => (execute_ASR_Z_ZI__ 256 d 32 n shift)
      | 512 => (execute_ASR_Z_ZI__ 512 d 32 n shift)
      | 1024 => (execute_ASR_Z_ZI__ 1024 d 32 n shift)
      | 2048 => (execute_ASR_Z_ZI__ 2048 d 32 n shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_ASR_Z_ZI__ 128 d 64 n shift)
      | 256 => (execute_ASR_Z_ZI__ 256 d 64 n shift)
      | 512 => (execute_ASR_Z_ZI__ 512 d 64 n shift)
      | 1024 => (execute_ASR_Z_ZI__ 1024 d 64 n shift)
      | 2048 => (execute_ASR_Z_ZI__ 2048 d 64 n shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:31637.22-31637.23"

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, shift : Int, g ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ASRD_Z_P_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (pure (BitVec.toInt (← (Elem_read operand1 e esize)))) ) :
              SailM Int )
            let element1 : Int :=
              bif (element1 <b 0)
              then (element1 +i ((_shl_int_general 1 shift) -i 1))
              else element1
            let element1 := element1
            (Elem_set result e esize
              (integer_subrange (_shr_int_general element1 shift) (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_ASRD_Z_P_ZI__ (tszh : (BitVec 2)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_ASRD_Z_P_ZI__ 128 dn 8 g shift)
      | 256 => (execute_ASRD_Z_P_ZI__ 256 dn 8 g shift)
      | 512 => (execute_ASRD_Z_P_ZI__ 512 dn 8 g shift)
      | 1024 => (execute_ASRD_Z_P_ZI__ 1024 dn 8 g shift)
      | 2048 => (execute_ASRD_Z_P_ZI__ 2048 dn 8 g shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_ASRD_Z_P_ZI__ 128 dn 16 g shift)
      | 256 => (execute_ASRD_Z_P_ZI__ 256 dn 16 g shift)
      | 512 => (execute_ASRD_Z_P_ZI__ 512 dn 16 g shift)
      | 1024 => (execute_ASRD_Z_P_ZI__ 1024 dn 16 g shift)
      | 2048 => (execute_ASRD_Z_P_ZI__ 2048 dn 16 g shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_ASRD_Z_P_ZI__ 128 dn 32 g shift)
      | 256 => (execute_ASRD_Z_P_ZI__ 256 dn 32 g shift)
      | 512 => (execute_ASRD_Z_P_ZI__ 512 dn 32 g shift)
      | 1024 => (execute_ASRD_Z_P_ZI__ 1024 dn 32 g shift)
      | 2048 => (execute_ASRD_Z_P_ZI__ 2048 dn 32 g shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_ASRD_Z_P_ZI__ 128 dn 64 g shift)
      | 256 => (execute_ASRD_Z_P_ZI__ 256 dn 64 g shift)
      | 512 => (execute_ASRD_Z_P_ZI__ 512 dn 64 g shift)
      | 1024 => (execute_ASRD_Z_P_ZI__ 1024 dn 64 g shift)
      | 2048 => (execute_ASRD_Z_P_ZI__ 2048 dn 64 g shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:31792.22-31792.23"

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, shift : Int, g ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_LSL_Z_P_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let PL := (Int.ediv VL 8)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (element1 <<< shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_LSL_Z_P_ZI__ (tszh : (BitVec 2)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let shift := ((BitVec.toNat (tsize ++ imm3)) -i esize)
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_LSL_Z_P_ZI__ 128 dn 8 g shift)
      | 256 => (execute_LSL_Z_P_ZI__ 256 dn 8 g shift)
      | 512 => (execute_LSL_Z_P_ZI__ 512 dn 8 g shift)
      | 1024 => (execute_LSL_Z_P_ZI__ 1024 dn 8 g shift)
      | 2048 => (execute_LSL_Z_P_ZI__ 2048 dn 8 g shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_LSL_Z_P_ZI__ 128 dn 16 g shift)
      | 256 => (execute_LSL_Z_P_ZI__ 256 dn 16 g shift)
      | 512 => (execute_LSL_Z_P_ZI__ 512 dn 16 g shift)
      | 1024 => (execute_LSL_Z_P_ZI__ 1024 dn 16 g shift)
      | 2048 => (execute_LSL_Z_P_ZI__ 2048 dn 16 g shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_LSL_Z_P_ZI__ 128 dn 32 g shift)
      | 256 => (execute_LSL_Z_P_ZI__ 256 dn 32 g shift)
      | 512 => (execute_LSL_Z_P_ZI__ 512 dn 32 g shift)
      | 1024 => (execute_LSL_Z_P_ZI__ 1024 dn 32 g shift)
      | 2048 => (execute_LSL_Z_P_ZI__ 2048 dn 32 g shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_LSL_Z_P_ZI__ 128 dn 64 g shift)
      | 256 => (execute_LSL_Z_P_ZI__ 256 dn 64 g shift)
      | 512 => (execute_LSL_Z_P_ZI__ 512 dn 64 g shift)
      | 1024 => (execute_LSL_Z_P_ZI__ 1024 dn 64 g shift)
      | 2048 => (execute_LSL_Z_P_ZI__ 2048 dn 64 g shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:31944.22-31944.23"

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, shift : Int, g ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_LSR_Z_P_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let PL := (Int.ediv VL 8)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (element1 >>> shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_LSR_Z_P_ZI__ (tszh : (BitVec 2)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_LSR_Z_P_ZI__ 128 dn 8 g shift)
      | 256 => (execute_LSR_Z_P_ZI__ 256 dn 8 g shift)
      | 512 => (execute_LSR_Z_P_ZI__ 512 dn 8 g shift)
      | 1024 => (execute_LSR_Z_P_ZI__ 1024 dn 8 g shift)
      | 2048 => (execute_LSR_Z_P_ZI__ 2048 dn 8 g shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_LSR_Z_P_ZI__ 128 dn 16 g shift)
      | 256 => (execute_LSR_Z_P_ZI__ 256 dn 16 g shift)
      | 512 => (execute_LSR_Z_P_ZI__ 512 dn 16 g shift)
      | 1024 => (execute_LSR_Z_P_ZI__ 1024 dn 16 g shift)
      | 2048 => (execute_LSR_Z_P_ZI__ 2048 dn 16 g shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_LSR_Z_P_ZI__ 128 dn 32 g shift)
      | 256 => (execute_LSR_Z_P_ZI__ 256 dn 32 g shift)
      | 512 => (execute_LSR_Z_P_ZI__ 512 dn 32 g shift)
      | 1024 => (execute_LSR_Z_P_ZI__ 1024 dn 32 g shift)
      | 2048 => (execute_LSR_Z_P_ZI__ 2048 dn 32 g shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_LSR_Z_P_ZI__ 128 dn 64 g shift)
      | 256 => (execute_LSR_Z_P_ZI__ 256 dn 64 g shift)
      | 512 => (execute_LSR_Z_P_ZI__ 512 dn 64 g shift)
      | 1024 => (execute_LSR_Z_P_ZI__ 1024 dn 64 g shift)
      | 2048 => (execute_LSR_Z_P_ZI__ 2048 dn 64 g shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:32096.22-32096.23"

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, shift : Int, g ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ASR_Z_P_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let PL := (Int.ediv VL 8)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (BitVec.rotateRight element1 shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_ASR_Z_P_ZI__ (tszh : (BitVec 2)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_ASR_Z_P_ZI__ 128 dn 8 g shift)
      | 256 => (execute_ASR_Z_P_ZI__ 256 dn 8 g shift)
      | 512 => (execute_ASR_Z_P_ZI__ 512 dn 8 g shift)
      | 1024 => (execute_ASR_Z_P_ZI__ 1024 dn 8 g shift)
      | 2048 => (execute_ASR_Z_P_ZI__ 2048 dn 8 g shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_ASR_Z_P_ZI__ 128 dn 16 g shift)
      | 256 => (execute_ASR_Z_P_ZI__ 256 dn 16 g shift)
      | 512 => (execute_ASR_Z_P_ZI__ 512 dn 16 g shift)
      | 1024 => (execute_ASR_Z_P_ZI__ 1024 dn 16 g shift)
      | 2048 => (execute_ASR_Z_P_ZI__ 2048 dn 16 g shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_ASR_Z_P_ZI__ 128 dn 32 g shift)
      | 256 => (execute_ASR_Z_P_ZI__ 256 dn 32 g shift)
      | 512 => (execute_ASR_Z_P_ZI__ 512 dn 32 g shift)
      | 1024 => (execute_ASR_Z_P_ZI__ 1024 dn 32 g shift)
      | 2048 => (execute_ASR_Z_P_ZI__ 2048 dn 32 g shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_ASR_Z_P_ZI__ 128 dn 64 g shift)
      | 256 => (execute_ASR_Z_P_ZI__ 256 dn 64 g shift)
      | 512 => (execute_ASR_Z_P_ZI__ 512 dn 64 g shift)
      | 1024 => (execute_ASR_Z_P_ZI__ 1024 dn 64 g shift)
      | 2048 => (execute_ASR_Z_P_ZI__ 2048 dn 64 g shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:32248.22-32248.23"

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_LSL_Z_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 (Int.ediv (e *i esize) 64) 64) ) : SailM
          (BitVec 64) )
        let shift := (Min.min (BitVec.toNat element2) esize)
        (Elem_set result e esize (element1 <<< shift))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_LSL_Z_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_LSL_Z_ZW__ 128 d esize m n)
  | 256 => (execute_LSL_Z_ZW__ 256 d esize m n)
  | 512 => (execute_LSL_Z_ZW__ 512 d esize m n)
  | 1024 => (execute_LSL_Z_ZW__ 1024 d esize m n)
  | 2048 => (execute_LSL_Z_ZW__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_LSR_Z_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 (Int.ediv (e *i esize) 64) 64) ) : SailM
          (BitVec 64) )
        let shift := (Min.min (BitVec.toNat element2) esize)
        (Elem_set result e esize (element1 >>> shift))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_LSR_Z_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_LSR_Z_ZW__ 128 d esize m n)
  | 256 => (execute_LSR_Z_ZW__ 256 d esize m n)
  | 512 => (execute_LSR_Z_ZW__ 512 d esize m n)
  | 1024 => (execute_LSR_Z_ZW__ 1024 d esize m n)
  | 2048 => (execute_LSR_Z_ZW__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ASR_Z_ZW__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 (Int.ediv (e *i esize) 64) 64) ) : SailM
          (BitVec 64) )
        let shift := (Min.min (BitVec.toNat element2) esize)
        (Elem_set result e esize (BitVec.rotateRight element1 shift))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ASR_Z_ZW__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_ASR_Z_ZW__ 128 d esize m n)
  | 256 => (execute_ASR_Z_ZW__ 256 d esize m n)
  | 512 => (execute_ASR_Z_ZW__ 512 d esize m n)
  | 1024 => (execute_ASR_Z_ZW__ 1024 d esize m n)
  | 2048 => (execute_ASR_Z_ZW__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_LSL_Z_P_ZW__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 (Int.ediv (e *i esize) 64) 64) ) : SailM
              (BitVec 64) )
            let shift := (Min.min (BitVec.toNat element2) esize)
            (Elem_set result e esize (element1 <<< shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_LSL_Z_P_ZW__ (size : (BitVec 2)) (R : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_LSL_Z_P_ZW__ 128 dn esize g m)
  | 256 => (execute_LSL_Z_P_ZW__ 256 dn esize g m)
  | 512 => (execute_LSL_Z_P_ZW__ 512 dn esize g m)
  | 1024 => (execute_LSL_Z_P_ZW__ 1024 dn esize g m)
  | 2048 => (execute_LSL_Z_P_ZW__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_LSR_Z_P_ZW__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 (Int.ediv (e *i esize) 64) 64) ) : SailM
              (BitVec 64) )
            let shift := (Min.min (BitVec.toNat element2) esize)
            (Elem_set result e esize (element1 >>> shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_LSR_Z_P_ZW__ (size : (BitVec 2)) (R : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_LSR_Z_P_ZW__ 128 dn esize g m)
  | 256 => (execute_LSR_Z_P_ZW__ 256 dn esize g m)
  | 512 => (execute_LSR_Z_P_ZW__ 512 dn esize g m)
  | 1024 => (execute_LSR_Z_P_ZW__ 1024 dn esize g m)
  | 2048 => (execute_LSR_Z_P_ZW__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ASR_Z_P_ZW__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let element2 ← (( do (Elem_read operand2 (Int.ediv (e *i esize) 64) 64) ) : SailM
              (BitVec 64) )
            let shift := (Min.min (BitVec.toNat element2) esize)
            (Elem_set result e esize (BitVec.rotateRight element1 shift)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_ASR_Z_P_ZW__ (size : (BitVec 2)) (R : (BitVec 1)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_ASR_Z_P_ZW__ 128 dn esize g m)
  | 256 => (execute_ASR_Z_P_ZW__ 256 dn esize g m)
  | 512 => (execute_ASR_Z_P_ZW__ 512 dn esize g m)
  | 1024 => (execute_ASR_Z_P_ZW__ 1024 dn esize g m)
  | 2048 => (execute_ASR_Z_P_ZW__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ABS_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (pure (BitVec.toInt (← (Elem_read operand e esize)))) ) : SailM
              Int )
            let element := (Int.natAbs element)
            (Elem_set result e esize (integer_subrange element (esize -i 1) 0)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ABS_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_ABS_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_ABS_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_ABS_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_ABS_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_ABS_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_CLS_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize
              (integer_subrange (CountLeadingSignBits element) (esize -i 1) 0)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_CLS_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_CLS_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_CLS_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_CLS_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_CLS_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_CLS_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_CLZ_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize
              (integer_subrange (CountLeadingZeroBits element) (esize -i 1) 0)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_CLZ_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_CLZ_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_CLZ_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_CLZ_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_CLZ_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_CLZ_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_CNOT_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize (Sail.BitVec.zeroExtend (IsZeroBit element) esize)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_CNOT_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_CNOT_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_CNOT_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_CNOT_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_CNOT_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_CNOT_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_CNT_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize (integer_subrange (BitCount element) (esize -i 1) 0)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_CNT_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_CNT_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_CNT_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_CNT_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_CNT_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_CNT_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FABS_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:33028.53-33028.54"
            (Elem_set result e esize (← (FPAbs element))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FABS_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FABS_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_FABS_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_FABS_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_FABS_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FABS_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_FNEG_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs64_sve.sail:33097.53-33097.54"
            (Elem_set result e esize (← (FPNeg element))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_FNEG_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_FNEG_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_FNEG_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_FNEG_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_FNEG_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_FNEG_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_NEG_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (pure (BitVec.toInt (← (Elem_read operand e esize)))) ) : SailM
              Int )
            let element := (Neg.neg element)
            (Elem_set result e esize (integer_subrange element (esize -i 1) 0)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_NEG_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_NEG_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_NEG_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_NEG_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_NEG_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_NEG_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_NOT_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize (Complement.complement element)))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_NOT_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_NOT_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_NOT_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_NOT_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_NOT_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_NOT_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_RBIT_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize (← (BitReverse element))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_RBIT_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_RBIT_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_RBIT_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_RBIT_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_RBIT_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_RBIT_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQADD_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 +i element2) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQADD_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQADD_Z_ZZ__ 128 d esize m n is_unsigned)
  | 256 => (execute_UQADD_Z_ZZ__ 256 d esize m n is_unsigned)
  | 512 => (execute_UQADD_Z_ZZ__ 512 d esize m n is_unsigned)
  | 1024 => (execute_UQADD_Z_ZZ__ 1024 d esize m n is_unsigned)
  | 2048 => (execute_UQADD_Z_ZZ__ 2048 d esize m n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQADD_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 +i element2) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQADD_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQADD_Z_ZZ__ 128 d esize m n is_unsigned)
  | 256 => (execute_SQADD_Z_ZZ__ 256 d esize m n is_unsigned)
  | 512 => (execute_SQADD_Z_ZZ__ 512 d esize m n is_unsigned)
  | 1024 => (execute_SQADD_Z_ZZ__ 1024 d esize m n is_unsigned)
  | 2048 => (execute_SQADD_Z_ZZ__ 2048 d esize m n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQSUB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 -i element2) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQSUB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQSUB_Z_ZZ__ 128 d esize m n is_unsigned)
  | 256 => (execute_UQSUB_Z_ZZ__ 256 d esize m n is_unsigned)
  | 512 => (execute_UQSUB_Z_ZZ__ 512 d esize m n is_unsigned)
  | 1024 => (execute_UQSUB_Z_ZZ__ 1024 d esize m n is_unsigned)
  | 2048 => (execute_UQSUB_Z_ZZ__ 2048 d esize m n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQSUB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 -i element2) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQSUB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQSUB_Z_ZZ__ 128 d esize m n is_unsigned)
  | 256 => (execute_SQSUB_Z_ZZ__ 256 d esize m n is_unsigned)
  | 512 => (execute_SQSUB_Z_ZZ__ 512 d esize m n is_unsigned)
  | 1024 => (execute_SQSUB_Z_ZZ__ 1024 d esize m n is_unsigned)
  | 2048 => (execute_SQSUB_Z_ZZ__ 2048 d esize m n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, k_is_unsigned : Bool, esize ∈
  {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQADD_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 +i imm) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQADD_Z_ZI__ (size : (BitVec 2)) (U : (BitVec 1)) (sh : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (size ++ sh) (0b001 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let imm : Int := (BitVec.toNat imm8)
  let imm : Int :=
    bif (BEq.beq sh (0b1 : (BitVec 1)))
    then (Int.shiftl imm 8)
    else imm
  let imm := imm
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQADD_Z_ZI__ 128 dn esize imm is_unsigned)
  | 256 => (execute_UQADD_Z_ZI__ 256 dn esize imm is_unsigned)
  | 512 => (execute_UQADD_Z_ZI__ 512 dn esize imm is_unsigned)
  | 1024 => (execute_UQADD_Z_ZI__ 1024 dn esize imm is_unsigned)
  | 2048 => (execute_UQADD_Z_ZI__ 2048 dn esize imm is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, k_is_unsigned : Bool, esize ∈
  {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQADD_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 +i imm) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQADD_Z_ZI__ (size : (BitVec 2)) (U : (BitVec 1)) (sh : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (size ++ sh) (0b001 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let imm : Int := (BitVec.toNat imm8)
  let imm : Int :=
    bif (BEq.beq sh (0b1 : (BitVec 1)))
    then (Int.shiftl imm 8)
    else imm
  let imm := imm
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQADD_Z_ZI__ 128 dn esize imm is_unsigned)
  | 256 => (execute_SQADD_Z_ZI__ 256 dn esize imm is_unsigned)
  | 512 => (execute_SQADD_Z_ZI__ 512 dn esize imm is_unsigned)
  | 1024 => (execute_SQADD_Z_ZI__ 1024 dn esize imm is_unsigned)
  | 2048 => (execute_SQADD_Z_ZI__ 2048 dn esize imm is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, k_is_unsigned : Bool, esize ∈
  {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQSUB_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 -i imm) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQSUB_Z_ZI__ (size : (BitVec 2)) (U : (BitVec 1)) (sh : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (size ++ sh) (0b001 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let imm : Int := (BitVec.toNat imm8)
  let imm : Int :=
    bif (BEq.beq sh (0b1 : (BitVec 1)))
    then (Int.shiftl imm 8)
    else imm
  let imm := imm
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQSUB_Z_ZI__ 128 dn esize imm is_unsigned)
  | 256 => (execute_UQSUB_Z_ZI__ 256 dn esize imm is_unsigned)
  | 512 => (execute_UQSUB_Z_ZI__ 512 dn esize imm is_unsigned)
  | 1024 => (execute_UQSUB_Z_ZI__ 1024 dn esize imm is_unsigned)
  | 2048 => (execute_UQSUB_Z_ZI__ 2048 dn esize imm is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, imm : Int, k_is_unsigned : Bool, esize ∈
  {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQSUB_Z_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (imm : Int) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let (__tup_0, _) ← do (SatQ (element1 -i imm) esize is_unsigned)
        (Elem_set result e esize __tup_0)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQSUB_Z_ZI__ (size : (BitVec 2)) (U : (BitVec 1)) (sh : (BitVec 1)) (imm8 : (BitVec 8)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (size ++ sh) (0b001 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let imm : Int := (BitVec.toNat imm8)
  let imm : Int :=
    bif (BEq.beq sh (0b1 : (BitVec 1)))
    then (Int.shiftl imm 8)
    else imm
  let imm := imm
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQSUB_Z_ZI__ 128 dn esize imm is_unsigned)
  | 256 => (execute_SQSUB_Z_ZI__ 256 dn esize imm is_unsigned)
  | 512 => (execute_SQSUB_Z_ZI__ 512 dn esize imm is_unsigned)
  | 1024 => (execute_SQSUB_Z_ZI__ 1024 dn esize imm is_unsigned)
  | 2048 => (execute_SQSUB_Z_ZI__ 2048 dn esize imm is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_BRKPA_P_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last ← (( do (pure (BEq.beq (← (LastActive mask operand1 8)) (0b1 : (BitVec 1)))) ) :
    SailM Bool )
  let (last, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, result) := loop_vars
      loop_vars ← do
        let (last, result) ← (( do
          bif (← (ActivePredicateElement mask e 8))
          then
            (do
              let pbit : (BitVec 1) :=
                bif last
                then (0b1 : (BitVec 1))
                else (0b0 : (BitVec 1))
              let result ← (Elem_set result e 1 (Sail.BitVec.zeroExtend pbit 1))
              let last ←
                (pure (Bool.and last (Bool.not (← (ActivePredicateElement operand2 e 8)))))
              (pure (last, result)))
          else
            (do
              let result ← (Elem_set result e 1 (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) 1))
              (pure (last, result))) ) : SailM (Bool × (BitVec PL)) )
        (pure (last, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec PL)) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_BRKPA_P_P_PP__ (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (B : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_BRKPA_P_P_PP__ 128 d esize g m n setflags)
  | 256 => (execute_BRKPA_P_P_PP__ 256 d esize g m n setflags)
  | 512 => (execute_BRKPA_P_P_PP__ 512 d esize g m n setflags)
  | 1024 => (execute_BRKPA_P_P_PP__ 1024 d esize g m n setflags)
  | 2048 => (execute_BRKPA_P_P_PP__ 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_BRKPAS_P_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last ← (( do (pure (BEq.beq (← (LastActive mask operand1 8)) (0b1 : (BitVec 1)))) ) :
    SailM Bool )
  let (last, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, result) := loop_vars
      loop_vars ← do
        let (last, result) ← (( do
          bif (← (ActivePredicateElement mask e 8))
          then
            (do
              let pbit : (BitVec 1) :=
                bif last
                then (0b1 : (BitVec 1))
                else (0b0 : (BitVec 1))
              let result ← (Elem_set result e 1 (Sail.BitVec.zeroExtend pbit 1))
              let last ←
                (pure (Bool.and last (Bool.not (← (ActivePredicateElement operand2 e 8)))))
              (pure (last, result)))
          else
            (do
              let result ← (Elem_set result e 1 (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) 1))
              (pure (last, result))) ) : SailM (Bool × (BitVec PL)) )
        (pure (last, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec PL)) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_BRKPAS_P_P_PP__ (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (B : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_BRKPAS_P_P_PP__ 128 d esize g m n setflags)
  | 256 => (execute_BRKPAS_P_P_PP__ 256 d esize g m n setflags)
  | 512 => (execute_BRKPAS_P_P_PP__ 512 d esize g m n setflags)
  | 1024 => (execute_BRKPAS_P_P_PP__ 1024 d esize g m n setflags)
  | 2048 => (execute_BRKPAS_P_P_PP__ 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_BRKPB_P_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last ← (( do (pure (BEq.beq (← (LastActive mask operand1 8)) (0b1 : (BitVec 1)))) ) :
    SailM Bool )
  let (last, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, result) := loop_vars
      loop_vars ← do
        let (last, result) ← (( do
          bif (← (ActivePredicateElement mask e 8))
          then
            (do
              let last ←
                (pure (Bool.and last (Bool.not (← (ActivePredicateElement operand2 e 8)))))
              let pbit : (BitVec 1) :=
                bif last
                then (0b1 : (BitVec 1))
                else (0b0 : (BitVec 1))
              let result ← (Elem_set result e 1 (Sail.BitVec.zeroExtend pbit 1))
              (pure (last, result)))
          else
            (do
              let result ← (Elem_set result e 1 (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) 1))
              (pure (last, result))) ) : SailM (Bool × (BitVec PL)) )
        (pure (last, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec PL)) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_BRKPB_P_P_PP__ (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (B : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_BRKPB_P_P_PP__ 128 d esize g m n setflags)
  | 256 => (execute_BRKPB_P_P_PP__ 256 d esize g m n setflags)
  | 512 => (execute_BRKPB_P_P_PP__ 512 d esize g m n setflags)
  | 1024 => (execute_BRKPB_P_P_PP__ 1024 d esize g m n setflags)
  | 2048 => (execute_BRKPB_P_P_PP__ 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, k_setflags : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_BRKPBS_P_P_PP__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let last ← (( do (pure (BEq.beq (← (LastActive mask operand1 8)) (0b1 : (BitVec 1)))) ) :
    SailM Bool )
  let (last, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (last, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, result) := loop_vars
      loop_vars ← do
        let (last, result) ← (( do
          bif (← (ActivePredicateElement mask e 8))
          then
            (do
              let last ←
                (pure (Bool.and last (Bool.not (← (ActivePredicateElement operand2 e 8)))))
              let pbit : (BitVec 1) :=
                bif last
                then (0b1 : (BitVec 1))
                else (0b0 : (BitVec 1))
              let result ← (Elem_set result e 1 (Sail.BitVec.zeroExtend pbit 1))
              (pure (last, result)))
          else
            (do
              let result ← (Elem_set result e 1 (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) 1))
              (pure (last, result))) ) : SailM (Bool × (BitVec PL)) )
        (pure (last, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec PL)) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest mask result esize)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set d PL result)

def decode_BRKPBS_P_P_PP__ (S : (BitVec 1)) (Pm : (BitVec 4)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (B : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_BRKPBS_P_P_PP__ 128 d esize g m n setflags)
  | 256 => (execute_BRKPBS_P_P_PP__ 256 d esize g m n setflags)
  | 512 => (execute_BRKPBS_P_P_PP__ 512 d esize g m n setflags)
  | 1024 => (execute_BRKPBS_P_P_PP__ 1024 d esize g m n setflags)
  | 2048 => (execute_BRKPBS_P_P_PP__ 2048 d esize g m n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dm : Nat, g : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ 0 ≤ dm ∧ dm ≤ 15 ∧ is_VL(VL) -/
def execute_BRKN_P_P_PP__ (VL : Nat) (dm : Nat) (g : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read dm PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let result ← (( do
    bif (BEq.beq (← (LastActive mask operand1 8)) (0b1 : (BitVec 1)))
    then (pure operand2)
    else (pure (Zeros (n := PL))) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest (Ones (n := PL)) result 8)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set dm PL result)

def decode_BRKN_P_P_PP__ (S : (BitVec 1)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pdm : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let dm := (BitVec.toNat Pdm)
  let setflags : Bool := false
  match VL with
  | 128 => (execute_BRKN_P_P_PP__ 128 dm g n setflags)
  | 256 => (execute_BRKN_P_P_PP__ 256 dm g n setflags)
  | 512 => (execute_BRKN_P_P_PP__ 512 dm g n setflags)
  | 1024 => (execute_BRKN_P_P_PP__ 1024 dm g n setflags)
  | 2048 => (execute_BRKN_P_P_PP__ 2048 dm g n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dm : Nat, g : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ g ∧ g ≤ 15 ∧ 0 ≤ dm ∧ dm ≤ 15 ∧ is_VL(VL) -/
def execute_BRKNS_P_P_PP__ (VL : Nat) (dm : Nat) (g : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read dm PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let result ← (( do
    bif (BEq.beq (← (LastActive mask operand1 8)) (0b1 : (BitVec 1)))
    then (pure operand2)
    else (pure (Zeros (n := PL))) ) : SailM (BitVec PL) )
  bif setflags
  then
    (do
      let split_vec ← do (PredTest (Ones (n := PL)) result 8)
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
  else (pure ())
  (P_set dm PL result)

def decode_BRKNS_P_P_PP__ (S : (BitVec 1)) (Pg : (BitVec 4)) (Pn : (BitVec 4)) (Pdm : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Pn)
  let dm := (BitVec.toNat Pdm)
  let setflags : Bool := true
  match VL with
  | 128 => (execute_BRKNS_P_P_PP__ 128 dm g n setflags)
  | 256 => (execute_BRKNS_P_P_PP__ 256 dm g n setflags)
  | 512 => (execute_BRKNS_P_P_PP__ 512 dm g n setflags)
  | 1024 => (execute_BRKNS_P_P_PP__ 1024 dm g n setflags)
  | 2048 => (execute_BRKNS_P_P_PP__ 2048 dm g n setflags)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INSR_Z_V__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dest ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let src ← (( do (V_read m esize) ) : SailM (BitVec esize) )
  (Z_set dn VL ((Sail.BitVec.extractLsb dest ((VL -i esize) -i 1) 0) ++ src))

def decode_INSR_Z_V__ (size : (BitVec 2)) (Vm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Vm)
  match VL with
  | 128 => (execute_INSR_Z_V__ 128 dn esize m)
  | 256 => (execute_INSR_Z_V__ 256 dn esize m)
  | 512 => (execute_INSR_Z_V__ 512 dn esize m)
  | 1024 => (execute_INSR_Z_V__ 1024 dn esize m)
  | 2048 => (execute_INSR_Z_V__ 2048 dn esize m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_INSR_Z_R__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let dest ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let src ← (( do (X_read m esize) ) : SailM (BitVec esize) )
  (Z_set dn VL ((Sail.BitVec.extractLsb dest ((VL -i esize) -i 1) 0) ++ src))

def decode_INSR_Z_R__ (size : (BitVec 2)) (Rm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Rm)
  match VL with
  | 128 => (execute_INSR_Z_R__ 128 dn esize m)
  | 256 => (execute_INSR_Z_R__ 256 dn esize m)
  | 512 => (execute_INSR_Z_R__ 512 dn esize m)
  | 1024 => (execute_INSR_Z_R__ 1024 dn esize m)
  | 2048 => (execute_INSR_Z_R__ 2048 dn esize m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SDOT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toInt (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
              let element2 ← do
                (pure (BitVec.toInt (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SDOT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SDOT_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SDOT_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SDOT_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SDOT_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SDOT_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SDOT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toInt (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
              let element2 ← do
                (pure (BitVec.toInt (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SDOT_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SDOT_Z_ZZZi_S 128 da esize index m n)
  | 256 => (execute_SDOT_Z_ZZZi_S 256 da esize index m n)
  | 512 => (execute_SDOT_Z_ZZZi_S 512 da esize index m n)
  | 1024 => (execute_SDOT_Z_ZZZi_S 1024 da esize index m n)
  | 2048 => (execute_SDOT_Z_ZZZi_S 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SDOT_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toInt (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
              let element2 ← do
                (pure (BitVec.toInt (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SDOT_Z_ZZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SDOT_Z_ZZZi_D 128 da esize index m n)
  | 256 => (execute_SDOT_Z_ZZZi_D 256 da esize index m n)
  | 512 => (execute_SDOT_Z_ZZZi_D 512 da esize index m n)
  | 1024 => (execute_SDOT_Z_ZZZi_D 1024 da esize index m n)
  | 2048 => (execute_SDOT_Z_ZZZi_D 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UDOT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toNat (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
              let element2 ← do
                (pure (BitVec.toNat (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UDOT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UDOT_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_UDOT_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_UDOT_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_UDOT_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_UDOT_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UDOT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toNat (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
              let element2 ← do
                (pure (BitVec.toNat (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UDOT_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UDOT_Z_ZZZi_S 128 da esize index m n)
  | 256 => (execute_UDOT_Z_ZZZi_S 256 da esize index m n)
  | 512 => (execute_UDOT_Z_ZZZi_S 512 da esize index m n)
  | 1024 => (execute_UDOT_Z_ZZZi_S 1024 da esize index m n)
  | 2048 => (execute_UDOT_Z_ZZZi_S 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UDOT_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toNat (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
              let element2 ← do
                (pure (BitVec.toNat (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UDOT_Z_ZZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UDOT_Z_ZZZi_D 128 da esize index m n)
  | 256 => (execute_UDOT_Z_ZZZi_D 256 da esize index m n)
  | 512 => (execute_UDOT_Z_ZZZi_D 512 da esize index m n)
  | 1024 => (execute_UDOT_Z_ZZZi_D 1024 da esize index m n)
  | 2048 => (execute_UDOT_Z_ZZZi_D 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_USDOT_Z_ZZZ_S (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toNat (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
              let element2 ← do
                (pure (BitVec.toInt (← (Elem_read operand2 ((4 *i e) +i i) (Int.ediv esize 4)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_USDOT_Z_ZZZ_S (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveInt8MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_USDOT_Z_ZZZ_S 128 da esize m n)
  | 256 => (execute_USDOT_Z_ZZZ_S 256 da esize m n)
  | 512 => (execute_USDOT_Z_ZZZ_S 512 da esize m n)
  | 1024 => (execute_USDOT_Z_ZZZ_S 1024 da esize m n)
  | 2048 => (execute_USDOT_Z_ZZZ_S 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_USDOT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toNat (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
              let element2 ← do
                (pure (BitVec.toInt (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_USDOT_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveInt8MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_USDOT_Z_ZZZi_S 128 da esize index m n)
  | 256 => (execute_USDOT_Z_ZZZi_S 256 da esize index m n)
  | 512 => (execute_USDOT_Z_ZZZi_S 512 da esize index m n)
  | 1024 => (execute_USDOT_Z_ZZZi_S 1024 da esize index m n)
  | 2048 => (execute_USDOT_Z_ZZZi_S 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SUDOT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 3
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toInt (← (Elem_read operand1 ((4 *i e) +i i) (Int.ediv esize 4)))))
              let element2 ← do
                (pure (BitVec.toNat (← (Elem_read operand2 ((4 *i s) +i i) (Int.ediv esize 4)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SUDOT_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
       (Bool.not (← (HaveInt8MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SUDOT_Z_ZZZi_S 128 da esize index m n)
  | 256 => (execute_SUDOT_Z_ZZZi_S 256 da esize index m n)
  | 512 => (execute_SUDOT_Z_ZZZi_S 512 da esize index m n)
  | 1024 => (execute_SUDOT_Z_ZZZi_S 1024 da esize index m n)
  | 2048 => (execute_SUDOT_Z_ZZZi_S 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SDOT_Z32_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
              let element2 ← do
                (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SDOT_Z32_ZZZ__ (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SDOT_Z32_ZZZ__ 128 da esize m n)
  | 256 => (execute_SDOT_Z32_ZZZ__ 256 da esize m n)
  | 512 => (execute_SDOT_Z32_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SDOT_Z32_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SDOT_Z32_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SDOT_Z32_ZZZi__ (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
              let element2 ← do
                (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i i) (Int.ediv esize 2)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SDOT_Z32_ZZZi__ (i2 : (BitVec 2)) (Zm : (BitVec 3)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SDOT_Z32_ZZZi__ 128 da esize index m n)
  | 256 => (execute_SDOT_Z32_ZZZi__ 256 da esize index m n)
  | 512 => (execute_SDOT_Z32_ZZZi__ 512 da esize index m n)
  | 1024 => (execute_SDOT_Z32_ZZZi__ 1024 da esize index m n)
  | 2048 => (execute_SDOT_Z32_ZZZi__ 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UDOT_Z32_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
              let element2 ← do
                (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i i) (Int.ediv esize 2)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UDOT_Z32_ZZZ__ (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UDOT_Z32_ZZZ__ 128 da esize m n)
  | 256 => (execute_UDOT_Z32_ZZZ__ 256 da esize m n)
  | 512 => (execute_UDOT_Z32_ZZZ__ 512 da esize m n)
  | 1024 => (execute_UDOT_Z32_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_UDOT_Z32_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UDOT_Z32_ZZZi__ (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let element1 ← do
                (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i i) (Int.ediv esize 2)))))
              let element2 ← do
                (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i i) (Int.ediv esize 2)))))
              (pure (BitVec.addInt res (element1 *i element2)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UDOT_Z32_ZZZi__ (i2 : (BitVec 2)) (Zm : (BitVec 3)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UDOT_Z32_ZZZi__ 128 da esize index m n)
  | 256 => (execute_UDOT_Z32_ZZZi__ 256 da esize index m n)
  | 512 => (execute_UDOT_Z32_ZZZi__ 512 da esize index m n)
  | 1024 => (execute_UDOT_Z32_ZZZi__ 1024 da esize index m n)
  | 2048 => (execute_UDOT_Z32_ZZZi__ 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQABS_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (pure (BitVec.toInt (← (Elem_read operand e esize)))) ) : SailM
              Int )
            let element := (Int.natAbs element)
            (Elem_set result e esize (← (SignedSat element esize))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQABS_Z_P_Z__ (size : (BitVec 2)) (Q : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQABS_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_SQABS_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_SQABS_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_SQABS_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_SQABS_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQNEG_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (pure (BitVec.toInt (← (Elem_read operand e esize)))) ) : SailM
              Int )
            let element := (Neg.neg element)
            (Elem_set result e esize (← (SignedSat element esize))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQNEG_Z_P_Z__ (size : (BitVec 2)) (Q : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQNEG_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_SQNEG_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_SQNEG_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_SQNEG_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_SQNEG_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULH_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e esize (← (SignedSat (Int.shiftr res esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQDMULH_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (R : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQDMULH_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SQDMULH_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SQDMULH_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SQDMULH_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SQDMULH_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMULH_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRDMULH_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (R : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQRDMULH_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SQRDMULH_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SQRDMULH_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SQRDMULH_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SQRDMULH_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMLAH_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let res := ((Int.shiftl element3 esize) +i ((2 *i element1) *i element2))
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQRDMLAH_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SQRDMLAH_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SQRDMLAH_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SQRDMLAH_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SQRDMLAH_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SQRDMLAH_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMLSH_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let res := ((Int.shiftl element3 esize) -i ((2 *i element1) *i element2))
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQRDMLSH_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SQRDMLSH_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SQRDMLSH_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SQRDMLSH_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SQRDMLSH_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SQRDMLSH_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_ADDP_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2, result) ← (( do
          bif (Bool.not (← (ActivePredicateElement mask e esize)))
          then
            (do
              let result ← (Elem_set result e esize (← (Elem_read operand1 e esize)))
              (pure (element1, element2, result)))
          else
            (do
              let (element1, element2) ← (( do
                bif (IsEven e)
                then
                  (do
                    let element1 ← (pure (BitVec.toNat (← (Elem_read operand1 (e +i 0) esize))))
                    let element2 ← (pure (BitVec.toNat (← (Elem_read operand1 (e +i 1) esize))))
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ← (pure (BitVec.toNat (← (Elem_read operand2 (e -i 1) esize))))
                    let element2 ← (pure (BitVec.toNat (← (Elem_read operand2 (e +i 0) esize))))
                    (pure (element1, element2))) ) : SailM (Int × Int) )
              let res := (element1 +i element2)
              let result ← (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
              (pure (element1, element2, result))) ) : SailM (Int × Int × (BitVec VL)) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec VL)) )
  (Z_set dn VL result)

def decode_ADDP_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_ADDP_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_ADDP_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_ADDP_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_ADDP_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_ADDP_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMAXP_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2, result) ← (( do
          bif (Bool.not (← (ActivePredicateElement mask e esize)))
          then
            (do
              let result ← (Elem_set result e esize (← (Elem_read operand1 e esize)))
              (pure (element1, element2, result)))
          else
            (do
              let (element1, element2) ← (( do
                bif (IsEven e)
                then
                  (do
                    let element1 ← (pure (BitVec.toNat (← (Elem_read operand1 (e +i 0) esize))))
                    let element2 ← (pure (BitVec.toNat (← (Elem_read operand1 (e +i 1) esize))))
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ← (pure (BitVec.toNat (← (Elem_read operand2 (e -i 1) esize))))
                    let element2 ← (pure (BitVec.toNat (← (Elem_read operand2 (e +i 0) esize))))
                    (pure (element1, element2))) ) : SailM (Int × Int) )
              let res := (Max.max element1 element2)
              let result ← (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
              (pure (element1, element2, result))) ) : SailM (Int × Int × (BitVec VL)) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec VL)) )
  (Z_set dn VL result)

def decode_UMAXP_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_UMAXP_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_UMAXP_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_UMAXP_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_UMAXP_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_UMAXP_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMAXP_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2, result) ← (( do
          bif (Bool.not (← (ActivePredicateElement mask e esize)))
          then
            (do
              let result ← (Elem_set result e esize (← (Elem_read operand1 e esize)))
              (pure (element1, element2, result)))
          else
            (do
              let (element1, element2) ← (( do
                bif (IsEven e)
                then
                  (do
                    let element1 ← (pure (BitVec.toInt (← (Elem_read operand1 (e +i 0) esize))))
                    let element2 ← (pure (BitVec.toInt (← (Elem_read operand1 (e +i 1) esize))))
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ← (pure (BitVec.toInt (← (Elem_read operand2 (e -i 1) esize))))
                    let element2 ← (pure (BitVec.toInt (← (Elem_read operand2 (e +i 0) esize))))
                    (pure (element1, element2))) ) : SailM (Int × Int) )
              let res := (Max.max element1 element2)
              let result ← (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
              (pure (element1, element2, result))) ) : SailM (Int × Int × (BitVec VL)) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec VL)) )
  (Z_set dn VL result)

def decode_SMAXP_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_SMAXP_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SMAXP_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SMAXP_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SMAXP_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SMAXP_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UMINP_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2, result) ← (( do
          bif (Bool.not (← (ActivePredicateElement mask e esize)))
          then
            (do
              let result ← (Elem_set result e esize (← (Elem_read operand1 e esize)))
              (pure (element1, element2, result)))
          else
            (do
              let (element1, element2) ← (( do
                bif (IsEven e)
                then
                  (do
                    let element1 ← (pure (BitVec.toNat (← (Elem_read operand1 (e +i 0) esize))))
                    let element2 ← (pure (BitVec.toNat (← (Elem_read operand1 (e +i 1) esize))))
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ← (pure (BitVec.toNat (← (Elem_read operand2 (e -i 1) esize))))
                    let element2 ← (pure (BitVec.toNat (← (Elem_read operand2 (e +i 0) esize))))
                    (pure (element1, element2))) ) : SailM (Int × Int) )
              let res := (Min.min element1 element2)
              let result ← (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
              (pure (element1, element2, result))) ) : SailM (Int × Int × (BitVec VL)) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec VL)) )
  (Z_set dn VL result)

def decode_UMINP_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_UMINP_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_UMINP_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_UMINP_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_UMINP_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_UMINP_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SMINP_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  let (element1, element2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (element1, element2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (element1, element2, result) := loop_vars
      loop_vars ← do
        let (element1, element2, result) ← (( do
          bif (Bool.not (← (ActivePredicateElement mask e esize)))
          then
            (do
              let result ← (Elem_set result e esize (← (Elem_read operand1 e esize)))
              (pure (element1, element2, result)))
          else
            (do
              let (element1, element2) ← (( do
                bif (IsEven e)
                then
                  (do
                    let element1 ← (pure (BitVec.toInt (← (Elem_read operand1 (e +i 0) esize))))
                    let element2 ← (pure (BitVec.toInt (← (Elem_read operand1 (e +i 1) esize))))
                    (pure (element1, element2)))
                else
                  (do
                    let element1 ← (pure (BitVec.toInt (← (Elem_read operand2 (e -i 1) esize))))
                    let element2 ← (pure (BitVec.toInt (← (Elem_read operand2 (e +i 0) esize))))
                    (pure (element1, element2))) ) : SailM (Int × Int) )
              let res := (Min.min element1 element2)
              let result ← (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
              (pure (element1, element2, result))) ) : SailM (Int × Int × (BitVec VL)) )
        (pure (element1, element2, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec VL)) )
  (Z_set dn VL result)

def decode_SMINP_Z_P_ZZ__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_SMINP_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SMINP_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SMINP_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SMINP_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SMINP_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SADALP_Z_P_Z__ (VL : Nat) (da : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand_acc ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let operand_src ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (Bool.not (← (ActivePredicateElement mask e esize)))
        then
          (do
            (Elem_set result e esize (← (Elem_read operand_acc e esize))))
        else
          (do
            let element1 ← do
              (pure (BitVec.toInt (← (Elem_read operand_src ((2 *i e) +i 0) (Int.ediv esize 2)))))
            let element2 ← do
              (pure (BitVec.toInt (← (Elem_read operand_src ((2 *i e) +i 1) (Int.ediv esize 2)))))
            let sum : (BitVec esize) := (integer_subrange (element1 +i element2) (esize -i 1) 0)
            (Elem_set result e esize ((← (Elem_read operand_acc e esize)) + sum)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SADALP_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SADALP_Z_P_Z__ 128 da esize g n)
  | 256 => (execute_SADALP_Z_P_Z__ 256 da esize g n)
  | 512 => (execute_SADALP_Z_P_Z__ 512 da esize g n)
  | 1024 => (execute_SADALP_Z_P_Z__ 1024 da esize g n)
  | 2048 => (execute_SADALP_Z_P_Z__ 2048 da esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UADALP_Z_P_Z__ (VL : Nat) (da : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand_acc ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let operand_src ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (Bool.not (← (ActivePredicateElement mask e esize)))
        then
          (do
            (Elem_set result e esize (← (Elem_read operand_acc e esize))))
        else
          (do
            let element1 ← do
              (pure (BitVec.toNat (← (Elem_read operand_src ((2 *i e) +i 0) (Int.ediv esize 2)))))
            let element2 ← do
              (pure (BitVec.toNat (← (Elem_read operand_src ((2 *i e) +i 1) (Int.ediv esize 2)))))
            let sum : (BitVec esize) := (integer_subrange (element1 +i element2) (esize -i 1) 0)
            (Elem_set result e esize ((← (Elem_read operand_acc e esize)) + sum)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UADALP_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UADALP_Z_P_Z__ 128 da esize g n)
  | 256 => (execute_UADALP_Z_P_Z__ 256 da esize g n)
  | 512 => (execute_UADALP_Z_P_Z__ 512 da esize g n)
  | 1024 => (execute_UADALP_Z_P_Z__ 1024 da esize g n)
  | 2048 => (execute_UADALP_Z_P_Z__ 2048 da esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SHRNB_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res := (_shr_int_general (BitVec.toNat element) shift)
        let result ← (Elem_set result ((2 *i e) +i 0) esize (integer_subrange res (esize -i 1) 0))
        (Elem_set result ((2 *i e) +i 1) esize (Zeros (n := esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SHRNB_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_SHRNB_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SHRNB_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SHRNB_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SHRNB_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SHRNB_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SHRNT_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res := (_shr_int_general (BitVec.toNat element) shift)
        (Elem_set result ((2 *i e) +i 1) esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SHRNT_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_SHRNT_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SHRNT_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SHRNT_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SHRNT_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SHRNT_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_RSHRNB_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res :=
          (_shr_int_general ((BitVec.toNat element) +i (_shl_int_general 1 (shift -i 1))) shift)
        let result ← (Elem_set result ((2 *i e) +i 0) esize (integer_subrange res (esize -i 1) 0))
        (Elem_set result ((2 *i e) +i 1) esize (Zeros (n := esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_RSHRNB_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_RSHRNB_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_RSHRNB_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_RSHRNB_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_RSHRNB_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_RSHRNB_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_RSHRNT_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res :=
          (_shr_int_general ((BitVec.toNat element) +i (_shl_int_general 1 (shift -i 1))) shift)
        (Elem_set result ((2 *i e) +i 1) esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_RSHRNT_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_RSHRNT_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_RSHRNT_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_RSHRNT_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_RSHRNT_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_RSHRNT_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQSHRNB_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res := (_shr_int_general (BitVec.toInt element) shift)
        let result ← (Elem_set result ((2 *i e) +i 0) esize (← (SignedSat res esize)))
        (Elem_set result ((2 *i e) +i 1) esize (Zeros (n := esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQSHRNB_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_SQSHRNB_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SQSHRNB_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SQSHRNB_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SQSHRNB_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SQSHRNB_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQSHRNT_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res := (_shr_int_general (BitVec.toInt element) shift)
        (Elem_set result ((2 *i e) +i 1) esize (← (SignedSat res esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQSHRNT_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_SQSHRNT_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SQSHRNT_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SQSHRNT_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SQSHRNT_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SQSHRNT_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQSHRNB_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res := (_shr_int_general (BitVec.toNat element) shift)
        let result ← (Elem_set result ((2 *i e) +i 0) esize (← (UnsignedSat res esize)))
        (Elem_set result ((2 *i e) +i 1) esize (Zeros (n := esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQSHRNB_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_UQSHRNB_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_UQSHRNB_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_UQSHRNB_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_UQSHRNB_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_UQSHRNB_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQSHRNT_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res := (_shr_int_general (BitVec.toNat element) shift)
        (Elem_set result ((2 *i e) +i 1) esize (← (UnsignedSat res esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQSHRNT_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_UQSHRNT_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_UQSHRNT_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_UQSHRNT_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_UQSHRNT_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_UQSHRNT_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHRNB_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res :=
          (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
        let result ← (Elem_set result ((2 *i e) +i 0) esize (← (SignedSat res esize)))
        (Elem_set result ((2 *i e) +i 1) esize (Zeros (n := esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHRNB_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_SQRSHRNB_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SQRSHRNB_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SQRSHRNB_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SQRSHRNB_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHRNB_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHRNT_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res :=
          (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
        (Elem_set result ((2 *i e) +i 1) esize (← (SignedSat res esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHRNT_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_SQRSHRNT_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SQRSHRNT_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SQRSHRNT_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SQRSHRNT_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHRNT_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQRSHRNB_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res :=
          (_shr_int_general ((BitVec.toNat element) +i (_shl_int_general 1 (shift -i 1))) shift)
        let result ← (Elem_set result ((2 *i e) +i 0) esize (← (UnsignedSat res esize)))
        (Elem_set result ((2 *i e) +i 1) esize (Zeros (n := esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQRSHRNB_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_UQRSHRNB_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_UQRSHRNB_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_UQRSHRNB_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_UQRSHRNB_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_UQRSHRNB_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQRSHRNT_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res :=
          (_shr_int_general ((BitVec.toNat element) +i (_shl_int_general 1 (shift -i 1))) shift)
        (Elem_set result ((2 *i e) +i 1) esize (← (UnsignedSat res esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQRSHRNT_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_UQRSHRNT_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_UQRSHRNT_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_UQRSHRNT_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_UQRSHRNT_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_UQRSHRNT_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQSHRUNB_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res := (_shr_int_general (BitVec.toInt element) shift)
        let result ← (Elem_set result ((2 *i e) +i 0) esize (← (UnsignedSat res esize)))
        (Elem_set result ((2 *i e) +i 1) esize (Zeros (n := esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQSHRUNB_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_SQSHRUNB_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SQSHRUNB_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SQSHRUNB_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SQSHRUNB_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SQSHRUNB_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQSHRUNT_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res := (_shr_int_general (BitVec.toInt element) shift)
        (Elem_set result ((2 *i e) +i 1) esize (← (UnsignedSat res esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQSHRUNT_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_SQSHRUNT_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SQSHRUNT_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SQSHRUNT_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SQSHRUNT_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SQSHRUNT_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHRUNB_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res :=
          (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
        let result ← (Elem_set result ((2 *i e) +i 0) esize (← (UnsignedSat res esize)))
        (Elem_set result ((2 *i e) +i 1) esize (Zeros (n := esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHRUNB_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_SQRSHRUNB_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SQRSHRUNB_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SQRSHRUNB_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SQRSHRUNB_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHRUNB_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHRUNT_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
        let res :=
          (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
        (Elem_set result ((2 *i e) +i 1) esize (← (UnsignedSat res esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHRUNT_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match VL with
  | 128 => (execute_SQRSHRUNT_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SQRSHRUNT_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SQRSHRUNT_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SQRSHRUNT_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHRUNT_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, shift : Int, g ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SRSHR_Z_P_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (_shr_int_general (element1 +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SRSHR_Z_P_ZI__ (tszh : (BitVec 2)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_SRSHR_Z_P_ZI__ 128 dn 8 g shift)
      | 256 => (execute_SRSHR_Z_P_ZI__ 256 dn 8 g shift)
      | 512 => (execute_SRSHR_Z_P_ZI__ 512 dn 8 g shift)
      | 1024 => (execute_SRSHR_Z_P_ZI__ 1024 dn 8 g shift)
      | 2048 => (execute_SRSHR_Z_P_ZI__ 2048 dn 8 g shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_SRSHR_Z_P_ZI__ 128 dn 16 g shift)
      | 256 => (execute_SRSHR_Z_P_ZI__ 256 dn 16 g shift)
      | 512 => (execute_SRSHR_Z_P_ZI__ 512 dn 16 g shift)
      | 1024 => (execute_SRSHR_Z_P_ZI__ 1024 dn 16 g shift)
      | 2048 => (execute_SRSHR_Z_P_ZI__ 2048 dn 16 g shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_SRSHR_Z_P_ZI__ 128 dn 32 g shift)
      | 256 => (execute_SRSHR_Z_P_ZI__ 256 dn 32 g shift)
      | 512 => (execute_SRSHR_Z_P_ZI__ 512 dn 32 g shift)
      | 1024 => (execute_SRSHR_Z_P_ZI__ 1024 dn 32 g shift)
      | 2048 => (execute_SRSHR_Z_P_ZI__ 2048 dn 32 g shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_SRSHR_Z_P_ZI__ 128 dn 64 g shift)
      | 256 => (execute_SRSHR_Z_P_ZI__ 256 dn 64 g shift)
      | 512 => (execute_SRSHR_Z_P_ZI__ 512 dn 64 g shift)
      | 1024 => (execute_SRSHR_Z_P_ZI__ 1024 dn 64 g shift)
      | 2048 => (execute_SRSHR_Z_P_ZI__ 2048 dn 64 g shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:37602.22-37602.23"

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, shift : Int, g ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_URSHR_Z_P_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (_shr_int_general (element1 +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_URSHR_Z_P_ZI__ (tszh : (BitVec 2)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_URSHR_Z_P_ZI__ 128 dn 8 g shift)
      | 256 => (execute_URSHR_Z_P_ZI__ 256 dn 8 g shift)
      | 512 => (execute_URSHR_Z_P_ZI__ 512 dn 8 g shift)
      | 1024 => (execute_URSHR_Z_P_ZI__ 1024 dn 8 g shift)
      | 2048 => (execute_URSHR_Z_P_ZI__ 2048 dn 8 g shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_URSHR_Z_P_ZI__ 128 dn 16 g shift)
      | 256 => (execute_URSHR_Z_P_ZI__ 256 dn 16 g shift)
      | 512 => (execute_URSHR_Z_P_ZI__ 512 dn 16 g shift)
      | 1024 => (execute_URSHR_Z_P_ZI__ 1024 dn 16 g shift)
      | 2048 => (execute_URSHR_Z_P_ZI__ 2048 dn 16 g shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_URSHR_Z_P_ZI__ 128 dn 32 g shift)
      | 256 => (execute_URSHR_Z_P_ZI__ 256 dn 32 g shift)
      | 512 => (execute_URSHR_Z_P_ZI__ 512 dn 32 g shift)
      | 1024 => (execute_URSHR_Z_P_ZI__ 1024 dn 32 g shift)
      | 2048 => (execute_URSHR_Z_P_ZI__ 2048 dn 32 g shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_URSHR_Z_P_ZI__ 128 dn 64 g shift)
      | 256 => (execute_URSHR_Z_P_ZI__ 256 dn 64 g shift)
      | 512 => (execute_URSHR_Z_P_ZI__ 512 dn 64 g shift)
      | 1024 => (execute_URSHR_Z_P_ZI__ 1024 dn 64 g shift)
      | 2048 => (execute_URSHR_Z_P_ZI__ 2048 dn 64 g shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:37755.22-37755.23"

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, shift : Int, g ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQSHL_Z_P_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (_shl_int_general element1 shift)
            (Elem_set result e esize (← (SignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQSHL_Z_P_ZI__ (tszh : (BitVec 2)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let shift := ((BitVec.toNat (tsize ++ imm3)) -i esize)
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_SQSHL_Z_P_ZI__ 128 dn 8 g shift)
      | 256 => (execute_SQSHL_Z_P_ZI__ 256 dn 8 g shift)
      | 512 => (execute_SQSHL_Z_P_ZI__ 512 dn 8 g shift)
      | 1024 => (execute_SQSHL_Z_P_ZI__ 1024 dn 8 g shift)
      | 2048 => (execute_SQSHL_Z_P_ZI__ 2048 dn 8 g shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_SQSHL_Z_P_ZI__ 128 dn 16 g shift)
      | 256 => (execute_SQSHL_Z_P_ZI__ 256 dn 16 g shift)
      | 512 => (execute_SQSHL_Z_P_ZI__ 512 dn 16 g shift)
      | 1024 => (execute_SQSHL_Z_P_ZI__ 1024 dn 16 g shift)
      | 2048 => (execute_SQSHL_Z_P_ZI__ 2048 dn 16 g shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_SQSHL_Z_P_ZI__ 128 dn 32 g shift)
      | 256 => (execute_SQSHL_Z_P_ZI__ 256 dn 32 g shift)
      | 512 => (execute_SQSHL_Z_P_ZI__ 512 dn 32 g shift)
      | 1024 => (execute_SQSHL_Z_P_ZI__ 1024 dn 32 g shift)
      | 2048 => (execute_SQSHL_Z_P_ZI__ 2048 dn 32 g shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_SQSHL_Z_P_ZI__ 128 dn 64 g shift)
      | 256 => (execute_SQSHL_Z_P_ZI__ 256 dn 64 g shift)
      | 512 => (execute_SQSHL_Z_P_ZI__ 512 dn 64 g shift)
      | 1024 => (execute_SQSHL_Z_P_ZI__ 1024 dn 64 g shift)
      | 2048 => (execute_SQSHL_Z_P_ZI__ 2048 dn 64 g shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:37908.22-37908.23"

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, shift : Int, g ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQSHL_Z_P_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (_shl_int_general element1 shift)
            (Elem_set result e esize (← (UnsignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQSHL_Z_P_ZI__ (tszh : (BitVec 2)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let shift := ((BitVec.toNat (tsize ++ imm3)) -i esize)
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_UQSHL_Z_P_ZI__ 128 dn 8 g shift)
      | 256 => (execute_UQSHL_Z_P_ZI__ 256 dn 8 g shift)
      | 512 => (execute_UQSHL_Z_P_ZI__ 512 dn 8 g shift)
      | 1024 => (execute_UQSHL_Z_P_ZI__ 1024 dn 8 g shift)
      | 2048 => (execute_UQSHL_Z_P_ZI__ 2048 dn 8 g shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_UQSHL_Z_P_ZI__ 128 dn 16 g shift)
      | 256 => (execute_UQSHL_Z_P_ZI__ 256 dn 16 g shift)
      | 512 => (execute_UQSHL_Z_P_ZI__ 512 dn 16 g shift)
      | 1024 => (execute_UQSHL_Z_P_ZI__ 1024 dn 16 g shift)
      | 2048 => (execute_UQSHL_Z_P_ZI__ 2048 dn 16 g shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_UQSHL_Z_P_ZI__ 128 dn 32 g shift)
      | 256 => (execute_UQSHL_Z_P_ZI__ 256 dn 32 g shift)
      | 512 => (execute_UQSHL_Z_P_ZI__ 512 dn 32 g shift)
      | 1024 => (execute_UQSHL_Z_P_ZI__ 1024 dn 32 g shift)
      | 2048 => (execute_UQSHL_Z_P_ZI__ 2048 dn 32 g shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_UQSHL_Z_P_ZI__ 128 dn 64 g shift)
      | 256 => (execute_UQSHL_Z_P_ZI__ 256 dn 64 g shift)
      | 512 => (execute_UQSHL_Z_P_ZI__ 512 dn 64 g shift)
      | 1024 => (execute_UQSHL_Z_P_ZI__ 1024 dn 64 g shift)
      | 2048 => (execute_UQSHL_Z_P_ZI__ 2048 dn 64 g shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:38061.22-38061.23"

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, shift : Int, g ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQSHLU_Z_P_ZI__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (_shl_int_general element1 shift)
            (Elem_set result e esize (← (UnsignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQSHLU_Z_P_ZI__ (tszh : (BitVec 2)) (L : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let shift := ((BitVec.toNat (tsize ++ imm3)) -i esize)
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_SQSHLU_Z_P_ZI__ 128 dn 8 g shift)
      | 256 => (execute_SQSHLU_Z_P_ZI__ 256 dn 8 g shift)
      | 512 => (execute_SQSHLU_Z_P_ZI__ 512 dn 8 g shift)
      | 1024 => (execute_SQSHLU_Z_P_ZI__ 1024 dn 8 g shift)
      | 2048 => (execute_SQSHLU_Z_P_ZI__ 2048 dn 8 g shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_SQSHLU_Z_P_ZI__ 128 dn 16 g shift)
      | 256 => (execute_SQSHLU_Z_P_ZI__ 256 dn 16 g shift)
      | 512 => (execute_SQSHLU_Z_P_ZI__ 512 dn 16 g shift)
      | 1024 => (execute_SQSHLU_Z_P_ZI__ 1024 dn 16 g shift)
      | 2048 => (execute_SQSHLU_Z_P_ZI__ 2048 dn 16 g shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_SQSHLU_Z_P_ZI__ 128 dn 32 g shift)
      | 256 => (execute_SQSHLU_Z_P_ZI__ 256 dn 32 g shift)
      | 512 => (execute_SQSHLU_Z_P_ZI__ 512 dn 32 g shift)
      | 1024 => (execute_SQSHLU_Z_P_ZI__ 1024 dn 32 g shift)
      | 2048 => (execute_SQSHLU_Z_P_ZI__ 2048 dn 32 g shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_SQSHLU_Z_P_ZI__ 128 dn 64 g shift)
      | 256 => (execute_SQSHLU_Z_P_ZI__ 256 dn 64 g shift)
      | 512 => (execute_SQSHLU_Z_P_ZI__ 512 dn 64 g shift)
      | 1024 => (execute_SQSHLU_Z_P_ZI__ 1024 dn 64 g shift)
      | 2048 => (execute_SQSHLU_Z_P_ZI__ 2048 dn 64 g shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:38214.22-38214.23"

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SSHLLB_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand ((2 *i e) +i 0) esize) ) : SailM (BitVec esize) )
        let shifted_value := (_shl_int_general (BitVec.toInt element) shift)
        (Elem_set result e (2 *i esize) (integer_subrange shifted_value ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SSHLLB_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((BitVec.toNat (tsize ++ imm3)) -i esize)
  match VL with
  | 128 => (execute_SSHLLB_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SSHLLB_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SSHLLB_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SSHLLB_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SSHLLB_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SSHLLT_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand ((2 *i e) +i 1) esize) ) : SailM (BitVec esize) )
        let shifted_value := (_shl_int_general (BitVec.toInt element) shift)
        (Elem_set result e (2 *i esize) (integer_subrange shifted_value ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SSHLLT_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((BitVec.toNat (tsize ++ imm3)) -i esize)
  match VL with
  | 128 => (execute_SSHLLT_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_SSHLLT_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_SSHLLT_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_SSHLLT_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_SSHLLT_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_USHLLB_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand ((2 *i e) +i 0) esize) ) : SailM (BitVec esize) )
        let shifted_value := (_shl_int_general (BitVec.toNat element) shift)
        (Elem_set result e (2 *i esize) (integer_subrange shifted_value ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_USHLLB_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((BitVec.toNat (tsize ++ imm3)) -i esize)
  match VL with
  | 128 => (execute_USHLLB_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_USHLLB_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_USHLLB_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_USHLLB_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_USHLLB_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_USHLLT_Z_ZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← (( do (Elem_read operand ((2 *i e) +i 1) esize) ) : SailM (BitVec esize) )
        let shifted_value := (_shl_int_general (BitVec.toNat element) shift)
        (Elem_set result e (2 *i esize) (integer_subrange shifted_value ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_USHLLT_Z_ZI__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0b000 : (BitVec 3)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0b001 : (BitVec 3)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b01 : (BitVec 2)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (let esize : Int := 32
        (pure ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((BitVec.toNat (tsize ++ imm3)) -i esize)
  match VL with
  | 128 => (execute_USHLLT_Z_ZI__ 128 d esize n shift)
  | 256 => (execute_USHLLT_Z_ZI__ 256 d esize n shift)
  | 512 => (execute_USHLLT_Z_ZI__ 512 d esize n shift)
  | 1024 => (execute_USHLLT_Z_ZI__ 1024 d esize n shift)
  | 2048 => (execute_USHLLT_Z_ZI__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQXTNB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let res ← (( do (SignedSat element1 halfesize) ) : SailM (BitVec halfesize) )
        let result ← (Elem_set result ((2 *i e) +i 0) halfesize res)
        (Elem_set result ((2 *i e) +i 1) halfesize (Zeros (n := halfesize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQXTNB_Z_ZZ__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 16
  let b__0 := tsize
  bif (BEq.beq b__0 (0b001 : (BitVec 3)))
  then
    (let esize : Int := 16
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0b010 : (BitVec 3)))
      then
        (let esize : Int := 32
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b100 : (BitVec 3)))
          then
            (let esize : Int := 64
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQXTNB_Z_ZZ__ 128 d esize n)
  | 256 => (execute_SQXTNB_Z_ZZ__ 256 d esize n)
  | 512 => (execute_SQXTNB_Z_ZZ__ 512 d esize n)
  | 1024 => (execute_SQXTNB_Z_ZZ__ 1024 d esize n)
  | 2048 => (execute_SQXTNB_Z_ZZ__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQXTNB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let res ← (( do (UnsignedSat element1 halfesize) ) : SailM (BitVec halfesize) )
        let result ← (Elem_set result ((2 *i e) +i 0) halfesize res)
        (Elem_set result ((2 *i e) +i 1) halfesize (Zeros (n := halfesize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQXTNB_Z_ZZ__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 16
  let b__0 := tsize
  bif (BEq.beq b__0 (0b001 : (BitVec 3)))
  then
    (let esize : Int := 16
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0b010 : (BitVec 3)))
      then
        (let esize : Int := 32
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b100 : (BitVec 3)))
          then
            (let esize : Int := 64
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UQXTNB_Z_ZZ__ 128 d esize n)
  | 256 => (execute_UQXTNB_Z_ZZ__ 256 d esize n)
  | 512 => (execute_UQXTNB_Z_ZZ__ 512 d esize n)
  | 1024 => (execute_UQXTNB_Z_ZZ__ 1024 d esize n)
  | 2048 => (execute_UQXTNB_Z_ZZ__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQXTUNB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let res ← (( do (UnsignedSat element1 halfesize) ) : SailM (BitVec halfesize) )
        let result ← (Elem_set result ((2 *i e) +i 0) halfesize res)
        (Elem_set result ((2 *i e) +i 1) halfesize (Zeros (n := halfesize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQXTUNB_Z_ZZ__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 16
  let b__0 := tsize
  bif (BEq.beq b__0 (0b001 : (BitVec 3)))
  then
    (let esize : Int := 16
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0b010 : (BitVec 3)))
      then
        (let esize : Int := 32
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b100 : (BitVec 3)))
          then
            (let esize : Int := 64
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQXTUNB_Z_ZZ__ 128 d esize n)
  | 256 => (execute_SQXTUNB_Z_ZZ__ 256 d esize n)
  | 512 => (execute_SQXTUNB_Z_ZZ__ 512 d esize n)
  | 1024 => (execute_SQXTUNB_Z_ZZ__ 1024 d esize n)
  | 2048 => (execute_SQXTUNB_Z_ZZ__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQXTNT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let res ← (( do (SignedSat element1 halfesize) ) : SailM (BitVec halfesize) )
        (Elem_set result ((2 *i e) +i 1) halfesize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQXTNT_Z_ZZ__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 16
  let b__0 := tsize
  bif (BEq.beq b__0 (0b001 : (BitVec 3)))
  then
    (let esize : Int := 16
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0b010 : (BitVec 3)))
      then
        (let esize : Int := 32
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b100 : (BitVec 3)))
          then
            (let esize : Int := 64
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQXTNT_Z_ZZ__ 128 d esize n)
  | 256 => (execute_SQXTNT_Z_ZZ__ 256 d esize n)
  | 512 => (execute_SQXTNT_Z_ZZ__ 512 d esize n)
  | 1024 => (execute_SQXTNT_Z_ZZ__ 1024 d esize n)
  | 2048 => (execute_SQXTNT_Z_ZZ__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQXTNT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let res ← (( do (UnsignedSat element1 halfesize) ) : SailM (BitVec halfesize) )
        (Elem_set result ((2 *i e) +i 1) halfesize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQXTNT_Z_ZZ__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 16
  let b__0 := tsize
  bif (BEq.beq b__0 (0b001 : (BitVec 3)))
  then
    (let esize : Int := 16
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0b010 : (BitVec 3)))
      then
        (let esize : Int := 32
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b100 : (BitVec 3)))
          then
            (let esize : Int := 64
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UQXTNT_Z_ZZ__ 128 d esize n)
  | 256 => (execute_UQXTNT_Z_ZZ__ 256 d esize n)
  | 512 => (execute_UQXTNT_Z_ZZ__ 512 d esize n)
  | 1024 => (execute_UQXTNT_Z_ZZ__ 1024 d esize n)
  | 2048 => (execute_UQXTNT_Z_ZZ__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQXTUNT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let res ← (( do (UnsignedSat element1 halfesize) ) : SailM (BitVec halfesize) )
        (Elem_set result ((2 *i e) +i 1) halfesize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQXTUNT_Z_ZZ__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 3) := (tszh ++ tszl)
  let esize : Int := 16
  let b__0 := tsize
  bif (BEq.beq b__0 (0b001 : (BitVec 3)))
  then
    (let esize : Int := 16
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0b010 : (BitVec 3)))
      then
        (let esize : Int := 32
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b100 : (BitVec 3)))
          then
            (let esize : Int := 64
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQXTUNT_Z_ZZ__ 128 d esize n)
  | 256 => (execute_SQXTUNT_Z_ZZ__ 256 d esize n)
  | 512 => (execute_SQXTUNT_Z_ZZ__ 512 d esize n)
  | 1024 => (execute_SQXTUNT_Z_ZZ__ 1024 d esize n)
  | 2048 => (execute_SQXTUNT_Z_ZZ__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMULLT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let res := (element1 *i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SMULLT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SMULLT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SMULLT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SMULLT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SMULLT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SMULLT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMULLB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let res := (element1 *i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SMULLB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SMULLB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SMULLB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SMULLB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SMULLB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SMULLB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMULLT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let res := (element1 *i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UMULLT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UMULLT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_UMULLT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_UMULLT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_UMULLT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_UMULLT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMULLB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let res := (element1 *i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UMULLB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UMULLB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_UMULLB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_UMULLB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_UMULLB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_UMULLB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULLT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e esize (← (SignedSat res esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQDMULLT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQDMULLT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SQDMULLT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SQDMULLT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SQDMULLT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SQDMULLT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULLB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e esize (← (SignedSat res esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQDMULLB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQDMULLB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SQDMULLB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SQDMULLB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SQDMULLB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SQDMULLB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLALT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLALT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SMLALT_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SMLALT_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SMLALT_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SMLALT_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SMLALT_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLALB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLALB_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SMLALB_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SMLALB_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SMLALB_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SMLALB_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SMLALB_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLALT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLALT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UMLALT_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_UMLALT_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_UMLALT_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_UMLALT_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_UMLALT_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLALB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLALB_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UMLALB_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_UMLALB_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_UMLALB_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_UMLALB_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_UMLALB_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, sel1 : Nat, sel2 : Nat, sel2
  = 1 ∧
  sel1 = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLALT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2)))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e esize))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) esize))))
        (Elem_set result e esize (← (SignedSat (element3 +i product) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLALT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel1 := 1
  let sel2 := 1
  match VL with
  | 128 => (execute_SQDMLALT_Z_ZZZ__ 128 da esize m n sel1 sel2)
  | 256 => (execute_SQDMLALT_Z_ZZZ__ 256 da esize m n sel1 sel2)
  | 512 => (execute_SQDMLALT_Z_ZZZ__ 512 da esize m n sel1 sel2)
  | 1024 => (execute_SQDMLALT_Z_ZZZ__ 1024 da esize m n sel1 sel2)
  | 2048 => (execute_SQDMLALT_Z_ZZZ__ 2048 da esize m n sel1 sel2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, sel1 : Nat, sel2 : Nat, sel2
  = 0 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLALB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2)))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e esize))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) esize))))
        (Elem_set result e esize (← (SignedSat (element3 +i product) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLALB_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel1 := 0
  let sel2 := 0
  match VL with
  | 128 => (execute_SQDMLALB_Z_ZZZ__ 128 da esize m n sel1 sel2)
  | 256 => (execute_SQDMLALB_Z_ZZZ__ 256 da esize m n sel1 sel2)
  | 512 => (execute_SQDMLALB_Z_ZZZ__ 512 da esize m n sel1 sel2)
  | 1024 => (execute_SQDMLALB_Z_ZZZ__ 1024 da esize m n sel1 sel2)
  | 2048 => (execute_SQDMLALB_Z_ZZZ__ 2048 da esize m n sel1 sel2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLSLT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLSLT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SMLSLT_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SMLSLT_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SMLSLT_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SMLSLT_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SMLSLT_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLSLB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLSLB_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SMLSLB_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SMLSLB_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SMLSLB_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SMLSLB_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SMLSLB_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLSLT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLSLT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UMLSLT_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_UMLSLT_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_UMLSLT_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_UMLSLT_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_UMLSLT_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLSLB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLSLB_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UMLSLB_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_UMLSLB_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_UMLSLB_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_UMLSLB_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_UMLSLB_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, sel1 : Nat, sel2 : Nat, sel2
  = 1 ∧
  sel1 = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLSLT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2)))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e esize))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) esize))))
        (Elem_set result e esize (← (SignedSat (element3 -i product) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLSLT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel1 := 1
  let sel2 := 1
  match VL with
  | 128 => (execute_SQDMLSLT_Z_ZZZ__ 128 da esize m n sel1 sel2)
  | 256 => (execute_SQDMLSLT_Z_ZZZ__ 256 da esize m n sel1 sel2)
  | 512 => (execute_SQDMLSLT_Z_ZZZ__ 512 da esize m n sel1 sel2)
  | 1024 => (execute_SQDMLSLT_Z_ZZZ__ 1024 da esize m n sel1 sel2)
  | 2048 => (execute_SQDMLSLT_Z_ZZZ__ 2048 da esize m n sel1 sel2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, sel1 : Nat, sel2 : Nat, sel2
  = 0 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLSLB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2)))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e esize))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) esize))))
        (Elem_set result e esize (← (SignedSat (element3 -i product) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLSLB_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel1 := 0
  let sel2 := 0
  match VL with
  | 128 => (execute_SQDMLSLB_Z_ZZZ__ 128 da esize m n sel1 sel2)
  | 256 => (execute_SQDMLSLB_Z_ZZZ__ 256 da esize m n sel1 sel2)
  | 512 => (execute_SQDMLSLB_Z_ZZZ__ 512 da esize m n sel1 sel2)
  | 1024 => (execute_SQDMLSLB_Z_ZZZ__ 1024 da esize m n sel1 sel2)
  | 2048 => (execute_SQDMLSLB_Z_ZZZ__ 2048 da esize m n sel1 sel2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SABALT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let absdiff : (BitVec esize) :=
          (integer_subrange (Int.natAbs (element1 -i element2)) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + absdiff))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SABALT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SABALT_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SABALT_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SABALT_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SABALT_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SABALT_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SABALB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let absdiff : (BitVec esize) :=
          (integer_subrange (Int.natAbs (element1 -i element2)) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + absdiff))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SABALB_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SABALB_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SABALB_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SABALB_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SABALB_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SABALB_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UABALT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let absdiff : (BitVec esize) :=
          (integer_subrange (Int.natAbs (element1 -i element2)) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + absdiff))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UABALT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UABALT_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_UABALT_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_UABALT_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_UABALT_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_UABALT_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UABALB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let absdiff : (BitVec esize) :=
          (integer_subrange (Int.natAbs (element1 -i element2)) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + absdiff))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UABALB_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_UABALB_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_UABALB_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_UABALB_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_UABALB_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_UABALB_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SABA_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let absdiff : (BitVec esize) :=
          (integer_subrange (Int.natAbs (element1 -i element2)) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + absdiff))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SABA_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SABA_Z_ZZZ__ 128 da esize m n is_unsigned)
  | 256 => (execute_SABA_Z_ZZZ__ 256 da esize m n is_unsigned)
  | 512 => (execute_SABA_Z_ZZZ__ 512 da esize m n is_unsigned)
  | 1024 => (execute_SABA_Z_ZZZ__ 1024 da esize m n is_unsigned)
  | 2048 => (execute_SABA_Z_ZZZ__ 2048 da esize m n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UABA_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let absdiff : (BitVec esize) :=
          (integer_subrange (Int.natAbs (element1 -i element2)) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + absdiff))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UABA_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UABA_Z_ZZZ__ 128 da esize m n is_unsigned)
  | 256 => (execute_UABA_Z_ZZZ__ 256 da esize m n is_unsigned)
  | 512 => (execute_UABA_Z_ZZZ__ 512 da esize m n is_unsigned)
  | 1024 => (execute_UABA_Z_ZZZ__ 1024 da esize m n is_unsigned)
  | 2048 => (execute_UABA_Z_ZZZ__ 2048 da esize m n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SADDWT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        (Elem_set result e esize (integer_subrange (element1 +i element2) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SADDWT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SADDWT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SADDWT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SADDWT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SADDWT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SADDWT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SADDWB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        (Elem_set result e esize (integer_subrange (element1 +i element2) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SADDWB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SADDWB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SADDWB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SADDWB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SADDWB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SADDWB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UADDWT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        (Elem_set result e esize (integer_subrange (element1 +i element2) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UADDWT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UADDWT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_UADDWT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_UADDWT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_UADDWT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_UADDWT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UADDWB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        (Elem_set result e esize (integer_subrange (element1 +i element2) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UADDWB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UADDWB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_UADDWB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_UADDWB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_UADDWB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_UADDWB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SSUBWT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        (Elem_set result e esize (integer_subrange (element1 -i element2) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SSUBWT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SSUBWT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SSUBWT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SSUBWT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SSUBWT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SSUBWT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SSUBWB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        (Elem_set result e esize (integer_subrange (element1 -i element2) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SSUBWB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SSUBWB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SSUBWB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SSUBWB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SSUBWB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SSUBWB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_USUBWT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        (Elem_set result e esize (integer_subrange (element1 -i element2) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_USUBWT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_USUBWT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_USUBWT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_USUBWT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_USUBWT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_USUBWT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_USUBWB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        (Elem_set result e esize (integer_subrange (element1 -i element2) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_USUBWB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_USUBWB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_USUBWB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_USUBWB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_USUBWB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_USUBWB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_PMUL_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        (Elem_set result e esize
          (Sail.BitVec.extractLsb (PolynomialMult element1 element2) (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_PMUL_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_PMUL_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_PMUL_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_PMUL_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_PMUL_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_PMUL_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_PMULLT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        (Elem_set result e esize (PolynomialMult element1 element2))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_PMULLT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize : Int := 16
  let b__0 := size
  bif (BEq.beq b__0 (0b01 : (BitVec 2)))
  then
    (let esize : Int := 16
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0b11 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_PMULLT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_PMULLT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_PMULLT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_PMULLT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_PMULLT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_PMULLB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        (Elem_set result e esize (PolynomialMult element1 element2))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_PMULLB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize : Int := 16
  let b__0 := size
  bif (BEq.beq b__0 (0b01 : (BitVec 2)))
  then
    (let esize : Int := 16
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0b11 : (BitVec 2)))
      then
        (let esize : Int := 64
        (pure ()))
      else sailThrow ((Error_Undefined ())))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_PMULLB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_PMULLB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_PMULLB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_PMULLB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_PMULLB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_PMULLT_Z_ZZ_Q (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        (Elem_set result e esize (PolynomialMult element1 element2))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_PMULLT_Z_ZZ_Q (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2PMULL128 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_PMULLT_Z_ZZ_Q 128 d esize m n)
  | 256 => (execute_PMULLT_Z_ZZ_Q 256 d esize m n)
  | 512 => (execute_PMULLT_Z_ZZ_Q 512 d esize m n)
  | 1024 => (execute_PMULLT_Z_ZZ_Q 1024 d esize m n)
  | 2048 => (execute_PMULLT_Z_ZZ_Q 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_PMULLB_Z_ZZ_Q (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)) ) : SailM
          (BitVec (esize / 2)) )
        (Elem_set result e esize (PolynomialMult element1 element2))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_PMULLB_Z_ZZ_Q (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2PMULL128 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_PMULLB_Z_ZZ_Q 128 d esize m n)
  | 256 => (execute_PMULLB_Z_ZZ_Q 256 d esize m n)
  | 512 => (execute_PMULLB_Z_ZZ_Q 512 d esize m n)
  | 1024 => (execute_PMULLB_Z_ZZ_Q 1024 d esize m n)
  | 2048 => (execute_PMULLB_Z_ZZ_Q 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQSHL_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general element shift))
            let res := res
            (Elem_set result e esize (← (SignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQSHL_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_SQSHL_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SQSHL_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SQSHL_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SQSHL_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SQSHL_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQSHL_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general element shift))
            let res := res
            (Elem_set result e esize (← (UnsignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQSHL_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_UQSHL_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_UQSHL_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_UQSHL_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_UQSHL_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_UQSHL_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SRSHL_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SRSHL_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_SRSHL_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SRSHL_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SRSHL_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SRSHL_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SRSHL_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_URSHL_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_URSHL_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_URSHL_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_URSHL_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_URSHL_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_URSHL_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_URSHL_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHL_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (Elem_set result e esize (← (SignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQRSHL_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_SQRSHL_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SQRSHL_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SQRSHL_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SQRSHL_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SQRSHL_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQRSHL_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (Elem_set result e esize (← (UnsignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQRSHL_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_UQRSHL_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_UQRSHL_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_UQRSHL_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_UQRSHL_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_UQRSHL_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQSHLR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general element shift))
            let res := res
            (Elem_set result e esize (← (SignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand2 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQSHLR_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_SQSHLR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SQSHLR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SQSHLR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SQSHLR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SQSHLR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQSHLR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general element shift))
            let res := res
            (Elem_set result e esize (← (UnsignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand2 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQSHLR_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_UQSHLR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_UQSHLR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_UQSHLR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_UQSHLR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_UQSHLR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SRSHLR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand2 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SRSHLR_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_SRSHLR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SRSHLR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SRSHLR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SRSHLR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SRSHLR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_URSHLR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand2 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_URSHLR_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_URSHLR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_URSHLR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_URSHLR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_URSHLR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_URSHLR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHLR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (Elem_set result e esize (← (SignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand2 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQRSHLR_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_SQRSHLR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SQRSHLR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SQRSHLR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SQRSHLR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SQRSHLR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQRSHLR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
            let shift ← (( do
              (pure (ShiftSat (BitVec.toInt (← (Elem_read operand2 e esize))) esize)) ) : SailM
              Int )
            let res ← (( do (undefined_int ()) ) : SailM Int )
            let res : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            let res := res
            (Elem_set result e esize (← (UnsignedSat res esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand2 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQRSHLR_Z_P_ZZ__ (size : (BitVec 2)) (Q : (BitVec 1)) (R : (BitVec 1)) (N : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_UQRSHLR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_UQRSHLR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_UQRSHLR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_UQRSHLR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_UQRSHLR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ADDHNB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        let res := (Int.shiftr (element1 +i element2) halfesize)
        let result ←
          (Elem_set result ((2 *i e) +i 0) halfesize (integer_subrange res (halfesize -i 1) 0))
        (Elem_set result ((2 *i e) +i 1) halfesize (Zeros (n := halfesize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ADDHNB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_ADDHNB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_ADDHNB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_ADDHNB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_ADDHNB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_ADDHNB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ADDHNT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        let res := (Int.shiftr (element1 +i element2) halfesize)
        (Elem_set result ((2 *i e) +i 1) halfesize (integer_subrange res (halfesize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ADDHNT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_ADDHNT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_ADDHNT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_ADDHNT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_ADDHNT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_ADDHNT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SUBHNB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        let res := (Int.shiftr (element1 -i element2) halfesize)
        let result ←
          (Elem_set result ((2 *i e) +i 0) halfesize (integer_subrange res (halfesize -i 1) 0))
        (Elem_set result ((2 *i e) +i 1) halfesize (Zeros (n := halfesize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SUBHNB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SUBHNB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SUBHNB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SUBHNB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SUBHNB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SUBHNB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SUBHNT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        let res := (Int.shiftr (element1 -i element2) halfesize)
        (Elem_set result ((2 *i e) +i 1) halfesize (integer_subrange res (halfesize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SUBHNT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SUBHNT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SUBHNT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SUBHNT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SUBHNT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SUBHNT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_RADDHNB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        let res :=
          (Int.shiftr ((element1 +i element2) +i (Int.shiftl 1 (halfesize -i 1))) halfesize)
        let result ←
          (Elem_set result ((2 *i e) +i 0) halfesize (integer_subrange res (halfesize -i 1) 0))
        (Elem_set result ((2 *i e) +i 1) halfesize (Zeros (n := halfesize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_RADDHNB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_RADDHNB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_RADDHNB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_RADDHNB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_RADDHNB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_RADDHNB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_RADDHNT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        let res :=
          (Int.shiftr ((element1 +i element2) +i (Int.shiftl 1 (halfesize -i 1))) halfesize)
        (Elem_set result ((2 *i e) +i 1) halfesize (integer_subrange res (halfesize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_RADDHNT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_RADDHNT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_RADDHNT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_RADDHNT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_RADDHNT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_RADDHNT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_RSUBHNB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        let res :=
          (Int.shiftr ((element1 -i element2) +i (Int.shiftl 1 (halfesize -i 1))) halfesize)
        let result ←
          (Elem_set result ((2 *i e) +i 0) halfesize (integer_subrange res (halfesize -i 1) 0))
        (Elem_set result ((2 *i e) +i 1) halfesize (Zeros (n := halfesize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_RSUBHNB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_RSUBHNB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_RSUBHNB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_RSUBHNB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_RSUBHNB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_RSUBHNB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_RSUBHNT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let halfesize := (Int.ediv esize 2)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        let res :=
          (Int.shiftr ((element1 -i element2) +i (Int.shiftl 1 (halfesize -i 1))) halfesize)
        (Elem_set result ((2 *i e) +i 1) halfesize (integer_subrange res (halfesize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_RSUBHNT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (R : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_RSUBHNT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_RSUBHNT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_RSUBHNT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_RSUBHNT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_RSUBHNT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SABDLB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let res := (Int.natAbs (element1 -i element2))
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SABDLB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SABDLB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SABDLB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SABDLB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SABDLB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SABDLB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SABDLT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let res := (Int.natAbs (element1 -i element2))
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SABDLT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SABDLT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SABDLT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SABDLT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SABDLT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SABDLT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UABDLB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 0) (Int.ediv esize 2)))))
        let res := (Int.natAbs (element1 -i element2))
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UABDLB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UABDLB_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_UABDLB_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_UABDLB_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_UABDLB_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_UABDLB_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UABDLT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i e) +i 1) (Int.ediv esize 2)))))
        let res := (Int.natAbs (element1 -i element2))
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UABDLT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UABDLT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_UABDLT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_UABDLT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_UABDLT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_UABDLT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 0 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SADDLB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 +i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SADDLB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 0
  let sel2 := 0
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SADDLB_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_SADDLB_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_SADDLB_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_SADDLB_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_SADDLB_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 1 ∧
  sel1 = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SADDLT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 +i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SADDLT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 1
  let sel2 := 1
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SADDLT_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_SADDLT_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_SADDLT_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_SADDLT_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_SADDLT_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 0 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SSUBLB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 -i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SSUBLB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 0
  let sel2 := 0
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SSUBLB_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_SSUBLB_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_SSUBLB_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_SSUBLB_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_SSUBLB_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 1 ∧
  sel1 = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SSUBLT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 -i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SSUBLT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 1
  let sel2 := 1
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SSUBLT_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_SSUBLT_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_SSUBLT_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_SSUBLT_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_SSUBLT_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 0 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UADDLB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 +i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UADDLB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 0
  let sel2 := 0
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UADDLB_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_UADDLB_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_UADDLB_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_UADDLB_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_UADDLB_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 1 ∧
  sel1 = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UADDLT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 +i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UADDLT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 1
  let sel2 := 1
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UADDLT_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_UADDLT_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_UADDLT_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_UADDLT_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_UADDLT_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 0 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_USUBLB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 -i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_USUBLB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 0
  let sel2 := 0
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_USUBLB_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_USUBLB_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_USUBLB_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_USUBLB_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_USUBLB_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 1 ∧
  sel1 = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_USUBLT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 -i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_USUBLT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (U : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 1
  let sel2 := 1
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_USUBLT_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_USUBLT_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_USUBLT_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_USUBLT_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_USUBLT_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 1 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SADDLBT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 +i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SADDLBT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (tb : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 0
  let sel2 := 1
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SADDLBT_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_SADDLBT_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_SADDLBT_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_SADDLBT_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_SADDLBT_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 1 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SSUBLBT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 -i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SSUBLBT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (tb : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 0
  let sel2 := 1
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SSUBLBT_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_SSUBLBT_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_SSUBLBT_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_SSUBLBT_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_SSUBLBT_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, sel1 :
  Nat, sel2 : Nat, sel2 = 0 ∧
  sel1 = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SSUBLTB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (asl_Int (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2))) is_unsigned)
        let element2 ← do
          (asl_Int (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2))) is_unsigned)
        let res := (element1 -i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SSUBLTB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (tb : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 1
  let sel2 := 0
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SSUBLTB_Z_ZZ__ 128 d esize m n sel1 sel2 is_unsigned)
  | 256 => (execute_SSUBLTB_Z_ZZ__ 256 d esize m n sel1 sel2 is_unsigned)
  | 512 => (execute_SSUBLTB_Z_ZZ__ 512 d esize m n sel1 sel2 is_unsigned)
  | 1024 => (execute_SSUBLTB_Z_ZZ__ 1024 d esize m n sel1 sel2 is_unsigned)
  | 2048 => (execute_SSUBLTB_Z_ZZ__ 2048 d esize m n sel1 sel2 is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, k_sub_i : Bool, k_sub_r : Bool, 0
  ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_CADD_Z_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (sub_i : Bool) (sub_r : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let acc_r ← (( do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i p) +i 0) esize)))) )
          : SailM Int )
        let acc_i ← (( do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i p) +i 1) esize)))) )
          : SailM Int )
        let elt2_r ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i p) +i 0) esize))))
        let elt2_i ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i p) +i 1) esize))))
        let (acc_i, acc_r) : (Int × Int) :=
          bif sub_i
          then
            (let acc_r : Int := (acc_r -i elt2_i)
            let acc_i : Int := (acc_i +i elt2_r)
            (acc_i, acc_r))
          else (acc_i, acc_r)
        let (acc_i, acc_r) : (Int × Int) :=
          bif sub_r
          then
            (let acc_r : Int := (acc_r +i elt2_i)
            let acc_i : Int := (acc_i -i elt2_r)
            (acc_i, acc_r))
          else (acc_i, acc_r)
        let acc_r := acc_r
        let acc_i := acc_i
        let result ←
          (Elem_set result ((2 *i p) +i 0) esize (integer_subrange acc_r (esize -i 1) 0))
        (Elem_set result ((2 *i p) +i 1) esize (integer_subrange acc_i (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_CADD_Z_ZZ__ (size : (BitVec 2)) (rot : (BitVec 1)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  let sub_i : Bool := (BEq.beq rot (0b0 : (BitVec 1)))
  let sub_r : Bool := (BEq.beq rot (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_CADD_Z_ZZ__ 128 dn esize m sub_i sub_r)
  | 256 => (execute_CADD_Z_ZZ__ 256 dn esize m sub_i sub_r)
  | 512 => (execute_CADD_Z_ZZ__ 512 dn esize m sub_i sub_r)
  | 1024 => (execute_CADD_Z_ZZ__ 1024 dn esize m sub_i sub_r)
  | 2048 => (execute_CADD_Z_ZZ__ 2048 dn esize m sub_i sub_r)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, k_sub_i : Bool, k_sub_r : Bool, 0
  ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQCADD_Z_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (sub_i : Bool) (sub_r : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let acc_r ← (( do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i p) +i 0) esize)))) )
          : SailM Int )
        let acc_i ← (( do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i p) +i 1) esize)))) )
          : SailM Int )
        let elt2_r ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i p) +i 0) esize))))
        let elt2_i ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i p) +i 1) esize))))
        let (acc_i, acc_r) : (Int × Int) :=
          bif sub_i
          then
            (let acc_r : Int := (acc_r -i elt2_i)
            let acc_i : Int := (acc_i +i elt2_r)
            (acc_i, acc_r))
          else (acc_i, acc_r)
        let (acc_i, acc_r) : (Int × Int) :=
          bif sub_r
          then
            (let acc_r : Int := (acc_r +i elt2_i)
            let acc_i : Int := (acc_i -i elt2_r)
            (acc_i, acc_r))
          else (acc_i, acc_r)
        let acc_r := acc_r
        let acc_i := acc_i
        let result ← (Elem_set result ((2 *i p) +i 0) esize (← (SignedSat acc_r esize)))
        (Elem_set result ((2 *i p) +i 1) esize (← (SignedSat acc_i esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQCADD_Z_ZZ__ (size : (BitVec 2)) (rot : (BitVec 1)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  let sub_i : Bool := (BEq.beq rot (0b0 : (BitVec 1)))
  let sub_r : Bool := (BEq.beq rot (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_SQCADD_Z_ZZ__ 128 dn esize m sub_i sub_r)
  | 256 => (execute_SQCADD_Z_ZZ__ 256 dn esize m sub_i sub_r)
  | 512 => (execute_SQCADD_Z_ZZ__ 512 dn esize m sub_i sub_r)
  | 1024 => (execute_SQCADD_Z_ZZ__ 1024 dn esize m sub_i sub_r)
  | 2048 => (execute_SQCADD_Z_ZZ__ 2048 dn esize m sub_i sub_r)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, sel_a : Nat, sel_b : Nat, k_sub_i
  : Bool, k_sub_r : Bool, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_CMLA_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel_a : Nat) (sel_b : Nat) (sub_i : Bool) (sub_r : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let elt1_a ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i p) +i sel_a) esize))))
        let elt2_a ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i p) +i sel_a) esize))))
        let elt2_b ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i p) +i sel_b) esize))))
        let elt3_r ← (( do (Elem_read operand3 ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let elt3_i ← (( do (Elem_read operand3 ((2 *i p) +i 1) esize) ) : SailM (BitVec esize) )
        let product_r := (elt1_a *i elt2_a)
        let product_i := (elt1_a *i elt2_b)
        let result ← (( do
          bif sub_r
          then
            (do
              (Elem_set result ((2 *i p) +i 0) esize (BitVec.subInt elt3_r product_r)))
          else
            (do
              (Elem_set result ((2 *i p) +i 0) esize (BitVec.addInt elt3_r product_r))) ) : SailM
          (BitVec VL) )
        bif sub_i
        then
          (do
            (Elem_set result ((2 *i p) +i 1) esize (BitVec.subInt elt3_i product_i)))
        else
          (do
            (Elem_set result ((2 *i p) +i 1) esize (BitVec.addInt elt3_i product_i)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_CMLA_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let sub_r : Bool :=
    (bne (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  let sub_i : Bool := (BEq.beq (BitVec.join1 [(BitVec.access rot 1)]) (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_CMLA_Z_ZZZ__ 128 da esize m n sel_a sel_b sub_i sub_r)
  | 256 => (execute_CMLA_Z_ZZZ__ 256 da esize m n sel_a sel_b sub_i sub_r)
  | 512 => (execute_CMLA_Z_ZZZ__ 512 da esize m n sel_a sel_b sub_i sub_r)
  | 1024 => (execute_CMLA_Z_ZZZ__ 1024 da esize m n sel_a sel_b sub_i sub_r)
  | 2048 => (execute_CMLA_Z_ZZZ__ 2048 da esize m n sel_a sel_b sub_i sub_r)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel_a : Nat, sel_b
  : Nat, k_sub_i : Bool, k_sub_r : Bool, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_CMLA_Z_ZZZi_H (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel_a : Nat) (sel_b : Nat) (sub_i : Bool) (sub_r : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let pairspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (p -i (Nat.div p pairspersegment))
        let s := (segmentbase +i index)
        let elt1_a ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i p) +i sel_a) esize))))
        let elt2_a ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i sel_a) esize))))
        let elt2_b ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i sel_b) esize))))
        let elt3_r ← (( do (Elem_read operand3 ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let elt3_i ← (( do (Elem_read operand3 ((2 *i p) +i 1) esize) ) : SailM (BitVec esize) )
        let product_r := (elt1_a *i elt2_a)
        let product_i := (elt1_a *i elt2_b)
        let result ← (( do
          bif sub_r
          then
            (do
              (Elem_set result ((2 *i p) +i 0) esize (BitVec.subInt elt3_r product_r)))
          else
            (do
              (Elem_set result ((2 *i p) +i 0) esize (BitVec.addInt elt3_r product_r))) ) : SailM
          (BitVec VL) )
        bif sub_i
        then
          (do
            (Elem_set result ((2 *i p) +i 1) esize (BitVec.subInt elt3_i product_i)))
        else
          (do
            (Elem_set result ((2 *i p) +i 1) esize (BitVec.addInt elt3_i product_i)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_CMLA_Z_ZZZi_H (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let sub_r : Bool :=
    (bne (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  let sub_i : Bool := (BEq.beq (BitVec.join1 [(BitVec.access rot 1)]) (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_CMLA_Z_ZZZi_H 128 da esize index m n sel_a sel_b sub_i sub_r)
  | 256 => (execute_CMLA_Z_ZZZi_H 256 da esize index m n sel_a sel_b sub_i sub_r)
  | 512 => (execute_CMLA_Z_ZZZi_H 512 da esize index m n sel_a sel_b sub_i sub_r)
  | 1024 => (execute_CMLA_Z_ZZZi_H 1024 da esize index m n sel_a sel_b sub_i sub_r)
  | 2048 => (execute_CMLA_Z_ZZZi_H 2048 da esize index m n sel_a sel_b sub_i sub_r)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel_a : Nat, sel_b
  : Nat, k_sub_i : Bool, k_sub_r : Bool, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_CMLA_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel_a : Nat) (sel_b : Nat) (sub_i : Bool) (sub_r : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let pairspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := result
    for p in [loop_p_lower:loop_p_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (p -i (Nat.div p pairspersegment))
        let s := (segmentbase +i index)
        let elt1_a ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i p) +i sel_a) esize))))
        let elt2_a ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i sel_a) esize))))
        let elt2_b ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i sel_b) esize))))
        let elt3_r ← (( do (Elem_read operand3 ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let elt3_i ← (( do (Elem_read operand3 ((2 *i p) +i 1) esize) ) : SailM (BitVec esize) )
        let product_r := (elt1_a *i elt2_a)
        let product_i := (elt1_a *i elt2_b)
        let result ← (( do
          bif sub_r
          then
            (do
              (Elem_set result ((2 *i p) +i 0) esize (BitVec.subInt elt3_r product_r)))
          else
            (do
              (Elem_set result ((2 *i p) +i 0) esize (BitVec.addInt elt3_r product_r))) ) : SailM
          (BitVec VL) )
        bif sub_i
        then
          (do
            (Elem_set result ((2 *i p) +i 1) esize (BitVec.subInt elt3_i product_i)))
        else
          (do
            (Elem_set result ((2 *i p) +i 1) esize (BitVec.addInt elt3_i product_i)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_CMLA_Z_ZZZi_S (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let sub_r : Bool :=
    (bne (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  let sub_i : Bool := (BEq.beq (BitVec.join1 [(BitVec.access rot 1)]) (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_CMLA_Z_ZZZi_S 128 da esize index m n sel_a sel_b sub_i sub_r)
  | 256 => (execute_CMLA_Z_ZZZi_S 256 da esize index m n sel_a sel_b sub_i sub_r)
  | 512 => (execute_CMLA_Z_ZZZi_S 512 da esize index m n sel_a sel_b sub_i sub_r)
  | 1024 => (execute_CMLA_Z_ZZZi_S 1024 da esize index m n sel_a sel_b sub_i sub_r)
  | 2048 => (execute_CMLA_Z_ZZZi_S 2048 da esize index m n sel_a sel_b sub_i sub_r)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, sel_a : Nat, sel_b : Nat, k_sub_i
  : Bool, k_sub_r : Bool, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDCMLAH_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel_a : Nat) (sel_b : Nat) (sub_i : Bool) (sub_r : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let res_i ← (( do (undefined_int ()) ) : SailM Int )
  let res_r ← (( do (undefined_int ()) ) : SailM Int )
  let (res_i, res_r, result) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (res_i, res_r, result)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (res_i, res_r, result) := loop_vars
      loop_vars ← do
        let elt1_a ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i p) +i sel_a) esize))))
        let elt2_a ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i p) +i sel_a) esize))))
        let elt2_b ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i p) +i sel_b) esize))))
        let elt3_r ← (( do (Elem_read operand3 ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let elt3_i ← (( do (Elem_read operand3 ((2 *i p) +i 1) esize) ) : SailM (BitVec esize) )
        let product_r := (elt1_a *i elt2_a)
        let product_i := (elt1_a *i elt2_b)
        let res_r : Int :=
          bif sub_r
          then ((Int.shiftl (BitVec.toInt elt3_r) esize) -i (2 *i product_r))
          else ((Int.shiftl (BitVec.toInt elt3_r) esize) +i (2 *i product_r))
        let res_r : Int := (Int.shiftr (res_r +i (Int.shiftl 1 (esize -i 1))) esize)
        let result ← (Elem_set result ((2 *i p) +i 0) esize (← (SignedSat res_r esize)))
        let res_i : Int :=
          bif sub_i
          then ((Int.shiftl (BitVec.toInt elt3_i) esize) -i (2 *i product_i))
          else ((Int.shiftl (BitVec.toInt elt3_i) esize) +i (2 *i product_i))
        let res_i : Int := (Int.shiftr (res_i +i (Int.shiftl 1 (esize -i 1))) esize)
        let result ← (Elem_set result ((2 *i p) +i 1) esize (← (SignedSat res_i esize)))
        (pure (res_i, res_r, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec VL)) )
  (Z_set da VL result)

def decode_SQRDCMLAH_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let sub_r : Bool :=
    (bne (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  let sub_i : Bool := (BEq.beq (BitVec.join1 [(BitVec.access rot 1)]) (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_SQRDCMLAH_Z_ZZZ__ 128 da esize m n sel_a sel_b sub_i sub_r)
  | 256 => (execute_SQRDCMLAH_Z_ZZZ__ 256 da esize m n sel_a sel_b sub_i sub_r)
  | 512 => (execute_SQRDCMLAH_Z_ZZZ__ 512 da esize m n sel_a sel_b sub_i sub_r)
  | 1024 => (execute_SQRDCMLAH_Z_ZZZ__ 1024 da esize m n sel_a sel_b sub_i sub_r)
  | 2048 => (execute_SQRDCMLAH_Z_ZZZ__ 2048 da esize m n sel_a sel_b sub_i sub_r)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel_a : Nat, sel_b
  : Nat, k_sub_i : Bool, k_sub_r : Bool, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDCMLAH_Z_ZZZi_H (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel_a : Nat) (sel_b : Nat) (sub_i : Bool) (sub_r : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let pairspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let res_i ← (( do (undefined_int ()) ) : SailM Int )
  let res_r ← (( do (undefined_int ()) ) : SailM Int )
  let (res_i, res_r, result) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (res_i, res_r, result)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (res_i, res_r, result) := loop_vars
      loop_vars ← do
        let segmentbase := (p -i (Nat.div p pairspersegment))
        let s := (segmentbase +i index)
        let elt1_a ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i p) +i sel_a) esize))))
        let elt2_a ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i sel_a) esize))))
        let elt2_b ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i sel_b) esize))))
        let elt3_r ← (( do (Elem_read operand3 ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let elt3_i ← (( do (Elem_read operand3 ((2 *i p) +i 1) esize) ) : SailM (BitVec esize) )
        let product_r := (elt1_a *i elt2_a)
        let product_i := (elt1_a *i elt2_b)
        let res_r : Int :=
          bif sub_r
          then ((Int.shiftl (BitVec.toInt elt3_r) esize) -i (2 *i product_r))
          else ((Int.shiftl (BitVec.toInt elt3_r) esize) +i (2 *i product_r))
        let res_r : Int := (Int.shiftr (res_r +i (Int.shiftl 1 (esize -i 1))) esize)
        let result ← (Elem_set result ((2 *i p) +i 0) esize (← (SignedSat res_r esize)))
        let res_i : Int :=
          bif sub_i
          then ((Int.shiftl (BitVec.toInt elt3_i) esize) -i (2 *i product_i))
          else ((Int.shiftl (BitVec.toInt elt3_i) esize) +i (2 *i product_i))
        let res_i : Int := (Int.shiftr (res_i +i (Int.shiftl 1 (esize -i 1))) esize)
        let result ← (Elem_set result ((2 *i p) +i 1) esize (← (SignedSat res_i esize)))
        (pure (res_i, res_r, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec VL)) )
  (Z_set da VL result)

def decode_SQRDCMLAH_Z_ZZZi_H (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let sub_r : Bool :=
    (bne (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  let sub_i : Bool := (BEq.beq (BitVec.join1 [(BitVec.access rot 1)]) (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_SQRDCMLAH_Z_ZZZi_H 128 da esize index m n sel_a sel_b sub_i sub_r)
  | 256 => (execute_SQRDCMLAH_Z_ZZZi_H 256 da esize index m n sel_a sel_b sub_i sub_r)
  | 512 => (execute_SQRDCMLAH_Z_ZZZi_H 512 da esize index m n sel_a sel_b sub_i sub_r)
  | 1024 => (execute_SQRDCMLAH_Z_ZZZi_H 1024 da esize index m n sel_a sel_b sub_i sub_r)
  | 2048 => (execute_SQRDCMLAH_Z_ZZZi_H 2048 da esize index m n sel_a sel_b sub_i sub_r)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel_a : Nat, sel_b
  : Nat, k_sub_i : Bool, k_sub_r : Bool, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDCMLAH_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel_a : Nat) (sel_b : Nat) (sub_i : Bool) (sub_r : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let pairs := (Int.ediv VL (2 *i esize))
  let pairspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let res_i ← (( do (undefined_int ()) ) : SailM Int )
  let res_r ← (( do (undefined_int ()) ) : SailM Int )
  let (res_i, res_r, result) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (res_i, res_r, result)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (res_i, res_r, result) := loop_vars
      loop_vars ← do
        let segmentbase := (p -i (Nat.div p pairspersegment))
        let s := (segmentbase +i index)
        let elt1_a ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i p) +i sel_a) esize))))
        let elt2_a ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i sel_a) esize))))
        let elt2_b ← do (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i sel_b) esize))))
        let elt3_r ← (( do (Elem_read operand3 ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let elt3_i ← (( do (Elem_read operand3 ((2 *i p) +i 1) esize) ) : SailM (BitVec esize) )
        let product_r := (elt1_a *i elt2_a)
        let product_i := (elt1_a *i elt2_b)
        let res_r : Int :=
          bif sub_r
          then ((Int.shiftl (BitVec.toInt elt3_r) esize) -i (2 *i product_r))
          else ((Int.shiftl (BitVec.toInt elt3_r) esize) +i (2 *i product_r))
        let res_r : Int := (Int.shiftr (res_r +i (Int.shiftl 1 (esize -i 1))) esize)
        let result ← (Elem_set result ((2 *i p) +i 0) esize (← (SignedSat res_r esize)))
        let res_i : Int :=
          bif sub_i
          then ((Int.shiftl (BitVec.toInt elt3_i) esize) -i (2 *i product_i))
          else ((Int.shiftl (BitVec.toInt elt3_i) esize) +i (2 *i product_i))
        let res_i : Int := (Int.shiftr (res_i +i (Int.shiftl 1 (esize -i 1))) esize)
        let result ← (Elem_set result ((2 *i p) +i 1) esize (← (SignedSat res_i esize)))
        (pure (res_i, res_r, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec VL)) )
  (Z_set da VL result)

def decode_SQRDCMLAH_Z_ZZZi_S (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let sub_r : Bool :=
    (bne (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  let sub_i : Bool := (BEq.beq (BitVec.join1 [(BitVec.access rot 1)]) (0b1 : (BitVec 1)))
  match VL with
  | 128 => (execute_SQRDCMLAH_Z_ZZZi_S 128 da esize index m n sel_a sel_b sub_i sub_r)
  | 256 => (execute_SQRDCMLAH_Z_ZZZi_S 256 da esize index m n sel_a sel_b sub_i sub_r)
  | 512 => (execute_SQRDCMLAH_Z_ZZZi_S 512 da esize index m n sel_a sel_b sub_i sub_r)
  | 1024 => (execute_SQRDCMLAH_Z_ZZZi_S 1024 da esize index m n sel_a sel_b sub_i sub_r)
  | 2048 => (execute_SQRDCMLAH_Z_ZZZi_S 2048 da esize index m n sel_a sel_b sub_i sub_r)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MUL_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        let product := (element1 *i element2)
        (Elem_set result e esize (integer_subrange product (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MUL_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_MUL_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_MUL_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_MUL_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_MUL_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_MUL_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MUL_Z_ZZi_H (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 s esize))))
        let res := (element1 *i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MUL_Z_ZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_MUL_Z_ZZi_H 128 d esize index m n)
  | 256 => (execute_MUL_Z_ZZi_H 256 d esize index m n)
  | 512 => (execute_MUL_Z_ZZi_H 512 d esize index m n)
  | 1024 => (execute_MUL_Z_ZZi_H 1024 d esize index m n)
  | 2048 => (execute_MUL_Z_ZZi_H 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MUL_Z_ZZi_S (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 s esize))))
        let res := (element1 *i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MUL_Z_ZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_MUL_Z_ZZi_S 128 d esize index m n)
  | 256 => (execute_MUL_Z_ZZi_S 256 d esize index m n)
  | 512 => (execute_MUL_Z_ZZi_S 512 d esize index m n)
  | 1024 => (execute_MUL_Z_ZZi_S 1024 d esize index m n)
  | 2048 => (execute_MUL_Z_ZZi_S 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_MUL_Z_ZZi_D (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 s esize))))
        let res := (element1 *i element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_MUL_Z_ZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_MUL_Z_ZZi_D 128 d esize index m n)
  | 256 => (execute_MUL_Z_ZZi_D 256 d esize index m n)
  | 512 => (execute_MUL_Z_ZZi_D 512 d esize index m n)
  | 1024 => (execute_MUL_Z_ZZi_D 1024 d esize index m n)
  | 2048 => (execute_MUL_Z_ZZi_D 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_MLA_Z_ZZZi_H (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 s esize))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_MLA_Z_ZZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_MLA_Z_ZZZi_H 128 da esize index m n)
  | 256 => (execute_MLA_Z_ZZZi_H 256 da esize index m n)
  | 512 => (execute_MLA_Z_ZZZi_H 512 da esize index m n)
  | 1024 => (execute_MLA_Z_ZZZi_H 1024 da esize index m n)
  | 2048 => (execute_MLA_Z_ZZZi_H 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_MLA_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 s esize))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_MLA_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_MLA_Z_ZZZi_S 128 da esize index m n)
  | 256 => (execute_MLA_Z_ZZZi_S 256 da esize index m n)
  | 512 => (execute_MLA_Z_ZZZi_S 512 da esize index m n)
  | 1024 => (execute_MLA_Z_ZZZi_S 1024 da esize index m n)
  | 2048 => (execute_MLA_Z_ZZZi_S 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_MLA_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 s esize))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_MLA_Z_ZZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_MLA_Z_ZZZi_D 128 da esize index m n)
  | 256 => (execute_MLA_Z_ZZZi_D 256 da esize index m n)
  | 512 => (execute_MLA_Z_ZZZi_D 512 da esize index m n)
  | 1024 => (execute_MLA_Z_ZZZi_D 1024 da esize index m n)
  | 2048 => (execute_MLA_Z_ZZZi_D 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_MLS_Z_ZZZi_H (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 s esize))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_MLS_Z_ZZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_MLS_Z_ZZZi_H 128 da esize index m n)
  | 256 => (execute_MLS_Z_ZZZi_H 256 da esize index m n)
  | 512 => (execute_MLS_Z_ZZZi_H 512 da esize index m n)
  | 1024 => (execute_MLS_Z_ZZZi_H 1024 da esize index m n)
  | 2048 => (execute_MLS_Z_ZZZi_H 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_MLS_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 s esize))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_MLS_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_MLS_Z_ZZZi_S 128 da esize index m n)
  | 256 => (execute_MLS_Z_ZZZi_S 256 da esize index m n)
  | 512 => (execute_MLS_Z_ZZZi_S 512 da esize index m n)
  | 1024 => (execute_MLS_Z_ZZZi_S 1024 da esize index m n)
  | 2048 => (execute_MLS_Z_ZZZi_S 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_MLS_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 s esize))))
        let product : (BitVec esize) := (integer_subrange (element1 *i element2) (esize -i 1) 0)
        (Elem_set result e esize ((← (Elem_read result e esize)) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_MLS_Z_ZZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_MLS_Z_ZZZi_D 128 da esize index m n)
  | 256 => (execute_MLS_Z_ZZZi_D 256 da esize index m n)
  | 512 => (execute_MLS_Z_ZZZi_D 512 da esize index m n)
  | 1024 => (execute_MLS_Z_ZZZi_D 1024 da esize index m n)
  | 2048 => (execute_MLS_Z_ZZZi_D 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMULLB_Z_ZZi_S (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := (element1 *i element2)
        (Elem_set result e (2 *i esize) (integer_subrange res ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SMULLB_Z_ZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 0
  match VL with
  | 128 => (execute_SMULLB_Z_ZZi_S 128 d esize index m n sel)
  | 256 => (execute_SMULLB_Z_ZZi_S 256 d esize index m n sel)
  | 512 => (execute_SMULLB_Z_ZZi_S 512 d esize index m n sel)
  | 1024 => (execute_SMULLB_Z_ZZi_S 1024 d esize index m n sel)
  | 2048 => (execute_SMULLB_Z_ZZi_S 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMULLB_Z_ZZi_D (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := (element1 *i element2)
        (Elem_set result e (2 *i esize) (integer_subrange res ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SMULLB_Z_ZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 0
  match VL with
  | 128 => (execute_SMULLB_Z_ZZi_D 128 d esize index m n sel)
  | 256 => (execute_SMULLB_Z_ZZi_D 256 d esize index m n sel)
  | 512 => (execute_SMULLB_Z_ZZi_D 512 d esize index m n sel)
  | 1024 => (execute_SMULLB_Z_ZZi_D 1024 d esize index m n sel)
  | 2048 => (execute_SMULLB_Z_ZZi_D 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMULLT_Z_ZZi_S (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := (element1 *i element2)
        (Elem_set result e (2 *i esize) (integer_subrange res ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SMULLT_Z_ZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 1
  match VL with
  | 128 => (execute_SMULLT_Z_ZZi_S 128 d esize index m n sel)
  | 256 => (execute_SMULLT_Z_ZZi_S 256 d esize index m n sel)
  | 512 => (execute_SMULLT_Z_ZZi_S 512 d esize index m n sel)
  | 1024 => (execute_SMULLT_Z_ZZi_S 1024 d esize index m n sel)
  | 2048 => (execute_SMULLT_Z_ZZi_S 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMULLT_Z_ZZi_D (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := (element1 *i element2)
        (Elem_set result e (2 *i esize) (integer_subrange res ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SMULLT_Z_ZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 1
  match VL with
  | 128 => (execute_SMULLT_Z_ZZi_D 128 d esize index m n sel)
  | 256 => (execute_SMULLT_Z_ZZi_D 256 d esize index m n sel)
  | 512 => (execute_SMULLT_Z_ZZi_D 512 d esize index m n sel)
  | 1024 => (execute_SMULLT_Z_ZZi_D 1024 d esize index m n sel)
  | 2048 => (execute_SMULLT_Z_ZZi_D 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMULLB_Z_ZZi_S (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := (element1 *i element2)
        (Elem_set result e (2 *i esize) (integer_subrange res ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UMULLB_Z_ZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 0
  match VL with
  | 128 => (execute_UMULLB_Z_ZZi_S 128 d esize index m n sel)
  | 256 => (execute_UMULLB_Z_ZZi_S 256 d esize index m n sel)
  | 512 => (execute_UMULLB_Z_ZZi_S 512 d esize index m n sel)
  | 1024 => (execute_UMULLB_Z_ZZi_S 1024 d esize index m n sel)
  | 2048 => (execute_UMULLB_Z_ZZi_S 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMULLB_Z_ZZi_D (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := (element1 *i element2)
        (Elem_set result e (2 *i esize) (integer_subrange res ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UMULLB_Z_ZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 0
  match VL with
  | 128 => (execute_UMULLB_Z_ZZi_D 128 d esize index m n sel)
  | 256 => (execute_UMULLB_Z_ZZi_D 256 d esize index m n sel)
  | 512 => (execute_UMULLB_Z_ZZi_D 512 d esize index m n sel)
  | 1024 => (execute_UMULLB_Z_ZZi_D 1024 d esize index m n sel)
  | 2048 => (execute_UMULLB_Z_ZZi_D 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMULLT_Z_ZZi_S (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := (element1 *i element2)
        (Elem_set result e (2 *i esize) (integer_subrange res ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UMULLT_Z_ZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 1
  match VL with
  | 128 => (execute_UMULLT_Z_ZZi_S 128 d esize index m n sel)
  | 256 => (execute_UMULLT_Z_ZZi_S 256 d esize index m n sel)
  | 512 => (execute_UMULLT_Z_ZZi_S 512 d esize index m n sel)
  | 1024 => (execute_UMULLT_Z_ZZi_S 1024 d esize index m n sel)
  | 2048 => (execute_UMULLT_Z_ZZi_S 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMULLT_Z_ZZi_D (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := (element1 *i element2)
        (Elem_set result e (2 *i esize) (integer_subrange res ((2 *i esize) -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UMULLT_Z_ZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 1
  match VL with
  | 128 => (execute_UMULLT_Z_ZZi_D 128 d esize index m n sel)
  | 256 => (execute_UMULLT_Z_ZZi_D 256 d esize index m n sel)
  | 512 => (execute_UMULLT_Z_ZZi_D 512 d esize index m n sel)
  | 1024 => (execute_UMULLT_Z_ZZi_D 1024 d esize index m n sel)
  | 2048 => (execute_UMULLT_Z_ZZi_D 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLALB_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLALB_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_SMLALB_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_SMLALB_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_SMLALB_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_SMLALB_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_SMLALB_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLALB_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLALB_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_SMLALB_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_SMLALB_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_SMLALB_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_SMLALB_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_SMLALB_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLALT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLALT_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_SMLALT_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_SMLALT_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_SMLALT_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_SMLALT_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_SMLALT_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLALT_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLALT_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_SMLALT_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_SMLALT_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_SMLALT_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_SMLALT_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_SMLALT_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLALB_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLALB_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_UMLALB_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_UMLALB_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_UMLALB_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_UMLALB_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_UMLALB_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLALB_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLALB_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_UMLALB_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_UMLALB_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_UMLALB_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_UMLALB_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_UMLALB_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLALT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLALT_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_UMLALT_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_UMLALT_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_UMLALT_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_UMLALT_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_UMLALT_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLALT_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) + product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLALT_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_UMLALT_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_UMLALT_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_UMLALT_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_UMLALT_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_UMLALT_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLSLB_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLSLB_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_SMLSLB_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_SMLSLB_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_SMLSLB_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_SMLSLB_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_SMLSLB_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLSLB_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLSLB_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_SMLSLB_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_SMLSLB_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_SMLSLB_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_SMLSLB_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_SMLSLB_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLSLT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLSLT_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_SMLSLT_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_SMLSLT_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_SMLSLT_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_SMLSLT_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_SMLSLT_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMLSLT_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SMLSLT_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_SMLSLT_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_SMLSLT_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_SMLSLT_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_SMLSLT_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_SMLSLT_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLSLB_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLSLB_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_UMLSLB_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_UMLSLB_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_UMLSLB_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_UMLSLB_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_UMLSLB_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLSLB_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLSLB_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_UMLSLB_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_UMLSLB_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_UMLSLB_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_UMLSLB_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_UMLSLB_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLSLT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLSLT_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (U : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_UMLSLT_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_UMLSLT_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_UMLSLT_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_UMLSLT_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_UMLSLT_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMLSLT_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toNat (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let product : (BitVec (2 * esize)) :=
          (integer_subrange (element1 *i element2) ((2 *i esize) -i 1) 0)
        (Elem_set result e (2 *i esize) ((← (Elem_read result e (2 *i esize))) - product))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_UMLSLT_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (U : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_UMLSLT_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_UMLSLT_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_UMLSLT_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_UMLSLT_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_UMLSLT_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULLB_Z_ZZi_S (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQDMULLB_Z_ZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 0
  match VL with
  | 128 => (execute_SQDMULLB_Z_ZZi_S 128 d esize index m n sel)
  | 256 => (execute_SQDMULLB_Z_ZZi_S 256 d esize index m n sel)
  | 512 => (execute_SQDMULLB_Z_ZZi_S 512 d esize index m n sel)
  | 1024 => (execute_SQDMULLB_Z_ZZi_S 1024 d esize index m n sel)
  | 2048 => (execute_SQDMULLB_Z_ZZi_S 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULLB_Z_ZZi_D (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQDMULLB_Z_ZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 0
  match VL with
  | 128 => (execute_SQDMULLB_Z_ZZi_D 128 d esize index m n sel)
  | 256 => (execute_SQDMULLB_Z_ZZi_D 256 d esize index m n sel)
  | 512 => (execute_SQDMULLB_Z_ZZi_D 512 d esize index m n sel)
  | 1024 => (execute_SQDMULLB_Z_ZZi_D 1024 d esize index m n sel)
  | 2048 => (execute_SQDMULLB_Z_ZZi_D 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULLT_Z_ZZi_S (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQDMULLT_Z_ZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 1
  match VL with
  | 128 => (execute_SQDMULLT_Z_ZZi_S 128 d esize index m n sel)
  | 256 => (execute_SQDMULLT_Z_ZZi_S 256 d esize index m n sel)
  | 512 => (execute_SQDMULLT_Z_ZZi_S 512 d esize index m n sel)
  | 1024 => (execute_SQDMULLT_Z_ZZi_S 1024 d esize index m n sel)
  | 2048 => (execute_SQDMULLT_Z_ZZi_S 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULLT_Z_ZZi_D (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQDMULLT_Z_ZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel := 1
  match VL with
  | 128 => (execute_SQDMULLT_Z_ZZi_D 128 d esize index m n sel)
  | 256 => (execute_SQDMULLT_Z_ZZi_D 256 d esize index m n sel)
  | 512 => (execute_SQDMULLT_Z_ZZi_D 512 d esize index m n sel)
  | 1024 => (execute_SQDMULLT_Z_ZZi_D 1024 d esize index m n sel)
  | 2048 => (execute_SQDMULLT_Z_ZZi_D 2048 d esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLALB_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e (2 *i esize)))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) (2 *i esize)))))
        let res := (element3 +i product)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLALB_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_SQDMLALB_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_SQDMLALB_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_SQDMLALB_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_SQDMLALB_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_SQDMLALB_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLALB_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e (2 *i esize)))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) (2 *i esize)))))
        let res := (element3 +i product)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLALB_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_SQDMLALB_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_SQDMLALB_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_SQDMLALB_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_SQDMLALB_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_SQDMLALB_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLALT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e (2 *i esize)))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) (2 *i esize)))))
        let res := (element3 +i product)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLALT_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_SQDMLALT_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_SQDMLALT_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_SQDMLALT_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_SQDMLALT_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_SQDMLALT_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLALT_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e (2 *i esize)))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) (2 *i esize)))))
        let res := (element3 +i product)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLALT_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_SQDMLALT_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_SQDMLALT_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_SQDMLALT_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_SQDMLALT_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_SQDMLALT_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLSLB_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e (2 *i esize)))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) (2 *i esize)))))
        let res := (element3 -i product)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLSLB_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_SQDMLSLB_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_SQDMLSLB_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_SQDMLSLB_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_SQDMLSLB_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_SQDMLSLB_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLSLB_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e (2 *i esize)))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) (2 *i esize)))))
        let res := (element3 -i product)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLSLB_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 0
  match VL with
  | 128 => (execute_SQDMLSLB_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_SQDMLSLB_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_SQDMLSLB_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_SQDMLSLB_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_SQDMLSLB_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLSLT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e (2 *i esize)))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) (2 *i esize)))))
        let res := (element3 -i product)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLSLT_Z_ZZZi_S (size : (BitVec 2)) (i3h : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (i3l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_SQDMLSLT_Z_ZZZi_S 128 da esize index m n sel)
  | 256 => (execute_SQDMLSLT_Z_ZZZi_S 256 da esize index m n sel)
  | 512 => (execute_SQDMLSLT_Z_ZZZi_S 512 da esize index m n sel)
  | 1024 => (execute_SQDMLSLT_Z_ZZZi_S 1024 da esize index m n sel)
  | 2048 => (execute_SQDMLSLT_Z_ZZZi_S 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel : Nat, sel
  = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLSLT_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let eltspersegment := (Int.ediv 128 (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let s := (e -i (Nat.div e eltspersegment))
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel) esize))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i s) +i index) esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e (2 *i esize)))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) (2 *i esize)))))
        let res := (element3 -i product)
        (Elem_set result e (2 *i esize) (← (SignedSat res (2 *i esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLSLT_Z_ZZZi_D (size : (BitVec 2)) (i2h : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (i2l : (BitVec 1)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat (i2h ++ i2l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel := 1
  match VL with
  | 128 => (execute_SQDMLSLT_Z_ZZZi_D 128 da esize index m n sel)
  | 256 => (execute_SQDMLSLT_Z_ZZZi_D 256 da esize index m n sel)
  | 512 => (execute_SQDMLSLT_Z_ZZZi_D 512 da esize index m n sel)
  | 1024 => (execute_SQDMLSLT_Z_ZZZi_D 1024 da esize index m n sel)
  | 2048 => (execute_SQDMLSLT_Z_ZZZi_D 2048 da esize index m n sel)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, sel1 : Nat, sel2 : Nat, sel2
  = 1 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLALBT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2)))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e esize))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) esize))))
        (Elem_set result e esize (← (SignedSat (element3 +i product) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLALBT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel1 := 0
  let sel2 := 1
  match VL with
  | 128 => (execute_SQDMLALBT_Z_ZZZ__ 128 da esize m n sel1 sel2)
  | 256 => (execute_SQDMLALBT_Z_ZZZ__ 256 da esize m n sel1 sel2)
  | 512 => (execute_SQDMLALBT_Z_ZZZ__ 512 da esize m n sel1 sel2)
  | 1024 => (execute_SQDMLALBT_Z_ZZZ__ 1024 da esize m n sel1 sel2)
  | 2048 => (execute_SQDMLALBT_Z_ZZZ__ 2048 da esize m n sel1 sel2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, sel1 : Nat, sel2 : Nat, sel2
  = 1 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMLSLBT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do
          (pure (BitVec.toInt (← (Elem_read operand1 ((2 *i e) +i sel1) (Int.ediv esize 2)))))
        let element2 ← do
          (pure (BitVec.toInt (← (Elem_read operand2 ((2 *i e) +i sel2) (Int.ediv esize 2)))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read result e esize))))
        let product ← do
          (pure (BitVec.toInt (← (SignedSat ((2 *i element1) *i element2) esize))))
        (Elem_set result e esize (← (SignedSat (element3 -i product) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQDMLSLBT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel1 := 0
  let sel2 := 1
  match VL with
  | 128 => (execute_SQDMLSLBT_Z_ZZZ__ 128 da esize m n sel1 sel2)
  | 256 => (execute_SQDMLSLBT_Z_ZZZ__ 256 da esize m n sel1 sel2)
  | 512 => (execute_SQDMLSLBT_Z_ZZZ__ 512 da esize m n sel1 sel2)
  | 1024 => (execute_SQDMLSLBT_Z_ZZZ__ 1024 da esize m n sel1 sel2)
  | 2048 => (execute_SQDMLSLBT_Z_ZZZ__ 2048 da esize m n sel1 sel2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMULH_Z_ZZi_H (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRDMULH_Z_ZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (R : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQRDMULH_Z_ZZi_H 128 d esize index m n)
  | 256 => (execute_SQRDMULH_Z_ZZi_H 256 d esize index m n)
  | 512 => (execute_SQRDMULH_Z_ZZi_H 512 d esize index m n)
  | 1024 => (execute_SQRDMULH_Z_ZZi_H 1024 d esize index m n)
  | 2048 => (execute_SQRDMULH_Z_ZZi_H 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMULH_Z_ZZi_S (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRDMULH_Z_ZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (R : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQRDMULH_Z_ZZi_S 128 d esize index m n)
  | 256 => (execute_SQRDMULH_Z_ZZi_S 256 d esize index m n)
  | 512 => (execute_SQRDMULH_Z_ZZi_S 512 d esize index m n)
  | 1024 => (execute_SQRDMULH_Z_ZZi_S 1024 d esize index m n)
  | 2048 => (execute_SQRDMULH_Z_ZZi_S 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMULH_Z_ZZi_D (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRDMULH_Z_ZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (R : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQRDMULH_Z_ZZi_D 128 d esize index m n)
  | 256 => (execute_SQRDMULH_Z_ZZi_D 256 d esize index m n)
  | 512 => (execute_SQRDMULH_Z_ZZi_D 512 d esize index m n)
  | 1024 => (execute_SQRDMULH_Z_ZZi_D 1024 d esize index m n)
  | 2048 => (execute_SQRDMULH_Z_ZZi_D 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMLAH_Z_ZZZi_H (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let res := ((Int.shiftl element3 esize) +i ((2 *i element1) *i element2))
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQRDMLAH_Z_ZZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SQRDMLAH_Z_ZZZi_H 128 da esize index m n)
  | 256 => (execute_SQRDMLAH_Z_ZZZi_H 256 da esize index m n)
  | 512 => (execute_SQRDMLAH_Z_ZZZi_H 512 da esize index m n)
  | 1024 => (execute_SQRDMLAH_Z_ZZZi_H 1024 da esize index m n)
  | 2048 => (execute_SQRDMLAH_Z_ZZZi_H 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMLAH_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let res := ((Int.shiftl element3 esize) +i ((2 *i element1) *i element2))
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQRDMLAH_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SQRDMLAH_Z_ZZZi_S 128 da esize index m n)
  | 256 => (execute_SQRDMLAH_Z_ZZZi_S 256 da esize index m n)
  | 512 => (execute_SQRDMLAH_Z_ZZZi_S 512 da esize index m n)
  | 1024 => (execute_SQRDMLAH_Z_ZZZi_S 1024 da esize index m n)
  | 2048 => (execute_SQRDMLAH_Z_ZZZi_S 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMLAH_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let res := ((Int.shiftl element3 esize) +i ((2 *i element1) *i element2))
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQRDMLAH_Z_ZZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SQRDMLAH_Z_ZZZi_D 128 da esize index m n)
  | 256 => (execute_SQRDMLAH_Z_ZZZi_D 256 da esize index m n)
  | 512 => (execute_SQRDMLAH_Z_ZZZi_D 512 da esize index m n)
  | 1024 => (execute_SQRDMLAH_Z_ZZZi_D 1024 da esize index m n)
  | 2048 => (execute_SQRDMLAH_Z_ZZZi_D 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMLSH_Z_ZZZi_H (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let res := ((Int.shiftl element3 esize) -i ((2 *i element1) *i element2))
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQRDMLSH_Z_ZZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SQRDMLSH_Z_ZZZi_H 128 da esize index m n)
  | 256 => (execute_SQRDMLSH_Z_ZZZi_H 256 da esize index m n)
  | 512 => (execute_SQRDMLSH_Z_ZZZi_H 512 da esize index m n)
  | 1024 => (execute_SQRDMLSH_Z_ZZZi_H 1024 da esize index m n)
  | 2048 => (execute_SQRDMLSH_Z_ZZZi_H 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMLSH_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let res := ((Int.shiftl element3 esize) -i ((2 *i element1) *i element2))
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQRDMLSH_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SQRDMLSH_Z_ZZZi_S 128 da esize index m n)
  | 256 => (execute_SQRDMLSH_Z_ZZZi_S 256 da esize index m n)
  | 512 => (execute_SQRDMLSH_Z_ZZZi_S 512 da esize index m n)
  | 1024 => (execute_SQRDMLSH_Z_ZZZi_S 1024 da esize index m n)
  | 2048 => (execute_SQRDMLSH_Z_ZZZi_S 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SQRDMLSH_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let res := ((Int.shiftl element3 esize) -i ((2 *i element1) *i element2))
        (Elem_set result e esize
          (← (SignedSat (Int.shiftr (res +i (Int.shiftl 1 (esize -i 1))) esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SQRDMLSH_Z_ZZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (S : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SQRDMLSH_Z_ZZZi_D 128 da esize index m n)
  | 256 => (execute_SQRDMLSH_Z_ZZZi_D 256 da esize index m n)
  | 512 => (execute_SQRDMLSH_Z_ZZZi_D 512 da esize index m n)
  | 1024 => (execute_SQRDMLSH_Z_ZZZi_D 1024 da esize index m n)
  | 2048 => (execute_SQRDMLSH_Z_ZZZi_D 2048 da esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SHADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (Int.shiftr (element1 +i element2) 1)
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SHADD_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_SHADD_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SHADD_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SHADD_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SHADD_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SHADD_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SHSUB_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (Int.shiftr (element1 -i element2) 1)
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SHSUB_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_SHSUB_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SHSUB_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SHSUB_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SHSUB_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SHSUB_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SHSUBR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (Int.shiftr (element2 -i element1) 1)
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SHSUBR_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_SHSUBR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SHSUBR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SHSUBR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SHSUBR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SHSUBR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SRHADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (Int.shiftr ((element1 +i element2) +i 1) 1)
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SRHADD_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_SRHADD_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SRHADD_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SRHADD_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SRHADD_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SRHADD_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UHADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (Int.shiftr (element1 +i element2) 1)
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UHADD_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_UHADD_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_UHADD_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_UHADD_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_UHADD_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_UHADD_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UHSUB_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (Int.shiftr (element1 -i element2) 1)
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UHSUB_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_UHSUB_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_UHSUB_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_UHSUB_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_UHSUB_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_UHSUB_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UHSUBR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (Int.shiftr (element2 -i element1) 1)
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UHSUBR_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_UHSUBR_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_UHSUBR_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_UHSUBR_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_UHSUBR_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_UHSUBR_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_URHADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res := (Int.shiftr ((element1 +i element2) +i 1) 1)
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_URHADD_Z_P_ZZ__ (size : (BitVec 2)) (R : (BitVec 1)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_URHADD_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_URHADD_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_URHADD_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_URHADD_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_URHADD_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res ← do
              (pure (BitVec.toInt (← (Sat (element1 +i element2) esize is_unsigned))))
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQADD_Z_P_ZZ__ (size : (BitVec 2)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQADD_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_SQADD_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_SQADD_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_SQADD_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_SQADD_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res ← do
              (pure (BitVec.toNat (← (Sat (element1 +i element2) esize is_unsigned))))
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQADD_Z_P_ZZ__ (size : (BitVec 2)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQADD_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_UQADD_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_UQADD_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_UQADD_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_UQADD_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQSUB_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res ← do
              (pure (BitVec.toInt (← (Sat (element1 -i element2) esize is_unsigned))))
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQSUB_Z_P_ZZ__ (size : (BitVec 2)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQSUB_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_SQSUB_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_SQSUB_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_SQSUB_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_SQSUB_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQSUB_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res ← do
              (pure (BitVec.toNat (← (Sat (element1 -i element2) esize is_unsigned))))
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQSUB_Z_P_ZZ__ (size : (BitVec 2)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQSUB_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_UQSUB_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_UQSUB_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_UQSUB_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_UQSUB_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SQSUBR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res ← do
              (pure (BitVec.toInt (← (Sat (element2 -i element1) esize is_unsigned))))
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SQSUBR_Z_P_ZZ__ (size : (BitVec 2)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SQSUBR_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_SQSUBR_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_SQSUBR_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_SQSUBR_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_SQSUBR_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤
  m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_UQSUBR_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let res ← do
              (pure (BitVec.toNat (← (Sat (element2 -i element1) esize is_unsigned))))
            (Elem_set result e esize (integer_subrange res (esize -i 1) 0)))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_UQSUBR_Z_P_ZZ__ (size : (BitVec 2)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UQSUBR_Z_P_ZZ__ 128 dn esize g m is_unsigned)
  | 256 => (execute_UQSUBR_Z_P_ZZ__ 256 dn esize g m is_unsigned)
  | 512 => (execute_UQSUBR_Z_P_ZZ__ 512 dn esize g m is_unsigned)
  | 1024 => (execute_UQSUBR_Z_P_ZZ__ 1024 dn esize g m is_unsigned)
  | 2048 => (execute_UQSUBR_Z_P_ZZ__ 2048 dn esize g m is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SUQADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize
              (← (SignedSat ((BitVec.toInt element1) +i (BitVec.toNat element2)) esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SUQADD_Z_P_ZZ__ (size : (BitVec 2)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_SUQADD_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_SUQADD_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_SUQADD_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_SUQADD_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_SUQADD_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, g : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_USQADD_Z_P_ZZ__ (VL : Nat) (dn : Nat) (esize : Nat) (g : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize
              (← (UnsignedSat ((BitVec.toNat element1) +i (BitVec.toInt element2)) esize))))
        else
          (do
            (Elem_set result e esize (← (Elem_read operand1 e esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_USQADD_Z_P_ZZ__ (size : (BitVec 2)) (S : (BitVec 1)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_USQADD_Z_P_ZZ__ 128 dn esize g m)
  | 256 => (execute_USQADD_Z_P_ZZ__ 256 dn esize g m)
  | 512 => (execute_USQADD_Z_P_ZZ__ 512 dn esize g m)
  | 1024 => (execute_USQADD_Z_P_ZZ__ 1024 dn esize g m)
  | 2048 => (execute_USQADD_Z_P_ZZ__ 2048 dn esize g m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SLI_Z_ZZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read result e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        let mask : (BitVec esize) := ((Ones (n := esize)) <<< shift)
        let shiftedval : (BitVec esize) := (element2 <<< shift)
        (Elem_set result e esize ((element1 &&& (Complement.complement mask)) ||| shiftedval))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SLI_Z_ZZI__ (tszh : (BitVec 2)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((BitVec.toNat (tsize ++ imm3)) -i esize)
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_SLI_Z_ZZI__ 128 d 8 n shift)
      | 256 => (execute_SLI_Z_ZZI__ 256 d 8 n shift)
      | 512 => (execute_SLI_Z_ZZI__ 512 d 8 n shift)
      | 1024 => (execute_SLI_Z_ZZI__ 1024 d 8 n shift)
      | 2048 => (execute_SLI_Z_ZZI__ 2048 d 8 n shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_SLI_Z_ZZI__ 128 d 16 n shift)
      | 256 => (execute_SLI_Z_ZZI__ 256 d 16 n shift)
      | 512 => (execute_SLI_Z_ZZI__ 512 d 16 n shift)
      | 1024 => (execute_SLI_Z_ZZI__ 1024 d 16 n shift)
      | 2048 => (execute_SLI_Z_ZZI__ 2048 d 16 n shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_SLI_Z_ZZI__ 128 d 32 n shift)
      | 256 => (execute_SLI_Z_ZZI__ 256 d 32 n shift)
      | 512 => (execute_SLI_Z_ZZI__ 512 d 32 n shift)
      | 1024 => (execute_SLI_Z_ZZI__ 1024 d 32 n shift)
      | 2048 => (execute_SLI_Z_ZZI__ 2048 d 32 n shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_SLI_Z_ZZI__ 128 d 64 n shift)
      | 256 => (execute_SLI_Z_ZZI__ 256 d 64 n shift)
      | 512 => (execute_SLI_Z_ZZI__ 512 d 64 n shift)
      | 1024 => (execute_SLI_Z_ZZI__ 1024 d 64 n shift)
      | 2048 => (execute_SLI_Z_ZZI__ 2048 d 64 n shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:49830.22-49830.23"

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SRI_Z_ZZI__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read result e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
        let mask : (BitVec esize) := ((Ones (n := esize)) >>> shift)
        let shiftedval : (BitVec esize) := (element2 >>> shift)
        (Elem_set result e esize ((element1 &&& (Complement.complement mask)) ||| shiftedval))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SRI_Z_ZZI__ (tszh : (BitVec 2)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_SRI_Z_ZZI__ 128 d 8 n shift)
      | 256 => (execute_SRI_Z_ZZI__ 256 d 8 n shift)
      | 512 => (execute_SRI_Z_ZZI__ 512 d 8 n shift)
      | 1024 => (execute_SRI_Z_ZZI__ 1024 d 8 n shift)
      | 2048 => (execute_SRI_Z_ZZI__ 2048 d 8 n shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_SRI_Z_ZZI__ 128 d 16 n shift)
      | 256 => (execute_SRI_Z_ZZI__ 256 d 16 n shift)
      | 512 => (execute_SRI_Z_ZZI__ 512 d 16 n shift)
      | 1024 => (execute_SRI_Z_ZZI__ 1024 d 16 n shift)
      | 2048 => (execute_SRI_Z_ZZI__ 2048 d 16 n shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_SRI_Z_ZZI__ 128 d 32 n shift)
      | 256 => (execute_SRI_Z_ZZI__ 256 d 32 n shift)
      | 512 => (execute_SRI_Z_ZZI__ 512 d 32 n shift)
      | 1024 => (execute_SRI_Z_ZZI__ 1024 d 32 n shift)
      | 2048 => (execute_SRI_Z_ZZI__ 2048 d 32 n shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_SRI_Z_ZZI__ 128 d 64 n shift)
      | 256 => (execute_SRI_Z_ZZI__ 256 d 64 n shift)
      | 512 => (execute_SRI_Z_ZZI__ 512 d 64 n shift)
      | 1024 => (execute_SRI_Z_ZZI__ 1024 d 64 n shift)
      | 2048 => (execute_SRI_Z_ZZI__ 2048 d 64 n shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:49978.22-49978.23"

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_TBX_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        bif (element2 <b elements)
        then
          (do
            (Elem_set result e esize (← (Elem_read operand1 element2 esize))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_TBX_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_TBX_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_TBX_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_TBX_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_TBX_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_TBX_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_URECPE_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize (← (UnsignedRecipEstimate element))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_URECPE_Z_P_Z__ (size : (BitVec 2)) (Q : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (bne size (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_URECPE_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_URECPE_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_URECPE_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_URECPE_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_URECPE_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_URSQRTE_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize (← (UnsignedRSqrtEstimate element))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_URSQRTE_Z_P_Z__ (size : (BitVec 2)) (Q : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (bne size (0b10 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_URSQRTE_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_URSQRTE_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_URSQRTE_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_URSQRTE_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_URSQRTE_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_MATCH_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let segmentbase := (e -i (Nat.div e eltspersegment))
            let result ←
              (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize))
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let loop_i_lower := segmentbase
            let loop_i_upper := ((segmentbase +i eltspersegment) -i 1)
            let mut loop_vars_1 := result
            for i in [loop_i_lower:loop_i_upper:1]i do
              let result := loop_vars_1
              loop_vars_1 ← do
                let element2 ← (( do (Elem_read operand2 i esize) ) : SailM (BitVec esize) )
                bif (BEq.beq element1 element2)
                then
                  (do
                    (Elem_set result e psize (Sail.BitVec.zeroExtend (0b1 : (BitVec 1)) psize)))
                else (pure result)
            (pure loop_vars_1))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_MATCH_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b1 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let d := (BitVec.toNat Pd)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_MATCH_P_P_ZZ__ 128 d esize g m n)
  | 256 => (execute_MATCH_P_P_ZZ__ 256 d esize g m n)
  | 512 => (execute_MATCH_P_P_ZZ__ 512 d esize g m n)
  | 1024 => (execute_MATCH_P_P_ZZ__ 1024 d esize g m n)
  | 2048 => (execute_MATCH_P_P_ZZ__ 2048 d esize g m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_NMATCH_P_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let segmentbase := (e -i (Nat.div e eltspersegment))
            let result ←
              (Elem_set result e psize (Sail.BitVec.zeroExtend (0b1 : (BitVec 1)) psize))
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let loop_i_lower := segmentbase
            let loop_i_upper := ((segmentbase +i eltspersegment) -i 1)
            let mut loop_vars_1 := result
            for i in [loop_i_lower:loop_i_upper:1]i do
              let result := loop_vars_1
              loop_vars_1 ← do
                let element2 ← (( do (Elem_read operand2 i esize) ) : SailM (BitVec esize) )
                bif (BEq.beq element1 element2)
                then
                  (do
                    (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
                else (pure result)
            (pure loop_vars_1))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_NMATCH_P_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b1 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let d := (BitVec.toNat Pd)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_NMATCH_P_P_ZZ__ 128 d esize g m n)
  | 256 => (execute_NMATCH_P_P_ZZ__ 256 d esize g m n)
  | 512 => (execute_NMATCH_P_P_ZZ__ 512 d esize g m n)
  | 1024 => (execute_NMATCH_P_P_ZZ__ 1024 d esize g m n)
  | 2048 => (execute_NMATCH_P_P_ZZ__ 2048 d esize g m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_HISTCNT_Z_P_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand1 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let operand2 ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read m VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let count : Int := 0
        let count ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
              let loop_i_lower := 0
              let loop_i_upper := e
              let mut loop_vars_1 := count
              for i in [loop_i_lower:loop_i_upper:1]i do
                let count := loop_vars_1
                loop_vars_1 ← do
                  bif (← (ActivePredicateElement mask i esize))
                  then
                    (do
                      let element2 ← (( do (Elem_read operand2 i esize) ) : SailM (BitVec esize) )
                      bif (BEq.beq element1 element2)
                      then (pure (count +i 1))
                      else (pure count))
                  else (pure count)
              (pure loop_vars_1))
          else (pure count) ) : SailM Int )
        let count := count
        (Elem_set result e esize (integer_subrange count (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_HISTCNT_Z_P_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let d := (BitVec.toNat Zd)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_HISTCNT_Z_P_ZZ__ 128 d esize g m n)
  | 256 => (execute_HISTCNT_Z_P_ZZ__ 256 d esize g m n)
  | 512 => (execute_HISTCNT_Z_P_ZZ__ 512 d esize g m n)
  | 1024 => (execute_HISTCNT_Z_P_ZZ__ 1024 d esize g m n)
  | 2048 => (execute_HISTCNT_Z_P_ZZ__ 2048 d esize g m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_HISTSEG_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let segments := (Int.ediv VL 128)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_b_lower := 0
    let loop_b_upper := (segments -i 1)
    let mut loop_vars := result
    for b in [loop_b_lower:loop_b_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_s_lower := 0
        let loop_s_upper := (eltspersegment -i 1)
        let mut loop_vars_1 := result
        for s in [loop_s_lower:loop_s_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let count : Int := 0
            let e := ((eltspersegment *i b) +i s)
            let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
            let count ← (( do
              let loop_i_lower := 0
              let loop_i_upper := (eltspersegment -i 1)
              let mut loop_vars_2 := count
              for i in [loop_i_lower:loop_i_upper:1]i do
                let count := loop_vars_2
                loop_vars_2 ← do
                  let e2 := ((eltspersegment *i b) +i i)
                  let element2 ← (( do (Elem_read operand2 e2 esize) ) : SailM (BitVec esize) )
                  bif (BEq.beq element1 element2)
                  then (pure (count +i 1))
                  else (pure count)
              (pure loop_vars_2) ) : SailM Int )
            let count := count
            (Elem_set result e esize (integer_subrange count (esize -i 1) 0))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_HISTSEG_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (bne size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let d := (BitVec.toNat Zd)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  match VL with
  | 128 => (execute_HISTSEG_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_HISTSEG_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_HISTSEG_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_HISTSEG_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_HISTSEG_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEWR_P_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec PL) := (Ones (n := PL))
  let src1 ← (( do (X_read n 64) ) : SailM (BitVec 64) )
  let src2 ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let operand1 := (BitVec.toNat src1)
  let operand2 := (BitVec.toNat src2)
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let diff := (fdiv_int (operand2 -i operand1) (Int.ediv esize 8))
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (Bool.or (diff ≤b 0) (e <b diff))
        then
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b1 : (BitVec 1)) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILEWR_P_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (Rn : (BitVec 5)) (rw : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Pd)
  match VL with
  | 128 => (execute_WHILEWR_P_RR__ 128 d esize m n)
  | 256 => (execute_WHILEWR_P_RR__ 256 d esize m n)
  | 512 => (execute_WHILEWR_P_RR__ 512 d esize m n)
  | 1024 => (execute_WHILEWR_P_RR__ 1024 d esize m n)
  | 2048 => (execute_WHILEWR_P_RR__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILERW_P_RR__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec PL) := (Ones (n := PL))
  let src1 ← (( do (X_read n 64) ) : SailM (BitVec 64) )
  let src2 ← (( do (X_read m 64) ) : SailM (BitVec 64) )
  let operand1 := (BitVec.toNat src1)
  let operand2 := (BitVec.toNat src2)
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let diff := (Int.ediv (Int.natAbs (operand2 -i operand1)) (Int.ediv esize 8))
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (Bool.or (BEq.beq diff 0) (e <b diff))
        then
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b1 : (BitVec 1)) psize)))
        else
          (do
            (Elem_set result e psize (Sail.BitVec.zeroExtend (0b0 : (BitVec 1)) psize)))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILERW_P_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (Rn : (BitVec 5)) (rw : (BitVec 1)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat Pd)
  match VL with
  | 128 => (execute_WHILERW_P_RR__ 128 d esize m n)
  | 256 => (execute_WHILERW_P_RR__ 256 d esize m n)
  | 512 => (execute_WHILERW_P_RR__ 512 d esize m n)
  | 1024 => (execute_WHILERW_P_RR__ 1024 d esize m n)
  | 2048 => (execute_WHILERW_P_RR__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BDEP_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let data ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let mask ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize
          (← (BitDeposit (← (Elem_read data e esize)) (← (Elem_read mask e esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BDEP_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVE2BitPerm ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BDEP_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_BDEP_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_BDEP_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_BDEP_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_BDEP_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BEXT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let data ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let mask ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize
          (← (BitExtract (← (Elem_read data e esize)) (← (Elem_read mask e esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BEXT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVE2BitPerm ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BEXT_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_BEXT_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_BEXT_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_BEXT_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_BEXT_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_BGRP_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let data ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let mask ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e esize
          (← (BitGroup (← (Elem_read data e esize)) (← (Elem_read mask e esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_BGRP_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVE2BitPerm ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_BGRP_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_BGRP_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_BGRP_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_BGRP_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_BGRP_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, sel1 : Nat, sel2 : Nat, sel2
  = 1 ∧
  sel1 = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_EORBT_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i sel1) esize) ) : SailM
          (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i sel2) esize) ) : SailM
          (BitVec esize) )
        (Elem_set result ((2 *i e) +i sel1) esize (element1 ^^^ element2))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_EORBT_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (tb : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 0
  let sel2 := 1
  match VL with
  | 128 => (execute_EORBT_Z_ZZ__ 128 d esize m n sel1 sel2)
  | 256 => (execute_EORBT_Z_ZZ__ 256 d esize m n sel1 sel2)
  | 512 => (execute_EORBT_Z_ZZ__ 512 d esize m n sel1 sel2)
  | 1024 => (execute_EORBT_Z_ZZ__ 1024 d esize m n sel1 sel2)
  | 2048 => (execute_EORBT_Z_ZZ__ 2048 d esize m n sel1 sel2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, sel1 : Nat, sel2 : Nat, sel2
  = 0 ∧
  sel1 = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_EORTB_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel1 : Nat) (sel2 : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL (2 *i esize))
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 ((2 *i e) +i sel1) esize) ) : SailM
          (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 ((2 *i e) +i sel2) esize) ) : SailM
          (BitVec esize) )
        (Elem_set result ((2 *i e) +i sel1) esize (element1 ^^^ element2))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_EORTB_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (tb : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let sel1 := 1
  let sel2 := 0
  match VL with
  | 128 => (execute_EORTB_Z_ZZ__ 128 d esize m n sel1 sel2)
  | 256 => (execute_EORTB_Z_ZZ__ 256 d esize m n sel1 sel2)
  | 512 => (execute_EORTB_Z_ZZ__ 512 d esize m n sel1 sel2)
  | 1024 => (execute_EORTB_Z_ZZ__ 1024 d esize m n sel1 sel2)
  | 2048 => (execute_EORTB_Z_ZZ__ 2048 d esize m n sel1 sel2)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, sel_a : Nat, sel_b : Nat, k_sub_i
  : Bool, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_CDOT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) (sel_a : Nat) (sel_b : Nat) (sub_i : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let elt1_r ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand1 (((4 *i e) +i (2 *i i)) +i 0) (Int.ediv esize 4)))))
              let elt1_i ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand1 (((4 *i e) +i (2 *i i)) +i 1) (Int.ediv esize 4)))))
              let elt2_a ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand2 (((4 *i e) +i (2 *i i)) +i sel_a) (Int.ediv esize 4)))))
              let elt2_b ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand2 (((4 *i e) +i (2 *i i)) +i sel_b) (Int.ediv esize 4)))))
              bif sub_i
              then (pure (BitVec.subInt (BitVec.addInt res (elt1_r *i elt2_a)) (elt1_i *i elt2_b)))
              else (pure (BitVec.addInt (BitVec.addInt res (elt1_r *i elt2_a)) (elt1_i *i elt2_b)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_CDOT_Z_ZZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (let b__0 := size
     bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 1) (0b0 : (BitVec 1)))
     then true
     else false : Bool)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let sub_i : Bool :=
    (BEq.beq (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  match VL with
  | 128 => (execute_CDOT_Z_ZZZ__ 128 da esize m n sel_a sel_b sub_i)
  | 256 => (execute_CDOT_Z_ZZZ__ 256 da esize m n sel_a sel_b sub_i)
  | 512 => (execute_CDOT_Z_ZZZ__ 512 da esize m n sel_a sel_b sub_i)
  | 1024 => (execute_CDOT_Z_ZZZ__ 1024 da esize m n sel_a sel_b sub_i)
  | 2048 => (execute_CDOT_Z_ZZZ__ 2048 da esize m n sel_a sel_b sub_i)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel_a : Nat, sel_b
  : Nat, k_sub_i : Bool, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_CDOT_Z_ZZZi_S (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel_a : Nat) (sel_b : Nat) (sub_i : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let elt1_r ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand1 (((4 *i e) +i (2 *i i)) +i 0) (Int.ediv esize 4)))))
              let elt1_i ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand1 (((4 *i e) +i (2 *i i)) +i 1) (Int.ediv esize 4)))))
              let elt2_a ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand2 (((4 *i s) +i (2 *i i)) +i sel_a) (Int.ediv esize 4)))))
              let elt2_b ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand2 (((4 *i s) +i (2 *i i)) +i sel_b) (Int.ediv esize 4)))))
              bif sub_i
              then (pure (BitVec.subInt (BitVec.addInt res (elt1_r *i elt2_a)) (elt1_i *i elt2_b)))
              else (pure (BitVec.addInt (BitVec.addInt res (elt1_r *i elt2_a)) (elt1_i *i elt2_b)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_CDOT_Z_ZZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let sub_i : Bool :=
    (BEq.beq (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  match VL with
  | 128 => (execute_CDOT_Z_ZZZi_S 128 da esize index m n sel_a sel_b sub_i)
  | 256 => (execute_CDOT_Z_ZZZi_S 256 da esize index m n sel_a sel_b sub_i)
  | 512 => (execute_CDOT_Z_ZZZi_S 512 da esize index m n sel_a sel_b sub_i)
  | 1024 => (execute_CDOT_Z_ZZZi_S 1024 da esize index m n sel_a sel_b sub_i)
  | 2048 => (execute_CDOT_Z_ZZZi_S 2048 da esize index m n sel_a sel_b sub_i)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, sel_a : Nat, sel_b
  : Nat, k_sub_i : Bool, sel_b ∈ {0, 1} ∧
  sel_a ∈ {0, 1} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_CDOT_Z_ZZZi_D (VL : Nat) (da : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (sel_a : Nat) (sel_b : Nat) (sub_i : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let res ← (( do (Elem_read operand3 e esize) ) : SailM (BitVec esize) )
        let res ← (( do
          let loop_i_lower := 0
          let loop_i_upper := 1
          let mut loop_vars_1 := res
          for i in [loop_i_lower:loop_i_upper:1]i do
            let res := loop_vars_1
            loop_vars_1 ← do
              let elt1_r ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand1 (((4 *i e) +i (2 *i i)) +i 0) (Int.ediv esize 4)))))
              let elt1_i ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand1 (((4 *i e) +i (2 *i i)) +i 1) (Int.ediv esize 4)))))
              let elt2_a ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand2 (((4 *i s) +i (2 *i i)) +i sel_a) (Int.ediv esize 4)))))
              let elt2_b ← do
                (pure (BitVec.toInt
                    (← (Elem_read operand2 (((4 *i s) +i (2 *i i)) +i sel_b) (Int.ediv esize 4)))))
              bif sub_i
              then (pure (BitVec.subInt (BitVec.addInt res (elt1_r *i elt2_a)) (elt1_i *i elt2_b)))
              else (pure (BitVec.addInt (BitVec.addInt res (elt1_r *i elt2_a)) (elt1_i *i elt2_b)))
          (pure loop_vars_1) ) : SailM (BitVec esize) )
        (Elem_set result e esize res)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_CDOT_Z_ZZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (rot : (BitVec 2)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let sel_a := (BitVec.toNat (BitVec.join1 [(BitVec.access rot 0)]))
  let sel_b := (BitVec.toNat (Complement.complement (BitVec.join1 [(BitVec.access rot 0)])))
  let sub_i : Bool :=
    (BEq.beq (BitVec.join1 [(BitVec.access rot 0)]) (BitVec.join1 [(BitVec.access rot 1)]))
  match VL with
  | 128 => (execute_CDOT_Z_ZZZi_D 128 da esize index m n sel_a sel_b sub_i)
  | 256 => (execute_CDOT_Z_ZZZi_D 256 da esize index m n sel_a sel_b sub_i)
  | 512 => (execute_CDOT_Z_ZZZi_D 512 da esize index m n sel_a sel_b sub_i)
  | 1024 => (execute_CDOT_Z_ZZZi_D 1024 da esize index m n sel_a sel_b sub_i)
  | 2048 => (execute_CDOT_Z_ZZZi_D 2048 da esize index m n sel_a sel_b sub_i)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, m : Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned :
  Bool, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SMMLA_Z_ZZZ__ (VL : Nat) (da : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let segments := (Int.ediv VL 128)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let op1 ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let op2 ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let addend ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let res ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let (addend, op1, op2, res, result) ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := (addend, op1, op2, res, result)
    for s in [loop_s_lower:loop_s_upper:1]i do
      let (addend, op1, op2, res, result) := loop_vars
      loop_vars ← do
        let op1 ← (Elem_read operand1 s 128)
        let op2 ← (Elem_read operand2 s 128)
        let addend ← (Elem_read operand3 s 128)
        let res ← (MatMulAdd addend op1 op2 op1_unsigned op2_unsigned)
        let result ← (Elem_set result s 128 res)
        (pure (addend, op1, op2, res, result))
    (pure loop_vars) ) : SailM
    ((BitVec 128) × (BitVec 128) × (BitVec 128) × (BitVec 128) × (BitVec VL)) )
  (Z_set da VL result)

def decode_SMMLA_Z_ZZZ__ (uns : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveInt8MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_unsigned : Bool := false
  let op2_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMMLA_Z_ZZZ__ 128 da m n op1_unsigned op2_unsigned)
  | 256 => (execute_SMMLA_Z_ZZZ__ 256 da m n op1_unsigned op2_unsigned)
  | 512 => (execute_SMMLA_Z_ZZZ__ 512 da m n op1_unsigned op2_unsigned)
  | 1024 => (execute_SMMLA_Z_ZZZ__ 1024 da m n op1_unsigned op2_unsigned)
  | 2048 => (execute_SMMLA_Z_ZZZ__ 2048 da m n op1_unsigned op2_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, m : Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned :
  Bool, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_UMMLA_Z_ZZZ__ (VL : Nat) (da : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let segments := (Int.ediv VL 128)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let op1 ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let op2 ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let addend ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let res ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let (addend, op1, op2, res, result) ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := (addend, op1, op2, res, result)
    for s in [loop_s_lower:loop_s_upper:1]i do
      let (addend, op1, op2, res, result) := loop_vars
      loop_vars ← do
        let op1 ← (Elem_read operand1 s 128)
        let op2 ← (Elem_read operand2 s 128)
        let addend ← (Elem_read operand3 s 128)
        let res ← (MatMulAdd addend op1 op2 op1_unsigned op2_unsigned)
        let result ← (Elem_set result s 128 res)
        (pure (addend, op1, op2, res, result))
    (pure loop_vars) ) : SailM
    ((BitVec 128) × (BitVec 128) × (BitVec 128) × (BitVec 128) × (BitVec VL)) )
  (Z_set da VL result)

def decode_UMMLA_Z_ZZZ__ (uns : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveInt8MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_unsigned : Bool := true
  let op2_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMMLA_Z_ZZZ__ 128 da m n op1_unsigned op2_unsigned)
  | 256 => (execute_UMMLA_Z_ZZZ__ 256 da m n op1_unsigned op2_unsigned)
  | 512 => (execute_UMMLA_Z_ZZZ__ 512 da m n op1_unsigned op2_unsigned)
  | 1024 => (execute_UMMLA_Z_ZZZ__ 1024 da m n op1_unsigned op2_unsigned)
  | 2048 => (execute_UMMLA_Z_ZZZ__ 2048 da m n op1_unsigned op2_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, m : Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned :
  Bool, 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_USMMLA_Z_ZZZ__ (VL : Nat) (da : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let segments := (Int.ediv VL 128)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let op1 ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let op2 ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let addend ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let res ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let (addend, op1, op2, res, result) ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := (addend, op1, op2, res, result)
    for s in [loop_s_lower:loop_s_upper:1]i do
      let (addend, op1, op2, res, result) := loop_vars
      loop_vars ← do
        let op1 ← (Elem_read operand1 s 128)
        let op2 ← (Elem_read operand2 s 128)
        let addend ← (Elem_read operand3 s 128)
        let res ← (MatMulAdd addend op1 op2 op1_unsigned op2_unsigned)
        let result ← (Elem_set result s 128 res)
        (pure (addend, op1, op2, res, result))
    (pure loop_vars) ) : SailM
    ((BitVec 128) × (BitVec 128) × (BitVec 128) × (BitVec 128) × (BitVec VL)) )
  (Z_set da VL result)

def decode_USMMLA_Z_ZZZ__ (uns : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveInt8MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  let op1_unsigned : Bool := true
  let op2_unsigned : Bool := false
  match VL with
  | 128 => (execute_USMMLA_Z_ZZZ__ 128 da m n op1_unsigned op2_unsigned)
  | 256 => (execute_USMMLA_Z_ZZZ__ 256 da m n op1_unsigned op2_unsigned)
  | 512 => (execute_USMMLA_Z_ZZZ__ 512 da m n op1_unsigned op2_unsigned)
  | 1024 => (execute_USMMLA_Z_ZZZ__ 1024 da m n op1_unsigned op2_unsigned)
  | 2048 => (execute_USMMLA_Z_ZZZ__ 2048 da m n op1_unsigned op2_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULH_Z_ZZi_H (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e esize (← (SignedSat (Int.shiftr res esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQDMULH_Z_ZZi_H (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zm : (BitVec 3)) (R : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let index := (BitVec.toNat (i3h ++ i3l))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQDMULH_Z_ZZi_H 128 d esize index m n)
  | 256 => (execute_SQDMULH_Z_ZZi_H 256 d esize index m n)
  | 512 => (execute_SQDMULH_Z_ZZi_H 512 d esize index m n)
  | 1024 => (execute_SQDMULH_Z_ZZi_H 1024 d esize index m n)
  | 2048 => (execute_SQDMULH_Z_ZZi_H 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULH_Z_ZZi_S (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e esize (← (SignedSat (Int.shiftr res esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQDMULH_Z_ZZi_S (size : (BitVec 2)) (i2 : (BitVec 2)) (Zm : (BitVec 3)) (R : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let index := (BitVec.toNat i2)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQDMULH_Z_ZZi_S 128 d esize index m n)
  | 256 => (execute_SQDMULH_Z_ZZi_S 256 d esize index m n)
  | 512 => (execute_SQDMULH_Z_ZZi_S 512 d esize index m n)
  | 1024 => (execute_SQDMULH_Z_ZZi_S 1024 d esize index m n)
  | 2048 => (execute_SQDMULH_Z_ZZi_S 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQDMULH_Z_ZZi_D (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let eltspersegment := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let segmentbase := (e -i (Nat.div e eltspersegment))
        let s := (segmentbase +i index)
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 s esize))))
        let res := ((2 *i element1) *i element2)
        (Elem_set result e esize (← (SignedSat (Int.shiftr res esize) esize)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQDMULH_Z_ZZi_D (size : (BitVec 2)) (i1 : (BitVec 1)) (Zm : (BitVec 4)) (R : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let index := (BitVec.toNat i1)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQDMULH_Z_ZZi_D 128 d esize index m n)
  | 256 => (execute_SQDMULH_Z_ZZi_D 256 d esize index m n)
  | 512 => (execute_SQDMULH_Z_ZZi_D 512 d esize index m n)
  | 1024 => (execute_SQDMULH_Z_ZZi_D 1024 d esize index m n)
  | 2048 => (execute_SQDMULH_Z_ZZi_D 2048 d esize index m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SRSRA_Z_ZI__ (VL : Nat) (da : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← do
          (pure (_shr_int_general
              ((BitVec.toInt (← (Elem_read operand1 e esize))) +i (_shl_int_general 1 (shift -i 1)))
              shift))
        (Elem_set result e esize
          ((← (Elem_read operand2 e esize)) + (integer_subrange element (esize -i 1) 0)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SRSRA_Z_ZI__ (tszh : (BitVec 2)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (R : (BitVec 1)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let da := (BitVec.toNat Zda)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_SRSRA_Z_ZI__ 128 da 8 n shift)
      | 256 => (execute_SRSRA_Z_ZI__ 256 da 8 n shift)
      | 512 => (execute_SRSRA_Z_ZI__ 512 da 8 n shift)
      | 1024 => (execute_SRSRA_Z_ZI__ 1024 da 8 n shift)
      | 2048 => (execute_SRSRA_Z_ZI__ 2048 da 8 n shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_SRSRA_Z_ZI__ 128 da 16 n shift)
      | 256 => (execute_SRSRA_Z_ZI__ 256 da 16 n shift)
      | 512 => (execute_SRSRA_Z_ZI__ 512 da 16 n shift)
      | 1024 => (execute_SRSRA_Z_ZI__ 1024 da 16 n shift)
      | 2048 => (execute_SRSRA_Z_ZI__ 2048 da 16 n shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_SRSRA_Z_ZI__ 128 da 32 n shift)
      | 256 => (execute_SRSRA_Z_ZI__ 256 da 32 n shift)
      | 512 => (execute_SRSRA_Z_ZI__ 512 da 32 n shift)
      | 1024 => (execute_SRSRA_Z_ZI__ 1024 da 32 n shift)
      | 2048 => (execute_SRSRA_Z_ZI__ 2048 da 32 n shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_SRSRA_Z_ZI__ 128 da 64 n shift)
      | 256 => (execute_SRSRA_Z_ZI__ 256 da 64 n shift)
      | 512 => (execute_SRSRA_Z_ZI__ 512 da 64 n shift)
      | 1024 => (execute_SRSRA_Z_ZI__ 1024 da 64 n shift)
      | 2048 => (execute_SRSRA_Z_ZI__ 2048 da 64 n shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:51742.22-51742.23"

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SSRA_Z_ZI__ (VL : Nat) (da : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← do
          (pure (_shr_int_general (BitVec.toInt (← (Elem_read operand1 e esize))) shift))
        (Elem_set result e esize
          ((← (Elem_read operand2 e esize)) + (integer_subrange element (esize -i 1) 0)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_SSRA_Z_ZI__ (tszh : (BitVec 2)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (R : (BitVec 1)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let da := (BitVec.toNat Zda)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_SSRA_Z_ZI__ 128 da 8 n shift)
      | 256 => (execute_SSRA_Z_ZI__ 256 da 8 n shift)
      | 512 => (execute_SSRA_Z_ZI__ 512 da 8 n shift)
      | 1024 => (execute_SSRA_Z_ZI__ 1024 da 8 n shift)
      | 2048 => (execute_SSRA_Z_ZI__ 2048 da 8 n shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_SSRA_Z_ZI__ 128 da 16 n shift)
      | 256 => (execute_SSRA_Z_ZI__ 256 da 16 n shift)
      | 512 => (execute_SSRA_Z_ZI__ 512 da 16 n shift)
      | 1024 => (execute_SSRA_Z_ZI__ 1024 da 16 n shift)
      | 2048 => (execute_SSRA_Z_ZI__ 2048 da 16 n shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_SSRA_Z_ZI__ 128 da 32 n shift)
      | 256 => (execute_SSRA_Z_ZI__ 256 da 32 n shift)
      | 512 => (execute_SSRA_Z_ZI__ 512 da 32 n shift)
      | 1024 => (execute_SSRA_Z_ZI__ 1024 da 32 n shift)
      | 2048 => (execute_SSRA_Z_ZI__ 2048 da 32 n shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_SSRA_Z_ZI__ 128 da 64 n shift)
      | 256 => (execute_SSRA_Z_ZI__ 256 da 64 n shift)
      | 512 => (execute_SSRA_Z_ZI__ 512 da 64 n shift)
      | 1024 => (execute_SSRA_Z_ZI__ 1024 da 64 n shift)
      | 2048 => (execute_SSRA_Z_ZI__ 2048 da 64 n shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:51889.22-51889.23"

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_URSRA_Z_ZI__ (VL : Nat) (da : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← do
          (pure (_shr_int_general
              ((BitVec.toNat (← (Elem_read operand1 e esize))) +i (_shl_int_general 1 (shift -i 1)))
              shift))
        (Elem_set result e esize
          ((← (Elem_read operand2 e esize)) + (integer_subrange element (esize -i 1) 0)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_URSRA_Z_ZI__ (tszh : (BitVec 2)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (R : (BitVec 1)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let da := (BitVec.toNat Zda)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_URSRA_Z_ZI__ 128 da 8 n shift)
      | 256 => (execute_URSRA_Z_ZI__ 256 da 8 n shift)
      | 512 => (execute_URSRA_Z_ZI__ 512 da 8 n shift)
      | 1024 => (execute_URSRA_Z_ZI__ 1024 da 8 n shift)
      | 2048 => (execute_URSRA_Z_ZI__ 2048 da 8 n shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_URSRA_Z_ZI__ 128 da 16 n shift)
      | 256 => (execute_URSRA_Z_ZI__ 256 da 16 n shift)
      | 512 => (execute_URSRA_Z_ZI__ 512 da 16 n shift)
      | 1024 => (execute_URSRA_Z_ZI__ 1024 da 16 n shift)
      | 2048 => (execute_URSRA_Z_ZI__ 2048 da 16 n shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_URSRA_Z_ZI__ 128 da 32 n shift)
      | 256 => (execute_URSRA_Z_ZI__ 256 da 32 n shift)
      | 512 => (execute_URSRA_Z_ZI__ 512 da 32 n shift)
      | 1024 => (execute_URSRA_Z_ZI__ 1024 da 32 n shift)
      | 2048 => (execute_URSRA_Z_ZI__ 2048 da 32 n shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_URSRA_Z_ZI__ 128 da 64 n shift)
      | 256 => (execute_URSRA_Z_ZI__ 256 da 64 n shift)
      | 512 => (execute_URSRA_Z_ZI__ 512 da 64 n shift)
      | 1024 => (execute_URSRA_Z_ZI__ 1024 da 64 n shift)
      | 2048 => (execute_URSRA_Z_ZI__ 2048 da 64 n shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:52036.22-52036.23"

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_USRA_Z_ZI__ (VL : Nat) (da : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element ← do
          (pure (_shr_int_general (BitVec.toNat (← (Elem_read operand1 e esize))) shift))
        (Elem_set result e esize
          ((← (Elem_read operand2 e esize)) + (integer_subrange element (esize -i 1) 0)))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set da VL result)

def decode_USRA_Z_ZI__ (tszh : (BitVec 2)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (R : (BitVec 1)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let n := (BitVec.toNat Zn)
  let da := (BitVec.toNat Zda)
  let shift := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_USRA_Z_ZI__ 128 da 8 n shift)
      | 256 => (execute_USRA_Z_ZI__ 256 da 8 n shift)
      | 512 => (execute_USRA_Z_ZI__ 512 da 8 n shift)
      | 1024 => (execute_USRA_Z_ZI__ 1024 da 8 n shift)
      | 2048 => (execute_USRA_Z_ZI__ 2048 da 8 n shift)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_USRA_Z_ZI__ 128 da 16 n shift)
      | 256 => (execute_USRA_Z_ZI__ 256 da 16 n shift)
      | 512 => (execute_USRA_Z_ZI__ 512 da 16 n shift)
      | 1024 => (execute_USRA_Z_ZI__ 1024 da 16 n shift)
      | 2048 => (execute_USRA_Z_ZI__ 2048 da 16 n shift)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_USRA_Z_ZI__ 128 da 32 n shift)
      | 256 => (execute_USRA_Z_ZI__ 256 da 32 n shift)
      | 512 => (execute_USRA_Z_ZI__ 512 da 32 n shift)
      | 1024 => (execute_USRA_Z_ZI__ 1024 da 32 n shift)
      | 2048 => (execute_USRA_Z_ZI__ 2048 da 32 n shift)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_USRA_Z_ZI__ 128 da 64 n shift)
      | 256 => (execute_USRA_Z_ZI__ 256 da 64 n shift)
      | 512 => (execute_USRA_Z_ZI__ 512 da 64 n shift)
      | 1024 => (execute_USRA_Z_ZI__ 1024 da 64 n shift)
      | 2048 => (execute_USRA_Z_ZI__ 2048 da 64 n shift)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:52183.22-52183.23"

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_AESD_Z_ZZ__ (VL : Nat) (dn : Nat) (m : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let segments := (Int.ediv VL 128)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (operand1 ^^^ operand2)
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result s 128
          (← (AESInvSubBytes (AESInvShiftRows (← (Elem_read result s 128))))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_AESD_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVE2AES ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_AESD_Z_ZZ__ 128 dn m)
  | 256 => (execute_AESD_Z_ZZ__ 256 dn m)
  | 512 => (execute_AESD_Z_ZZ__ 512 dn m)
  | 1024 => (execute_AESD_Z_ZZ__ 1024 dn m)
  | 2048 => (execute_AESD_Z_ZZ__ 2048 dn m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_AESE_Z_ZZ__ (VL : Nat) (dn : Nat) (m : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let segments := (Int.ediv VL 128)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (operand1 ^^^ operand2)
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result s 128 (← (AESSubBytes (AESShiftRows (← (Elem_read result s 128))))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_AESE_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVE2AES ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_AESE_Z_ZZ__ 128 dn m)
  | 256 => (execute_AESE_Z_ZZ__ 256 dn m)
  | 512 => (execute_AESE_Z_ZZ__ 512 dn m)
  | 1024 => (execute_AESE_Z_ZZ__ 1024 dn m)
  | 2048 => (execute_AESE_Z_ZZ__ 2048 dn m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_AESIMC_Z_Z__ (VL : Nat) (dn : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let segments := (Int.ediv VL 128)
  let operand ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result s 128 (← (AESInvMixColumns (← (Elem_read operand s 128)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_AESIMC_Z_Z__ (size : (BitVec 2)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVE2AES ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_AESIMC_Z_Z__ 128 dn)
  | 256 => (execute_AESIMC_Z_Z__ 256 dn)
  | 512 => (execute_AESIMC_Z_Z__ 512 dn)
  | 1024 => (execute_AESIMC_Z_Z__ 1024 dn)
  | 2048 => (execute_AESIMC_Z_Z__ 2048 dn)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_AESMC_Z_Z__ (VL : Nat) (dn : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let segments := (Int.ediv VL 128)
  let operand ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do (Elem_set result s 128 (← (AESMixColumns (← (Elem_read operand s 128)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_AESMC_Z_Z__ (size : (BitVec 2)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVE2AES ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_AESMC_Z_Z__ 128 dn)
  | 256 => (execute_AESMC_Z_Z__ 256 dn)
  | 512 => (execute_AESMC_Z_Z__ 512 dn)
  | 1024 => (execute_AESMC_Z_Z__ 1024 dn)
  | 2048 => (execute_AESMC_Z_Z__ 2048 dn)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_RAX1_Z_ZZ__ (VL : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  bif (← (HaveSME2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 64)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e 64) ) : SailM (BitVec 64) )
        let element2 ← (( do (Elem_read operand2 e 64) ) : SailM (BitVec 64) )
        (Elem_set result e 64 (element1 ^^^ (← (ROL element2 1))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_RAX1_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2SHA3 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_RAX1_Z_ZZ__ 128 d m n)
  | 256 => (execute_RAX1_Z_ZZ__ 256 d m n)
  | 512 => (execute_RAX1_Z_ZZ__ 512 d m n)
  | 1024 => (execute_RAX1_Z_ZZ__ 1024 d m n)
  | 2048 => (execute_RAX1_Z_ZZ__ 2048 d m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_SM4E_Z_ZZ__ (VL : Nat) (dn : Nat) (m : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let segments := (Int.ediv VL 128)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let key ← (( do (Elem_read operand2 s 128) ) : SailM (BitVec 128) )
        let intval ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
        let sboxout ← (( do (undefined_bitvector 8) ) : SailM (BitVec 8) )
        let roundresult ← (( do (Elem_read operand1 s 128) ) : SailM (BitVec 128) )
        let roundkey ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
        let (intval, roundkey, roundresult) ← (( do
          let loop_index_lower := 0
          let loop_index_upper := 3
          let mut loop_vars_1 := (intval, roundkey, roundresult)
          for index in [loop_index_lower:loop_index_upper:1]i do
            let (intval, roundkey, roundresult) := loop_vars_1
            loop_vars_1 ← do
              let roundkey ← (Elem_read key index 32)
              let intval : (BitVec 32) :=
                ((((Sail.BitVec.extractLsb roundresult 127 96) ^^^ (Sail.BitVec.extractLsb
                        roundresult 95 64)) ^^^ (Sail.BitVec.extractLsb roundresult 63 32)) ^^^ roundkey)
              let intval ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := intval
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let intval := loop_vars_2
                  loop_vars_2 ← do (Elem_set intval i 8 (Sbox (← (Elem_read intval i 8))))
                (pure loop_vars_2) ) : SailM (BitVec 32) )
              let intval ←
                (pure ((((intval ^^^ (← (ROL intval 2))) ^^^ (← (ROL intval 10))) ^^^ (← (ROL
                          intval 18))) ^^^ (← (ROL intval 24))))
              let intval : (BitVec 32) := (intval ^^^ (Sail.BitVec.extractLsb roundresult 31 0))
              let roundresult : (BitVec 128) :=
                (Sail.BitVec.updateSubrange roundresult 31 0
                  (Sail.BitVec.extractLsb roundresult 63 32))
              let roundresult : (BitVec 128) :=
                (Sail.BitVec.updateSubrange roundresult 63 32
                  (Sail.BitVec.extractLsb roundresult 95 64))
              let roundresult : (BitVec 128) :=
                (Sail.BitVec.updateSubrange roundresult 95 64
                  (Sail.BitVec.extractLsb roundresult 127 96))
              let roundresult : (BitVec 128) :=
                (Sail.BitVec.updateSubrange roundresult 127 96 intval)
              (pure (intval, roundkey, roundresult))
          (pure loop_vars_1) ) : SailM ((BitVec 32) × (BitVec 32) × (BitVec 128)) )
        (Elem_set result s 128 roundresult)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_SM4E_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVE2SM4 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_SM4E_Z_ZZ__ 128 dn m)
  | 256 => (execute_SM4E_Z_ZZ__ 256 dn m)
  | 512 => (execute_SM4E_Z_ZZ__ 512 dn m)
  | 1024 => (execute_SM4E_Z_ZZ__ 1024 dn m)
  | 2048 => (execute_SM4E_Z_ZZ__ 2048 dn m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SM4EKEY_Z_ZZ__ (VL : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let segments := (Int.ediv VL 128)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let source ← (( do (Elem_read operand2 s 128) ) : SailM (BitVec 128) )
        let intval ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
        let sboxout ← (( do (undefined_bitvector 8) ) : SailM (BitVec 8) )
        let const ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
        let roundresult ← (( do (Elem_read operand1 s 128) ) : SailM (BitVec 128) )
        let (const, intval, roundresult) ← (( do
          let loop_index_lower := 0
          let loop_index_upper := 3
          let mut loop_vars_1 := (const, intval, roundresult)
          for index in [loop_index_lower:loop_index_upper:1]i do
            let (const, intval, roundresult) := loop_vars_1
            loop_vars_1 ← do
              let const ← (Elem_read source index 32)
              let intval : (BitVec 32) :=
                ((((Sail.BitVec.extractLsb roundresult 127 96) ^^^ (Sail.BitVec.extractLsb
                        roundresult 95 64)) ^^^ (Sail.BitVec.extractLsb roundresult 63 32)) ^^^ const)
              let intval ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := intval
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let intval := loop_vars_2
                  loop_vars_2 ← do (Elem_set intval i 8 (Sbox (← (Elem_read intval i 8))))
                (pure loop_vars_2) ) : SailM (BitVec 32) )
              let intval ← (pure ((intval ^^^ (← (ROL intval 13))) ^^^ (← (ROL intval 23))))
              let intval : (BitVec 32) := (intval ^^^ (Sail.BitVec.extractLsb roundresult 31 0))
              let roundresult : (BitVec 128) :=
                (Sail.BitVec.updateSubrange roundresult 31 0
                  (Sail.BitVec.extractLsb roundresult 63 32))
              let roundresult : (BitVec 128) :=
                (Sail.BitVec.updateSubrange roundresult 63 32
                  (Sail.BitVec.extractLsb roundresult 95 64))
              let roundresult : (BitVec 128) :=
                (Sail.BitVec.updateSubrange roundresult 95 64
                  (Sail.BitVec.extractLsb roundresult 127 96))
              let roundresult : (BitVec 128) :=
                (Sail.BitVec.updateSubrange roundresult 127 96 intval)
              (pure (const, intval, roundresult))
          (pure loop_vars_1) ) : SailM ((BitVec 32) × (BitVec 32) × (BitVec 128)) )
        (Elem_set result s 128 roundresult)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SM4EKEY_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVE2SM4 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SM4EKEY_Z_ZZ__ 128 d m n)
  | 256 => (execute_SM4EKEY_Z_ZZ__ 256 d m n)
  | 512 => (execute_SM4EKEY_Z_ZZ__ 512 d m n)
  | 1024 => (execute_SM4EKEY_Z_ZZ__ 1024 d m n)
  | 2048 => (execute_SM4EKEY_Z_ZZ__ 2048 d m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, esize : Nat, m : Nat, rot : Int, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_XAR_Z_ZZI__ (VL : Nat) (dn : Nat) (esize : Nat) (m : Nat) (rot : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read operand1 e esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand2 e esize) ) : SailM (BitVec esize) )
        assert (rot ≥b 0) "src/instrs64_sve.sail:52632.36-52632.37"
        (Elem_set result e esize (ROR (element1 ^^^ element2) rot))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_XAR_Z_ZZI__ (tszh : (BitVec 2)) (tszl : (BitVec 2)) (imm3 : (BitVec 3)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let tsize : (BitVec 4) := (tszh ++ tszl)
  let esize : Int := 8
  let b__0 := tsize
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let esize : Int := 8
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b001 : (BitVec 3)))
      then
        (let esize : Int := 16
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 2) (0b01 : (BitVec 2)))
        then
          (let esize : Int := 32
          (pure ()))
        else
          (let esize : Int := 64
          (pure ())))))
  let esize := esize
  let m := (BitVec.toNat Zm)
  let dn := (BitVec.toNat Zdn)
  let rot := ((2 *i esize) -i (BitVec.toNat (tsize ++ imm3)))
  match esize with
  | 8 => (do
      match VL with
      | 128 => (execute_XAR_Z_ZZI__ 128 dn 8 m rot)
      | 256 => (execute_XAR_Z_ZZI__ 256 dn 8 m rot)
      | 512 => (execute_XAR_Z_ZZI__ 512 dn 8 m rot)
      | 1024 => (execute_XAR_Z_ZZI__ 1024 dn 8 m rot)
      | 2048 => (execute_XAR_Z_ZZI__ 2048 dn 8 m rot)
      | _ => (pure ()))
  | 16 => (do
      match VL with
      | 128 => (execute_XAR_Z_ZZI__ 128 dn 16 m rot)
      | 256 => (execute_XAR_Z_ZZI__ 256 dn 16 m rot)
      | 512 => (execute_XAR_Z_ZZI__ 512 dn 16 m rot)
      | 1024 => (execute_XAR_Z_ZZI__ 1024 dn 16 m rot)
      | 2048 => (execute_XAR_Z_ZZI__ 2048 dn 16 m rot)
      | _ => (pure ()))
  | 32 => (do
      match VL with
      | 128 => (execute_XAR_Z_ZZI__ 128 dn 32 m rot)
      | 256 => (execute_XAR_Z_ZZI__ 256 dn 32 m rot)
      | 512 => (execute_XAR_Z_ZZI__ 512 dn 32 m rot)
      | 1024 => (execute_XAR_Z_ZZI__ 1024 dn 32 m rot)
      | 2048 => (execute_XAR_Z_ZZI__ 2048 dn 32 m rot)
      | _ => (pure ()))
  | 64 => (do
      match VL with
      | 128 => (execute_XAR_Z_ZZI__ 128 dn 64 m rot)
      | 256 => (execute_XAR_Z_ZZI__ 256 dn 64 m rot)
      | 512 => (execute_XAR_Z_ZZI__ 512 dn 64 m rot)
      | 1024 => (execute_XAR_Z_ZZI__ 1024 dn 64 m rot)
      | 2048 => (execute_XAR_Z_ZZI__ 2048 dn 64 m rot)
      | _ => (pure ()))
  | _ => assert false "src/instrs64_sve.sail:52750.22-52750.23"

/-- Type quantifiers: VL : Nat, dn : Nat, k : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ k ∧ k ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BCAX_Z_ZZZ__ (VL : Nat) (dn : Nat) (k : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read k VL) ) : SailM (BitVec VL) )
  (Z_set dn VL (operand1 ^^^ (operand2 &&& (Complement.complement operand3))))

def decode_BCAX_Z_ZZZ__ (Zm : (BitVec 5)) (Zk : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let m := (BitVec.toNat Zm)
  let k := (BitVec.toNat Zk)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_BCAX_Z_ZZZ__ 128 dn k m)
  | 256 => (execute_BCAX_Z_ZZZ__ 256 dn k m)
  | 512 => (execute_BCAX_Z_ZZZ__ 512 dn k m)
  | 1024 => (execute_BCAX_Z_ZZZ__ 1024 dn k m)
  | 2048 => (execute_BCAX_Z_ZZZ__ 2048 dn k m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, k : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ k ∧ k ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_EOR3_Z_ZZZ__ (VL : Nat) (dn : Nat) (k : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read k VL) ) : SailM (BitVec VL) )
  (Z_set dn VL ((operand1 ^^^ operand2) ^^^ operand3))

def decode_EOR3_Z_ZZZ__ (Zm : (BitVec 5)) (Zk : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let m := (BitVec.toNat Zm)
  let k := (BitVec.toNat Zk)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_EOR3_Z_ZZZ__ 128 dn k m)
  | 256 => (execute_EOR3_Z_ZZZ__ 256 dn k m)
  | 512 => (execute_EOR3_Z_ZZZ__ 512 dn k m)
  | 1024 => (execute_EOR3_Z_ZZZ__ 1024 dn k m)
  | 2048 => (execute_EOR3_Z_ZZZ__ 2048 dn k m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, k : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ k ∧ k ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BSL_Z_ZZZ__ (VL : Nat) (dn : Nat) (k : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read k VL) ) : SailM (BitVec VL) )
  (Z_set dn VL ((operand1 &&& operand3) ||| (operand2 &&& (Complement.complement operand3))))

def decode_BSL_Z_ZZZ__ (Zm : (BitVec 5)) (Zk : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let m := (BitVec.toNat Zm)
  let k := (BitVec.toNat Zk)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_BSL_Z_ZZZ__ 128 dn k m)
  | 256 => (execute_BSL_Z_ZZZ__ 256 dn k m)
  | 512 => (execute_BSL_Z_ZZZ__ 512 dn k m)
  | 1024 => (execute_BSL_Z_ZZZ__ 1024 dn k m)
  | 2048 => (execute_BSL_Z_ZZZ__ 2048 dn k m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, k : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ k ∧ k ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BSL1N_Z_ZZZ__ (VL : Nat) (dn : Nat) (k : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read k VL) ) : SailM (BitVec VL) )
  (Z_set dn VL
    (((Complement.complement operand1) &&& operand3) ||| (operand2 &&& (Complement.complement
          operand3))))

def decode_BSL1N_Z_ZZZ__ (Zm : (BitVec 5)) (Zk : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let m := (BitVec.toNat Zm)
  let k := (BitVec.toNat Zk)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_BSL1N_Z_ZZZ__ 128 dn k m)
  | 256 => (execute_BSL1N_Z_ZZZ__ 256 dn k m)
  | 512 => (execute_BSL1N_Z_ZZZ__ 512 dn k m)
  | 1024 => (execute_BSL1N_Z_ZZZ__ 1024 dn k m)
  | 2048 => (execute_BSL1N_Z_ZZZ__ 2048 dn k m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, k : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ k ∧ k ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_BSL2N_Z_ZZZ__ (VL : Nat) (dn : Nat) (k : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read k VL) ) : SailM (BitVec VL) )
  (Z_set dn VL
    ((operand1 &&& operand3) ||| ((Complement.complement operand2) &&& (Complement.complement
          operand3))))

def decode_BSL2N_Z_ZZZ__ (Zm : (BitVec 5)) (Zk : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let m := (BitVec.toNat Zm)
  let k := (BitVec.toNat Zk)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_BSL2N_Z_ZZZ__ 128 dn k m)
  | 256 => (execute_BSL2N_Z_ZZZ__ 256 dn k m)
  | 512 => (execute_BSL2N_Z_ZZZ__ 512 dn k m)
  | 1024 => (execute_BSL2N_Z_ZZZ__ 1024 dn k m)
  | 2048 => (execute_BSL2N_Z_ZZZ__ 2048 dn k m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, k : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ k ∧ k ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_NBSL_Z_ZZZ__ (VL : Nat) (dn : Nat) (k : Nat) (m : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read k VL) ) : SailM (BitVec VL) )
  (Z_set dn VL
    (Complement.complement
      ((operand1 &&& operand3) ||| (operand2 &&& (Complement.complement operand3)))))

def decode_NBSL_Z_ZZZ__ (Zm : (BitVec 5)) (Zk : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let m := (BitVec.toNat Zm)
  let k := (BitVec.toNat Zk)
  let dn := (BitVec.toNat Zdn)
  match VL with
  | 128 => (execute_NBSL_Z_ZZZ__ 128 dn k m)
  | 256 => (execute_NBSL_Z_ZZZ__ 256 dn k m)
  | 512 => (execute_NBSL_Z_ZZZ__ 512 dn k m)
  | 1024 => (execute_NBSL_Z_ZZZ__ 1024 dn k m)
  | 2048 => (execute_NBSL_Z_ZZZ__ 2048 dn k m)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_ADCLB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let carry_out ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let res ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let carries ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let (carry_out, nzcv, res, result) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (carry_out, nzcv, res, result)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (carry_out, nzcv, res, result) := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read result ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let carry_in ← (( do
          (BitVec.join1 [(BitVec.access (← (Elem_read carries ((2 *i p) +i 1) esize)) 0)]) ) :
          SailM (BitVec 1) )
        let _ : Unit :=
          let (tup__0, tup__1) :=
            ((AddWithCarry element1 element2 carry_in) : ((BitVec esize) × (BitVec 4)))
          let res : (BitVec esize) := tup__0
          let nzcv : (BitVec 4) := tup__1
          ()
        let carry_out : (BitVec 1) := (BitVec.join1 [(BitVec.access nzcv 1)])
        let result ← (Elem_set result ((2 *i p) +i 0) esize res)
        let result ←
          (Elem_set result ((2 *i p) +i 1) esize (Sail.BitVec.zeroExtend carry_out esize))
        (pure (carry_out, nzcv, res, result))
    (pure loop_vars) ) : SailM ((BitVec 1) × (BitVec 4) × (BitVec esize) × (BitVec VL)) )
  (Z_set da VL result)

def decode_ADCLB_Z_ZZZ__ (sz : (BitVec 1)) (Zm : (BitVec 5)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_ADCLB_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_ADCLB_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_ADCLB_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_ADCLB_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_ADCLB_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_ADCLT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let carry_out ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let res ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let carries ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let (carry_out, nzcv, res, result) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (carry_out, nzcv, res, result)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (carry_out, nzcv, res, result) := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read result ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand ((2 *i p) +i 1) esize) ) : SailM (BitVec esize) )
        let carry_in ← (( do
          (BitVec.join1 [(BitVec.access (← (Elem_read carries ((2 *i p) +i 1) esize)) 0)]) ) :
          SailM (BitVec 1) )
        let _ : Unit :=
          let (tup__0, tup__1) :=
            ((AddWithCarry element1 element2 carry_in) : ((BitVec esize) × (BitVec 4)))
          let res : (BitVec esize) := tup__0
          let nzcv : (BitVec 4) := tup__1
          ()
        let carry_out : (BitVec 1) := (BitVec.join1 [(BitVec.access nzcv 1)])
        let result ← (Elem_set result ((2 *i p) +i 0) esize res)
        let result ←
          (Elem_set result ((2 *i p) +i 1) esize (Sail.BitVec.zeroExtend carry_out esize))
        (pure (carry_out, nzcv, res, result))
    (pure loop_vars) ) : SailM ((BitVec 1) × (BitVec 4) × (BitVec esize) × (BitVec VL)) )
  (Z_set da VL result)

def decode_ADCLT_Z_ZZZ__ (sz : (BitVec 1)) (Zm : (BitVec 5)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_ADCLT_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_ADCLT_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_ADCLT_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_ADCLT_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_ADCLT_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SBCLB_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let carry_out ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let res ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let carries ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let (carry_out, nzcv, res, result) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (carry_out, nzcv, res, result)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (carry_out, nzcv, res, result) := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read result ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let carry_in ← (( do
          (BitVec.join1 [(BitVec.access (← (Elem_read carries ((2 *i p) +i 1) esize)) 0)]) ) :
          SailM (BitVec 1) )
        let _ : Unit :=
          let (tup__0, tup__1) :=
            ((AddWithCarry element1 (Complement.complement element2) carry_in) : ((BitVec esize) × (BitVec 4)))
          let res : (BitVec esize) := tup__0
          let nzcv : (BitVec 4) := tup__1
          ()
        let carry_out : (BitVec 1) := (BitVec.join1 [(BitVec.access nzcv 1)])
        let result ← (Elem_set result ((2 *i p) +i 0) esize res)
        let result ←
          (Elem_set result ((2 *i p) +i 1) esize (Sail.BitVec.zeroExtend carry_out esize))
        (pure (carry_out, nzcv, res, result))
    (pure loop_vars) ) : SailM ((BitVec 1) × (BitVec 4) × (BitVec esize) × (BitVec VL)) )
  (Z_set da VL result)

def decode_SBCLB_Z_ZZZ__ (sz : (BitVec 1)) (Zm : (BitVec 5)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SBCLB_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SBCLB_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SBCLB_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SBCLB_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SBCLB_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, da : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {32, 64} ∧ 0 ≤ da ∧ da ≤ 31 ∧ is_VL(VL) -/
def execute_SBCLT_Z_ZZZ__ (VL : Nat) (da : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let carry_out ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let res ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckSVEEnabled ())
  let VL := VL
  let pairs := (Int.ediv VL (esize *i 2))
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let carries ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read da VL) ) : SailM (BitVec VL) )
  let (carry_out, nzcv, res, result) ← (( do
    let loop_p_lower := 0
    let loop_p_upper := (pairs -i 1)
    let mut loop_vars := (carry_out, nzcv, res, result)
    for p in [loop_p_lower:loop_p_upper:1]i do
      let (carry_out, nzcv, res, result) := loop_vars
      loop_vars ← do
        let element1 ← (( do (Elem_read result ((2 *i p) +i 0) esize) ) : SailM (BitVec esize) )
        let element2 ← (( do (Elem_read operand ((2 *i p) +i 1) esize) ) : SailM (BitVec esize) )
        let carry_in ← (( do
          (BitVec.join1 [(BitVec.access (← (Elem_read carries ((2 *i p) +i 1) esize)) 0)]) ) :
          SailM (BitVec 1) )
        let _ : Unit :=
          let (tup__0, tup__1) :=
            ((AddWithCarry element1 (Complement.complement element2) carry_in) : ((BitVec esize) × (BitVec 4)))
          let res : (BitVec esize) := tup__0
          let nzcv : (BitVec 4) := tup__1
          ()
        let carry_out : (BitVec 1) := (BitVec.join1 [(BitVec.access nzcv 1)])
        let result ← (Elem_set result ((2 *i p) +i 0) esize res)
        let result ←
          (Elem_set result ((2 *i p) +i 1) esize (Sail.BitVec.zeroExtend carry_out esize))
        (pure (carry_out, nzcv, res, result))
    (pure loop_vars) ) : SailM ((BitVec 1) × (BitVec 4) × (BitVec esize) × (BitVec VL)) )
  (Z_set da VL result)

def decode_SBCLT_Z_ZZZ__ (sz : (BitVec 1)) (Zm : (BitVec 5)) (T : (BitVec 1)) (Zn : (BitVec 5)) (Zda : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let da := (BitVec.toNat Zda)
  match VL with
  | 128 => (execute_SBCLT_Z_ZZZ__ 128 da esize m n)
  | 256 => (execute_SBCLT_Z_ZZZ__ 256 da esize m n)
  | 512 => (execute_SBCLT_Z_ZZZ__ 512 da esize m n)
  | 1024 => (execute_SBCLT_Z_ZZZ__ 1024 da esize m n)
  | 2048 => (execute_SBCLT_Z_ZZZ__ 2048 da esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMULH_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let product := (Int.shiftr (element1 *i element2) esize)
        (Elem_set result e esize (integer_subrange product (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SMULH_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMULH_Z_ZZ__ 128 d esize m n is_unsigned)
  | 256 => (execute_SMULH_Z_ZZ__ 256 d esize m n is_unsigned)
  | 512 => (execute_SMULH_Z_ZZ__ 512 d esize m n is_unsigned)
  | 1024 => (execute_SMULH_Z_ZZ__ 1024 d esize m n is_unsigned)
  | 2048 => (execute_SMULH_Z_ZZ__ 2048 d esize m n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMULH_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (asl_Int (← (Elem_read operand1 e esize)) is_unsigned)
        let element2 ← do (asl_Int (← (Elem_read operand2 e esize)) is_unsigned)
        let product := (Int.shiftr (element1 *i element2) esize)
        (Elem_set result e esize (integer_subrange product (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UMULH_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2 ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMULH_Z_ZZ__ 128 d esize m n is_unsigned)
  | 256 => (execute_UMULH_Z_ZZ__ 256 d esize m n is_unsigned)
  | 512 => (execute_UMULH_Z_ZZ__ 512 d esize m n is_unsigned)
  | 1024 => (execute_UMULH_Z_ZZ__ 1024 d esize m n is_unsigned)
  | 2048 => (execute_UMULH_Z_ZZ__ 2048 d esize m n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SCLAMP_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toInt (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toInt (← (Elem_read operand2 e esize))))
        let element3 ← do (pure (BitVec.toInt (← (Elem_read operand3 e esize))))
        let res := (Min.min (Max.max element1 element3) element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SCLAMP_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SCLAMP_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_SCLAMP_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_SCLAMP_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_SCLAMP_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_SCLAMP_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UCLAMP_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let operand3 ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← do (pure (BitVec.toNat (← (Elem_read operand1 e esize))))
        let element2 ← do (pure (BitVec.toNat (← (Elem_read operand2 e esize))))
        let element3 ← do (pure (BitVec.toNat (← (Elem_read operand3 e esize))))
        let res := (Min.min (Max.max element1 element3) element2)
        (Elem_set result e esize (integer_subrange res (esize -i 1) 0))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UCLAMP_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UCLAMP_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_UCLAMP_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_UCLAMP_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_UCLAMP_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_UCLAMP_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, swsize : Nat, swsize = 64
  ∧
  0 ≤ n ∧
  n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_REVD_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (swsize : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let element ← (( do (Elem_read operand e esize) ) : SailM (BitVec esize) )
            (Elem_set result e esize (← (Reverse element swsize))))
        else (pure result)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_REVD_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 128
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  let swsize := 64
  match VL with
  | 128 => (execute_REVD_Z_P_Z__ 128 d esize g n swsize)
  | 256 => (execute_REVD_Z_P_Z__ 256 d esize g n swsize)
  | 512 => (execute_REVD_Z_P_Z__ 512 d esize g n swsize)
  | 1024 => (execute_REVD_Z_P_Z__ 1024 d esize g n swsize)
  | 2048 => (execute_REVD_Z_P_Z__ 2048 d esize g n swsize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, m : Nat, n : Nat, v : Nat, 0 ≤ v
  ∧
  v ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  0 ≤ imm ∧ imm ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PSEL_P_PPi__ (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (m : Nat) (n : Nat) (v : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand1 ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let operand2 ← (( do (P_read m PL) ) : SailM (BitVec PL) )
  let idx ← (( do (X_read v 32) ) : SailM (BitVec 32) )
  let element := (Nat.div ((BitVec.toNat idx) +i imm) elements)
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let result ← (( do
    bif (← (ActivePredicateElement operand2 element esize))
    then (pure operand1)
    else (pure (Zeros (n := PL))) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_PSEL_P_PPi__ (i1 : (BitVec 1)) (tszh : (BitVec 1)) (tszl : (BitVec 3)) (Rv : (BitVec 2)) (Pn : (BitVec 4)) (S : (BitVec 1)) (Pm : (BitVec 4)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let imm5 : (BitVec 5) := ((i1 ++ tszh) ++ tszl)
  let esize : Int := 8
  let imm ← (( do (undefined_range 0 15) ) : SailM Nat )
  let b__0 := (tszh ++ tszl)
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x8 : (BitVec 4)))
    then
      (let esize : Int := 64
      let imm : Nat := (BitVec.toNat (BitVec.join1 [(BitVec.access imm5 4)]))
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 0) (0b100 : (BitVec 3)))
      then
        (let esize : Int := 32
        let imm : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm5 4 3))
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 0) (0b10 : (BitVec 2)))
        then
          (let esize : Int := 16
          let imm : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm5 4 2))
          (pure ()))
        else
          (let esize : Int := 8
          let imm : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm5 4 1))
          (pure ())))))
  let imm := imm
  let esize := esize
  let n := (BitVec.toNat Pn)
  let m := (BitVec.toNat Pm)
  let d := (BitVec.toNat Pd)
  let v := (BitVec.toNat ((0b011 : (BitVec 3)) ++ Rv))
  match VL with
  | 128 => (execute_PSEL_P_PPi__ 128 d esize imm m n v)
  | 256 => (execute_PSEL_P_PPi__ 256 d esize imm m n v)
  | 512 => (execute_PSEL_P_PPi__ 512 d esize imm m n v)
  | 1024 => (execute_PSEL_P_PPi__ 1024 d esize imm m n v)
  | 2048 => (execute_PSEL_P_PPi__ 2048 d esize imm m n v)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d0 : Nat, d1 : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, rsize : Nat, rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d1 ∧ d1 ≤ 15 ∧ 0 ≤ d0 ∧ d0 ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELO_PP_RR__ (VL : Nat) (d0 : Nat) (d1 : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec (PL * 2)) := (Ones (n := (PL *i 2)))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector (PL *i 2)) ) : SailM (BitVec (PL * 2)) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((elements *i 2) -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec (PL * 2))) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d0 PL (Sail.BitVec.extractLsb result (PL -i 1) 0))
  (P_set d1 PL (Sail.BitVec.extractLsb result ((PL *i 2) -i 1) PL))

def decode_WHILELO_PP_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (Pd : (BitVec 3)) (eq : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d0 := (BitVec.toNat (Pd ++ (0b0 : (BitVec 1))))
  let d1 := (BitVec.toNat (Pd ++ (0b1 : (BitVec 1))))
  let is_unsigned : Bool := true
  let op : SVECmp := Cmp_LT
  match VL with
  | 128 => (execute_WHILELO_PP_RR__ 128 d0 d1 esize m n op rsize is_unsigned)
  | 256 => (execute_WHILELO_PP_RR__ 256 d0 d1 esize m n op rsize is_unsigned)
  | 512 => (execute_WHILELO_PP_RR__ 512 d0 d1 esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILELO_PP_RR__ 1024 d0 d1 esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILELO_PP_RR__ 2048 d0 d1 esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d0 : Nat, d1 : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, rsize : Nat, rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d1 ∧ d1 ≤ 15 ∧ 0 ≤ d0 ∧ d0 ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELS_PP_RR__ (VL : Nat) (d0 : Nat) (d1 : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec (PL * 2)) := (Ones (n := (PL *i 2)))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector (PL *i 2)) ) : SailM (BitVec (PL * 2)) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((elements *i 2) -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec (PL * 2))) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d0 PL (Sail.BitVec.extractLsb result (PL -i 1) 0))
  (P_set d1 PL (Sail.BitVec.extractLsb result ((PL *i 2) -i 1) PL))

def decode_WHILELS_PP_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (Pd : (BitVec 3)) (eq : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d0 := (BitVec.toNat (Pd ++ (0b0 : (BitVec 1))))
  let d1 := (BitVec.toNat (Pd ++ (0b1 : (BitVec 1))))
  let is_unsigned : Bool := true
  let op : SVECmp := Cmp_LE
  match VL with
  | 128 => (execute_WHILELS_PP_RR__ 128 d0 d1 esize m n op rsize is_unsigned)
  | 256 => (execute_WHILELS_PP_RR__ 256 d0 d1 esize m n op rsize is_unsigned)
  | 512 => (execute_WHILELS_PP_RR__ 512 d0 d1 esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILELS_PP_RR__ 1024 d0 d1 esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILELS_PP_RR__ 2048 d0 d1 esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d0 : Nat, d1 : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, rsize : Nat, rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d1 ∧ d1 ≤ 15 ∧ 0 ≤ d0 ∧ d0 ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELT_PP_RR__ (VL : Nat) (d0 : Nat) (d1 : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec (PL * 2)) := (Ones (n := (PL *i 2)))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector (PL *i 2)) ) : SailM (BitVec (PL * 2)) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((elements *i 2) -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec (PL * 2))) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d0 PL (Sail.BitVec.extractLsb result (PL -i 1) 0))
  (P_set d1 PL (Sail.BitVec.extractLsb result ((PL *i 2) -i 1) PL))

def decode_WHILELT_PP_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (Pd : (BitVec 3)) (eq : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d0 := (BitVec.toNat (Pd ++ (0b0 : (BitVec 1))))
  let d1 := (BitVec.toNat (Pd ++ (0b1 : (BitVec 1))))
  let is_unsigned : Bool := false
  let op : SVECmp := Cmp_LT
  match VL with
  | 128 => (execute_WHILELT_PP_RR__ 128 d0 d1 esize m n op rsize is_unsigned)
  | 256 => (execute_WHILELT_PP_RR__ 256 d0 d1 esize m n op rsize is_unsigned)
  | 512 => (execute_WHILELT_PP_RR__ 512 d0 d1 esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILELT_PP_RR__ 1024 d0 d1 esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILELT_PP_RR__ 2048 d0 d1 esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d0 : Nat, d1 : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, rsize : Nat, rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d1 ∧ d1 ≤ 15 ∧ 0 ≤ d0 ∧ d0 ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELE_PP_RR__ (VL : Nat) (d0 : Nat) (d1 : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec (PL * 2)) := (Ones (n := (PL *i 2)))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector (PL *i 2)) ) : SailM (BitVec (PL * 2)) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((elements *i 2) -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec (PL * 2))) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d0 PL (Sail.BitVec.extractLsb result (PL -i 1) 0))
  (P_set d1 PL (Sail.BitVec.extractLsb result ((PL *i 2) -i 1) PL))

def decode_WHILELE_PP_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (Pd : (BitVec 3)) (eq : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d0 := (BitVec.toNat (Pd ++ (0b0 : (BitVec 1))))
  let d1 := (BitVec.toNat (Pd ++ (0b1 : (BitVec 1))))
  let is_unsigned : Bool := false
  let op : SVECmp := Cmp_LE
  match VL with
  | 128 => (execute_WHILELE_PP_RR__ 128 d0 d1 esize m n op rsize is_unsigned)
  | 256 => (execute_WHILELE_PP_RR__ 256 d0 d1 esize m n op rsize is_unsigned)
  | 512 => (execute_WHILELE_PP_RR__ 512 d0 d1 esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILELE_PP_RR__ 1024 d0 d1 esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILELE_PP_RR__ 2048 d0 d1 esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d0 : Nat, d1 : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, rsize : Nat, rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d1 ∧ d1 ≤ 15 ∧ 0 ≤ d0 ∧ d0 ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEHI_PP_RR__ (VL : Nat) (d0 : Nat) (d1 : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec (PL * 2)) := (Ones (n := (PL *i 2)))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector (PL *i 2)) ) : SailM (BitVec (PL * 2)) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((elements *i 2) -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec (PL * 2))) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d0 PL (Sail.BitVec.extractLsb result (PL -i 1) 0))
  (P_set d1 PL (Sail.BitVec.extractLsb result ((PL *i 2) -i 1) PL))

def decode_WHILEHI_PP_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (Pd : (BitVec 3)) (eq : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d0 := (BitVec.toNat (Pd ++ (0b0 : (BitVec 1))))
  let d1 := (BitVec.toNat (Pd ++ (0b1 : (BitVec 1))))
  let is_unsigned : Bool := true
  let op : SVECmp := Cmp_GT
  match VL with
  | 128 => (execute_WHILEHI_PP_RR__ 128 d0 d1 esize m n op rsize is_unsigned)
  | 256 => (execute_WHILEHI_PP_RR__ 256 d0 d1 esize m n op rsize is_unsigned)
  | 512 => (execute_WHILEHI_PP_RR__ 512 d0 d1 esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILEHI_PP_RR__ 1024 d0 d1 esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILEHI_PP_RR__ 2048 d0 d1 esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d0 : Nat, d1 : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, rsize : Nat, rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d1 ∧ d1 ≤ 15 ∧ 0 ≤ d0 ∧ d0 ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEHS_PP_RR__ (VL : Nat) (d0 : Nat) (d1 : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec (PL * 2)) := (Ones (n := (PL *i 2)))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector (PL *i 2)) ) : SailM (BitVec (PL * 2)) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((elements *i 2) -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec (PL * 2))) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d0 PL (Sail.BitVec.extractLsb result (PL -i 1) 0))
  (P_set d1 PL (Sail.BitVec.extractLsb result ((PL *i 2) -i 1) PL))

def decode_WHILEHS_PP_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (Pd : (BitVec 3)) (eq : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d0 := (BitVec.toNat (Pd ++ (0b0 : (BitVec 1))))
  let d1 := (BitVec.toNat (Pd ++ (0b1 : (BitVec 1))))
  let is_unsigned : Bool := true
  let op : SVECmp := Cmp_GE
  match VL with
  | 128 => (execute_WHILEHS_PP_RR__ 128 d0 d1 esize m n op rsize is_unsigned)
  | 256 => (execute_WHILEHS_PP_RR__ 256 d0 d1 esize m n op rsize is_unsigned)
  | 512 => (execute_WHILEHS_PP_RR__ 512 d0 d1 esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILEHS_PP_RR__ 1024 d0 d1 esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILEHS_PP_RR__ 2048 d0 d1 esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d0 : Nat, d1 : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, rsize : Nat, rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d1 ∧ d1 ≤ 15 ∧ 0 ≤ d0 ∧ d0 ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEGT_PP_RR__ (VL : Nat) (d0 : Nat) (d1 : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec (PL * 2)) := (Ones (n := (PL *i 2)))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector (PL *i 2)) ) : SailM (BitVec (PL * 2)) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((elements *i 2) -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec (PL * 2))) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d0 PL (Sail.BitVec.extractLsb result (PL -i 1) 0))
  (P_set d1 PL (Sail.BitVec.extractLsb result ((PL *i 2) -i 1) PL))

def decode_WHILEGT_PP_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (Pd : (BitVec 3)) (eq : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d0 := (BitVec.toNat (Pd ++ (0b0 : (BitVec 1))))
  let d1 := (BitVec.toNat (Pd ++ (0b1 : (BitVec 1))))
  let is_unsigned : Bool := false
  let op : SVECmp := Cmp_GT
  match VL with
  | 128 => (execute_WHILEGT_PP_RR__ 128 d0 d1 esize m n op rsize is_unsigned)
  | 256 => (execute_WHILEGT_PP_RR__ 256 d0 d1 esize m n op rsize is_unsigned)
  | 512 => (execute_WHILEGT_PP_RR__ 512 d0 d1 esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILEGT_PP_RR__ 1024 d0 d1 esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILEGT_PP_RR__ 2048 d0 d1 esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d0 : Nat, d1 : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, rsize : Nat, rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d1 ∧ d1 ≤ 15 ∧ 0 ≤ d0 ∧ d0 ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEGE_PP_RR__ (VL : Nat) (d0 : Nat) (d1 : Nat) (esize : Nat) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask : (BitVec (PL * 2)) := (Ones (n := (PL *i 2)))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let result ← (( do (undefined_bitvector (PL *i 2)) ) : SailM (BitVec (PL * 2)) )
  let last : Bool := true
  let psize := (Int.ediv esize 8)
  let (last, operand1, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := ((elements *i 2) -i 1)
    let mut loop_vars := (last, operand1, result)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (last, operand1, result) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let pbit : (BitVec 1) :=
          bif last
          then (0b1 : (BitVec 1))
          else (0b0 : (BitVec 1))
        let result ← (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (last, operand1, result))
    (pure loop_vars) ) : SailM (Bool × (BitVec rsize) × (BitVec (PL * 2))) )
  let split_vec ← do (PredTest mask result esize)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d0 PL (Sail.BitVec.extractLsb result (PL -i 1) 0))
  (P_set d1 PL (Sail.BitVec.extractLsb result ((PL *i 2) -i 1) PL))

def decode_WHILEGE_PP_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (Pd : (BitVec 3)) (eq : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d0 := (BitVec.toNat (Pd ++ (0b0 : (BitVec 1))))
  let d1 := (BitVec.toNat (Pd ++ (0b1 : (BitVec 1))))
  let is_unsigned : Bool := false
  let op : SVECmp := Cmp_GE
  match VL with
  | 128 => (execute_WHILEGE_PP_RR__ 128 d0 d1 esize m n op rsize is_unsigned)
  | 256 => (execute_WHILEGE_PP_RR__ 256 d0 d1 esize m n op rsize is_unsigned)
  | 512 => (execute_WHILEGE_PP_RR__ 512 d0 d1 esize m n op rsize is_unsigned)
  | 1024 => (execute_WHILEGE_PP_RR__ 1024 d0 d1 esize m n op rsize is_unsigned)
  | 2048 => (execute_WHILEGE_PP_RR__ 2048 d0 d1 esize m n op rsize is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHRN_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 1
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((2 *i e) +i i) esize (← (SignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHRN_Z_MZ2__ (tszh : (BitVec 1)) (tszl : (BitVec 1)) (imm4 : (BitVec 4)) (U : (BitVec 1)) (R : (BitVec 1)) (Zn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  let shift := (esize -i (BitVec.toNat imm4))
  match VL with
  | 128 => (execute_SQRSHRN_Z_MZ2__ 128 d esize n shift)
  | 256 => (execute_SQRSHRN_Z_MZ2__ 256 d esize n shift)
  | 512 => (execute_SQRSHRN_Z_MZ2__ 512 d esize n shift)
  | 1024 => (execute_SQRSHRN_Z_MZ2__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHRN_Z_MZ2__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQRSHRUN_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 1
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toInt element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((2 *i e) +i i) esize (← (UnsignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQRSHRUN_Z_MZ2__ (tszh : (BitVec 1)) (tszl : (BitVec 1)) (imm4 : (BitVec 4)) (U : (BitVec 1)) (R : (BitVec 1)) (Zn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  let shift := (esize -i (BitVec.toNat imm4))
  match VL with
  | 128 => (execute_SQRSHRUN_Z_MZ2__ 128 d esize n shift)
  | 256 => (execute_SQRSHRUN_Z_MZ2__ 256 d esize n shift)
  | 512 => (execute_SQRSHRUN_Z_MZ2__ 512 d esize n shift)
  | 1024 => (execute_SQRSHRUN_Z_MZ2__ 1024 d esize n shift)
  | 2048 => (execute_SQRSHRUN_Z_MZ2__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, shift : Int, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQRSHRN_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (shift : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 1
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← (( do (Elem_read operand e (2 *i esize)) ) : SailM (BitVec (2 * esize))
              )
            let res :=
              (_shr_int_general ((BitVec.toNat element) +i (_shl_int_general 1 (shift -i 1))) shift)
            (Elem_set result ((2 *i e) +i i) esize (← (UnsignedSat res esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQRSHRN_Z_MZ2__ (tszh : (BitVec 1)) (tszl : (BitVec 1)) (imm4 : (BitVec 4)) (U : (BitVec 1)) (R : (BitVec 1)) (Zn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  let shift := (esize -i (BitVec.toNat imm4))
  match VL with
  | 128 => (execute_UQRSHRN_Z_MZ2__ 128 d esize n shift)
  | 256 => (execute_UQRSHRN_Z_MZ2__ 256 d esize n shift)
  | 512 => (execute_UQRSHRN_Z_MZ2__ 512 d esize n shift)
  | 1024 => (execute_UQRSHRN_Z_MZ2__ 1024 d esize n shift)
  | 2048 => (execute_UQRSHRN_Z_MZ2__ 2048 d esize n shift)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQCVTN_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 1
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← do (pure (BitVec.toInt (← (Elem_read operand e (2 *i esize)))))
            (Elem_set result ((2 *i e) +i i) esize (← (SignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQCVTN_Z_MZ2__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (U : (BitVec 1)) (Zn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQCVTN_Z_MZ2__ 128 d esize n)
  | 256 => (execute_SQCVTN_Z_MZ2__ 256 d esize n)
  | 512 => (execute_SQCVTN_Z_MZ2__ 512 d esize n)
  | 1024 => (execute_SQCVTN_Z_MZ2__ 1024 d esize n)
  | 2048 => (execute_SQCVTN_Z_MZ2__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SQCVTUN_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 1
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← do (pure (BitVec.toInt (← (Elem_read operand e (2 *i esize)))))
            (Elem_set result ((2 *i e) +i i) esize (← (UnsignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_SQCVTUN_Z_MZ2__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (Zn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_SQCVTUN_Z_MZ2__ 128 d esize n)
  | 256 => (execute_SQCVTUN_Z_MZ2__ 256 d esize n)
  | 512 => (execute_SQCVTUN_Z_MZ2__ 512 d esize n)
  | 1024 => (execute_SQCVTUN_Z_MZ2__ 1024 d esize n)
  | 2048 => (execute_SQCVTUN_Z_MZ2__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UQCVTN_Z_MZ2__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL (2 *i esize))
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_i_lower := 0
        let loop_i_upper := 1
        let mut loop_vars_1 := result
        for i in [loop_i_lower:loop_i_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let operand ← (( do (Z_read (n +i i) VL) ) : SailM (BitVec VL) )
            let element ← do (pure (BitVec.toNat (← (Elem_read operand e (2 *i esize)))))
            (Elem_set result ((2 *i e) +i i) esize (← (UnsignedSat element esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UQCVTN_Z_MZ2__ (tszh : (BitVec 1)) (tszl : (BitVec 2)) (U : (BitVec 1)) (Zn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let n := (BitVec.toNat (Zn ++ (0b0 : (BitVec 1))))
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_UQCVTN_Z_MZ2__ 128 d esize n)
  | 256 => (execute_UQCVTN_Z_MZ2__ 256 d esize n)
  | 512 => (execute_UQCVTN_Z_MZ2__ 512 d esize n)
  | 1024 => (execute_UQCVTN_Z_MZ2__ 1024 d esize n)
  | 2048 => (execute_UQCVTN_Z_MZ2__ 2048 d esize n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, index : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ index ∧ index ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_DUPQ_Z_Zi__ (VL : Nat) (d : Nat) (esize : Nat) (index : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elements := (Int.ediv 128 esize)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let element ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (element, result) ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := (element, result)
    for s in [loop_s_lower:loop_s_upper:1]i do
      let (element, result) := loop_vars
      loop_vars ← do
        let element ← (Elem_read operand ((s *i elements) +i index) esize)
        let result ← (Elem_set result s 128 (BitVec.replicateBits element (Int.ediv 128 esize)))
        (pure (element, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec VL)) )
  (Z_set d VL result)

def decode_DUPQ_Z_Zi__ (i1 : (BitVec 1)) (tsz : (BitVec 4)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let imm : (BitVec 5) := (i1 ++ tsz)
  let esize : Int := 8
  let index ← (( do (undefined_range 0 15) ) : SailM Nat )
  let b__0 := tsz
  bif (BEq.beq b__0 (0x0 : (BitVec 4)))
  then sailThrow ((Error_Undefined ()))
  else
    (bif (BEq.beq b__0 (0x8 : (BitVec 4)))
    then
      (let esize : Int := 64
      let index : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm 4 4))
      (pure ()))
    else
      (bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 0) (0b100 : (BitVec 3)))
      then
        (let esize : Int := 32
        let index : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm 4 3))
        (pure ()))
      else
        (bif (BEq.beq (Sail.BitVec.extractLsb b__0 1 0) (0b10 : (BitVec 2)))
        then
          (let esize : Int := 16
          let index : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm 4 2))
          (pure ()))
        else
          (let esize : Int := 8
          let index : Nat := (BitVec.toNat (Sail.BitVec.extractLsb imm 4 1))
          (pure ())))))
  let index := index
  let esize := esize
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_DUPQ_Z_Zi__ 128 d esize index n)
  | 256 => (execute_DUPQ_Z_Zi__ 256 d esize index n)
  | 512 => (execute_DUPQ_Z_Zi__ 512 d esize index n)
  | 1024 => (execute_DUPQ_Z_Zi__ 1024 d esize index n)
  | 2048 => (execute_DUPQ_Z_Zi__ 2048 d esize index n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, dn : Nat, m : Nat, position : Int, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ dn ∧ dn ≤ 31 ∧ is_VL(VL) -/
def execute_EXTQ_Z_ZI_Des (VL : Nat) (dn : Nat) (m : Nat) (position : Int) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let operand1 ← (( do (Z_read dn VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let concat ← (( do
          (pure ((← (Elem_read operand2 s 128)) ++ (← (Elem_read operand1 s 128)))) ) : SailM
          (BitVec 256) )
        assert (Bool.and (0 ≤b position) ((position +i 127) <b 256)) "src/instrs64_sve.sail:54880.67-54880.68"
        (Elem_set result s 128 (Sail.BitVec.extractLsb concat (position +i 127) position))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set dn VL result)

def decode_EXTQ_Z_ZI_Des (imm4 : (BitVec 4)) (Zm : (BitVec 5)) (Zdn : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let dn := (BitVec.toNat Zdn)
  let m := (BitVec.toNat Zm)
  let position := (Int.shiftl (BitVec.toNat imm4) 3)
  match VL with
  | 128 => (execute_EXTQ_Z_ZI_Des 128 dn m position)
  | 256 => (execute_EXTQ_Z_ZI_Des 256 dn m position)
  | 512 => (execute_EXTQ_Z_ZI_Des 512 dn m position)
  | 1024 => (execute_EXTQ_Z_ZI_Des 1024 dn m position)
  | 2048 => (execute_EXTQ_Z_ZI_Des 2048 dn m position)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_TBLQ_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elements := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let idx ← do
              (pure (BitVec.toNat (← (Elem_read operand2 ((s *i elements) +i e) esize))))
            bif (idx <b elements)
            then
              (do
                (Elem_set result ((s *i elements) +i e) esize
                  (← (Elem_read operand1 ((s *i elements) +i idx) esize))))
            else
              (do
                (Elem_set result ((s *i elements) +i e) esize (Zeros (n := esize))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_TBLQ_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_TBLQ_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_TBLQ_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_TBLQ_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_TBLQ_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_TBLQ_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_TBXQ_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elements := (Int.ediv 128 esize)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (Z_read d VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let idx ← do
              (pure (BitVec.toNat (← (Elem_read operand2 ((s *i elements) +i e) esize))))
            bif (idx <b elements)
            then
              (do
                (Elem_set result ((s *i elements) +i e) esize
                  (← (Elem_read operand1 ((s *i elements) +i idx) esize))))
            else (pure result)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_TBXQ_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  match VL with
  | 128 => (execute_TBXQ_Z_ZZ__ 128 d esize m n)
  | 256 => (execute_TBXQ_Z_ZZ__ 256 d esize m n)
  | 512 => (execute_TBXQ_Z_ZZ__ 512 d esize m n)
  | 1024 => (execute_TBXQ_Z_ZZ__ 1024 d esize m n)
  | 2048 => (execute_TBXQ_Z_ZZ__ 2048 d esize m n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UZPQ1_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elements := (Int.ediv 128 esize)
  let pairs := (Int.ediv elements 2)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ← (( do
          let loop_p_lower := 0
          let loop_p_upper := (pairs -i 1)
          let mut loop_vars_1 := result
          for p in [loop_p_lower:loop_p_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              (Elem_set result ((s *i elements) +i p) esize
                (← (Elem_read operand1 (((s *i elements) +i (2 *i p)) +i part) esize)))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let loop_p_lower := 0
        let loop_p_upper := (pairs -i 1)
        let mut loop_vars_2 := result
        for p in [loop_p_lower:loop_p_upper:1]i do
          let result := loop_vars_2
          loop_vars_2 ← do
            (Elem_set result (((s *i elements) +i pairs) +i p) esize
              (← (Elem_read operand2 (((s *i elements) +i (2 *i p)) +i part) esize)))
        (pure loop_vars_2)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UZPQ1_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 0
  match VL with
  | 128 => (execute_UZPQ1_Z_ZZ__ 128 d esize m n part)
  | 256 => (execute_UZPQ1_Z_ZZ__ 256 d esize m n part)
  | 512 => (execute_UZPQ1_Z_ZZ__ 512 d esize m n part)
  | 1024 => (execute_UZPQ1_Z_ZZ__ 1024 d esize m n part)
  | 2048 => (execute_UZPQ1_Z_ZZ__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UZPQ2_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elements := (Int.ediv 128 esize)
  let pairs := (Int.ediv elements 2)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ← (( do
          let loop_p_lower := 0
          let loop_p_upper := (pairs -i 1)
          let mut loop_vars_1 := result
          for p in [loop_p_lower:loop_p_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              (Elem_set result ((s *i elements) +i p) esize
                (← (Elem_read operand1 (((s *i elements) +i (2 *i p)) +i part) esize)))
          (pure loop_vars_1) ) : SailM (BitVec VL) )
        let loop_p_lower := 0
        let loop_p_upper := (pairs -i 1)
        let mut loop_vars_2 := result
        for p in [loop_p_lower:loop_p_upper:1]i do
          let result := loop_vars_2
          loop_vars_2 ← do
            (Elem_set result (((s *i elements) +i pairs) +i p) esize
              (← (Elem_read operand2 (((s *i elements) +i (2 *i p)) +i part) esize)))
        (pure loop_vars_2)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_UZPQ2_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 1
  match VL with
  | 128 => (execute_UZPQ2_Z_ZZ__ 128 d esize m n part)
  | 256 => (execute_UZPQ2_Z_ZZ__ 256 d esize m n part)
  | 512 => (execute_UZPQ2_Z_ZZ__ 512 d esize m n part)
  | 1024 => (execute_UZPQ2_Z_ZZ__ 1024 d esize m n part)
  | 2048 => (execute_UZPQ2_Z_ZZ__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ZIPQ1_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elements := (Int.ediv 128 esize)
  let pairs := (Int.ediv elements 2)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let base := ((s *i elements) +i (part *i pairs))
        let loop_p_lower := 0
        let loop_p_upper := (pairs -i 1)
        let mut loop_vars_1 := result
        for p in [loop_p_lower:loop_p_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let result ←
              (Elem_set result (((s *i elements) +i (2 *i p)) +i 0) esize
                (← (Elem_read operand1 (base +i p) esize)))
            (Elem_set result (((s *i elements) +i (2 *i p)) +i 1) esize
              (← (Elem_read operand2 (base +i p) esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ZIPQ1_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 0
  match VL with
  | 128 => (execute_ZIPQ1_Z_ZZ__ 128 d esize m n part)
  | 256 => (execute_ZIPQ1_Z_ZZ__ 256 d esize m n part)
  | 512 => (execute_ZIPQ1_Z_ZZ__ 512 d esize m n part)
  | 1024 => (execute_ZIPQ1_Z_ZZ__ 1024 d esize m n part)
  | 2048 => (execute_ZIPQ1_Z_ZZ__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, m : Nat, n : Nat, part : Nat, part = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ZIPQ2_Z_ZZ__ (VL : Nat) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elements := (Int.ediv 128 esize)
  let pairs := (Int.ediv elements 2)
  let operand1 ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let operand2 ← (( do (Z_read m VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_s_lower := 0
    let loop_s_upper := (segments -i 1)
    let mut loop_vars := result
    for s in [loop_s_lower:loop_s_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let base := ((s *i elements) +i (part *i pairs))
        let loop_p_lower := 0
        let loop_p_upper := (pairs -i 1)
        let mut loop_vars_1 := result
        for p in [loop_p_lower:loop_p_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let result ←
              (Elem_set result (((s *i elements) +i (2 *i p)) +i 0) esize
                (← (Elem_read operand1 (base +i p) esize)))
            (Elem_set result (((s *i elements) +i (2 *i p)) +i 1) esize
              (← (Elem_read operand2 (base +i p) esize)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_ZIPQ2_Z_ZZ__ (size : (BitVec 2)) (Zm : (BitVec 5)) (H : (BitVec 1)) (Zn : (BitVec 5)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Zm)
  let d := (BitVec.toNat Zd)
  let part := 1
  match VL with
  | 128 => (execute_ZIPQ2_Z_ZZ__ 128 d esize m n part)
  | 256 => (execute_ZIPQ2_Z_ZZ__ 256 d esize m n part)
  | 512 => (execute_ZIPQ2_Z_ZZ__ 512 d esize m n part)
  | 1024 => (execute_ZIPQ2_Z_ZZ__ 1024 d esize m n part)
  | 2048 => (execute_ZIPQ2_Z_ZZ__ 2048 d esize m n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ANDQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let stmp : (BitVec 128) := (Zeros (n := 128))
  let dtmp ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (dtmp, result, stmp) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := (dtmp, result, stmp)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (dtmp, result, stmp) := loop_vars
      loop_vars ← do
        let dtmp : (BitVec esize) := (Ones (n := esize))
        let (dtmp, stmp) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (segments -i 1)
          let mut loop_vars_1 := (dtmp, stmp)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (dtmp, stmp) := loop_vars_1
            loop_vars_1 ← do
              let (dtmp, stmp) ← (( do
                bif (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize))
                then
                  (do
                    let stmp ← (Elem_read operand s 128)
                    let dtmp ← (pure (dtmp &&& (← (Elem_read stmp e esize))))
                    (pure (dtmp, stmp)))
                else (pure (dtmp, stmp)) ) : SailM ((BitVec esize) × (BitVec 128)) )
              (pure (dtmp, stmp))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec 128)) )
        let result ← (Elem_set result e esize (Sail.BitVec.extractLsb dtmp (esize -i 1) 0))
        (pure (dtmp, result, stmp))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128) × (BitVec 128)) )
  (V_set d 128 result)

def decode_ANDQV_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_ANDQV_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_ANDQV_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_ANDQV_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_ANDQV_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_ANDQV_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_EORQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let stmp : (BitVec 128) := (Zeros (n := 128))
  let dtmp ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (dtmp, result, stmp) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := (dtmp, result, stmp)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (dtmp, result, stmp) := loop_vars
      loop_vars ← do
        let dtmp : (BitVec esize) := (Zeros (n := esize))
        let (dtmp, stmp) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (segments -i 1)
          let mut loop_vars_1 := (dtmp, stmp)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (dtmp, stmp) := loop_vars_1
            loop_vars_1 ← do
              let (dtmp, stmp) ← (( do
                bif (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize))
                then
                  (do
                    let stmp ← (Elem_read operand s 128)
                    let dtmp ← (pure (dtmp ^^^ (← (Elem_read stmp e esize))))
                    (pure (dtmp, stmp)))
                else (pure (dtmp, stmp)) ) : SailM ((BitVec esize) × (BitVec 128)) )
              (pure (dtmp, stmp))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec 128)) )
        let result ← (Elem_set result e esize (Sail.BitVec.extractLsb dtmp (esize -i 1) 0))
        (pure (dtmp, result, stmp))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128) × (BitVec 128)) )
  (V_set d 128 result)

def decode_EORQV_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_EORQV_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_EORQV_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_EORQV_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_EORQV_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_EORQV_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ORQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let stmp : (BitVec 128) := (Zeros (n := 128))
  let dtmp ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (dtmp, result, stmp) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := (dtmp, result, stmp)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (dtmp, result, stmp) := loop_vars
      loop_vars ← do
        let dtmp : (BitVec esize) := (Zeros (n := esize))
        let (dtmp, stmp) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (segments -i 1)
          let mut loop_vars_1 := (dtmp, stmp)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (dtmp, stmp) := loop_vars_1
            loop_vars_1 ← do
              let (dtmp, stmp) ← (( do
                bif (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize))
                then
                  (do
                    let stmp ← (Elem_read operand s 128)
                    let dtmp ← (pure (dtmp ||| (← (Elem_read stmp e esize))))
                    (pure (dtmp, stmp)))
                else (pure (dtmp, stmp)) ) : SailM ((BitVec esize) × (BitVec 128)) )
              (pure (dtmp, stmp))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec 128)) )
        let result ← (Elem_set result e esize (Sail.BitVec.extractLsb dtmp (esize -i 1) 0))
        (pure (dtmp, result, stmp))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec 128) × (BitVec 128)) )
  (V_set d 128 result)

def decode_ORQV_Z_P_Z__ (size : (BitVec 2)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  match VL with
  | 128 => (execute_ORQV_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_ORQV_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_ORQV_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_ORQV_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_ORQV_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_ADDQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let stmp : (BitVec 128) := (Zeros (n := 128))
  let dtmp ← (( do (undefined_int ()) ) : SailM Int )
  let (dtmp, result, stmp) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := (dtmp, result, stmp)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (dtmp, result, stmp) := loop_vars
      loop_vars ← do
        let dtmp : Int := 0
        let (dtmp, stmp) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (segments -i 1)
          let mut loop_vars_1 := (dtmp, stmp)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (dtmp, stmp) := loop_vars_1
            loop_vars_1 ← do
              let (dtmp, stmp) ← (( do
                bif (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize))
                then
                  (do
                    let stmp ← (Elem_read operand s 128)
                    let dtmp ← (pure (dtmp +i (BitVec.toNat (← (Elem_read stmp e esize)))))
                    (pure (dtmp, stmp)))
                else (pure (dtmp, stmp)) ) : SailM (Int × (BitVec 128)) )
              (pure (dtmp, stmp))
          (pure loop_vars_1) ) : SailM (Int × (BitVec 128)) )
        let result ← (Elem_set result e esize (integer_subrange dtmp (esize -i 1) 0))
        (pure (dtmp, result, stmp))
    (pure loop_vars) ) : SailM (Int × (BitVec 128) × (BitVec 128)) )
  (V_set d 128 result)

def decode_ADDQV_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_ADDQV_Z_P_Z__ 128 d esize g n)
  | 256 => (execute_ADDQV_Z_P_Z__ 256 d esize g n)
  | 512 => (execute_ADDQV_Z_P_Z__ 512 d esize g n)
  | 1024 => (execute_ADDQV_Z_P_Z__ 1024 d esize g n)
  | 2048 => (execute_ADDQV_Z_P_Z__ 2048 d esize g n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMAXQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let stmp : (BitVec 128) := (Zeros (n := 128))
  let dtmp ← (( do (undefined_int ()) ) : SailM Int )
  let (dtmp, result, stmp) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := (dtmp, result, stmp)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (dtmp, result, stmp) := loop_vars
      loop_vars ← do
        let dtmp : Int :=
          bif is_unsigned
          then 0
          else (Neg.neg (2 ^i (esize -i 1)))
        let (dtmp, stmp) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (segments -i 1)
          let mut loop_vars_1 := (dtmp, stmp)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (dtmp, stmp) := loop_vars_1
            loop_vars_1 ← do
              let (dtmp, stmp) ← (( do
                bif (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize))
                then
                  (do
                    let stmp ← (Elem_read operand s 128)
                    let dtmp ← (pure (Max.max dtmp (BitVec.toInt (← (Elem_read stmp e esize)))))
                    (pure (dtmp, stmp)))
                else (pure (dtmp, stmp)) ) : SailM (Int × (BitVec 128)) )
              (pure (dtmp, stmp))
          (pure loop_vars_1) ) : SailM (Int × (BitVec 128)) )
        let result ← (Elem_set result e esize (integer_subrange dtmp (esize -i 1) 0))
        (pure (dtmp, result, stmp))
    (pure loop_vars) ) : SailM (Int × (BitVec 128) × (BitVec 128)) )
  (V_set d 128 result)

def decode_SMAXQV_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMAXQV_Z_P_Z__ 128 d esize g n is_unsigned)
  | 256 => (execute_SMAXQV_Z_P_Z__ 256 d esize g n is_unsigned)
  | 512 => (execute_SMAXQV_Z_P_Z__ 512 d esize g n is_unsigned)
  | 1024 => (execute_SMAXQV_Z_P_Z__ 1024 d esize g n is_unsigned)
  | 2048 => (execute_SMAXQV_Z_P_Z__ 2048 d esize g n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMAXQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let stmp : (BitVec 128) := (Zeros (n := 128))
  let dtmp ← (( do (undefined_int ()) ) : SailM Int )
  let (dtmp, result, stmp) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := (dtmp, result, stmp)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (dtmp, result, stmp) := loop_vars
      loop_vars ← do
        let dtmp : Int :=
          bif is_unsigned
          then 0
          else (Neg.neg (2 ^i (esize -i 1)))
        let (dtmp, stmp) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (segments -i 1)
          let mut loop_vars_1 := (dtmp, stmp)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (dtmp, stmp) := loop_vars_1
            loop_vars_1 ← do
              let (dtmp, stmp) ← (( do
                bif (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize))
                then
                  (do
                    let stmp ← (Elem_read operand s 128)
                    let dtmp ← (pure (Max.max dtmp (BitVec.toNat (← (Elem_read stmp e esize)))))
                    (pure (dtmp, stmp)))
                else (pure (dtmp, stmp)) ) : SailM (Int × (BitVec 128)) )
              (pure (dtmp, stmp))
          (pure loop_vars_1) ) : SailM (Int × (BitVec 128)) )
        let result ← (Elem_set result e esize (integer_subrange dtmp (esize -i 1) 0))
        (pure (dtmp, result, stmp))
    (pure loop_vars) ) : SailM (Int × (BitVec 128) × (BitVec 128)) )
  (V_set d 128 result)

def decode_UMAXQV_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMAXQV_Z_P_Z__ 128 d esize g n is_unsigned)
  | 256 => (execute_UMAXQV_Z_P_Z__ 256 d esize g n is_unsigned)
  | 512 => (execute_UMAXQV_Z_P_Z__ 512 d esize g n is_unsigned)
  | 1024 => (execute_UMAXQV_Z_P_Z__ 1024 d esize g n is_unsigned)
  | 2048 => (execute_UMAXQV_Z_P_Z__ 2048 d esize g n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_SMINQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let stmp : (BitVec 128) := (Zeros (n := 128))
  let dtmp ← (( do (undefined_int ()) ) : SailM Int )
  let (dtmp, result, stmp) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := (dtmp, result, stmp)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (dtmp, result, stmp) := loop_vars
      loop_vars ← do
        let dtmp : Int :=
          bif is_unsigned
          then ((2 ^i esize) -i 1)
          else ((2 ^i (esize -i 1)) -i 1)
        let (dtmp, stmp) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (segments -i 1)
          let mut loop_vars_1 := (dtmp, stmp)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (dtmp, stmp) := loop_vars_1
            loop_vars_1 ← do
              let (dtmp, stmp) ← (( do
                bif (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize))
                then
                  (do
                    let stmp ← (Elem_read operand s 128)
                    let dtmp ← (pure (Min.min dtmp (BitVec.toInt (← (Elem_read stmp e esize)))))
                    (pure (dtmp, stmp)))
                else (pure (dtmp, stmp)) ) : SailM (Int × (BitVec 128)) )
              (pure (dtmp, stmp))
          (pure loop_vars_1) ) : SailM (Int × (BitVec 128)) )
        let result ← (Elem_set result e esize (integer_subrange dtmp (esize -i 1) 0))
        (pure (dtmp, result, stmp))
    (pure loop_vars) ) : SailM (Int × (BitVec 128) × (BitVec 128)) )
  (V_set d 128 result)

def decode_SMINQV_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_SMINQV_Z_P_Z__ 128 d esize g n is_unsigned)
  | 256 => (execute_SMINQV_Z_P_Z__ 256 d esize g n is_unsigned)
  | 512 => (execute_SMINQV_Z_P_Z__ 512 d esize g n is_unsigned)
  | 1024 => (execute_SMINQV_Z_P_Z__ 1024 d esize g n is_unsigned)
  | 2048 => (execute_SMINQV_Z_P_Z__ 2048 d esize g n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, n : Nat, 0 ≤
  n ∧
  n ≤ 31 ∧
  g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_UMINQV_Z_P_Z__ (VL : Nat) (d : Nat) (esize : Nat) (g : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let segments := (Int.ediv VL 128)
  let elempersegment := (Int.ediv 128 esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let operand ← (( do
    bif (← (AnyActiveElement mask esize))
    then (Z_read n VL)
    else (pure (Zeros (n := VL))) ) : SailM (BitVec VL) )
  let result : (BitVec 128) := (Zeros (n := 128))
  let stmp : (BitVec 128) := (Zeros (n := 128))
  let dtmp ← (( do (undefined_int ()) ) : SailM Int )
  let (dtmp, result, stmp) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elempersegment -i 1)
    let mut loop_vars := (dtmp, result, stmp)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (dtmp, result, stmp) := loop_vars
      loop_vars ← do
        let dtmp : Int :=
          bif is_unsigned
          then ((2 ^i esize) -i 1)
          else ((2 ^i (esize -i 1)) -i 1)
        let (dtmp, stmp) ← (( do
          let loop_s_lower := 0
          let loop_s_upper := (segments -i 1)
          let mut loop_vars_1 := (dtmp, stmp)
          for s in [loop_s_lower:loop_s_upper:1]i do
            let (dtmp, stmp) := loop_vars_1
            loop_vars_1 ← do
              let (dtmp, stmp) ← (( do
                bif (← (ActivePredicateElement mask ((s *i elempersegment) +i e) esize))
                then
                  (do
                    let stmp ← (Elem_read operand s 128)
                    let dtmp ← (pure (Min.min dtmp (BitVec.toNat (← (Elem_read stmp e esize)))))
                    (pure (dtmp, stmp)))
                else (pure (dtmp, stmp)) ) : SailM (Int × (BitVec 128)) )
              (pure (dtmp, stmp))
          (pure loop_vars_1) ) : SailM (Int × (BitVec 128)) )
        let result ← (Elem_set result e esize (integer_subrange dtmp (esize -i 1) 0))
        (pure (dtmp, result, stmp))
    (pure loop_vars) ) : SailM (Int × (BitVec 128) × (BitVec 128)) )
  (V_set d 128 result)

def decode_UMINQV_Z_P_Z__ (size : (BitVec 2)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Vd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Vd)
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_UMINQV_Z_P_Z__ 128 d esize g n is_unsigned)
  | 256 => (execute_UMINQV_Z_P_Z__ 256 d esize g n is_unsigned)
  | 512 => (execute_UMINQV_Z_P_Z__ 512 d esize g n is_unsigned)
  | 1024 => (execute_UMINQV_Z_P_Z__ 1024 d esize g n is_unsigned)
  | 2048 => (execute_UMINQV_Z_P_Z__ 2048 d esize g n is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ imm = 0 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_PMOV_Z_PI_B (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result : (BitVec VL) := (Zeros (n := VL))
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (pure (BitVec.update result ((elements *i imm) +i e)
            (Bit (← (PredicateElement operand e esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_PMOV_Z_PI_B (Pn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Zd)
  let esize := 8
  let imm := 0
  match VL with
  | 128 => (execute_PMOV_Z_PI_B 128 d esize imm n)
  | 256 => (execute_PMOV_Z_PI_B 256 d esize imm n)
  | 512 => (execute_PMOV_Z_PI_B 512 d esize imm n)
  | 1024 => (execute_PMOV_Z_PI_B 1024 d esize imm n)
  | 2048 => (execute_PMOV_Z_PI_B 2048 d esize imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ imm ∈ {0, 1} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_PMOV_Z_PI_H (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    bif (BEq.beq imm 0)
    then (pure (Zeros (n := VL)))
    else
      (do
        (Z_read d VL)) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (pure (BitVec.update result ((elements *i imm) +i e)
            (Bit (← (PredicateElement operand e esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_PMOV_Z_PI_H (i1 : (BitVec 1)) (Pn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Zd)
  let esize := 16
  let imm := (BitVec.toNat i1)
  match VL with
  | 128 => (execute_PMOV_Z_PI_H 128 d esize imm n)
  | 256 => (execute_PMOV_Z_PI_H 256 d esize imm n)
  | 512 => (execute_PMOV_Z_PI_H 512 d esize imm n)
  | 1024 => (execute_PMOV_Z_PI_H 1024 d esize imm n)
  | 2048 => (execute_PMOV_Z_PI_H 2048 d esize imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ imm ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_PMOV_Z_PI_S (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    bif (BEq.beq imm 0)
    then (pure (Zeros (n := VL)))
    else
      (do
        (Z_read d VL)) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (pure (BitVec.update result ((elements *i imm) +i e)
            (Bit (← (PredicateElement operand e esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_PMOV_Z_PI_S (i2 : (BitVec 2)) (Pn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Zd)
  let esize := 32
  let imm := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_PMOV_Z_PI_S 128 d esize imm n)
  | 256 => (execute_PMOV_Z_PI_S 256 d esize imm n)
  | 512 => (execute_PMOV_Z_PI_S 512 d esize imm n)
  | 1024 => (execute_PMOV_Z_PI_S 1024 d esize imm n)
  | 2048 => (execute_PMOV_Z_PI_S 2048 d esize imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧
  imm ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_PMOV_Z_PI_D (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do
    bif (BEq.beq imm 0)
    then (pure (Zeros (n := VL)))
    else
      (do
        (Z_read d VL)) ) : SailM (BitVec VL) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (pure (BitVec.update result ((elements *i imm) +i e)
            (Bit (← (PredicateElement operand e esize)))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set d VL result)

def decode_PMOV_Z_PI_D (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Pn : (BitVec 4)) (Zd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Pn)
  let d := (BitVec.toNat Zd)
  let esize := 64
  let imm := (BitVec.toNat (i3h ++ i3l))
  match VL with
  | 128 => (execute_PMOV_Z_PI_D 128 d esize imm n)
  | 256 => (execute_PMOV_Z_PI_D 256 d esize imm n)
  | 512 => (execute_PMOV_Z_PI_D 512 d esize imm n)
  | 1024 => (execute_PMOV_Z_PI_D 1024 d esize imm n)
  | 2048 => (execute_PMOV_Z_PI_D 2048 d esize imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ imm = 0 ∧ esize = 8 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PMOV_P_ZI_B (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e psize
          (Sail.BitVec.zeroExtend (BitVec.join1 [(BitVec.access operand ((elements *i imm) +i e))])
            psize))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_PMOV_P_ZI_B (Zn : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let esize := 8
  let imm := 0
  match VL with
  | 128 => (execute_PMOV_P_ZI_B 128 d esize imm n)
  | 256 => (execute_PMOV_P_ZI_B 256 d esize imm n)
  | 512 => (execute_PMOV_P_ZI_B 512 d esize imm n)
  | 1024 => (execute_PMOV_P_ZI_B 1024 d esize imm n)
  | 2048 => (execute_PMOV_P_ZI_B 2048 d esize imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ imm ∈ {0, 1} ∧ esize = 16 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PMOV_P_ZI_H (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e psize
          (Sail.BitVec.zeroExtend (BitVec.join1 [(BitVec.access operand ((elements *i imm) +i e))])
            psize))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_PMOV_P_ZI_H (i1 : (BitVec 1)) (Zn : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let esize := 16
  let imm := (BitVec.toNat i1)
  match VL with
  | 128 => (execute_PMOV_P_ZI_H 128 d esize imm n)
  | 256 => (execute_PMOV_P_ZI_H 256 d esize imm n)
  | 512 => (execute_PMOV_P_ZI_H 512 d esize imm n)
  | 1024 => (execute_PMOV_P_ZI_H 1024 d esize imm n)
  | 2048 => (execute_PMOV_P_ZI_H 2048 d esize imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ imm ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PMOV_P_ZI_S (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e psize
          (Sail.BitVec.zeroExtend (BitVec.join1 [(BitVec.access operand ((elements *i imm) +i e))])
            psize))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_PMOV_P_ZI_S (i2 : (BitVec 2)) (Zn : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let esize := 32
  let imm := (BitVec.toNat i2)
  match VL with
  | 128 => (execute_PMOV_P_ZI_S 128 d esize imm n)
  | 256 => (execute_PMOV_P_ZI_S 256 d esize imm n)
  | 512 => (execute_PMOV_P_ZI_S 512 d esize imm n)
  | 1024 => (execute_PMOV_P_ZI_S 1024 d esize imm n)
  | 2048 => (execute_PMOV_P_ZI_S 2048 d esize imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, imm : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  imm ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PMOV_P_ZI_D (VL : Nat) (d : Nat) (esize : Nat) (imm : Nat) (n : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let operand ← (( do (Z_read n VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (Elem_set result e psize
          (Sail.BitVec.zeroExtend (BitVec.join1 [(BitVec.access operand ((elements *i imm) +i e))])
            psize))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_PMOV_P_ZI_D (i3h : (BitVec 1)) (i3l : (BitVec 2)) (Zn : (BitVec 5)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Zn)
  let d := (BitVec.toNat Pd)
  let esize := 64
  let imm := (BitVec.toNat (i3h ++ i3l))
  match VL with
  | 128 => (execute_PMOV_P_ZI_D 128 d esize imm n)
  | 256 => (execute_PMOV_P_ZI_D 256 d esize imm n)
  | 512 => (execute_PMOV_P_ZI_D 512 d esize imm n)
  | 1024 => (execute_PMOV_P_ZI_D 1024 d esize imm n)
  | 2048 => (execute_PMOV_P_ZI_D 2048 d esize imm n)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, part : Nat, part ∈ {0, 1, 2, 3} ∧
  0 ≤ n ∧ n ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PEXT_PN_RR__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let pred ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i 4)) ) : SailM
    (BitVec (PL * 4)) )
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let pbit ← (( do (PredicateElement mask ((part *i elements) +i e) esize) ) : SailM
          (BitVec 1) )
        (Elem_set result e psize (Sail.BitVec.zeroExtend pbit psize))
    (pure loop_vars) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_PEXT_PN_RR__ (size : (BitVec 2)) (imm2 : (BitVec 2)) (PNn : (BitVec 3)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNn))
  let d := (BitVec.toNat Pd)
  let part := (BitVec.toNat imm2)
  match VL with
  | 128 => (execute_PEXT_PN_RR__ 128 d esize n part)
  | 256 => (execute_PEXT_PN_RR__ 256 d esize n part)
  | 512 => (execute_PEXT_PN_RR__ 512 d esize n part)
  | 1024 => (execute_PEXT_PN_RR__ 1024 d esize n part)
  | 2048 => (execute_PEXT_PN_RR__ 2048 d esize n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d0 : Nat, d1 : Int, esize : Nat, n : Nat, part : Nat, part ∈
  {0, 1} ∧
  0 ≤ n ∧ n ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d0 ∧ d0 ≤ 15 ∧ is_VL(VL) -/
def execute_PEXT_PP_RR__ (VL : Nat) (d0 : Nat) (d1 : Int) (esize : Nat) (n : Nat) (part : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let pred ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i 4)) ) : SailM
    (BitVec (PL * 4)) )
  let result0 ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let result1 ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let psize := (Int.ediv esize 8)
  let result0 ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result0
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result0 := loop_vars
      loop_vars ← do
        let pbit ← (( do (PredicateElement mask (((part *i 2) *i elements) +i e) esize) ) : SailM
          (BitVec 1) )
        (Elem_set result0 e psize (Sail.BitVec.zeroExtend pbit psize))
    (pure loop_vars) ) : SailM (BitVec PL) )
  let result1 ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars_1 := result1
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result1 := loop_vars_1
      loop_vars_1 ← do
        let pbit ← (( do
          (PredicateElement mask ((((part *i 2) *i elements) +i elements) +i e) esize) ) : SailM
          (BitVec 1) )
        (Elem_set result1 e psize (Sail.BitVec.zeroExtend pbit psize))
    (pure loop_vars_1) ) : SailM (BitVec PL) )
  (P_set d0 PL result0)
  (P_set d1 PL result1)

def decode_PEXT_PP_RR__ (size : (BitVec 2)) (i1 : (BitVec 1)) (PNn : (BitVec 3)) (Pd : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNn))
  let d0 := (BitVec.toNat Pd)
  let d1 := (Nat.div ((BitVec.toNat Pd) +i 1) 16)
  let part := (BitVec.toNat i1)
  match VL with
  | 128 => (execute_PEXT_PP_RR__ 128 d0 d1 esize n part)
  | 256 => (execute_PEXT_PP_RR__ 256 d0 d1 esize n part)
  | 512 => (execute_PEXT_PP_RR__ 512 d0 d1 esize n part)
  | 1024 => (execute_PEXT_PP_RR__ 1024 d0 d1 esize n part)
  | 2048 => (execute_PEXT_PP_RR__ 2048 d0 d1 esize n part)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, esize ∈ {8, 16, 32, 64} ∧
  0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_PTRUE_PN_I__ (VL : Nat) (d : Nat) (esize : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let result ← (( do (EncodePredCount esize elements elements false PL) ) : SailM (BitVec PL) )
  (P_set d PL result)

def decode_PTRUE_PN_I__ (size : (BitVec 2)) (PNd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let d := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNd))
  match VL with
  | 128 => (execute_PTRUE_PN_I__ 128 d esize)
  | 256 => (execute_PTRUE_PN_I__ 256 d esize)
  | 512 => (execute_PTRUE_PN_I__ 512 d esize)
  | 1024 => (execute_PTRUE_PN_I__ 1024 d esize)
  | 2048 => (execute_PTRUE_PN_I__ 2048 d esize)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, n : Nat, width : Nat, width ∈ {2, 4} ∧
  0 ≤ n ∧ n ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 ∧ is_VL(VL) -/
def execute_CNTP_R_PN__ (VL : Nat) (d : Nat) (esize : Nat) (n : Nat) (width : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let pred ← (( do (P_read n PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i 4)) ) : SailM
    (BitVec (PL * 4)) )
  let sum : (BitVec 64) := (Zeros (n := 64))
  let limit := (elements *i width)
  let sum ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (limit -i 1)
    let mut loop_vars := sum
    for e in [loop_e_lower:loop_e_upper:1]i do
      let sum := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then (pure (BitVec.addInt sum 1))
        else (pure sum)
    (pure loop_vars) ) : SailM (BitVec 64) )
  (X_set d 64 sum)

def decode_CNTP_R_PN__ (size : (BitVec 2)) (vl : (BitVec 1)) (PNn : (BitVec 4)) (Rd : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let n := (BitVec.toNat PNn)
  let d := (BitVec.toNat Rd)
  let width := (Int.shiftl 2 (BitVec.toNat vl))
  match VL with
  | 128 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and
              (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                (BEq.beq esize 64))
              (Bool.and (0 ≤b d)
                (Bool.and (d ≤b 31)
                  (Bool.or
                    (Bool.or
                      (Bool.or (Bool.or (BEq.beq 128 128) (BEq.beq 128 256)) (BEq.beq 128 512))
                      (BEq.beq 128 1024)) (BEq.beq 128 2048)))))))) "src/instrs64_sve.sail:56606.130-56606.131"
      (execute_CNTP_R_PN__ 128 d esize n width))
  | 256 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and
              (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                (BEq.beq esize 64))
              (Bool.and (0 ≤b d)
                (Bool.and (d ≤b 31)
                  (Bool.or
                    (Bool.or
                      (Bool.or (Bool.or (BEq.beq 256 128) (BEq.beq 256 256)) (BEq.beq 256 512))
                      (BEq.beq 256 1024)) (BEq.beq 256 2048)))))))) "src/instrs64_sve.sail:56610.130-56610.131"
      (execute_CNTP_R_PN__ 256 d esize n width))
  | 512 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and
              (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                (BEq.beq esize 64))
              (Bool.and (0 ≤b d)
                (Bool.and (d ≤b 31)
                  (Bool.or
                    (Bool.or
                      (Bool.or (Bool.or (BEq.beq 512 128) (BEq.beq 512 256)) (BEq.beq 512 512))
                      (BEq.beq 512 1024)) (BEq.beq 512 2048)))))))) "src/instrs64_sve.sail:56614.130-56614.131"
      (execute_CNTP_R_PN__ 512 d esize n width))
  | 1024 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and
              (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                (BEq.beq esize 64))
              (Bool.and (0 ≤b d)
                (Bool.and (d ≤b 31)
                  (Bool.or
                    (Bool.or
                      (Bool.or (Bool.or (BEq.beq 1024 128) (BEq.beq 1024 256)) (BEq.beq 1024 512))
                      (BEq.beq 1024 1024)) (BEq.beq 1024 2048)))))))) "src/instrs64_sve.sail:56618.131-56618.132"
      (execute_CNTP_R_PN__ 1024 d esize n width))
  | 2048 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and
              (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                (BEq.beq esize 64))
              (Bool.and (0 ≤b d)
                (Bool.and (d ≤b 31)
                  (Bool.or
                    (Bool.or
                      (Bool.or (Bool.or (BEq.beq 2048 128) (BEq.beq 2048 256)) (BEq.beq 2048 512))
                      (BEq.beq 2048 1024)) (BEq.beq 2048 2048)))))))) "src/instrs64_sve.sail:56622.131-56622.132"
      (execute_CNTP_R_PN__ 2048 d esize n width))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_invert : Bool, k_is_unsigned : Bool, m : Nat, n
  : Nat, rsize : Nat, width : Nat, width ∈ {2, 4} ∧
  rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELO_PN_RR__ (VL : Nat) (d : Nat) (esize : Nat) (invert : Bool) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) (width : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (width *i (Int.ediv VL esize))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let last : Bool := true
  let count : Int := 0
  let (count, last, operand1) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (count, last, operand1)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (count, last, operand1) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let count : Int :=
          bif last
          then (count +i 1)
          else count
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (count, last, operand1))
    (pure loop_vars) ) : SailM (Int × Bool × (BitVec rsize)) )
  let count := count
  let result ← (( do (EncodePredCount esize elements count invert PL) ) : SailM (BitVec PL) )
  let split_vec ← do (PredCountTest elements count invert)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILELO_PN_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (vl : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (PNd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNd))
  let is_unsigned : Bool := true
  let invert : Bool := false
  let op : SVECmp := Cmp_LT
  let width := (Int.shiftl 2 (BitVec.toNat vl))
  match VL with
  | 128 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 128 128) (BEq.beq 128 256)) (BEq.beq 128 512))
                          (BEq.beq 128 1024)) (BEq.beq 128 2048)))))))))) "src/instrs64_sve.sail:56696.151-56696.152"
      (execute_WHILELO_PN_RR__ 128 d esize invert m n op rsize is_unsigned width))
  | 256 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 256 128) (BEq.beq 256 256)) (BEq.beq 256 512))
                          (BEq.beq 256 1024)) (BEq.beq 256 2048)))))))))) "src/instrs64_sve.sail:56700.151-56700.152"
      (execute_WHILELO_PN_RR__ 256 d esize invert m n op rsize is_unsigned width))
  | 512 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 512 128) (BEq.beq 512 256)) (BEq.beq 512 512))
                          (BEq.beq 512 1024)) (BEq.beq 512 2048)))))))))) "src/instrs64_sve.sail:56704.151-56704.152"
      (execute_WHILELO_PN_RR__ 512 d esize invert m n op rsize is_unsigned width))
  | 1024 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 1024 128) (BEq.beq 1024 256))
                            (BEq.beq 1024 512)) (BEq.beq 1024 1024)) (BEq.beq 1024 2048)))))))))) "src/instrs64_sve.sail:56708.152-56708.153"
      (execute_WHILELO_PN_RR__ 1024 d esize invert m n op rsize is_unsigned width))
  | 2048 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 2048 128) (BEq.beq 2048 256))
                            (BEq.beq 2048 512)) (BEq.beq 2048 1024)) (BEq.beq 2048 2048)))))))))) "src/instrs64_sve.sail:56712.152-56712.153"
      (execute_WHILELO_PN_RR__ 2048 d esize invert m n op rsize is_unsigned width))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_invert : Bool, k_is_unsigned : Bool, m : Nat, n
  : Nat, rsize : Nat, width : Nat, width ∈ {2, 4} ∧
  rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELS_PN_RR__ (VL : Nat) (d : Nat) (esize : Nat) (invert : Bool) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) (width : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (width *i (Int.ediv VL esize))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let last : Bool := true
  let count : Int := 0
  let (count, last, operand1) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (count, last, operand1)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (count, last, operand1) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let count : Int :=
          bif last
          then (count +i 1)
          else count
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (count, last, operand1))
    (pure loop_vars) ) : SailM (Int × Bool × (BitVec rsize)) )
  let count := count
  let result ← (( do (EncodePredCount esize elements count invert PL) ) : SailM (BitVec PL) )
  let split_vec ← do (PredCountTest elements count invert)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILELS_PN_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (vl : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (PNd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNd))
  let is_unsigned : Bool := true
  let invert : Bool := false
  let op : SVECmp := Cmp_LE
  let width := (Int.shiftl 2 (BitVec.toNat vl))
  match VL with
  | 128 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 128 128) (BEq.beq 128 256)) (BEq.beq 128 512))
                          (BEq.beq 128 1024)) (BEq.beq 128 2048)))))))))) "src/instrs64_sve.sail:56790.151-56790.152"
      (execute_WHILELS_PN_RR__ 128 d esize invert m n op rsize is_unsigned width))
  | 256 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 256 128) (BEq.beq 256 256)) (BEq.beq 256 512))
                          (BEq.beq 256 1024)) (BEq.beq 256 2048)))))))))) "src/instrs64_sve.sail:56794.151-56794.152"
      (execute_WHILELS_PN_RR__ 256 d esize invert m n op rsize is_unsigned width))
  | 512 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 512 128) (BEq.beq 512 256)) (BEq.beq 512 512))
                          (BEq.beq 512 1024)) (BEq.beq 512 2048)))))))))) "src/instrs64_sve.sail:56798.151-56798.152"
      (execute_WHILELS_PN_RR__ 512 d esize invert m n op rsize is_unsigned width))
  | 1024 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 1024 128) (BEq.beq 1024 256))
                            (BEq.beq 1024 512)) (BEq.beq 1024 1024)) (BEq.beq 1024 2048)))))))))) "src/instrs64_sve.sail:56802.152-56802.153"
      (execute_WHILELS_PN_RR__ 1024 d esize invert m n op rsize is_unsigned width))
  | 2048 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 2048 128) (BEq.beq 2048 256))
                            (BEq.beq 2048 512)) (BEq.beq 2048 1024)) (BEq.beq 2048 2048)))))))))) "src/instrs64_sve.sail:56806.152-56806.153"
      (execute_WHILELS_PN_RR__ 2048 d esize invert m n op rsize is_unsigned width))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_invert : Bool, k_is_unsigned : Bool, m : Nat, n
  : Nat, rsize : Nat, width : Nat, width ∈ {2, 4} ∧
  rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELT_PN_RR__ (VL : Nat) (d : Nat) (esize : Nat) (invert : Bool) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) (width : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (width *i (Int.ediv VL esize))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let last : Bool := true
  let count : Int := 0
  let (count, last, operand1) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (count, last, operand1)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (count, last, operand1) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let count : Int :=
          bif last
          then (count +i 1)
          else count
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (count, last, operand1))
    (pure loop_vars) ) : SailM (Int × Bool × (BitVec rsize)) )
  let count := count
  let result ← (( do (EncodePredCount esize elements count invert PL) ) : SailM (BitVec PL) )
  let split_vec ← do (PredCountTest elements count invert)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILELT_PN_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (vl : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (PNd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNd))
  let is_unsigned : Bool := false
  let invert : Bool := false
  let op : SVECmp := Cmp_LT
  let width := (Int.shiftl 2 (BitVec.toNat vl))
  match VL with
  | 128 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 128 128) (BEq.beq 128 256)) (BEq.beq 128 512))
                          (BEq.beq 128 1024)) (BEq.beq 128 2048)))))))))) "src/instrs64_sve.sail:56884.151-56884.152"
      (execute_WHILELT_PN_RR__ 128 d esize invert m n op rsize is_unsigned width))
  | 256 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 256 128) (BEq.beq 256 256)) (BEq.beq 256 512))
                          (BEq.beq 256 1024)) (BEq.beq 256 2048)))))))))) "src/instrs64_sve.sail:56888.151-56888.152"
      (execute_WHILELT_PN_RR__ 256 d esize invert m n op rsize is_unsigned width))
  | 512 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 512 128) (BEq.beq 512 256)) (BEq.beq 512 512))
                          (BEq.beq 512 1024)) (BEq.beq 512 2048)))))))))) "src/instrs64_sve.sail:56892.151-56892.152"
      (execute_WHILELT_PN_RR__ 512 d esize invert m n op rsize is_unsigned width))
  | 1024 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 1024 128) (BEq.beq 1024 256))
                            (BEq.beq 1024 512)) (BEq.beq 1024 1024)) (BEq.beq 1024 2048)))))))))) "src/instrs64_sve.sail:56896.152-56896.153"
      (execute_WHILELT_PN_RR__ 1024 d esize invert m n op rsize is_unsigned width))
  | 2048 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 2048 128) (BEq.beq 2048 256))
                            (BEq.beq 2048 512)) (BEq.beq 2048 1024)) (BEq.beq 2048 2048)))))))))) "src/instrs64_sve.sail:56900.152-56900.153"
      (execute_WHILELT_PN_RR__ 2048 d esize invert m n op rsize is_unsigned width))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_invert : Bool, k_is_unsigned : Bool, m : Nat, n
  : Nat, rsize : Nat, width : Nat, width ∈ {2, 4} ∧
  rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILELE_PN_RR__ (VL : Nat) (d : Nat) (esize : Nat) (invert : Bool) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) (width : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (width *i (Int.ediv VL esize))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let last : Bool := true
  let count : Int := 0
  let (count, last, operand1) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (count, last, operand1)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (count, last, operand1) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_LT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) <b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_LE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≤b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let count : Int :=
          bif last
          then (count +i 1)
          else count
        let operand1 : (BitVec rsize) := (BitVec.addInt operand1 1)
        (pure (count, last, operand1))
    (pure loop_vars) ) : SailM (Int × Bool × (BitVec rsize)) )
  let count := count
  let result ← (( do (EncodePredCount esize elements count invert PL) ) : SailM (BitVec PL) )
  let split_vec ← do (PredCountTest elements count invert)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILELE_PN_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (vl : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (PNd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNd))
  let is_unsigned : Bool := false
  let invert : Bool := false
  let op : SVECmp := Cmp_LE
  let width := (Int.shiftl 2 (BitVec.toNat vl))
  match VL with
  | 128 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 128 128) (BEq.beq 128 256)) (BEq.beq 128 512))
                          (BEq.beq 128 1024)) (BEq.beq 128 2048)))))))))) "src/instrs64_sve.sail:56978.151-56978.152"
      (execute_WHILELE_PN_RR__ 128 d esize invert m n op rsize is_unsigned width))
  | 256 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 256 128) (BEq.beq 256 256)) (BEq.beq 256 512))
                          (BEq.beq 256 1024)) (BEq.beq 256 2048)))))))))) "src/instrs64_sve.sail:56982.151-56982.152"
      (execute_WHILELE_PN_RR__ 256 d esize invert m n op rsize is_unsigned width))
  | 512 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 512 128) (BEq.beq 512 256)) (BEq.beq 512 512))
                          (BEq.beq 512 1024)) (BEq.beq 512 2048)))))))))) "src/instrs64_sve.sail:56986.151-56986.152"
      (execute_WHILELE_PN_RR__ 512 d esize invert m n op rsize is_unsigned width))
  | 1024 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 1024 128) (BEq.beq 1024 256))
                            (BEq.beq 1024 512)) (BEq.beq 1024 1024)) (BEq.beq 1024 2048)))))))))) "src/instrs64_sve.sail:56990.152-56990.153"
      (execute_WHILELE_PN_RR__ 1024 d esize invert m n op rsize is_unsigned width))
  | 2048 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 2048 128) (BEq.beq 2048 256))
                            (BEq.beq 2048 512)) (BEq.beq 2048 1024)) (BEq.beq 2048 2048)))))))))) "src/instrs64_sve.sail:56994.152-56994.153"
      (execute_WHILELE_PN_RR__ 2048 d esize invert m n op rsize is_unsigned width))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_invert : Bool, k_is_unsigned : Bool, m : Nat, n
  : Nat, rsize : Nat, width : Nat, width ∈ {2, 4} ∧
  rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEHI_PN_RR__ (VL : Nat) (d : Nat) (esize : Nat) (invert : Bool) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) (width : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (width *i (Int.ediv VL esize))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let last : Bool := true
  let count : Int := 0
  let (count, last, operand1) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (count, last, operand1)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (count, last, operand1) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let count : Int :=
          bif last
          then (count +i 1)
          else count
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (count, last, operand1))
    (pure loop_vars) ) : SailM (Int × Bool × (BitVec rsize)) )
  let count := count
  let result ← (( do (EncodePredCount esize elements count invert PL) ) : SailM (BitVec PL) )
  let split_vec ← do (PredCountTest elements count invert)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILEHI_PN_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (vl : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (PNd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNd))
  let is_unsigned : Bool := true
  let invert : Bool := true
  let op : SVECmp := Cmp_GT
  let width := (Int.shiftl 2 (BitVec.toNat vl))
  match VL with
  | 128 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 128 128) (BEq.beq 128 256)) (BEq.beq 128 512))
                          (BEq.beq 128 1024)) (BEq.beq 128 2048)))))))))) "src/instrs64_sve.sail:57072.151-57072.152"
      (execute_WHILEHI_PN_RR__ 128 d esize invert m n op rsize is_unsigned width))
  | 256 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 256 128) (BEq.beq 256 256)) (BEq.beq 256 512))
                          (BEq.beq 256 1024)) (BEq.beq 256 2048)))))))))) "src/instrs64_sve.sail:57076.151-57076.152"
      (execute_WHILEHI_PN_RR__ 256 d esize invert m n op rsize is_unsigned width))
  | 512 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 512 128) (BEq.beq 512 256)) (BEq.beq 512 512))
                          (BEq.beq 512 1024)) (BEq.beq 512 2048)))))))))) "src/instrs64_sve.sail:57080.151-57080.152"
      (execute_WHILEHI_PN_RR__ 512 d esize invert m n op rsize is_unsigned width))
  | 1024 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 1024 128) (BEq.beq 1024 256))
                            (BEq.beq 1024 512)) (BEq.beq 1024 1024)) (BEq.beq 1024 2048)))))))))) "src/instrs64_sve.sail:57084.152-57084.153"
      (execute_WHILEHI_PN_RR__ 1024 d esize invert m n op rsize is_unsigned width))
  | 2048 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 2048 128) (BEq.beq 2048 256))
                            (BEq.beq 2048 512)) (BEq.beq 2048 1024)) (BEq.beq 2048 2048)))))))))) "src/instrs64_sve.sail:57088.152-57088.153"
      (execute_WHILEHI_PN_RR__ 2048 d esize invert m n op rsize is_unsigned width))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_invert : Bool, k_is_unsigned : Bool, m : Nat, n
  : Nat, rsize : Nat, width : Nat, width ∈ {2, 4} ∧
  rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEHS_PN_RR__ (VL : Nat) (d : Nat) (esize : Nat) (invert : Bool) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) (width : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (width *i (Int.ediv VL esize))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let last : Bool := true
  let count : Int := 0
  let (count, last, operand1) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (count, last, operand1)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (count, last, operand1) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let count : Int :=
          bif last
          then (count +i 1)
          else count
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (count, last, operand1))
    (pure loop_vars) ) : SailM (Int × Bool × (BitVec rsize)) )
  let count := count
  let result ← (( do (EncodePredCount esize elements count invert PL) ) : SailM (BitVec PL) )
  let split_vec ← do (PredCountTest elements count invert)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILEHS_PN_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (vl : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (PNd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNd))
  let is_unsigned : Bool := true
  let invert : Bool := true
  let op : SVECmp := Cmp_GE
  let width := (Int.shiftl 2 (BitVec.toNat vl))
  match VL with
  | 128 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 128 128) (BEq.beq 128 256)) (BEq.beq 128 512))
                          (BEq.beq 128 1024)) (BEq.beq 128 2048)))))))))) "src/instrs64_sve.sail:57166.151-57166.152"
      (execute_WHILEHS_PN_RR__ 128 d esize invert m n op rsize is_unsigned width))
  | 256 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 256 128) (BEq.beq 256 256)) (BEq.beq 256 512))
                          (BEq.beq 256 1024)) (BEq.beq 256 2048)))))))))) "src/instrs64_sve.sail:57170.151-57170.152"
      (execute_WHILEHS_PN_RR__ 256 d esize invert m n op rsize is_unsigned width))
  | 512 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 512 128) (BEq.beq 512 256)) (BEq.beq 512 512))
                          (BEq.beq 512 1024)) (BEq.beq 512 2048)))))))))) "src/instrs64_sve.sail:57174.151-57174.152"
      (execute_WHILEHS_PN_RR__ 512 d esize invert m n op rsize is_unsigned width))
  | 1024 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 1024 128) (BEq.beq 1024 256))
                            (BEq.beq 1024 512)) (BEq.beq 1024 1024)) (BEq.beq 1024 2048)))))))))) "src/instrs64_sve.sail:57178.152-57178.153"
      (execute_WHILEHS_PN_RR__ 1024 d esize invert m n op rsize is_unsigned width))
  | 2048 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 2048 128) (BEq.beq 2048 256))
                            (BEq.beq 2048 512)) (BEq.beq 2048 1024)) (BEq.beq 2048 2048)))))))))) "src/instrs64_sve.sail:57182.152-57182.153"
      (execute_WHILEHS_PN_RR__ 2048 d esize invert m n op rsize is_unsigned width))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_invert : Bool, k_is_unsigned : Bool, m : Nat, n
  : Nat, rsize : Nat, width : Nat, width ∈ {2, 4} ∧
  rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEGT_PN_RR__ (VL : Nat) (d : Nat) (esize : Nat) (invert : Bool) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) (width : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (width *i (Int.ediv VL esize))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let last : Bool := true
  let count : Int := 0
  let (count, last, operand1) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (count, last, operand1)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (count, last, operand1) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let count : Int :=
          bif last
          then (count +i 1)
          else count
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (count, last, operand1))
    (pure loop_vars) ) : SailM (Int × Bool × (BitVec rsize)) )
  let count := count
  let result ← (( do (EncodePredCount esize elements count invert PL) ) : SailM (BitVec PL) )
  let split_vec ← do (PredCountTest elements count invert)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILEGT_PN_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (vl : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (PNd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNd))
  let is_unsigned : Bool := false
  let invert : Bool := true
  let op : SVECmp := Cmp_GT
  let width := (Int.shiftl 2 (BitVec.toNat vl))
  match VL with
  | 128 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 128 128) (BEq.beq 128 256)) (BEq.beq 128 512))
                          (BEq.beq 128 1024)) (BEq.beq 128 2048)))))))))) "src/instrs64_sve.sail:57260.151-57260.152"
      (execute_WHILEGT_PN_RR__ 128 d esize invert m n op rsize is_unsigned width))
  | 256 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 256 128) (BEq.beq 256 256)) (BEq.beq 256 512))
                          (BEq.beq 256 1024)) (BEq.beq 256 2048)))))))))) "src/instrs64_sve.sail:57264.151-57264.152"
      (execute_WHILEGT_PN_RR__ 256 d esize invert m n op rsize is_unsigned width))
  | 512 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 512 128) (BEq.beq 512 256)) (BEq.beq 512 512))
                          (BEq.beq 512 1024)) (BEq.beq 512 2048)))))))))) "src/instrs64_sve.sail:57268.151-57268.152"
      (execute_WHILEGT_PN_RR__ 512 d esize invert m n op rsize is_unsigned width))
  | 1024 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 1024 128) (BEq.beq 1024 256))
                            (BEq.beq 1024 512)) (BEq.beq 1024 1024)) (BEq.beq 1024 2048)))))))))) "src/instrs64_sve.sail:57272.152-57272.153"
      (execute_WHILEGT_PN_RR__ 1024 d esize invert m n op rsize is_unsigned width))
  | 2048 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 2048 128) (BEq.beq 2048 256))
                            (BEq.beq 2048 512)) (BEq.beq 2048 1024)) (BEq.beq 2048 2048)))))))))) "src/instrs64_sve.sail:57276.152-57276.153"
      (execute_WHILEGT_PN_RR__ 2048 d esize invert m n op rsize is_unsigned width))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, d : Nat, esize : Nat, k_invert : Bool, k_is_unsigned : Bool, m : Nat, n
  : Nat, rsize : Nat, width : Nat, width ∈ {2, 4} ∧
  rsize = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 15 ∧ is_VL(VL) -/
def execute_WHILEGE_PN_RR__ (VL : Nat) (d : Nat) (esize : Nat) (invert : Bool) (m : Nat) (n : Nat) (op : SVECmp) (rsize : Nat) (is_unsigned : Bool) (width : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (width *i (Int.ediv VL esize))
  let operand1 ← (( do (X_read n rsize) ) : SailM (BitVec rsize) )
  let operand2 ← (( do (X_read m rsize) ) : SailM (BitVec rsize) )
  let last : Bool := true
  let count : Int := 0
  let (count, last, operand1) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (count, last, operand1)
    for e in [loop_e_upper:loop_e_lower:-1]i do
      let (count, last, operand1) := loop_vars
      loop_vars ← do
        let cond ← (( do (undefined_bool ()) ) : SailM Bool )
        let cond ← (( do
          match op with
          | Cmp_GT => (do
              (pure ((← (asl_Int operand1 is_unsigned)) >b (← (asl_Int operand2 is_unsigned)))))
          | Cmp_GE => (do
              (pure ((← (asl_Int operand1 is_unsigned)) ≥b (← (asl_Int operand2 is_unsigned)))))
          | _ => (pure cond) ) : SailM Bool )
        let last : Bool := (Bool.and last cond)
        let count : Int :=
          bif last
          then (count +i 1)
          else count
        let operand1 : (BitVec rsize) := (BitVec.subInt operand1 1)
        (pure (count, last, operand1))
    (pure loop_vars) ) : SailM (Int × Bool × (BitVec rsize)) )
  let count := count
  let result ← (( do (EncodePredCount esize elements count invert PL) ) : SailM (BitVec PL) )
  let split_vec ← do (PredCountTest elements count invert)
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) }
  (P_set d PL result)

def decode_WHILEGE_PN_RR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (vl : (BitVec 1)) (U : (BitVec 1)) (lt : (BitVec 1)) (Rn : (BitVec 5)) (eq : (BitVec 1)) (PNd : (BitVec 3)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let rsize := 64
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let d := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNd))
  let is_unsigned : Bool := false
  let invert : Bool := true
  let op : SVECmp := Cmp_GE
  let width := (Int.shiftl 2 (BitVec.toNat vl))
  match VL with
  | 128 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 128 128) (BEq.beq 128 256)) (BEq.beq 128 512))
                          (BEq.beq 128 1024)) (BEq.beq 128 2048)))))))))) "src/instrs64_sve.sail:57354.151-57354.152"
      (execute_WHILEGE_PN_RR__ 128 d esize invert m n op rsize is_unsigned width))
  | 256 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 256 128) (BEq.beq 256 256)) (BEq.beq 256 512))
                          (BEq.beq 256 1024)) (BEq.beq 256 2048)))))))))) "src/instrs64_sve.sail:57358.151-57358.152"
      (execute_WHILEGE_PN_RR__ 256 d esize invert m n op rsize is_unsigned width))
  | 512 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 512 128) (BEq.beq 512 256)) (BEq.beq 512 512))
                          (BEq.beq 512 1024)) (BEq.beq 512 2048)))))))))) "src/instrs64_sve.sail:57362.151-57362.152"
      (execute_WHILEGE_PN_RR__ 512 d esize invert m n op rsize is_unsigned width))
  | 1024 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 1024 128) (BEq.beq 1024 256))
                            (BEq.beq 1024 512)) (BEq.beq 1024 1024)) (BEq.beq 1024 2048)))))))))) "src/instrs64_sve.sail:57366.152-57366.153"
      (execute_WHILEGE_PN_RR__ 1024 d esize invert m n op rsize is_unsigned width))
  | 2048 => (do
      assert (Bool.and (Bool.or (BEq.beq width 2) (BEq.beq width 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 15)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq 2048 128) (BEq.beq 2048 256))
                            (BEq.beq 2048 512)) (BEq.beq 2048 1024)) (BEq.beq 2048 2048)))))))))) "src/instrs64_sve.sail:57370.152-57370.153"
      (execute_WHILEGE_PN_RR__ 2048 d esize invert m n op rsize is_unsigned width))
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BZ_S_x32_unscaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1B_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1B_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1B_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_BZ_S_x32_unscaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1SB_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LD1SB_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LD1SB_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1B_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:57610.24-57610.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1B_Z_P_BZ_S_x32_unscaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1B_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1B_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1B_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1B_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1B_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1SB_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:57727.24-57727.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SB_Z_P_BZ_S_x32_unscaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1SB_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 256 => (execute_LDFF1SB_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 512 => (execute_LDFF1SB_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 1024 => (execute_LDFF1SB_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SB_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BZ_S_x32_unscaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1H_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1H_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1H_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_BZ_S_x32_unscaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1SH_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LD1SH_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LD1SH_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:58030.24-58030.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_BZ_S_x32_unscaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1H_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1SH_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:58147.24-58147.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SH_Z_P_BZ_S_x32_unscaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1SH_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 256 => (execute_LDFF1SH_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 512 => (execute_LDFF1SH_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 1024 => (execute_LDFF1SH_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SH_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BZ_S_x32_unscaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1W_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1W_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1W_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1W_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:58357.24-58357.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1W_Z_P_BZ_S_x32_unscaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1W_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1W_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1W_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1W_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1W_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_PRFB_I_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFB_I_P_BZ_S_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_PRFB_I_P_BZ_S_x32_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFB_I_P_BZ_S_x32_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFB_I_P_BZ_S_x32_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFB_I_P_BZ_S_x32_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFB_I_P_BZ_S_x32_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_PRFH_I_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFH_I_P_BZ_S_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_PRFH_I_P_BZ_S_x32_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFH_I_P_BZ_S_x32_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFH_I_P_BZ_S_x32_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFH_I_P_BZ_S_x32_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFH_I_P_BZ_S_x32_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 2 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_PRFW_I_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFW_I_P_BZ_S_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 2
  match VL with
  | 128 => (execute_PRFW_I_P_BZ_S_x32_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFW_I_P_BZ_S_x32_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFW_I_P_BZ_S_x32_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFW_I_P_BZ_S_x32_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFW_I_P_BZ_S_x32_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 3 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_PRFD_I_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFD_I_P_BZ_S_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 3
  match VL with
  | 128 => (execute_PRFD_I_P_BZ_S_x32_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFD_I_P_BZ_S_x32_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFD_I_P_BZ_S_x32_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFD_I_P_BZ_S_x32_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFD_I_P_BZ_S_x32_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BZ_S_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_LD1H_Z_P_BZ_S_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1H_Z_P_BZ_S_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1H_Z_P_BZ_S_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BZ_S_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BZ_S_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_BZ_S_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_LD1SH_Z_P_BZ_S_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1SH_Z_P_BZ_S_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1SH_Z_P_BZ_S_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_BZ_S_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_BZ_S_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:58968.24-58968.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_BZ_S_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_LDFF1H_Z_P_BZ_S_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_BZ_S_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_BZ_S_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_BZ_S_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_BZ_S_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1SH_Z_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:59085.24-59085.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SH_Z_P_BZ_S_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_LDFF1SH_Z_P_BZ_S_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1SH_Z_P_BZ_S_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1SH_Z_P_BZ_S_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1SH_Z_P_BZ_S_x32_scaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SH_Z_P_BZ_S_x32_scaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BZ_S_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 2
  match VL with
  | 128 => (execute_LD1W_Z_P_BZ_S_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1W_Z_P_BZ_S_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1W_Z_P_BZ_S_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BZ_S_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BZ_S_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1W_Z_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:59295.24-59295.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1W_Z_P_BZ_S_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 2
  match VL with
  | 128 => (execute_LDFF1W_Z_P_BZ_S_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LDFF1W_Z_P_BZ_S_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LDFF1W_Z_P_BZ_S_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LDFF1W_Z_P_BZ_S_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LDFF1W_Z_P_BZ_S_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, imm : Int, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 31 ∧ is_VL(VL) -/
def execute_LDR_P_BI__ (VL : Nat) (imm : Int) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv PL 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset : Int := (imm *i elements)
  let result ← (( do (undefined_bitvector PL) ) : SailM (BitVec PL) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (BEq.beq n 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let aligned : Bool := (IsAligned__1 (BitVec.addInt base offset) 2)
  bif (Bool.and (Bool.not aligned) (← (AlignmentEnforced ())))
  then (AArch64_Abort (BitVec.addInt base offset) (← (AlignmentFault accdesc)))
  else (pure ())
  let (offset, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (offset, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (offset, result) := loop_vars
      loop_vars ← do
        let offset := offset
        let result ←
          (Elem_set result e 8
            (← (AArch64_MemSingle_read (BitVec.addInt base offset) 1 accdesc aligned)))
        (pure ())
        let offset : Int := (offset +i 1)
        (pure (offset, result))
    (pure loop_vars) ) : SailM (Int × (BitVec PL)) )
  (P_set t PL result)

def decode_LDR_P_BI__ (imm9h : (BitVec 6)) (imm9l : (BitVec 3)) (Rn : (BitVec 5)) (Pt : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Pt)
  let n := (BitVec.toNat Rn)
  let imm := (BitVec.toInt (imm9h ++ imm9l))
  match VL with
  | 128 => (execute_LDR_P_BI__ 128 imm n t)
  | 256 => (execute_LDR_P_BI__ 256 imm n t)
  | 512 => (execute_LDR_P_BI__ 512 imm n t)
  | 1024 => (execute_LDR_P_BI__ 1024 imm n t)
  | 2048 => (execute_LDR_P_BI__ 2048 imm n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, imm : Int, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ is_VL(VL) -/
def execute_LDR_Z_BI__ (VL : Nat) (imm : Int) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset : Int := (imm *i elements)
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (BEq.beq n 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let aligned : Bool := (IsAligned__1 (BitVec.addInt base offset) 16)
  bif (Bool.and (Bool.not aligned) (← (AlignmentEnforced ())))
  then (AArch64_Abort (BitVec.addInt base offset) (← (AlignmentFault accdesc)))
  else (pure ())
  let (offset, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (offset, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (offset, result) := loop_vars
      loop_vars ← do
        let offset := offset
        let result ←
          (Elem_set result e 8
            (← (AArch64_MemSingle_read (BitVec.addInt base offset) 1 accdesc aligned)))
        (pure ())
        let offset : Int := (offset +i 1)
        (pure (offset, result))
    (pure loop_vars) ) : SailM (Int × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDR_Z_BI__ (imm9h : (BitVec 6)) (imm9l : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let imm := (BitVec.toInt (imm9h ++ imm9l))
  match VL with
  | 128 => (execute_LDR_Z_BI__ 128 imm n t)
  | 256 => (execute_LDR_Z_BI__ 256 imm n t)
  | 512 => (execute_LDR_Z_BI__ 512 imm n t)
  | 1024 => (execute_LDR_Z_BI__ 1024 imm n t)
  | 2048 => (execute_LDR_Z_BI__ 2048 imm n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Int, scale :
  Nat, k_stream : Bool, scale = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_PRFB_I_P_BI_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Int) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64))
    else (pure base) ) : SailM (BitVec 64) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (let eoff := ((offset *i elements) +i e)
        let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl eoff scale))
        (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFB_I_P_BI_S (imm6 : (BitVec 6)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 0
  let offset := (BitVec.toInt imm6)
  match VL with
  | 128 => (execute_PRFB_I_P_BI_S 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFB_I_P_BI_S 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFB_I_P_BI_S 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFB_I_P_BI_S 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFB_I_P_BI_S 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Int, scale :
  Nat, k_stream : Bool, scale = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_PRFH_I_P_BI_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Int) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64))
    else (pure base) ) : SailM (BitVec 64) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (let eoff := ((offset *i elements) +i e)
        let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl eoff scale))
        (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFH_I_P_BI_S (imm6 : (BitVec 6)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 1
  let offset := (BitVec.toInt imm6)
  match VL with
  | 128 => (execute_PRFH_I_P_BI_S 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFH_I_P_BI_S 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFH_I_P_BI_S 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFH_I_P_BI_S 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFH_I_P_BI_S 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Int, scale :
  Nat, k_stream : Bool, scale = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_PRFW_I_P_BI_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Int) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64))
    else (pure base) ) : SailM (BitVec 64) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (let eoff := ((offset *i elements) +i e)
        let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl eoff scale))
        (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFW_I_P_BI_S (imm6 : (BitVec 6)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 2
  let offset := (BitVec.toInt imm6)
  match VL with
  | 128 => (execute_PRFW_I_P_BI_S 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFW_I_P_BI_S 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFW_I_P_BI_S 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFW_I_P_BI_S 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFW_I_P_BI_S 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Int, scale :
  Nat, k_stream : Bool, scale = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFD_I_P_BI_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Int) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64))
    else (pure base) ) : SailM (BitVec 64) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (let eoff := ((offset *i elements) +i e)
        let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl eoff scale))
        (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFD_I_P_BI_S (imm6 : (BitVec 6)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 3
  let offset := (BitVec.toInt imm6)
  match VL with
  | 128 => (execute_PRFD_I_P_BI_S 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFD_I_P_BI_S 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFD_I_P_BI_S 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFD_I_P_BI_S 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFD_I_P_BI_S 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, scale : Nat, k_stream
  : Bool, scale = 0 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_PRFB_I_P_BR_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (let eoff := ((BitVec.toNat offset) +i e)
        let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl eoff scale))
        (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFB_I_P_BR_S (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 8
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 0
  match VL with
  | 128 => (execute_PRFB_I_P_BR_S 128 esize g level m n pref_hint scale stream)
  | 256 => (execute_PRFB_I_P_BR_S 256 esize g level m n pref_hint scale stream)
  | 512 => (execute_PRFB_I_P_BR_S 512 esize g level m n pref_hint scale stream)
  | 1024 => (execute_PRFB_I_P_BR_S 1024 esize g level m n pref_hint scale stream)
  | 2048 => (execute_PRFB_I_P_BR_S 2048 esize g level m n pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, scale : Nat, k_stream
  : Bool, scale = 1 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_PRFH_I_P_BR_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (let eoff := ((BitVec.toNat offset) +i e)
        let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl eoff scale))
        (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFH_I_P_BR_S (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 16
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 1
  match VL with
  | 128 => (execute_PRFH_I_P_BR_S 128 esize g level m n pref_hint scale stream)
  | 256 => (execute_PRFH_I_P_BR_S 256 esize g level m n pref_hint scale stream)
  | 512 => (execute_PRFH_I_P_BR_S 512 esize g level m n pref_hint scale stream)
  | 1024 => (execute_PRFH_I_P_BR_S 1024 esize g level m n pref_hint scale stream)
  | 2048 => (execute_PRFH_I_P_BR_S 2048 esize g level m n pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, scale : Nat, k_stream
  : Bool, scale = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_PRFW_I_P_BR_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (let eoff := ((BitVec.toNat offset) +i e)
        let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl eoff scale))
        (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFW_I_P_BR_S (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 2
  match VL with
  | 128 => (execute_PRFW_I_P_BR_S 128 esize g level m n pref_hint scale stream)
  | 256 => (execute_PRFW_I_P_BR_S 256 esize g level m n pref_hint scale stream)
  | 512 => (execute_PRFW_I_P_BR_S 512 esize g level m n pref_hint scale stream)
  | 1024 => (execute_PRFW_I_P_BR_S 1024 esize g level m n pref_hint scale stream)
  | 2048 => (execute_PRFW_I_P_BR_S 2048 esize g level m n pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, scale : Nat, k_stream
  : Bool, scale = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFD_I_P_BR_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (let eoff := ((BitVec.toNat offset) +i e)
        let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl eoff scale))
        (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFD_I_P_BR_S (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 3
  match VL with
  | 128 => (execute_PRFD_I_P_BR_S 128 esize g level m n pref_hint scale stream)
  | 256 => (execute_PRFD_I_P_BR_S 256 esize g level m n pref_hint scale stream)
  | 512 => (execute_PRFD_I_P_BR_S 512 esize g level m n pref_hint scale stream)
  | 1024 => (execute_PRFD_I_P_BR_S 1024 esize g level m n pref_hint scale stream)
  | 2048 => (execute_PRFD_I_P_BR_S 2048 esize g level m n pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Nat, scale :
  Nat, k_stream : Bool, scale = 0 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_PRFB_I_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (Int.shiftl offset scale))) ) : SailM (BitVec 64) )
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFB_I_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 0
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_PRFB_I_P_AI_S 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFB_I_P_AI_S 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFB_I_P_AI_S 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFB_I_P_AI_S 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFB_I_P_AI_S 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Nat, scale :
  Nat, k_stream : Bool, scale = 1 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_PRFH_I_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (Int.shiftl offset scale))) ) : SailM (BitVec 64) )
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFH_I_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 1
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_PRFH_I_P_AI_S 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFH_I_P_AI_S 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFH_I_P_AI_S 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFH_I_P_AI_S 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFH_I_P_AI_S 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Nat, scale :
  Nat, k_stream : Bool, scale = 2 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_PRFW_I_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (Int.shiftl offset scale))) ) : SailM (BitVec 64) )
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFW_I_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 2
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_PRFW_I_P_AI_S 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFW_I_P_AI_S 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFW_I_P_AI_S 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFW_I_P_AI_S 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFW_I_P_AI_S 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Nat, scale :
  Nat, k_stream : Bool, scale = 3 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_PRFD_I_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (Int.shiftl offset scale))) ) : SailM (BitVec 64) )
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFD_I_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 32
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 3
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_PRFD_I_P_AI_S 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFD_I_P_AI_S 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFD_I_P_AI_S 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFD_I_P_AI_S 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFD_I_P_AI_S 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1B_Z_P_AI_S 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1B_Z_P_AI_S 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1B_Z_P_AI_S 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1B_Z_P_AI_S 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_AI_S 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1SB_Z_P_AI_S 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SB_Z_P_AI_S 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SB_Z_P_AI_S 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_AI_S 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_AI_S 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1B_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:60585.24-60585.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1B_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1B_Z_P_AI_S 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1B_Z_P_AI_S 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1B_Z_P_AI_S 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1B_Z_P_AI_S 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1B_Z_P_AI_S 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1SB_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:60689.24-60689.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SB_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1SB_Z_P_AI_S 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1SB_Z_P_AI_S 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1SB_Z_P_AI_S 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1SB_Z_P_AI_S 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1SB_Z_P_AI_S 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1H_Z_P_AI_S 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1H_Z_P_AI_S 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1H_Z_P_AI_S 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1H_Z_P_AI_S 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_AI_S 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1SH_Z_P_AI_S 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SH_Z_P_AI_S 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SH_Z_P_AI_S 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_AI_S 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_AI_S 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:60953.24-60953.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1H_Z_P_AI_S 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_AI_S 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_AI_S 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_AI_S 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_AI_S 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1SH_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:61057.24-61057.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SH_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1SH_Z_P_AI_S 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1SH_Z_P_AI_S 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1SH_Z_P_AI_S 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1SH_Z_P_AI_S 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1SH_Z_P_AI_S 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1W_Z_P_AI_S 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1W_Z_P_AI_S 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1W_Z_P_AI_S 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1W_Z_P_AI_S 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_AI_S 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1W_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:61241.24-61241.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1W_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1W_Z_P_AI_S 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1W_Z_P_AI_S 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1W_Z_P_AI_S 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1W_Z_P_AI_S 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1W_Z_P_AI_S 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1RB_Z_P_BI_U8 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RB_Z_P_BI_U8 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RB_Z_P_BI_U8 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RB_Z_P_BI_U8 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RB_Z_P_BI_U8 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RB_Z_P_BI_U8 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RB_Z_P_BI_U8 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1RB_Z_P_BI_U16 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RB_Z_P_BI_U16 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RB_Z_P_BI_U16 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RB_Z_P_BI_U16 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RB_Z_P_BI_U16 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RB_Z_P_BI_U16 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RB_Z_P_BI_U16 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1RB_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RB_Z_P_BI_U32 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RB_Z_P_BI_U32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RB_Z_P_BI_U32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RB_Z_P_BI_U32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RB_Z_P_BI_U32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RB_Z_P_BI_U32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1RB_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RB_Z_P_BI_U64 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RB_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RB_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RB_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RB_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RB_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1RSW_Z_P_BI_S64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RSW_Z_P_BI_S64 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RSW_Z_P_BI_S64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RSW_Z_P_BI_S64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RSW_Z_P_BI_S64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RSW_Z_P_BI_S64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RSW_Z_P_BI_S64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1RH_Z_P_BI_U16 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RH_Z_P_BI_U16 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RH_Z_P_BI_U16 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RH_Z_P_BI_U16 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RH_Z_P_BI_U16 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RH_Z_P_BI_U16 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RH_Z_P_BI_U16 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1RH_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RH_Z_P_BI_U32 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RH_Z_P_BI_U32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RH_Z_P_BI_U32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RH_Z_P_BI_U32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RH_Z_P_BI_U32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RH_Z_P_BI_U32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1RH_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RH_Z_P_BI_U64 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RH_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RH_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RH_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RH_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RH_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1RSH_Z_P_BI_S64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RSH_Z_P_BI_S64 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RSH_Z_P_BI_S64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RSH_Z_P_BI_S64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RSH_Z_P_BI_S64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RSH_Z_P_BI_S64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RSH_Z_P_BI_S64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1RSH_Z_P_BI_S32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RSH_Z_P_BI_S32 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RSH_Z_P_BI_S32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RSH_Z_P_BI_S32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RSH_Z_P_BI_S32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RSH_Z_P_BI_S32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RSH_Z_P_BI_S32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1RW_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RW_Z_P_BI_U32 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RW_Z_P_BI_U32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RW_Z_P_BI_U32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RW_Z_P_BI_U32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RW_Z_P_BI_U32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RW_Z_P_BI_U32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1RW_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RW_Z_P_BI_U64 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RW_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RW_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RW_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RW_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RW_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1RSB_Z_P_BI_S64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RSB_Z_P_BI_S64 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RSB_Z_P_BI_S64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RSB_Z_P_BI_S64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RSB_Z_P_BI_S64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RSB_Z_P_BI_S64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RSB_Z_P_BI_S64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1RSB_Z_P_BI_S32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RSB_Z_P_BI_S32 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RSB_Z_P_BI_S32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RSB_Z_P_BI_S32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RSB_Z_P_BI_S32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RSB_Z_P_BI_S32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RSB_Z_P_BI_S32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1RSB_Z_P_BI_S16 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RSB_Z_P_BI_S16 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RSB_Z_P_BI_S16 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RSB_Z_P_BI_S16 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RSB_Z_P_BI_S16 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RSB_Z_P_BI_S16 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RSB_Z_P_BI_S16 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 63 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 64 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1RD_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let data ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure data))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ← (( do
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64) ) : SailM (BitVec 64) )
        let addr : (BitVec 64) := (BitVec.addInt base (offset *i mbytes))
        (Mem_read addr mbytes accdesc)) ) : SailM (BitVec msize) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            (Elem_set result e esize (← (Extend data esize is_unsigned))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1RD_Z_P_BI_U64 (dtypeh : (BitVec 2)) (imm6 : (BitVec 6)) (dtypel : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm6)
  match VL with
  | 128 => (execute_LD1RD_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1RD_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1RD_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1RD_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1RD_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BR_U8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BR_U8 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let msize := 8
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1B_Z_P_BR_U8 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1B_Z_P_BR_U8 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1B_Z_P_BR_U8 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BR_U8 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BR_U8 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BR_U16 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BR_U16 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 8
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1B_Z_P_BR_U16 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1B_Z_P_BR_U16 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1B_Z_P_BR_U16 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BR_U16 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BR_U16 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BR_U32 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BR_U32 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1B_Z_P_BR_U32 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1B_Z_P_BR_U32 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1B_Z_P_BR_U32 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BR_U32 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BR_U32 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BR_U64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BR_U64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1B_Z_P_BR_U64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1B_Z_P_BR_U64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1B_Z_P_BR_U64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BR_U64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BR_U64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SW_Z_P_BR_S64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SW_Z_P_BR_S64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LD1SW_Z_P_BR_S64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1SW_Z_P_BR_S64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1SW_Z_P_BR_S64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1SW_Z_P_BR_S64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1SW_Z_P_BR_S64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BR_U16 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BR_U16 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 16
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1H_Z_P_BR_U16 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1H_Z_P_BR_U16 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1H_Z_P_BR_U16 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BR_U16 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BR_U16 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BR_U32 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BR_U32 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1H_Z_P_BR_U32 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1H_Z_P_BR_U32 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1H_Z_P_BR_U32 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BR_U32 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BR_U32 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BR_U64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BR_U64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1H_Z_P_BR_U64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1H_Z_P_BR_U64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1H_Z_P_BR_U64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BR_U64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BR_U64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_BR_S64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_BR_S64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LD1SH_Z_P_BR_S64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1SH_Z_P_BR_S64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1SH_Z_P_BR_S64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_BR_S64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_BR_S64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_BR_S32 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_BR_S32 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LD1SH_Z_P_BR_S32 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1SH_Z_P_BR_S32 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1SH_Z_P_BR_S32 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_BR_S32 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_BR_S32 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BR_U32 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BR_U32 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1W_Z_P_BR_U32 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1W_Z_P_BR_U32 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1W_Z_P_BR_U32 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BR_U32 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BR_U32 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BR_U64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BR_U64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1W_Z_P_BR_U64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1W_Z_P_BR_U64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1W_Z_P_BR_U64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BR_U64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BR_U64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_BR_S64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_BR_S64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LD1SB_Z_P_BR_S64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1SB_Z_P_BR_S64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1SB_Z_P_BR_S64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_BR_S64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_BR_S64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_BR_S32 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_BR_S32 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LD1SB_Z_P_BR_S32 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1SB_Z_P_BR_S32 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1SB_Z_P_BR_S32 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_BR_S32 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_BR_S32 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_BR_S16 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_BR_S16 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 8
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LD1SB_Z_P_BR_S16 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1SB_Z_P_BR_S16 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1SB_Z_P_BR_S16 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_BR_S16 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_BR_S16 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_Z_P_BR_U64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1D_Z_P_BR_U64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1D_Z_P_BR_U64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1D_Z_P_BR_U64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1D_Z_P_BR_U64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1D_Z_P_BR_U64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1D_Z_P_BR_U64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BR_U128 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BR_U128 (dtype : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let msize := 32
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1W_Z_P_BR_U128 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1W_Z_P_BR_U128 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1W_Z_P_BR_U128 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BR_U128 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BR_U128 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD1D_Z_P_BR_U128 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1D_Z_P_BR_U128 (dtype : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let msize := 64
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LD1D_Z_P_BR_U128 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LD1D_Z_P_BR_U128 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LD1D_Z_P_BR_U128 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LD1D_Z_P_BR_U128 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LD1D_Z_P_BR_U128 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDFF1B_Z_P_BR_U8 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:64370.24-64370.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1B_Z_P_BR_U8 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let msize := 8
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDFF1B_Z_P_BR_U8 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1B_Z_P_BR_U8 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1B_Z_P_BR_U8 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1B_Z_P_BR_U8 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1B_Z_P_BR_U8 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDFF1B_Z_P_BR_U16 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:64481.24-64481.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1B_Z_P_BR_U16 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 8
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDFF1B_Z_P_BR_U16 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1B_Z_P_BR_U16 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1B_Z_P_BR_U16 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1B_Z_P_BR_U16 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1B_Z_P_BR_U16 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1B_Z_P_BR_U32 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:64592.24-64592.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1B_Z_P_BR_U32 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDFF1B_Z_P_BR_U32 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1B_Z_P_BR_U32 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1B_Z_P_BR_U32 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1B_Z_P_BR_U32 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1B_Z_P_BR_U32 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1B_Z_P_BR_U64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:64703.24-64703.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1B_Z_P_BR_U64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDFF1B_Z_P_BR_U64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1B_Z_P_BR_U64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1B_Z_P_BR_U64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1B_Z_P_BR_U64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1B_Z_P_BR_U64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SW_Z_P_BR_S64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:64814.24-64814.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SW_Z_P_BR_S64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDFF1SW_Z_P_BR_S64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1SW_Z_P_BR_S64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1SW_Z_P_BR_S64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1SW_Z_P_BR_S64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1SW_Z_P_BR_S64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_BR_U16 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:64925.24-64925.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_BR_U16 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 16
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDFF1H_Z_P_BR_U16 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_BR_U16 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_BR_U16 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_BR_U16 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_BR_U16 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_BR_U32 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:65036.24-65036.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_BR_U32 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDFF1H_Z_P_BR_U32 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_BR_U32 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_BR_U32 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_BR_U32 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_BR_U32 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_BR_U64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:65147.24-65147.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_BR_U64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDFF1H_Z_P_BR_U64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_BR_U64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_BR_U64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_BR_U64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_BR_U64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SH_Z_P_BR_S64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:65258.24-65258.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SH_Z_P_BR_S64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDFF1SH_Z_P_BR_S64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1SH_Z_P_BR_S64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1SH_Z_P_BR_S64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1SH_Z_P_BR_S64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1SH_Z_P_BR_S64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1SH_Z_P_BR_S32 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:65369.24-65369.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SH_Z_P_BR_S32 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDFF1SH_Z_P_BR_S32 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1SH_Z_P_BR_S32 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1SH_Z_P_BR_S32 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1SH_Z_P_BR_S32 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1SH_Z_P_BR_S32 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1W_Z_P_BR_U32 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:65480.24-65480.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1W_Z_P_BR_U32 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDFF1W_Z_P_BR_U32 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1W_Z_P_BR_U32 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1W_Z_P_BR_U32 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1W_Z_P_BR_U32 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1W_Z_P_BR_U32 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1W_Z_P_BR_U64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:65591.24-65591.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1W_Z_P_BR_U64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDFF1W_Z_P_BR_U64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1W_Z_P_BR_U64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1W_Z_P_BR_U64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1W_Z_P_BR_U64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1W_Z_P_BR_U64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SB_Z_P_BR_S64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:65702.24-65702.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SB_Z_P_BR_S64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDFF1SB_Z_P_BR_S64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1SB_Z_P_BR_S64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1SB_Z_P_BR_S64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1SB_Z_P_BR_S64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1SB_Z_P_BR_S64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDFF1SB_Z_P_BR_S32 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:65813.24-65813.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SB_Z_P_BR_S32 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDFF1SB_Z_P_BR_S32 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1SB_Z_P_BR_S32 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1SB_Z_P_BR_S32 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1SB_Z_P_BR_S32 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1SB_Z_P_BR_S32 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDFF1SB_Z_P_BR_S16 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:65924.24-65924.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SB_Z_P_BR_S16 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 8
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDFF1SB_Z_P_BR_S16 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1SB_Z_P_BR_S16 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1SB_Z_P_BR_S16 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1SB_Z_P_BR_S16 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1SB_Z_P_BR_S16 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1D_Z_P_BR_U64 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  assert accdesc.first "src/instrs64_sve.sail:66035.24-66035.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr : (BitVec 64) :=
                (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1D_Z_P_BR_U64 (dtype : (BitVec 4)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDFF1D_Z_P_BR_U64 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDFF1D_Z_P_BR_U64 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDFF1D_Z_P_BR_U64 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDFF1D_Z_P_BR_U64 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDFF1D_Z_P_BR_U64 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNT1B_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LDNT1B_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  match VL with
  | 128 => (execute_LDNT1B_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LDNT1B_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LDNT1B_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LDNT1B_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LDNT1B_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNT1H_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LDNT1H_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  match VL with
  | 128 => (execute_LDNT1H_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LDNT1H_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LDNT1H_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LDNT1H_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LDNT1H_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LDNT1W_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  match VL with
  | 128 => (execute_LDNT1W_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LDNT1W_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LDNT1W_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LDNT1W_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LDNT1W_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LDNT1D_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  match VL with
  | 128 => (execute_LDNT1D_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LDNT1D_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LDNT1D_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LDNT1D_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LDNT1D_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD2B_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD2B_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let nreg := 2
  match VL with
  | 128 => (execute_LD2B_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD2B_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD2B_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD2B_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD2B_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD2H_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD2H_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let nreg := 2
  match VL with
  | 128 => (execute_LD2H_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD2H_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD2H_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD2H_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD2H_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD2W_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD2W_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let nreg := 2
  match VL with
  | 128 => (execute_LD2W_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD2W_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD2W_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD2W_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD2W_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD2D_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD2D_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let nreg := 2
  match VL with
  | 128 => (execute_LD2D_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD2D_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD2D_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD2D_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD2D_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD3B_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD3B_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let nreg := 3
  match VL with
  | 128 => (execute_LD3B_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD3B_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD3B_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD3B_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD3B_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD3H_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD3H_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let nreg := 3
  match VL with
  | 128 => (execute_LD3H_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD3H_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD3H_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD3H_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD3H_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD3W_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD3W_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let nreg := 3
  match VL with
  | 128 => (execute_LD3W_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD3W_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD3W_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD3W_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD3W_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD3D_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD3D_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let nreg := 3
  match VL with
  | 128 => (execute_LD3D_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD3D_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD3D_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD3D_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD3D_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD4B_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD4B_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let nreg := 4
  match VL with
  | 128 => (execute_LD4B_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD4B_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD4B_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD4B_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD4B_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD4H_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD4H_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let nreg := 4
  match VL with
  | 128 => (execute_LD4H_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD4H_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD4H_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD4H_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD4H_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD4W_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD4W_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let nreg := 4
  match VL with
  | 128 => (execute_LD4W_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD4W_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD4W_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD4W_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD4W_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD4D_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD4D_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let nreg := 4
  match VL with
  | 128 => (execute_LD4D_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD4D_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD4D_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD4D_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD4D_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD2Q_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD2Q_Z_P_BR_Contiguous (num : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let nreg := 2
  match VL with
  | 128 => (execute_LD2Q_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD2Q_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD2Q_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD2Q_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD2Q_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD3Q_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD3Q_Z_P_BR_Contiguous (num : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let nreg := 3
  match VL with
  | 128 => (execute_LD3Q_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD3Q_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD3Q_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD3Q_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD3Q_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD4Q_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD4Q_Z_P_BR_Contiguous (num : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let nreg := 4
  match VL with
  | 128 => (execute_LD4Q_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_LD4Q_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_LD4Q_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_LD4Q_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_LD4Q_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1RQB_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv 128 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((BitVec.toNat offset) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (Z_set t VL (BitVec.replicateBits result (Int.ediv VL 128)))

def decode_LD1RQB_Z_P_BR_Contiguous (msz : (BitVec 2)) (ssz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  match VL with
  | 128 => (execute_LD1RQB_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LD1RQB_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LD1RQB_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LD1RQB_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LD1RQB_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1RQH_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv 128 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((BitVec.toNat offset) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (Z_set t VL (BitVec.replicateBits result (Int.ediv VL 128)))

def decode_LD1RQH_Z_P_BR_Contiguous (msz : (BitVec 2)) (ssz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  match VL with
  | 128 => (execute_LD1RQH_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LD1RQH_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LD1RQH_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LD1RQH_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LD1RQH_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1RQW_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv 128 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((BitVec.toNat offset) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (Z_set t VL (BitVec.replicateBits result (Int.ediv VL 128)))

def decode_LD1RQW_Z_P_BR_Contiguous (msz : (BitVec 2)) (ssz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  match VL with
  | 128 => (execute_LD1RQW_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LD1RQW_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LD1RQW_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LD1RQW_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LD1RQW_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1RQD_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv 128 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((BitVec.toNat offset) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (Z_set t VL (BitVec.replicateBits result (Int.ediv VL 128)))

def decode_LD1RQD_Z_P_BR_Contiguous (msz : (BitVec 2)) (ssz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  match VL with
  | 128 => (execute_LD1RQD_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LD1RQD_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LD1RQD_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LD1RQD_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LD1RQD_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1ROB_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  bif (VL <b 256)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (Int.ediv 256 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 256) ) : SailM (BitVec 256) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((BitVec.toNat offset) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 256) )
  (Z_set t VL (Sail.BitVec.zeroExtend (BitVec.replicateBits result (Int.ediv VL 256)) VL))

def decode_LD1ROB_Z_P_BR_Contiguous (msz : (BitVec 2)) (ssz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  match VL with
  | 128 => (execute_LD1ROB_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LD1ROB_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LD1ROB_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LD1ROB_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LD1ROB_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1ROH_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  bif (VL <b 256)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (Int.ediv 256 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 256) ) : SailM (BitVec 256) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((BitVec.toNat offset) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 256) )
  (Z_set t VL (Sail.BitVec.zeroExtend (BitVec.replicateBits result (Int.ediv VL 256)) VL))

def decode_LD1ROH_Z_P_BR_Contiguous (msz : (BitVec 2)) (ssz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  match VL with
  | 128 => (execute_LD1ROH_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LD1ROH_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LD1ROH_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LD1ROH_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LD1ROH_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1ROW_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  bif (VL <b 256)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (Int.ediv 256 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 256) ) : SailM (BitVec 256) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((BitVec.toNat offset) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 256) )
  (Z_set t VL (Sail.BitVec.zeroExtend (BitVec.replicateBits result (Int.ediv VL 256)) VL))

def decode_LD1ROW_Z_P_BR_Contiguous (msz : (BitVec 2)) (ssz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  match VL with
  | 128 => (execute_LD1ROW_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LD1ROW_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LD1ROW_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LD1ROW_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LD1ROW_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1ROD_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  bif (VL <b 256)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (Int.ediv 256 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 256) ) : SailM (BitVec 256) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((BitVec.toNat offset) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 256) )
  (Z_set t VL (Sail.BitVec.zeroExtend (BitVec.replicateBits result (Int.ediv VL 256)) VL))

def decode_LD1ROD_Z_P_BR_Contiguous (msz : (BitVec 2)) (ssz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  match VL with
  | 128 => (execute_LD1ROD_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_LD1ROD_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_LD1ROD_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_LD1ROD_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_LD1ROD_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BI_U8 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BI_U8 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1B_Z_P_BI_U8 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1B_Z_P_BI_U8 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1B_Z_P_BI_U8 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BI_U8 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BI_U8 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BI_U16 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BI_U16 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1B_Z_P_BI_U16 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1B_Z_P_BI_U16 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1B_Z_P_BI_U16 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BI_U16 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BI_U16 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BI_U32 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1B_Z_P_BI_U32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1B_Z_P_BI_U32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1B_Z_P_BI_U32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BI_U32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BI_U32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BI_U64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1B_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1B_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1B_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SW_Z_P_BI_S64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SW_Z_P_BI_S64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1SW_Z_P_BI_S64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SW_Z_P_BI_S64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SW_Z_P_BI_S64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SW_Z_P_BI_S64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SW_Z_P_BI_S64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BI_U16 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BI_U16 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1H_Z_P_BI_U16 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1H_Z_P_BI_U16 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1H_Z_P_BI_U16 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BI_U16 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BI_U16 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BI_U32 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1H_Z_P_BI_U32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1H_Z_P_BI_U32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1H_Z_P_BI_U32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BI_U32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BI_U32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BI_U64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1H_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1H_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1H_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_BI_S64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_BI_S64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1SH_Z_P_BI_S64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SH_Z_P_BI_S64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SH_Z_P_BI_S64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_BI_S64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_BI_S64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_BI_S32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_BI_S32 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1SH_Z_P_BI_S32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SH_Z_P_BI_S32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SH_Z_P_BI_S32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_BI_S32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_BI_S32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BI_U32 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1W_Z_P_BI_U32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1W_Z_P_BI_U32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1W_Z_P_BI_U32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BI_U32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BI_U32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BI_U64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1W_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1W_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1W_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_BI_S64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_BI_S64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1SB_Z_P_BI_S64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SB_Z_P_BI_S64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SB_Z_P_BI_S64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_BI_S64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_BI_S64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_BI_S32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_BI_S32 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1SB_Z_P_BI_S32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SB_Z_P_BI_S32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SB_Z_P_BI_S32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_BI_S32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_BI_S32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_BI_S16 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_BI_S16 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1SB_Z_P_BI_S16 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SB_Z_P_BI_S16 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SB_Z_P_BI_S16 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_BI_S16 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_BI_S16 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 64 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1D_Z_P_BI_U64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1D_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1D_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1D_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1D_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1D_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNF1B_Z_P_BI_U8 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1B_Z_P_BI_U8 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1B_Z_P_BI_U8 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1B_Z_P_BI_U8 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1B_Z_P_BI_U8 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1B_Z_P_BI_U8 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1B_Z_P_BI_U8 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNF1B_Z_P_BI_U16 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1B_Z_P_BI_U16 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1B_Z_P_BI_U16 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1B_Z_P_BI_U16 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1B_Z_P_BI_U16 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1B_Z_P_BI_U16 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1B_Z_P_BI_U16 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNF1B_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1B_Z_P_BI_U32 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1B_Z_P_BI_U32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1B_Z_P_BI_U32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1B_Z_P_BI_U32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1B_Z_P_BI_U32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1B_Z_P_BI_U32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNF1B_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1B_Z_P_BI_U64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1B_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1B_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1B_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1B_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1B_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNF1SW_Z_P_BI_S64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1SW_Z_P_BI_S64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1SW_Z_P_BI_S64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1SW_Z_P_BI_S64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1SW_Z_P_BI_S64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1SW_Z_P_BI_S64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1SW_Z_P_BI_S64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNF1H_Z_P_BI_U16 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1H_Z_P_BI_U16 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1H_Z_P_BI_U16 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1H_Z_P_BI_U16 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1H_Z_P_BI_U16 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1H_Z_P_BI_U16 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1H_Z_P_BI_U16 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNF1H_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1H_Z_P_BI_U32 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1H_Z_P_BI_U32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1H_Z_P_BI_U32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1H_Z_P_BI_U32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1H_Z_P_BI_U32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1H_Z_P_BI_U32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNF1H_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1H_Z_P_BI_U64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1H_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1H_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1H_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1H_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1H_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNF1SH_Z_P_BI_S64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1SH_Z_P_BI_S64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1SH_Z_P_BI_S64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1SH_Z_P_BI_S64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1SH_Z_P_BI_S64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1SH_Z_P_BI_S64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1SH_Z_P_BI_S64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNF1SH_Z_P_BI_S32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1SH_Z_P_BI_S32 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1SH_Z_P_BI_S32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1SH_Z_P_BI_S32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1SH_Z_P_BI_S32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1SH_Z_P_BI_S32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1SH_Z_P_BI_S32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNF1W_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1W_Z_P_BI_U32 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1W_Z_P_BI_U32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1W_Z_P_BI_U32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1W_Z_P_BI_U32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1W_Z_P_BI_U32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1W_Z_P_BI_U32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNF1W_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1W_Z_P_BI_U64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1W_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1W_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1W_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1W_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1W_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNF1SB_Z_P_BI_S64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1SB_Z_P_BI_S64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1SB_Z_P_BI_S64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1SB_Z_P_BI_S64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1SB_Z_P_BI_S64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1SB_Z_P_BI_S64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1SB_Z_P_BI_S64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNF1SB_Z_P_BI_S32 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1SB_Z_P_BI_S32 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1SB_Z_P_BI_S32 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1SB_Z_P_BI_S32 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1SB_Z_P_BI_S32 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1SB_Z_P_BI_S32 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1SB_Z_P_BI_S32 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNF1SB_Z_P_BI_S16 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1SB_Z_P_BI_S16 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1SB_Z_P_BI_S16 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1SB_Z_P_BI_S16 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1SB_Z_P_BI_S16 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1SB_Z_P_BI_S16 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1SB_Z_P_BI_S16 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 64 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNF1D_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVENF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
              let data : (BitVec msize) := tup__0
              let fault : Bool := tup__1
              (pure (data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (data, fault))) ) : SailM ((BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM ((BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDNF1D_Z_P_BI_U64 (dtype : (BitVec 4)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNF1D_Z_P_BI_U64 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDNF1D_Z_P_BI_U64 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDNF1D_Z_P_BI_U64 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDNF1D_Z_P_BI_U64 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDNF1D_Z_P_BI_U64 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BI_U128 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BI_U128 (dtype : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1W_Z_P_BI_U128 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1W_Z_P_BI_U128 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1W_Z_P_BI_U128 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BI_U128 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BI_U128 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 64 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD1D_Z_P_BI_U128 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((offset *i elements) +i e)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1D_Z_P_BI_U128 (dtype : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let msize := 64
  let is_unsigned : Bool := true
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1D_Z_P_BI_U128 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1D_Z_P_BI_U128 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1D_Z_P_BI_U128 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1D_Z_P_BI_U128 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1D_Z_P_BI_U128 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNT1B_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((offset *i elements) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LDNT1B_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1B_Z_P_BI_Contiguous 128 esize g n offset t)
  | 256 => (execute_LDNT1B_Z_P_BI_Contiguous 256 esize g n offset t)
  | 512 => (execute_LDNT1B_Z_P_BI_Contiguous 512 esize g n offset t)
  | 1024 => (execute_LDNT1B_Z_P_BI_Contiguous 1024 esize g n offset t)
  | 2048 => (execute_LDNT1B_Z_P_BI_Contiguous 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNT1H_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((offset *i elements) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LDNT1H_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1H_Z_P_BI_Contiguous 128 esize g n offset t)
  | 256 => (execute_LDNT1H_Z_P_BI_Contiguous 256 esize g n offset t)
  | 512 => (execute_LDNT1H_Z_P_BI_Contiguous 512 esize g n offset t)
  | 1024 => (execute_LDNT1H_Z_P_BI_Contiguous 1024 esize g n offset t)
  | 2048 => (execute_LDNT1H_Z_P_BI_Contiguous 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((offset *i elements) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LDNT1W_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1W_Z_P_BI_Contiguous 128 esize g n offset t)
  | 256 => (execute_LDNT1W_Z_P_BI_Contiguous 256 esize g n offset t)
  | 512 => (execute_LDNT1W_Z_P_BI_Contiguous 512 esize g n offset t)
  | 1024 => (execute_LDNT1W_Z_P_BI_Contiguous 1024 esize g n offset t)
  | 2048 => (execute_LDNT1W_Z_P_BI_Contiguous 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((offset *i elements) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LDNT1D_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1D_Z_P_BI_Contiguous 128 esize g n offset t)
  | 256 => (execute_LDNT1D_Z_P_BI_Contiguous 256 esize g n offset t)
  | 512 => (execute_LDNT1D_Z_P_BI_Contiguous 512 esize g n offset t)
  | 1024 => (execute_LDNT1D_Z_P_BI_Contiguous 1024 esize g n offset t)
  | 2048 => (execute_LDNT1D_Z_P_BI_Contiguous 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD2B_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD2B_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let offset := (BitVec.toInt imm4)
  let nreg := 2
  match VL with
  | 128 => (execute_LD2B_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD2B_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD2B_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD2B_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD2B_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD2H_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD2H_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let offset := (BitVec.toInt imm4)
  let nreg := 2
  match VL with
  | 128 => (execute_LD2H_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD2H_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD2H_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD2H_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD2H_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD2W_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD2W_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let offset := (BitVec.toInt imm4)
  let nreg := 2
  match VL with
  | 128 => (execute_LD2W_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD2W_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD2W_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD2W_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD2W_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD2D_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD2D_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let offset := (BitVec.toInt imm4)
  let nreg := 2
  match VL with
  | 128 => (execute_LD2D_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD2D_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD2D_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD2D_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD2D_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 3 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD3B_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD3B_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let offset := (BitVec.toInt imm4)
  let nreg := 3
  match VL with
  | 128 => (execute_LD3B_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD3B_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD3B_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD3B_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD3B_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 3 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD3H_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD3H_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let offset := (BitVec.toInt imm4)
  let nreg := 3
  match VL with
  | 128 => (execute_LD3H_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD3H_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD3H_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD3H_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD3H_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 3 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD3W_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD3W_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let offset := (BitVec.toInt imm4)
  let nreg := 3
  match VL with
  | 128 => (execute_LD3W_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD3W_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD3W_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD3W_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD3W_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 3 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD3D_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD3D_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let offset := (BitVec.toInt imm4)
  let nreg := 3
  match VL with
  | 128 => (execute_LD3D_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD3D_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD3D_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD3D_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD3D_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD4B_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD4B_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let offset := (BitVec.toInt imm4)
  let nreg := 4
  match VL with
  | 128 => (execute_LD4B_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD4B_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD4B_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD4B_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD4B_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD4H_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD4H_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let offset := (BitVec.toInt imm4)
  let nreg := 4
  match VL with
  | 128 => (execute_LD4H_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD4H_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD4H_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD4H_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD4H_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD4W_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD4W_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let offset := (BitVec.toInt imm4)
  let nreg := 4
  match VL with
  | 128 => (execute_LD4W_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD4W_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD4W_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD4W_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD4W_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD4D_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD4D_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let offset := (BitVec.toInt imm4)
  let nreg := 4
  match VL with
  | 128 => (execute_LD4D_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD4D_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD4D_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD4D_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD4D_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD2Q_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD2Q_Z_P_BI_Contiguous (num : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let offset := (BitVec.toInt imm4)
  let nreg := 2
  match VL with
  | 128 => (execute_LD2Q_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD2Q_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD2Q_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD2Q_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD2Q_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 3 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD3Q_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD3Q_Z_P_BI_Contiguous (num : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let offset := (BitVec.toInt imm4)
  let nreg := 3
  match VL with
  | 128 => (execute_LD3Q_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD3Q_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD3Q_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD3Q_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD3Q_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_LD4Q_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := values_name
    for e in [loop_e_lower:loop_e_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_r_lower := 0
        let loop_r_upper := (nreg -i 1)
        let mut loop_vars_1 := values_name
        for r in [loop_r_lower:loop_r_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask e esize))
            then
              (do
                let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
                let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (Nat.div (t +i r) 32) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD4Q_Z_P_BI_Contiguous (num : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let offset := (BitVec.toInt imm4)
  let nreg := 4
  match VL with
  | 128 => (execute_LD4Q_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_LD4Q_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_LD4Q_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_LD4Q_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_LD4Q_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1RQB_Z_P_BI_U8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv 128 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let addr : (BitVec 64) :=
              (BitVec.addInt (BitVec.addInt base (offset *i 16)) (e *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (Z_set t VL (BitVec.replicateBits result (Int.ediv VL 128)))

def decode_LD1RQB_Z_P_BI_U8 (msz : (BitVec 2)) (ssz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1RQB_Z_P_BI_U8 128 esize g n offset t)
  | 256 => (execute_LD1RQB_Z_P_BI_U8 256 esize g n offset t)
  | 512 => (execute_LD1RQB_Z_P_BI_U8 512 esize g n offset t)
  | 1024 => (execute_LD1RQB_Z_P_BI_U8 1024 esize g n offset t)
  | 2048 => (execute_LD1RQB_Z_P_BI_U8 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1RQH_Z_P_BI_U16 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv 128 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let addr : (BitVec 64) :=
              (BitVec.addInt (BitVec.addInt base (offset *i 16)) (e *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (Z_set t VL (BitVec.replicateBits result (Int.ediv VL 128)))

def decode_LD1RQH_Z_P_BI_U16 (msz : (BitVec 2)) (ssz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1RQH_Z_P_BI_U16 128 esize g n offset t)
  | 256 => (execute_LD1RQH_Z_P_BI_U16 256 esize g n offset t)
  | 512 => (execute_LD1RQH_Z_P_BI_U16 512 esize g n offset t)
  | 1024 => (execute_LD1RQH_Z_P_BI_U16 1024 esize g n offset t)
  | 2048 => (execute_LD1RQH_Z_P_BI_U16 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1RQW_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv 128 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let addr : (BitVec 64) :=
              (BitVec.addInt (BitVec.addInt base (offset *i 16)) (e *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (Z_set t VL (BitVec.replicateBits result (Int.ediv VL 128)))

def decode_LD1RQW_Z_P_BI_U32 (msz : (BitVec 2)) (ssz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1RQW_Z_P_BI_U32 128 esize g n offset t)
  | 256 => (execute_LD1RQW_Z_P_BI_U32 256 esize g n offset t)
  | 512 => (execute_LD1RQW_Z_P_BI_U32 512 esize g n offset t)
  | 1024 => (execute_LD1RQW_Z_P_BI_U32 1024 esize g n offset t)
  | 2048 => (execute_LD1RQW_Z_P_BI_U32 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1RQD_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv 128 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let addr : (BitVec 64) :=
              (BitVec.addInt (BitVec.addInt base (offset *i 16)) (e *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (Z_set t VL (BitVec.replicateBits result (Int.ediv VL 128)))

def decode_LD1RQD_Z_P_BI_U64 (msz : (BitVec 2)) (ssz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1RQD_Z_P_BI_U64 128 esize g n offset t)
  | 256 => (execute_LD1RQD_Z_P_BI_U64 256 esize g n offset t)
  | 512 => (execute_LD1RQD_Z_P_BI_U64 512 esize g n offset t)
  | 1024 => (execute_LD1RQD_Z_P_BI_U64 1024 esize g n offset t)
  | 2048 => (execute_LD1RQD_Z_P_BI_U64 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1ROB_Z_P_BI_U8 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  bif (VL <b 256)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (Int.ediv 256 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector 256) ) : SailM (BitVec 256) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((offset *i elements) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 256) )
  (Z_set t VL (Sail.BitVec.zeroExtend (BitVec.replicateBits result (Int.ediv VL 256)) VL))

def decode_LD1ROB_Z_P_BI_U8 (msz : (BitVec 2)) (ssz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1ROB_Z_P_BI_U8 128 esize g n offset t)
  | 256 => (execute_LD1ROB_Z_P_BI_U8 256 esize g n offset t)
  | 512 => (execute_LD1ROB_Z_P_BI_U8 512 esize g n offset t)
  | 1024 => (execute_LD1ROB_Z_P_BI_U8 1024 esize g n offset t)
  | 2048 => (execute_LD1ROB_Z_P_BI_U8 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1ROH_Z_P_BI_U16 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  bif (VL <b 256)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (Int.ediv 256 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector 256) ) : SailM (BitVec 256) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((offset *i elements) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 256) )
  (Z_set t VL (Sail.BitVec.zeroExtend (BitVec.replicateBits result (Int.ediv VL 256)) VL))

def decode_LD1ROH_Z_P_BI_U16 (msz : (BitVec 2)) (ssz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1ROH_Z_P_BI_U16 128 esize g n offset t)
  | 256 => (execute_LD1ROH_Z_P_BI_U16 256 esize g n offset t)
  | 512 => (execute_LD1ROH_Z_P_BI_U16 512 esize g n offset t)
  | 1024 => (execute_LD1ROH_Z_P_BI_U16 1024 esize g n offset t)
  | 2048 => (execute_LD1ROH_Z_P_BI_U16 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1ROW_Z_P_BI_U32 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  bif (VL <b 256)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (Int.ediv 256 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector 256) ) : SailM (BitVec 256) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((offset *i elements) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 256) )
  (Z_set t VL (Sail.BitVec.zeroExtend (BitVec.replicateBits result (Int.ediv VL 256)) VL))

def decode_LD1ROW_Z_P_BI_U32 (msz : (BitVec 2)) (ssz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1ROW_Z_P_BI_U32 128 esize g n offset t)
  | 256 => (execute_LD1ROW_Z_P_BI_U32 256 esize g n offset t)
  | 512 => (execute_LD1ROW_Z_P_BI_U32 512 esize g n offset t)
  | 1024 => (execute_LD1ROW_Z_P_BI_U32 1024 esize g n offset t)
  | 2048 => (execute_LD1ROW_Z_P_BI_U32 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1ROD_Z_P_BI_U64 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  bif (VL <b 256)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (Int.ediv 256 esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let result ← (( do (undefined_bitvector 256) ) : SailM (BitVec 256) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e esize))
        then
          (do
            let eoff := ((offset *i elements) +i e)
            let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
            (Elem_set result e esize (← (Mem_read addr mbytes accdesc))))
        else
          (do
            (Elem_set result e esize (Zeros (n := esize))))
    (pure loop_vars) ) : SailM (BitVec 256) )
  (Z_set t VL (Sail.BitVec.zeroExtend (BitVec.replicateBits result (Int.ediv VL 256)) VL))

def decode_LD1ROD_Z_P_BI_U64 (msz : (BitVec 2)) (ssz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.or (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSVEFP64MatMulExt ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1ROD_Z_P_BI_U64 128 esize g n offset t)
  | 256 => (execute_LD1ROD_Z_P_BI_U64 256 esize g n offset t)
  | 512 => (execute_LD1ROD_Z_P_BI_U64 512 esize g n offset t)
  | 1024 => (execute_LD1ROD_Z_P_BI_U64 1024 esize g n offset t)
  | 2048 => (execute_LD1ROD_Z_P_BI_U64 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1B_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1B_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1B_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1SB_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LD1SB_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LD1SB_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1B_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:74311.24-74311.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1B_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1B_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1B_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1B_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1B_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1B_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SB_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:74429.24-74429.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SB_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1SB_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 256 => (execute_LDFF1SB_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 512 => (execute_LDFF1SB_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 1024 => (execute_LDFF1SB_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SB_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1H_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1H_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1H_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1SH_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LD1SH_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LD1SH_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:74735.24-74735.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1H_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SH_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:74853.24-74853.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SH_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1SH_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 256 => (execute_LDFF1SH_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 512 => (execute_LDFF1SH_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 1024 => (execute_LDFF1SH_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SH_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1W_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1W_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1W_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SW_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SW_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1SW_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LD1SW_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LD1SW_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LD1SW_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LD1SW_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1W_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:75159.24-75159.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1W_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1W_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1W_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1W_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1W_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1W_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SW_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:75277.24-75277.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SW_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1SW_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 256 => (execute_LDFF1SW_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 512 => (execute_LDFF1SW_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 1024 => (execute_LDFF1SW_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SW_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1D_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LD1D_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1D_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1D_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1D_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1D_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1D_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:75489.24-75489.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1D_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1D_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1D_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1D_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1D_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1D_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFB_I_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFB_I_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_PRFB_I_P_BZ_D_x32_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFB_I_P_BZ_D_x32_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFB_I_P_BZ_D_x32_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFB_I_P_BZ_D_x32_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFB_I_P_BZ_D_x32_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFH_I_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFH_I_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_PRFH_I_P_BZ_D_x32_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFH_I_P_BZ_D_x32_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFH_I_P_BZ_D_x32_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFH_I_P_BZ_D_x32_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFH_I_P_BZ_D_x32_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 2 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFW_I_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFW_I_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 2
  match VL with
  | 128 => (execute_PRFW_I_P_BZ_D_x32_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFW_I_P_BZ_D_x32_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFW_I_P_BZ_D_x32_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFW_I_P_BZ_D_x32_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFW_I_P_BZ_D_x32_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 3 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFD_I_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFD_I_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 3
  match VL with
  | 128 => (execute_PRFD_I_P_BZ_D_x32_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFD_I_P_BZ_D_x32_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFD_I_P_BZ_D_x32_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFD_I_P_BZ_D_x32_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFD_I_P_BZ_D_x32_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_LD1H_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1H_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1H_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_LD1SH_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1SH_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1SH_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:76101.24-76101.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_LDFF1H_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SH_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:76218.24-76218.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SH_Z_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_LDFF1SH_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1SH_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1SH_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1SH_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SH_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 2
  match VL with
  | 128 => (execute_LD1W_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1W_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1W_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SW_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SW_Z_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 2
  match VL with
  | 128 => (execute_LD1SW_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1SW_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1SW_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1SW_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1SW_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1W_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:76521.24-76521.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1W_Z_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 2
  match VL with
  | 128 => (execute_LDFF1W_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LDFF1W_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LDFF1W_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LDFF1W_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LDFF1W_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SW_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:76638.24-76638.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SW_Z_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 32
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 2
  match VL with
  | 128 => (execute_LDFF1SW_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1SW_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1SW_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1SW_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SW_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 3 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1D_Z_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 3
  match VL with
  | 128 => (execute_LD1D_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1D_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1D_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1D_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 2048 => (execute_LD1D_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 3 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1D_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:76848.24-76848.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1D_Z_P_BZ_D_x32_scaled (xs : (BitVec 1)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 32
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 3
  match VL with
  | 128 => (execute_LDFF1D_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LDFF1D_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LDFF1D_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LDFF1D_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LDFF1D_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Nat, scale :
  Nat, k_stream : Bool, scale = 0 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFB_I_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (Int.shiftl offset scale))) ) : SailM (BitVec 64) )
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFB_I_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 0
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_PRFB_I_P_AI_D 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFB_I_P_AI_D 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFB_I_P_AI_D 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFB_I_P_AI_D 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFB_I_P_AI_D 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Nat, scale :
  Nat, k_stream : Bool, scale = 1 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFH_I_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (Int.shiftl offset scale))) ) : SailM (BitVec 64) )
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFH_I_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 1
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_PRFH_I_P_AI_D 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFH_I_P_AI_D 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFH_I_P_AI_D 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFH_I_P_AI_D 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFH_I_P_AI_D 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Nat, scale :
  Nat, k_stream : Bool, scale = 2 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFW_I_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (Int.shiftl offset scale))) ) : SailM (BitVec 64) )
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFW_I_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 2
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_PRFW_I_P_AI_D 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFW_I_P_AI_D 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFW_I_P_AI_D 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFW_I_P_AI_D 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFW_I_P_AI_D 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, n : Nat, offset : Nat, scale :
  Nat, k_stream : Bool, scale = 3 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFD_I_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (n : Nat) (offset : Nat) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (Int.shiftl offset scale))) ) : SailM (BitVec 64) )
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFD_I_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Zn)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let scale := 3
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_PRFD_I_P_AI_D 128 esize g level n offset pref_hint scale stream)
  | 256 => (execute_PRFD_I_P_AI_D 256 esize g level n offset pref_hint scale stream)
  | 512 => (execute_PRFD_I_P_AI_D 512 esize g level n offset pref_hint scale stream)
  | 1024 => (execute_PRFD_I_P_AI_D 1024 esize g level n offset pref_hint scale stream)
  | 2048 => (execute_PRFD_I_P_AI_D 2048 esize g level n offset pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1B_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1B_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1B_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1B_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1SB_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SB_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SB_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1B_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:77396.24-77396.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1B_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1B_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1B_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1B_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1B_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1B_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SB_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:77500.24-77500.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SB_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1SB_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1SB_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1SB_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1SB_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1SB_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1H_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1H_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1H_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1H_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1SH_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SH_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SH_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:77764.24-77764.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1H_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SH_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:77868.24-77868.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SH_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1SH_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1SH_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1SH_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1SH_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1SH_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1W_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1W_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1W_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1W_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SW_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SW_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1SW_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1SW_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1SW_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1SW_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1SW_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1W_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:78132.24-78132.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1W_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1W_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1W_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1W_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1W_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1W_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SW_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:78236.24-78236.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SW_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := false
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1SW_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1SW_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1SW_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1SW_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1SW_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 64 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1D_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LD1D_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LD1D_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LD1D_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LD1D_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LD1D_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, msize : Nat, n : Nat, offset
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 64 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1D_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let base ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        (Z_read n VL))
    else (pure base) ) : SailM (BitVec VL) )
  let base := base
  assert accdesc.first "src/instrs64_sve.sail:78420.24-78420.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                    (offset *i mbytes))) ) : SailM (BitVec 64) )
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1D_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let is_unsigned : Bool := true
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_LDFF1D_Z_P_AI_D 128 esize g msize n offset t is_unsigned)
  | 256 => (execute_LDFF1D_Z_P_AI_D 256 esize g msize n offset t is_unsigned)
  | 512 => (execute_LDFF1D_Z_P_AI_D 512 esize g msize n offset t is_unsigned)
  | 1024 => (execute_LDFF1D_Z_P_AI_D 1024 esize g msize n offset t is_unsigned)
  | 2048 => (execute_LDFF1D_Z_P_AI_D 2048 esize g msize n offset t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1B_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1B_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LD1B_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1B_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1B_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1B_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1B_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SB_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SB_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offs_size := 64
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LD1SB_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1SB_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1SB_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1SB_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1SB_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1B_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:78719.24-78719.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1B_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1B_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1B_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1B_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1B_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1B_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SB_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:78836.24-78836.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SB_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offs_size := 64
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1SB_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1SB_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1SB_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1SB_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SB_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LD1H_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1H_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1H_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 64
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LD1SH_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1SH_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1SH_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:79139.24-79139.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1H_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SH_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:79256.24-79256.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SH_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 64
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1SH_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1SH_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1SH_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1SH_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SH_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LD1W_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1W_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1W_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SW_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SW_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 64
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LD1SW_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1SW_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1SW_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1SW_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1SW_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1W_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:79559.24-79559.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1W_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1W_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1W_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1W_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1W_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1W_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SW_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:79676.24-79676.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SW_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 64
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1SW_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1SW_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1SW_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1SW_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1SW_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1D_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LD1D_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1D_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1D_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1D_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LD1D_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1D_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:79886.24-79886.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1D_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_LDFF1D_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 256 => (execute_LDFF1D_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 512 => (execute_LDFF1D_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 1024 => (execute_LDFF1D_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | 2048 => (execute_LDFF1D_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned
      scale t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFB_I_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFB_I_P_BZ_D_64_scaled (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_PRFB_I_P_BZ_D_64_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFB_I_P_BZ_D_64_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFB_I_P_BZ_D_64_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFB_I_P_BZ_D_64_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFB_I_P_BZ_D_64_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 1 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFH_I_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFH_I_P_BZ_D_64_scaled (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 1
  match VL with
  | 128 => (execute_PRFH_I_P_BZ_D_64_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFH_I_P_BZ_D_64_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFH_I_P_BZ_D_64_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFH_I_P_BZ_D_64_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFH_I_P_BZ_D_64_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 2 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFW_I_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFW_I_P_BZ_D_64_scaled (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 2
  match VL with
  | 128 => (execute_PRFW_I_P_BZ_D_64_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFW_I_P_BZ_D_64_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFW_I_P_BZ_D_64_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFW_I_P_BZ_D_64_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFW_I_P_BZ_D_64_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, level : Nat, m : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, k_stream : Bool, scale = 3 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  level ∈ {0, 1, 2, 3} ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_PRFD_I_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (level : Nat) (m : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (pref_hint : PrefetchHint) (scale : Nat) (stream : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (pure (Hint_Prefetch addr pref_hint level stream)))
      else (pure ())
  (pure loop_vars)

def decode_PRFD_I_P_BZ_D_64_scaled (Zm : (BitVec 5)) (msz : (BitVec 2)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (prfop : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize := 64
  let g := (BitVec.toNat Pg)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let level := (BitVec.toNat (Sail.BitVec.extractLsb prfop 2 1))
  let stream : Bool := (BEq.beq (BitVec.join1 [(BitVec.access prfop 0)]) (0b1 : (BitVec 1)))
  let pref_hint : PrefetchHint :=
    bif (BEq.beq (BitVec.join1 [(BitVec.access prfop 3)]) (0b0 : (BitVec 1)))
    then Prefetch_READ
    else Prefetch_WRITE
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 3
  match VL with
  | 128 => (execute_PRFD_I_P_BZ_D_64_scaled 128 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 256 => (execute_PRFD_I_P_BZ_D_64_scaled 256 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 512 => (execute_PRFD_I_P_BZ_D_64_scaled 512 esize g level m n offs_size offs_unsigned pref_hint
      scale stream)
  | 1024 => (execute_PRFD_I_P_BZ_D_64_scaled 1024 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | 2048 => (execute_PRFD_I_P_BZ_D_64_scaled 2048 esize g level m n offs_size offs_unsigned
      pref_hint scale stream)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1H_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1H_Z_P_BZ_D_64_scaled (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 1
  match VL with
  | 128 => (execute_LD1H_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1H_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1H_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1H_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 2048 => (execute_LD1H_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SH_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SH_Z_P_BZ_D_64_scaled (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 64
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := true
  let scale := 1
  match VL with
  | 128 => (execute_LD1SH_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1SH_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1SH_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1SH_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 2048 => (execute_LD1SH_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1H_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:80491.24-80491.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1H_Z_P_BZ_D_64_scaled (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 1
  match VL with
  | 128 => (execute_LDFF1H_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LDFF1H_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LDFF1H_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LDFF1H_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LDFF1H_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SH_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:80607.24-80607.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SH_Z_P_BZ_D_64_scaled (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 64
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := true
  let scale := 1
  match VL with
  | 128 => (execute_LDFF1SH_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LDFF1SH_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LDFF1SH_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LDFF1SH_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LDFF1SH_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1W_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1W_Z_P_BZ_D_64_scaled (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 2
  match VL with
  | 128 => (execute_LD1W_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1W_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1W_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1W_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 2048 => (execute_LD1W_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1SW_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1SW_Z_P_BZ_D_64_scaled (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 64
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := true
  let scale := 2
  match VL with
  | 128 => (execute_LD1SW_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1SW_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1SW_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1SW_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 2048 => (execute_LD1SW_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1W_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:80907.24-80907.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1W_Z_P_BZ_D_64_scaled (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 2
  match VL with
  | 128 => (execute_LDFF1W_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LDFF1W_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LDFF1W_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LDFF1W_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LDFF1W_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1SW_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:81023.24-81023.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1SW_Z_P_BZ_D_64_scaled (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 64
  let is_unsigned : Bool := false
  let offs_unsigned : Bool := true
  let scale := 2
  match VL with
  | 128 => (execute_LDFF1SW_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LDFF1SW_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LDFF1SW_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LDFF1SW_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LDFF1SW_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 3 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LD1D_Z_P_BZ_D_64_scaled (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 3
  match VL with
  | 128 => (execute_LD1D_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LD1D_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LD1D_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LD1D_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 2048 => (execute_LD1D_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, offs_size : Nat, k_offs_unsigned : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 3 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDFF1D_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let orig ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let fault : Bool := false
  let faulted : Bool := false
  let unknown : Bool := false
  let contiguous : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVEFF contiguous tagchecked) ) : SailM AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  assert accdesc.first "src/instrs64_sve.sail:81231.24-81231.25"
  let (accdesc, data, fault, faulted, result, unknown) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (accdesc, data, fault, faulted, result, unknown)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (accdesc, data, fault, faulted, result, unknown) := loop_vars
      loop_vars ← do
        let (accdesc, data, fault) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let off ← do
                (asl_Int
                  (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
                  offs_unsigned)
              let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
              let (accdesc, data, fault) ← (( do
                bif accdesc.first
                then
                  (do
                    let data ← (Mem_read addr mbytes accdesc)
                    let accdesc : AccessDescriptor := { accdesc with first := false }
                    (pure (accdesc, data, fault)))
                else
                  (do
                    let (tup__0, tup__1) ← do (MemNF_read addr mbytes accdesc)
                    let data : (BitVec msize) := tup__0
                    let fault : Bool := tup__1
                    (pure (accdesc, data, fault))) ) : SailM
                (AccessDescriptor × (BitVec msize) × Bool) )
              (pure (accdesc, data, fault)))
          else
            (let (tup__0, tup__1) := (((Zeros (n := msize)), false) : ((BitVec msize) × Bool))
            let data : (BitVec msize) := tup__0
            let fault : Bool := tup__1
            (pure (accdesc, data, fault))) ) : SailM (AccessDescriptor × (BitVec msize) × Bool) )
        let faulted : Bool := (Bool.or faulted fault)
        bif faulted
        then (ElemFFR_set e esize (0b0 : (BitVec 1)))
        else (pure ())
        let unknown ←
          (pure (Bool.or unknown (BEq.beq (← (ElemFFR_read e esize)) (0b0 : (BitVec 1)))))
        let result ← (( do
          bif unknown
          then
            (do
              bif (Bool.and (Bool.not fault)
                   (← (ConstrainUnpredictableBool Unpredictable_SVELDNFDATA)))
              then
                (do
                  (Elem_set result e esize (← (Extend data esize is_unsigned))))
              else
                (do
                  bif (← (ConstrainUnpredictableBool Unpredictable_SVELDNFZERO))
                  then
                    (do
                      (Elem_set result e esize (Zeros (n := esize))))
                  else
                    (do
                      (Elem_set result e esize (← (Elem_read orig e esize))))))
          else
            (do
              (Elem_set result e esize (← (Extend data esize is_unsigned)))) ) : SailM (BitVec VL)
          )
        (pure (accdesc, data, fault, faulted, result, unknown))
    (pure loop_vars) ) : SailM
    (AccessDescriptor × (BitVec msize) × Bool × Bool × (BitVec VL) × Bool) )
  (Z_set t VL result)

def decode_LDFF1D_Z_P_BZ_D_64_scaled (Zm : (BitVec 5)) (U : (BitVec 1)) (ff : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 64
  let is_unsigned : Bool := true
  let offs_unsigned : Bool := true
  let scale := 3
  match VL with
  | 128 => (execute_LDFF1D_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 256 => (execute_LDFF1D_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 512 => (execute_LDFF1D_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t
      is_unsigned)
  | 1024 => (execute_LDFF1D_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | 2048 => (execute_LDFF1D_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale
      t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ is_VL(VL) -/
def execute_ST1B_Z_P_BR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1B_Z_P_BR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let msize := 8
  match VL with
  | 128 => (execute_ST1B_Z_P_BR__ 128 esize g m msize n t)
  | 256 => (execute_ST1B_Z_P_BR__ 256 esize g m msize n t)
  | 512 => (execute_ST1B_Z_P_BR__ 512 esize g m msize n t)
  | 1024 => (execute_ST1B_Z_P_BR__ 1024 esize g m msize n t)
  | 2048 => (execute_ST1B_Z_P_BR__ 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ is_VL(VL) -/
def execute_ST1H_Z_P_BR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
          assert (Bool.and (0 ≤b (msize -i 1)) ((msize -i 1) <b esize)) "src/instrs64_sve.sail:81433.70-81433.71"
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1H_Z_P_BR__ (size : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let msize := 16
  match VL with
  | 128 => (execute_ST1H_Z_P_BR__ 128 esize g m msize n t)
  | 256 => (execute_ST1H_Z_P_BR__ 256 esize g m msize n t)
  | 512 => (execute_ST1H_Z_P_BR__ 512 esize g m msize n t)
  | 1024 => (execute_ST1H_Z_P_BR__ 1024 esize g m msize n t)
  | 2048 => (execute_ST1H_Z_P_BR__ 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_ST1W_Z_P_BR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_BR__ (sz : (BitVec 1)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let msize := 32
  match VL with
  | 128 => (execute_ST1W_Z_P_BR__ 128 esize g m msize n t)
  | 256 => (execute_ST1W_Z_P_BR__ 256 esize g m msize n t)
  | 512 => (execute_ST1W_Z_P_BR__ 512 esize g m msize n t)
  | 1024 => (execute_ST1W_Z_P_BR__ 1024 esize g m msize n t)
  | 2048 => (execute_ST1W_Z_P_BR__ 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_Z_P_BR__ (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1D_Z_P_BR__ (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  match VL with
  | 128 => (execute_ST1D_Z_P_BR__ 128 esize g m msize n t)
  | 256 => (execute_ST1D_Z_P_BR__ 256 esize g m msize n t)
  | 512 => (execute_ST1D_Z_P_BR__ 512 esize g m msize n t)
  | 1024 => (execute_ST1D_Z_P_BR__ 1024 esize g m msize n t)
  | 2048 => (execute_ST1D_Z_P_BR__ 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST1W_Z_P_BR_U128 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_BR_U128 (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let msize := 32
  match VL with
  | 128 => (execute_ST1W_Z_P_BR_U128 128 esize g m msize n t)
  | 256 => (execute_ST1W_Z_P_BR_U128 256 esize g m msize n t)
  | 512 => (execute_ST1W_Z_P_BR_U128 512 esize g m msize n t)
  | 1024 => (execute_ST1W_Z_P_BR_U128 1024 esize g m msize n t)
  | 2048 => (execute_ST1W_Z_P_BR_U128 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST1D_Z_P_BR_U128 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1D_Z_P_BR_U128 (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let msize := 64
  match VL with
  | 128 => (execute_ST1D_Z_P_BR_U128 128 esize g m msize n t)
  | 256 => (execute_ST1D_Z_P_BR_U128 256 esize g m msize n t)
  | 512 => (execute_ST1D_Z_P_BR_U128 512 esize g m msize n t)
  | 1024 => (execute_ST1D_Z_P_BR_U128 1024 esize g m msize n t)
  | 2048 => (execute_ST1D_Z_P_BR_U128 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, imm : Int, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 31 ∧ is_VL(VL) -/
def execute_STR_P_BI__ (VL : Nat) (imm : Int) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv PL 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset : Int := (imm *i elements)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (BEq.beq n 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do (P_read t PL) ) : SailM (BitVec PL) )
  let aligned : Bool := (IsAligned__1 (BitVec.addInt base offset) 2)
  bif (Bool.and (Bool.not aligned) (← (AlignmentEnforced ())))
  then (AArch64_Abort (BitVec.addInt base offset) (← (AlignmentFault accdesc)))
  else (pure ())
  let offset ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := offset
    for e in [loop_e_lower:loop_e_upper:1]i do
      let offset := loop_vars
      loop_vars ← do
        let offset := offset
        (AArch64_MemSingle_set (BitVec.addInt base offset) 1 accdesc aligned
          (← (Elem_read src e 8)))
        (pure (offset +i 1))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_STR_P_BI__ (imm9h : (BitVec 6)) (imm9l : (BitVec 3)) (Rn : (BitVec 5)) (Pt : (BitVec 4)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Pt)
  let n := (BitVec.toNat Rn)
  let imm := (BitVec.toInt (imm9h ++ imm9l))
  match VL with
  | 128 => (execute_STR_P_BI__ 128 imm n t)
  | 256 => (execute_STR_P_BI__ 256 imm n t)
  | 512 => (execute_STR_P_BI__ 512 imm n t)
  | 1024 => (execute_STR_P_BI__ 1024 imm n t)
  | 2048 => (execute_STR_P_BI__ 2048 imm n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, imm : Int, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ is_VL(VL) -/
def execute_STR_Z_BI__ (VL : Nat) (imm : Int) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let elements := (Int.ediv VL 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset : Int := (imm *i elements)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (BEq.beq n 31)
    then
      (do
        (CheckSPAlignment ())
        (SP_read ()))
    else
      (do
        (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do (Z_read t VL) ) : SailM (BitVec VL) )
  let aligned : Bool := (IsAligned__1 (BitVec.addInt base offset) 16)
  bif (Bool.and (Bool.not aligned) (← (AlignmentEnforced ())))
  then (AArch64_Abort (BitVec.addInt base offset) (← (AlignmentFault accdesc)))
  else (pure ())
  let offset ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := offset
    for e in [loop_e_lower:loop_e_upper:1]i do
      let offset := loop_vars
      loop_vars ← do
        let offset := offset
        (AArch64_MemSingle_set (BitVec.addInt base offset) 1 accdesc aligned
          (← (Elem_read src e 8)))
        (pure (offset +i 1))
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_STR_Z_BI__ (imm9h : (BitVec 6)) (imm9l : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let imm := (BitVec.toInt (imm9h ++ imm9l))
  match VL with
  | 128 => (execute_STR_Z_BI__ 128 imm n t)
  | 256 => (execute_STR_Z_BI__ 256 imm n t)
  | 512 => (execute_STR_Z_BI__ 512 imm n t)
  | 1024 => (execute_STR_Z_BI__ 1024 imm n t)
  | 2048 => (execute_STR_Z_BI__ 2048 imm n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_STNT1B_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
          (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
      else (pure ())
  (pure loop_vars)

def decode_STNT1B_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  match VL with
  | 128 => (execute_STNT1B_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_STNT1B_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_STNT1B_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_STNT1B_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_STNT1B_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_STNT1H_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
          (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
      else (pure ())
  (pure loop_vars)

def decode_STNT1H_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  match VL with
  | 128 => (execute_STNT1H_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_STNT1H_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_STNT1H_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_STNT1H_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_STNT1H_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
          (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
      else (pure ())
  (pure loop_vars)

def decode_STNT1W_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  match VL with
  | 128 => (execute_STNT1W_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_STNT1W_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_STNT1W_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_STNT1W_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_STNT1W_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr : (BitVec 64) := (BitVec.addInt base (((BitVec.toNat offset) +i e) *i mbytes))
          (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
      else (pure ())
  (pure loop_vars)

def decode_STNT1D_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  match VL with
  | 128 => (execute_STNT1D_Z_P_BR_Contiguous 128 esize g m n t)
  | 256 => (execute_STNT1D_Z_P_BR_Contiguous 256 esize g m n t)
  | 512 => (execute_STNT1D_Z_P_BR_Contiguous 512 esize g m n t)
  | 1024 => (execute_STNT1D_Z_P_BR_Contiguous 1024 esize g m n t)
  | 2048 => (execute_STNT1D_Z_P_BR_Contiguous 2048 esize g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST2B_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST2B_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let nreg := 2
  match VL with
  | 128 => (execute_ST2B_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST2B_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST2B_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST2B_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST2B_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST2H_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST2H_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let nreg := 2
  match VL with
  | 128 => (execute_ST2H_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST2H_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST2H_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST2H_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST2H_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST2W_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST2W_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let nreg := 2
  match VL with
  | 128 => (execute_ST2W_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST2W_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST2W_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST2W_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST2W_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST2D_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST2D_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let nreg := 2
  match VL with
  | 128 => (execute_ST2D_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST2D_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST2D_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST2D_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST2D_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST3B_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST3B_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let nreg := 3
  match VL with
  | 128 => (execute_ST3B_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST3B_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST3B_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST3B_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST3B_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST3H_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST3H_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let nreg := 3
  match VL with
  | 128 => (execute_ST3H_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST3H_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST3H_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST3H_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST3H_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST3W_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST3W_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let nreg := 3
  match VL with
  | 128 => (execute_ST3W_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST3W_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST3W_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST3W_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST3W_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST3D_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST3D_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let nreg := 3
  match VL with
  | 128 => (execute_ST3D_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST3D_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST3D_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST3D_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST3D_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST4B_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST4B_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let nreg := 4
  match VL with
  | 128 => (execute_ST4B_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST4B_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST4B_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST4B_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST4B_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST4H_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST4H_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let nreg := 4
  match VL with
  | 128 => (execute_ST4H_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST4H_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST4H_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST4H_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST4H_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST4W_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST4W_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let nreg := 4
  match VL with
  | 128 => (execute_ST4W_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST4W_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST4W_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST4W_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST4W_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST4D_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST4D_Z_P_BR_Contiguous (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let nreg := 4
  match VL with
  | 128 => (execute_ST4D_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST4D_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST4D_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST4D_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST4D_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST2Q_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST2Q_Z_P_BR_Contiguous (num : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let nreg := 2
  match VL with
  | 128 => (execute_ST2Q_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST2Q_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST2Q_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST2Q_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST2Q_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 3 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST3Q_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST3Q_Z_P_BR_Contiguous (num : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let nreg := 3
  match VL with
  | 128 => (execute_ST3Q_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST3Q_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST3Q_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST3Q_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST3Q_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST4Q_Z_P_BR_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := (((BitVec.toNat offset) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST4Q_Z_P_BR_Contiguous (num : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq Rm (0b11111 : (BitVec 5)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let nreg := 4
  match VL with
  | 128 => (execute_ST4Q_Z_P_BR_Contiguous 128 esize g m n nreg t)
  | 256 => (execute_ST4Q_Z_P_BR_Contiguous 256 esize g m n nreg t)
  | 512 => (execute_ST4Q_Z_P_BR_Contiguous 512 esize g m n nreg t)
  | 1024 => (execute_ST4Q_Z_P_BR_Contiguous 1024 esize g m n nreg t)
  | 2048 => (execute_ST4Q_Z_P_BR_Contiguous 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1B_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1B_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_ST1B_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1B_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1B_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1B_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1B_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1H_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1H_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_ST1H_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1H_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1H_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1H_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1H_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1W_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_ST1W_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1W_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1W_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1W_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1W_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_Z_P_BZ_D_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1D_Z_P_BZ_D_x32_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_ST1D_Z_P_BZ_D_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1D_Z_P_BZ_D_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1D_Z_P_BZ_D_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1D_Z_P_BZ_D_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1D_Z_P_BZ_D_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1B_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1B_Z_P_BZ_S_x32_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_ST1B_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1B_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1B_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1B_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1B_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1H_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1H_Z_P_BZ_S_x32_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_ST1H_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1H_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1H_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1H_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1H_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_Z_P_BZ_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_BZ_S_x32_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 0
  match VL with
  | 128 => (execute_ST1W_Z_P_BZ_S_x32_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1W_Z_P_BZ_S_x32_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1W_Z_P_BZ_S_x32_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1W_Z_P_BZ_S_x32_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1W_Z_P_BZ_S_x32_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1H_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1H_Z_P_BZ_D_x32_scaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_ST1H_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1H_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1H_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1H_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale t)
  | 2048 => (execute_ST1H_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1W_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_BZ_D_x32_scaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 2
  match VL with
  | 128 => (execute_ST1W_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1W_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1W_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1W_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale t)
  | 2048 => (execute_ST1W_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 3 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_Z_P_BZ_D_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1D_Z_P_BZ_D_x32_scaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 3
  match VL with
  | 128 => (execute_ST1D_Z_P_BZ_D_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1D_Z_P_BZ_D_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1D_Z_P_BZ_D_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1D_Z_P_BZ_D_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale t)
  | 2048 => (execute_ST1D_Z_P_BZ_D_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1H_Z_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1H_Z_P_BZ_S_x32_scaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 1
  match VL with
  | 128 => (execute_ST1H_Z_P_BZ_S_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1H_Z_P_BZ_S_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1H_Z_P_BZ_S_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1H_Z_P_BZ_S_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale t)
  | 2048 => (execute_ST1H_Z_P_BZ_S_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 32 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_Z_P_BZ_S_x32_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_BZ_S_x32_scaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (xs : (BitVec 1)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let offs_size := 32
  let offs_unsigned : Bool := (BEq.beq xs (0b0 : (BitVec 1)))
  let scale := 2
  match VL with
  | 128 => (execute_ST1W_Z_P_BZ_S_x32_scaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1W_Z_P_BZ_S_x32_scaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1W_Z_P_BZ_S_x32_scaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1W_Z_P_BZ_S_x32_scaled 1024 esize g m msize n offs_size offs_unsigned scale t)
  | 2048 => (execute_ST1W_Z_P_BZ_S_x32_scaled 2048 esize g m msize n offs_size offs_unsigned scale t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1B_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1B_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_ST1B_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1B_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1B_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1B_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1B_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1H_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1H_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_ST1H_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1H_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1H_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1H_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1H_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1W_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_ST1W_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1W_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1W_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1W_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1W_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 0 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_Z_P_BZ_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1D_Z_P_BZ_D_64_unscaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 0
  match VL with
  | 128 => (execute_ST1D_Z_P_BZ_D_64_unscaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1D_Z_P_BZ_D_64_unscaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1D_Z_P_BZ_D_64_unscaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1D_Z_P_BZ_D_64_unscaled 1024 esize g m msize n offs_size offs_unsigned scale
      t)
  | 2048 => (execute_ST1D_Z_P_BZ_D_64_unscaled 2048 esize g m msize n offs_size offs_unsigned scale
      t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 1 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1H_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1H_Z_P_BZ_D_64_scaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 1
  match VL with
  | 128 => (execute_ST1H_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1H_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1H_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1H_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale t)
  | 2048 => (execute_ST1H_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 2 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1W_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_BZ_D_64_scaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 2
  match VL with
  | 128 => (execute_ST1W_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1W_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1W_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1W_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale t)
  | 2048 => (execute_ST1W_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, offs_size : Nat, k_offs_unsigned
  : Bool, scale : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  scale = 3 ∧
  offs_size = 64 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_Z_P_BZ_D_64_scaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (offs_size : Nat) (offs_unsigned : Bool) (scale : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let offset ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (Z_read m VL)
        let src ← (Z_read t VL)
        (pure (base, offset, src))) ) : SailM ((BitVec 64) × (BitVec VL) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let off ← do
            (asl_Int (Sail.BitVec.extractLsb (← (Elem_read offset e esize)) (offs_size -i 1) 0)
              offs_unsigned)
          let addr : (BitVec 64) := (BitVec.addInt base (Int.shiftl off scale))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1D_Z_P_BZ_D_64_scaled (msz : (BitVec 2)) (Zm : (BitVec 5)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Zm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offs_size := 64
  let offs_unsigned : Bool := true
  let scale := 3
  match VL with
  | 128 => (execute_ST1D_Z_P_BZ_D_64_scaled 128 esize g m msize n offs_size offs_unsigned scale t)
  | 256 => (execute_ST1D_Z_P_BZ_D_64_scaled 256 esize g m msize n offs_size offs_unsigned scale t)
  | 512 => (execute_ST1D_Z_P_BZ_D_64_scaled 512 esize g m msize n offs_size offs_unsigned scale t)
  | 1024 => (execute_ST1D_Z_P_BZ_D_64_scaled 1024 esize g m msize n offs_size offs_unsigned scale t)
  | 2048 => (execute_ST1D_Z_P_BZ_D_64_scaled 2048 esize g m msize n offs_size offs_unsigned scale t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Nat, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1B_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let src ← (Z_read t VL)
        (pure (base, src)))
    else (pure (base, src)) ) : SailM ((BitVec VL) × (BitVec VL)) )
  let src := src
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (offset *i mbytes))) ) : SailM (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1B_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_ST1B_Z_P_AI_D 128 esize g msize n offset t)
  | 256 => (execute_ST1B_Z_P_AI_D 256 esize g msize n offset t)
  | 512 => (execute_ST1B_Z_P_AI_D 512 esize g msize n offset t)
  | 1024 => (execute_ST1B_Z_P_AI_D 1024 esize g msize n offset t)
  | 2048 => (execute_ST1B_Z_P_AI_D 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Nat, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1H_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let src ← (Z_read t VL)
        (pure (base, src)))
    else (pure (base, src)) ) : SailM ((BitVec VL) × (BitVec VL)) )
  let src := src
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (offset *i mbytes))) ) : SailM (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1H_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_ST1H_Z_P_AI_D 128 esize g msize n offset t)
  | 256 => (execute_ST1H_Z_P_AI_D 256 esize g msize n offset t)
  | 512 => (execute_ST1H_Z_P_AI_D 512 esize g msize n offset t)
  | 1024 => (execute_ST1H_Z_P_AI_D 1024 esize g msize n offset t)
  | 2048 => (execute_ST1H_Z_P_AI_D 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Nat, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1W_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let src ← (Z_read t VL)
        (pure (base, src)))
    else (pure (base, src)) ) : SailM ((BitVec VL) × (BitVec VL)) )
  let src := src
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (offset *i mbytes))) ) : SailM (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_ST1W_Z_P_AI_D 128 esize g msize n offset t)
  | 256 => (execute_ST1W_Z_P_AI_D 256 esize g msize n offset t)
  | 512 => (execute_ST1W_Z_P_AI_D 512 esize g msize n offset t)
  | 1024 => (execute_ST1W_Z_P_AI_D 1024 esize g msize n offset t)
  | 2048 => (execute_ST1W_Z_P_AI_D 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Nat, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 64 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_Z_P_AI_D (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let src ← (Z_read t VL)
        (pure (base, src)))
    else (pure (base, src)) ) : SailM ((BitVec VL) × (BitVec VL)) )
  let src := src
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (offset *i mbytes))) ) : SailM (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1D_Z_P_AI_D (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_ST1D_Z_P_AI_D 128 esize g msize n offset t)
  | 256 => (execute_ST1D_Z_P_AI_D 256 esize g msize n offset t)
  | 512 => (execute_ST1D_Z_P_AI_D 512 esize g msize n offset t)
  | 1024 => (execute_ST1D_Z_P_AI_D 1024 esize g msize n offset t)
  | 2048 => (execute_ST1D_Z_P_AI_D 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Nat, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1B_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let src ← (Z_read t VL)
        (pure (base, src)))
    else (pure (base, src)) ) : SailM ((BitVec VL) × (BitVec VL)) )
  let src := src
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (offset *i mbytes))) ) : SailM (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1B_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_ST1B_Z_P_AI_S 128 esize g msize n offset t)
  | 256 => (execute_ST1B_Z_P_AI_S 256 esize g msize n offset t)
  | 512 => (execute_ST1B_Z_P_AI_S 512 esize g msize n offset t)
  | 1024 => (execute_ST1B_Z_P_AI_S 1024 esize g msize n offset t)
  | 2048 => (execute_ST1B_Z_P_AI_S 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Nat, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1H_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let src ← (Z_read t VL)
        (pure (base, src)))
    else (pure (base, src)) ) : SailM ((BitVec VL) × (BitVec VL)) )
  let src := src
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (offset *i mbytes))) ) : SailM (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1H_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_ST1H_Z_P_AI_S 128 esize g msize n offset t)
  | 256 => (execute_ST1H_Z_P_AI_S 256 esize g msize n offset t)
  | 512 => (execute_ST1H_Z_P_AI_S 512 esize g msize n offset t)
  | 1024 => (execute_ST1H_Z_P_AI_S 1024 esize g msize n offset t)
  | 2048 => (execute_ST1H_Z_P_AI_S 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Nat, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ offset ∧
  offset ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_Z_P_AI_S (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let src ← (Z_read t VL)
        (pure (base, src)))
    else (pure (base, src)) ) : SailM ((BitVec VL) × (BitVec VL)) )
  let src := src
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure (BitVec.addInt (Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64)
                (offset *i mbytes))) ) : SailM (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_AI_S (msz : (BitVec 2)) (imm5 : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let offset := (BitVec.toNat imm5)
  match VL with
  | 128 => (execute_ST1W_Z_P_AI_S 128 esize g msize n offset t)
  | 256 => (execute_ST1W_Z_P_AI_S 256 esize g msize n offset t)
  | 512 => (execute_ST1W_Z_P_AI_S 512 esize g msize n offset t)
  | 1024 => (execute_ST1W_Z_P_AI_S 1024 esize g msize n offset t)
  | 2048 => (execute_ST1W_Z_P_AI_S 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ is_VL(VL) -/
def execute_ST1B_Z_P_BI__ (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let src ← (Z_read t VL)
        (pure (base, src))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let eoff := ((offset *i elements) +i e)
          let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1B_Z_P_BI__ (msz : (BitVec 2)) (size : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let msize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1B_Z_P_BI__ 128 esize g msize n offset t)
  | 256 => (execute_ST1B_Z_P_BI__ 256 esize g msize n offset t)
  | 512 => (execute_ST1B_Z_P_BI__ 512 esize g msize n offset t)
  | 1024 => (execute_ST1B_Z_P_BI__ 1024 esize g msize n offset t)
  | 2048 => (execute_ST1B_Z_P_BI__ 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {8, 16, 32, 64} ∧ is_VL(VL) -/
def execute_ST1H_Z_P_BI__ (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let src ← (Z_read t VL)
        (pure (base, src))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let eoff := ((offset *i elements) +i e)
          let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
          assert (Bool.and (0 ≤b (msize -i 1)) ((msize -i 1) <b esize)) "src/instrs64_sve.sail:86003.70-86003.71"
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1H_Z_P_BI__ (msz : (BitVec 2)) (size : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := (Int.shiftl 8 (BitVec.toNat size))
  let msize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1H_Z_P_BI__ 128 esize g msize n offset t)
  | 256 => (execute_ST1H_Z_P_BI__ 256 esize g msize n offset t)
  | 512 => (execute_ST1H_Z_P_BI__ 512 esize g msize n offset t)
  | 1024 => (execute_ST1H_Z_P_BI__ 1024 esize g msize n offset t)
  | 2048 => (execute_ST1H_Z_P_BI__ 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize ∈ {32, 64} ∧ is_VL(VL) -/
def execute_ST1W_Z_P_BI__ (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let src ← (Z_read t VL)
        (pure (base, src))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let eoff := ((offset *i elements) +i e)
          let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_BI__ (msz : (BitVec 2)) (sz : (BitVec 1)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := (Int.shiftl 32 (BitVec.toNat sz))
  let msize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1W_Z_P_BI__ 128 esize g msize n offset t)
  | 256 => (execute_ST1W_Z_P_BI__ 256 esize g msize n offset t)
  | 512 => (execute_ST1W_Z_P_BI__ 512 esize g msize n offset t)
  | 1024 => (execute_ST1W_Z_P_BI__ 1024 esize g msize n offset t)
  | 2048 => (execute_ST1W_Z_P_BI__ 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 64 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_Z_P_BI__ (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let src ← (Z_read t VL)
        (pure (base, src))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let eoff := ((offset *i elements) +i e)
          let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1D_Z_P_BI__ (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1D_Z_P_BI__ 128 esize g msize n offset t)
  | 256 => (execute_ST1D_Z_P_BI__ 256 esize g msize n offset t)
  | 512 => (execute_ST1D_Z_P_BI__ 512 esize g msize n offset t)
  | 1024 => (execute_ST1D_Z_P_BI__ 1024 esize g msize n offset t)
  | 2048 => (execute_ST1D_Z_P_BI__ 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 32 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST1W_Z_P_BI_U128 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let src ← (Z_read t VL)
        (pure (base, src))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let eoff := ((offset *i elements) +i e)
          let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1W_Z_P_BI_U128 (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let msize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1W_Z_P_BI_U128 128 esize g msize n offset t)
  | 256 => (execute_ST1W_Z_P_BI_U128 256 esize g msize n offset t)
  | 512 => (execute_ST1W_Z_P_BI_U128 512 esize g msize n offset t)
  | 1024 => (execute_ST1W_Z_P_BI_U128 1024 esize g msize n offset t)
  | 2048 => (execute_ST1W_Z_P_BI_U128 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, msize : Nat, n : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ msize = 64 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST1D_Z_P_BI_U128 (VL : Nat) (esize : Nat) (g : Nat) (msize : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let src ← (Z_read t VL)
        (pure (base, src))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let eoff := ((offset *i elements) +i e)
          let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_ST1D_Z_P_BI_U128 (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let msize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1D_Z_P_BI_U128 128 esize g msize n offset t)
  | 256 => (execute_ST1D_Z_P_BI_U128 256 esize g msize n offset t)
  | 512 => (execute_ST1D_Z_P_BI_U128 512 esize g msize n offset t)
  | 1024 => (execute_ST1D_Z_P_BI_U128 1024 esize g msize n offset t)
  | 2048 => (execute_ST1D_Z_P_BI_U128 2048 esize g msize n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_STNT1B_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let src ← (Z_read t VL)
        (pure (base, src))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let eoff := ((offset *i elements) +i e)
          let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
          (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
      else (pure ())
  (pure loop_vars)

def decode_STNT1B_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1B_Z_P_BI_Contiguous 128 esize g n offset t)
  | 256 => (execute_STNT1B_Z_P_BI_Contiguous 256 esize g n offset t)
  | 512 => (execute_STNT1B_Z_P_BI_Contiguous 512 esize g n offset t)
  | 1024 => (execute_STNT1B_Z_P_BI_Contiguous 1024 esize g n offset t)
  | 2048 => (execute_STNT1B_Z_P_BI_Contiguous 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_STNT1H_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let src ← (Z_read t VL)
        (pure (base, src))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let eoff := ((offset *i elements) +i e)
          let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
          (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
      else (pure ())
  (pure loop_vars)

def decode_STNT1H_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1H_Z_P_BI_Contiguous 128 esize g n offset t)
  | 256 => (execute_STNT1H_Z_P_BI_Contiguous 256 esize g n offset t)
  | 512 => (execute_STNT1H_Z_P_BI_Contiguous 512 esize g n offset t)
  | 1024 => (execute_STNT1H_Z_P_BI_Contiguous 1024 esize g n offset t)
  | 2048 => (execute_STNT1H_Z_P_BI_Contiguous 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let src ← (Z_read t VL)
        (pure (base, src))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let eoff := ((offset *i elements) +i e)
          let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
          (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
      else (pure ())
  (pure loop_vars)

def decode_STNT1W_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1W_Z_P_BI_Contiguous 128 esize g n offset t)
  | 256 => (execute_STNT1W_Z_P_BI_Contiguous 256 esize g n offset t)
  | 512 => (execute_STNT1W_Z_P_BI_Contiguous 512 esize g n offset t)
  | 1024 => (execute_STNT1W_Z_P_BI_Contiguous 1024 esize g n offset t)
  | 2048 => (execute_STNT1W_Z_P_BI_Contiguous 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, offset : Int, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mbytes := (Int.ediv esize 8)
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, src) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, src)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let src ← (Z_read t VL)
        (pure (base, src))) ) : SailM ((BitVec 64) × (BitVec VL)) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let eoff := ((offset *i elements) +i e)
          let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
          (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
      else (pure ())
  (pure loop_vars)

def decode_STNT1D_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1D_Z_P_BI_Contiguous 128 esize g n offset t)
  | 256 => (execute_STNT1D_Z_P_BI_Contiguous 256 esize g n offset t)
  | 512 => (execute_STNT1D_Z_P_BI_Contiguous 512 esize g n offset t)
  | 1024 => (execute_STNT1D_Z_P_BI_Contiguous 1024 esize g n offset t)
  | 2048 => (execute_STNT1D_Z_P_BI_Contiguous 2048 esize g n offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST2B_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST2B_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let offset := (BitVec.toInt imm4)
  let nreg := 2
  match VL with
  | 128 => (execute_ST2B_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST2B_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST2B_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST2B_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST2B_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST2H_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST2H_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let offset := (BitVec.toInt imm4)
  let nreg := 2
  match VL with
  | 128 => (execute_ST2H_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST2H_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST2H_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST2H_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST2H_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST2W_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST2W_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let offset := (BitVec.toInt imm4)
  let nreg := 2
  match VL with
  | 128 => (execute_ST2W_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST2W_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST2W_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST2W_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST2W_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST2D_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST2D_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let offset := (BitVec.toInt imm4)
  let nreg := 2
  match VL with
  | 128 => (execute_ST2D_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST2D_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST2D_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST2D_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST2D_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 3 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST3B_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST3B_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let offset := (BitVec.toInt imm4)
  let nreg := 3
  match VL with
  | 128 => (execute_ST3B_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST3B_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST3B_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST3B_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST3B_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 3 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST3H_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST3H_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let offset := (BitVec.toInt imm4)
  let nreg := 3
  match VL with
  | 128 => (execute_ST3H_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST3H_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST3H_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST3H_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST3H_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 3 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST3W_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST3W_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let offset := (BitVec.toInt imm4)
  let nreg := 3
  match VL with
  | 128 => (execute_ST3W_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST3W_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST3W_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST3W_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST3W_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 3 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST3D_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST3D_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let offset := (BitVec.toInt imm4)
  let nreg := 3
  match VL with
  | 128 => (execute_ST3D_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST3D_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST3D_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST3D_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST3D_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST4B_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST4B_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 8
  let offset := (BitVec.toInt imm4)
  let nreg := 4
  match VL with
  | 128 => (execute_ST4B_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST4B_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST4B_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST4B_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST4B_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST4H_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST4H_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 16
  let offset := (BitVec.toInt imm4)
  let nreg := 4
  match VL with
  | 128 => (execute_ST4H_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST4H_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST4H_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST4H_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST4H_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST4W_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST4W_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let offset := (BitVec.toInt imm4)
  let nreg := 4
  match VL with
  | 128 => (execute_ST4W_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST4W_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST4W_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST4W_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST4W_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST4D_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST4D_Z_P_BI_Contiguous (msz : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE ()))) (Bool.not (← (HaveSME ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let offset := (BitVec.toInt imm4)
  let nreg := 4
  match VL with
  | 128 => (execute_ST4D_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST4D_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST4D_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST4D_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST4D_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST2Q_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 2 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 2) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 2) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST2Q_Z_P_BI_Contiguous (num : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let offset := (BitVec.toInt imm4)
  let nreg := 2
  match VL with
  | 128 => (execute_ST2Q_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST2Q_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST2Q_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST2Q_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST2Q_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 3 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST3Q_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 3 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 3) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 3) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST3Q_Z_P_BI_Contiguous (num : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let offset := (BitVec.toInt imm4)
  let nreg := 3
  match VL with
  | 128 => (execute_ST3Q_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST3Q_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST3Q_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST3Q_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST3Q_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 128 ∧ is_VL(VL) -/
def execute_ST4Q_Z_P_BI_Contiguous (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  (CheckSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mbytes := (Int.ediv esize 8)
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do (pure (vectorUpdate values_name r (← (Z_read (Nat.div (t +i r) 32) VL))))
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars_1 := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars_1
    loop_vars_1 ← do
      let loop_r_lower := 0
      let loop_r_upper := (nreg -i 1)
      let mut loop_vars_2 := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars_2
        loop_vars_2 ← do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let eoff := ((((offset *i elements) *i nreg) +i (e *i nreg)) +i r)
              let addr : (BitVec 64) := (BitVec.addInt base (eoff *i mbytes))
              (Mem_set addr mbytes accdesc
                (← (Elem_read (GetElem?.getElem! values_name r) e esize))))
          else (pure ())
      (pure loop_vars_2)
  (pure loop_vars_1)

def decode_ST4Q_Z_P_BI_Contiguous (num : (BitVec 2)) (imm4 : (BitVec 4)) (Pg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSVE2p1 ()))) (Bool.not (← (HaveSME2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat Pg)
  let esize := 128
  let offset := (BitVec.toInt imm4)
  let nreg := 4
  match VL with
  | 128 => (execute_ST4Q_Z_P_BI_Contiguous 128 esize g n nreg offset t)
  | 256 => (execute_ST4Q_Z_P_BI_Contiguous 256 esize g n nreg offset t)
  | 512 => (execute_ST4Q_Z_P_BI_Contiguous 512 esize g n nreg offset t)
  | 1024 => (execute_ST4Q_Z_P_BI_Contiguous 1024 esize g n nreg offset t)
  | 2048 => (execute_ST4Q_Z_P_BI_Contiguous 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1B_Z_P_AR_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1B_Z_P_AR_S_x32_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDNT1B_Z_P_AR_S_x32_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1B_Z_P_AR_S_x32_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1B_Z_P_AR_S_x32_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1B_Z_P_AR_S_x32_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1B_Z_P_AR_S_x32_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1H_Z_P_AR_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1H_Z_P_AR_S_x32_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDNT1H_Z_P_AR_S_x32_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1H_Z_P_AR_S_x32_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1H_Z_P_AR_S_x32_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1H_Z_P_AR_S_x32_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1H_Z_P_AR_S_x32_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_Z_P_AR_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1W_Z_P_AR_S_x32_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDNT1W_Z_P_AR_S_x32_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1W_Z_P_AR_S_x32_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1W_Z_P_AR_S_x32_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1W_Z_P_AR_S_x32_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1W_Z_P_AR_S_x32_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1SB_Z_P_AR_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1SB_Z_P_AR_S_x32_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDNT1SB_Z_P_AR_S_x32_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1SB_Z_P_AR_S_x32_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1SB_Z_P_AR_S_x32_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1SB_Z_P_AR_S_x32_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1SB_Z_P_AR_S_x32_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1SH_Z_P_AR_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1SH_Z_P_AR_S_x32_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDNT1SH_Z_P_AR_S_x32_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1SH_Z_P_AR_S_x32_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1SH_Z_P_AR_S_x32_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1SH_Z_P_AR_S_x32_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1SH_Z_P_AR_S_x32_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1B_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1B_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDNT1B_Z_P_AR_D_64_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1B_Z_P_AR_D_64_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1B_Z_P_AR_D_64_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1B_Z_P_AR_D_64_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1B_Z_P_AR_D_64_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1H_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1H_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDNT1H_Z_P_AR_D_64_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1H_Z_P_AR_D_64_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1H_Z_P_AR_D_64_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1H_Z_P_AR_D_64_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1H_Z_P_AR_D_64_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1W_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1W_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDNT1W_Z_P_AR_D_64_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1W_Z_P_AR_D_64_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1W_Z_P_AR_D_64_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1W_Z_P_AR_D_64_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1W_Z_P_AR_D_64_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1D_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  let is_unsigned : Bool := true
  match VL with
  | 128 => (execute_LDNT1D_Z_P_AR_D_64_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1D_Z_P_AR_D_64_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1D_Z_P_AR_D_64_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1D_Z_P_AR_D_64_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1D_Z_P_AR_D_64_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1SB_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1SB_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDNT1SB_Z_P_AR_D_64_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1SB_Z_P_AR_D_64_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1SB_Z_P_AR_D_64_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1SB_Z_P_AR_D_64_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1SB_Z_P_AR_D_64_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1SH_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1SH_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDNT1SH_Z_P_AR_D_64_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1SH_Z_P_AR_D_64_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1SH_Z_P_AR_D_64_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1SH_Z_P_AR_D_64_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1SH_Z_P_AR_D_64_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, k_is_unsigned : Bool, m : Nat, msize : Nat, n
  : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1SW_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let data ← (( do (undefined_bitvector msize) ) : SailM (BitVec msize) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let (data, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (data, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (data, result) := loop_vars
      loop_vars ← do
        let (data, result) ← (( do
          bif (← (ActivePredicateElement mask e esize))
          then
            (do
              let addr ← (( do
                (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) :
                SailM (BitVec 64) )
              let data ← (Mem_read addr mbytes accdesc)
              let result ← (Elem_set result e esize (← (Extend data esize is_unsigned)))
              (pure (data, result)))
          else
            (do
              let result ← (Elem_set result e esize (Zeros (n := esize)))
              (pure (data, result))) ) : SailM ((BitVec msize) × (BitVec VL)) )
        (pure (data, result))
    (pure loop_vars) ) : SailM ((BitVec msize) × (BitVec VL)) )
  (Z_set t VL result)

def decode_LDNT1SW_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (U : (BitVec 1)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  let is_unsigned : Bool := false
  match VL with
  | 128 => (execute_LDNT1SW_Z_P_AR_D_64_unscaled 128 esize g m msize n t is_unsigned)
  | 256 => (execute_LDNT1SW_Z_P_AR_D_64_unscaled 256 esize g m msize n t is_unsigned)
  | 512 => (execute_LDNT1SW_Z_P_AR_D_64_unscaled 512 esize g m msize n t is_unsigned)
  | 1024 => (execute_LDNT1SW_Z_P_AR_D_64_unscaled 1024 esize g m msize n t is_unsigned)
  | 2048 => (execute_LDNT1SW_Z_P_AR_D_64_unscaled 2048 esize g m msize n t is_unsigned)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1B_Z_P_AR_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src)))
    else (pure (base, offset, src)) ) : SailM ((BitVec VL) × (BitVec 64) × (BitVec VL)) )
  let src := src
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) : SailM
            (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_STNT1B_Z_P_AR_S_x32_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 8
  match VL with
  | 128 => (execute_STNT1B_Z_P_AR_S_x32_unscaled 128 esize g m msize n t)
  | 256 => (execute_STNT1B_Z_P_AR_S_x32_unscaled 256 esize g m msize n t)
  | 512 => (execute_STNT1B_Z_P_AR_S_x32_unscaled 512 esize g m msize n t)
  | 1024 => (execute_STNT1B_Z_P_AR_S_x32_unscaled 1024 esize g m msize n t)
  | 2048 => (execute_STNT1B_Z_P_AR_S_x32_unscaled 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1H_Z_P_AR_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src)))
    else (pure (base, offset, src)) ) : SailM ((BitVec VL) × (BitVec 64) × (BitVec VL)) )
  let src := src
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) : SailM
            (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_STNT1H_Z_P_AR_S_x32_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 16
  match VL with
  | 128 => (execute_STNT1H_Z_P_AR_S_x32_unscaled 128 esize g m msize n t)
  | 256 => (execute_STNT1H_Z_P_AR_S_x32_unscaled 256 esize g m msize n t)
  | 512 => (execute_STNT1H_Z_P_AR_S_x32_unscaled 512 esize g m msize n t)
  | 1024 => (execute_STNT1H_Z_P_AR_S_x32_unscaled 1024 esize g m msize n t)
  | 2048 => (execute_STNT1H_Z_P_AR_S_x32_unscaled 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_Z_P_AR_S_x32_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src)))
    else (pure (base, offset, src)) ) : SailM ((BitVec VL) × (BitVec 64) × (BitVec VL)) )
  let src := src
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) : SailM
            (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_STNT1W_Z_P_AR_S_x32_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 32
  let msize := 32
  match VL with
  | 128 => (execute_STNT1W_Z_P_AR_S_x32_unscaled 128 esize g m msize n t)
  | 256 => (execute_STNT1W_Z_P_AR_S_x32_unscaled 256 esize g m msize n t)
  | 512 => (execute_STNT1W_Z_P_AR_S_x32_unscaled 512 esize g m msize n t)
  | 1024 => (execute_STNT1W_Z_P_AR_S_x32_unscaled 1024 esize g m msize n t)
  | 2048 => (execute_STNT1W_Z_P_AR_S_x32_unscaled 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 8 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1B_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src)))
    else (pure (base, offset, src)) ) : SailM ((BitVec VL) × (BitVec 64) × (BitVec VL)) )
  let src := src
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) : SailM
            (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_STNT1B_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 8
  match VL with
  | 128 => (execute_STNT1B_Z_P_AR_D_64_unscaled 128 esize g m msize n t)
  | 256 => (execute_STNT1B_Z_P_AR_D_64_unscaled 256 esize g m msize n t)
  | 512 => (execute_STNT1B_Z_P_AR_D_64_unscaled 512 esize g m msize n t)
  | 1024 => (execute_STNT1B_Z_P_AR_D_64_unscaled 1024 esize g m msize n t)
  | 2048 => (execute_STNT1B_Z_P_AR_D_64_unscaled 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 16 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1H_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src)))
    else (pure (base, offset, src)) ) : SailM ((BitVec VL) × (BitVec 64) × (BitVec VL)) )
  let src := src
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) : SailM
            (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_STNT1H_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 16
  match VL with
  | 128 => (execute_STNT1H_Z_P_AR_D_64_unscaled 128 esize g m msize n t)
  | 256 => (execute_STNT1H_Z_P_AR_D_64_unscaled 256 esize g m msize n t)
  | 512 => (execute_STNT1H_Z_P_AR_D_64_unscaled 512 esize g m msize n t)
  | 1024 => (execute_STNT1H_Z_P_AR_D_64_unscaled 1024 esize g m msize n t)
  | 2048 => (execute_STNT1H_Z_P_AR_D_64_unscaled 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 32 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1W_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src)))
    else (pure (base, offset, src)) ) : SailM ((BitVec VL) × (BitVec 64) × (BitVec VL)) )
  let src := src
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) : SailM
            (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_STNT1W_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 32
  match VL with
  | 128 => (execute_STNT1W_Z_P_AR_D_64_unscaled 128 esize g m msize n t)
  | 256 => (execute_STNT1W_Z_P_AR_D_64_unscaled 256 esize g m msize n t)
  | 512 => (execute_STNT1W_Z_P_AR_D_64_unscaled 512 esize g m msize n t)
  | 1024 => (execute_STNT1W_Z_P_AR_D_64_unscaled 1024 esize g m msize n t)
  | 2048 => (execute_STNT1W_Z_P_AR_D_64_unscaled 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, msize : Nat, n : Nat, t : Nat, 0 ≤
  t ∧
  t ≤ 31 ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  msize = 64 ∧
  0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_Z_P_AR_D_64_unscaled (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (msize : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  (CheckNonStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let mbytes := (Int.ediv msize 8)
  let contiguous : Bool := false
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (← (AnyActiveElement mask esize))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src)))
    else (pure (base, offset, src)) ) : SailM ((BitVec VL) × (BitVec 64) × (BitVec VL)) )
  let src := src
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e esize))
      then
        (do
          let addr ← (( do
            (pure ((Sail.BitVec.zeroExtend (← (Elem_read base e esize)) 64) + offset)) ) : SailM
            (BitVec 64) )
          (Mem_set addr mbytes accdesc
            (Sail.BitVec.extractLsb (← (Elem_read src e esize)) (msize -i 1) 0)))
      else (pure ())
  (pure loop_vars)

def decode_STNT1D_Z_P_AR_D_64_unscaled (msz : (BitVec 2)) (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  let esize := 64
  let msize := 64
  match VL with
  | 128 => (execute_STNT1D_Z_P_AR_D_64_unscaled 128 esize g m msize n t)
  | 256 => (execute_STNT1D_Z_P_AR_D_64_unscaled 256 esize g m msize n t)
  | 512 => (execute_STNT1D_Z_P_AR_D_64_unscaled 512 esize g m msize n t)
  | 1024 => (execute_STNT1D_Z_P_AR_D_64_unscaled 1024 esize g m msize n t)
  | 2048 => (execute_STNT1D_Z_P_AR_D_64_unscaled 2048 esize g m msize n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_LD1Q_Z_P_AR_D_64_unscaled (VL : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  let VL := VL
  let PL := (Int.ediv VL 8)
  (CheckNonStreamingSVEEnabled ())
  let elements := (Int.ediv VL 128)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (← (AnyActiveElement mask 128))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        (pure (base, offset)))
    else (pure (base, offset)) ) : SailM ((BitVec VL) × (BitVec 64)) )
  let offset := offset
  let base := base
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        bif (← (ActivePredicateElement mask e 128))
        then
          (do
            let addr ← (( do (pure ((← (Elem_read base (2 *i e) 64)) + offset)) ) : SailM
              (BitVec 64) )
            (Elem_set result e 128 (← (Mem_read addr 16 accdesc))))
        else
          (do
            (Elem_set result e 128 (Zeros (n := 128))))
    (pure loop_vars) ) : SailM (BitVec VL) )
  (Z_set t VL result)

def decode_LD1Q_Z_P_AR_D_64_unscaled (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  match VL with
  | 128 => (execute_LD1Q_Z_P_AR_D_64_unscaled 128 g m n t)
  | 256 => (execute_LD1Q_Z_P_AR_D_64_unscaled 256 g m n t)
  | 512 => (execute_LD1Q_Z_P_AR_D_64_unscaled 512 g m n t)
  | 1024 => (execute_LD1Q_Z_P_AR_D_64_unscaled 1024 g m n t)
  | 2048 => (execute_LD1Q_Z_P_AR_D_64_unscaled 2048 g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, g : Nat, m : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 31 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ g ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ is_VL(VL) -/
def execute_ST1Q_Z_P_AR_D_64_unscaled (VL : Nat) (g : Nat) (m : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  let VL := VL
  let PL := (Int.ediv VL 8)
  (CheckNonStreamingSVEEnabled ())
  let elements := (Int.ediv VL 128)
  let mask ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let base ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let contiguous : Bool := false
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset, src) ← (( do
    bif (← (AnyActiveElement mask 128))
    then
      (do
        let base ← (Z_read n VL)
        let offset ← (X_read m 64)
        let src ← (Z_read t VL)
        (pure (base, offset, src)))
    else (pure (base, offset, src)) ) : SailM ((BitVec VL) × (BitVec 64) × (BitVec VL)) )
  let src := src
  let offset := offset
  let base := base
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (← (ActivePredicateElement mask e 128))
      then
        (do
          let addr ← (( do (pure ((← (Elem_read base (2 *i e) 64)) + offset)) ) : SailM
            (BitVec 64) )
          (Mem_set addr 16 accdesc (← (Elem_read src e 128))))
      else (pure ())
  (pure loop_vars)

def decode_ST1Q_Z_P_AR_D_64_unscaled (Rm : (BitVec 5)) (Pg : (BitVec 3)) (Zn : (BitVec 5)) (Zt : (BitVec 5)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.not (← (HaveSVE2p1 ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let t := (BitVec.toNat Zt)
  let n := (BitVec.toNat Zn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat Pg)
  match VL with
  | 128 => (execute_ST1Q_Z_P_AR_D_64_unscaled 128 g m n t)
  | 256 => (execute_ST1Q_Z_P_AR_D_64_unscaled 256 g m n t)
  | 512 => (execute_ST1Q_Z_P_AR_D_64_unscaled 512 g m n t)
  | 1024 => (execute_ST1Q_Z_P_AR_D_64_unscaled 1024 g m n t)
  | 2048 => (execute_ST1Q_Z_P_AR_D_64_unscaled 2048 g m n t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1B_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 8
  match VL with
  | 128 => (execute_LD1B_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_LD1B_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_LD1B_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_LD1B_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_LD1B_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1H_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 16
  match VL with
  | 128 => (execute_LD1H_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_LD1H_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_LD1H_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_LD1H_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_LD1H_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1W_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 32
  match VL with
  | 128 => (execute_LD1W_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_LD1W_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_LD1W_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_LD1W_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_LD1W_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1D_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 64
  match VL with
  | 128 => (execute_LD1D_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_LD1D_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_LD1D_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_LD1D_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_LD1D_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1B_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 8
  match VL with
  | 128 => (execute_LD1B_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_LD1B_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_LD1B_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_LD1B_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_LD1B_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1H_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 16
  match VL with
  | 128 => (execute_LD1H_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_LD1H_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_LD1H_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_LD1H_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_LD1H_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1W_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 32
  match VL with
  | 128 => (execute_LD1W_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_LD1W_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_LD1W_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_LD1W_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_LD1W_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1D_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 64
  match VL with
  | 128 => (execute_LD1D_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_LD1D_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_LD1D_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_LD1D_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_LD1D_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNT1B_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1B_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 8
  match VL with
  | 128 => (execute_LDNT1B_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_LDNT1B_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_LDNT1B_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_LDNT1B_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_LDNT1B_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNT1H_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1H_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 16
  match VL with
  | 128 => (execute_LDNT1H_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_LDNT1H_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_LDNT1H_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_LDNT1H_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_LDNT1H_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1W_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 32
  match VL with
  | 128 => (execute_LDNT1W_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_LDNT1W_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_LDNT1W_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_LDNT1W_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_LDNT1W_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1D_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 64
  match VL with
  | 128 => (execute_LDNT1D_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_LDNT1D_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_LDNT1D_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_LDNT1D_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_LDNT1D_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNT1B_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1B_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 8
  match VL with
  | 128 => (execute_LDNT1B_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_LDNT1B_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_LDNT1B_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_LDNT1B_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_LDNT1B_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNT1H_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1H_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 16
  match VL with
  | 128 => (execute_LDNT1H_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_LDNT1H_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_LDNT1H_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_LDNT1H_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_LDNT1H_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1W_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 32
  match VL with
  | 128 => (execute_LDNT1W_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_LDNT1W_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_LDNT1W_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_LDNT1W_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_LDNT1W_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1D_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 64
  match VL with
  | 128 => (execute_LDNT1D_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_LDNT1D_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_LDNT1D_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_LDNT1D_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_LDNT1D_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST1B_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1B_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 8
  match VL with
  | 128 => (execute_ST1B_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_ST1B_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_ST1B_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_ST1B_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_ST1B_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST1H_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1H_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 16
  match VL with
  | 128 => (execute_ST1H_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_ST1H_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_ST1H_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_ST1H_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_ST1H_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1W_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 32
  match VL with
  | 128 => (execute_ST1W_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_ST1W_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_ST1W_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_ST1W_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_ST1W_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1D_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 64
  match VL with
  | 128 => (execute_ST1D_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_ST1D_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_ST1D_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_ST1D_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_ST1D_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST1B_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1B_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 8
  match VL with
  | 128 => (execute_ST1B_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_ST1B_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_ST1B_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_ST1B_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_ST1B_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST1H_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1H_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 16
  match VL with
  | 128 => (execute_ST1H_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_ST1H_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_ST1H_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_ST1H_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_ST1H_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1W_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 32
  match VL with
  | 128 => (execute_ST1W_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_ST1W_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_ST1W_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_ST1W_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_ST1W_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1D_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 64
  match VL with
  | 128 => (execute_ST1D_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_ST1D_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_ST1D_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_ST1D_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_ST1D_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_STNT1B_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1B_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 8
  match VL with
  | 128 => (execute_STNT1B_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_STNT1B_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_STNT1B_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_STNT1B_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_STNT1B_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_STNT1H_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1H_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 16
  match VL with
  | 128 => (execute_STNT1H_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_STNT1H_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_STNT1H_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_STNT1H_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_STNT1H_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1W_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 32
  match VL with
  | 128 => (execute_STNT1W_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_STNT1W_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_STNT1W_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_STNT1W_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_STNT1W_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 2 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_MZ_P_BR_2 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1D_MZ_P_BR_2 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 64
  match VL with
  | 128 => (execute_STNT1D_MZ_P_BR_2 128 esize g m n nreg t)
  | 256 => (execute_STNT1D_MZ_P_BR_2 256 esize g m n nreg t)
  | 512 => (execute_STNT1D_MZ_P_BR_2 512 esize g m n nreg t)
  | 1024 => (execute_STNT1D_MZ_P_BR_2 1024 esize g m n nreg t)
  | 2048 => (execute_STNT1D_MZ_P_BR_2 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_STNT1B_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1B_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 8
  match VL with
  | 128 => (execute_STNT1B_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_STNT1B_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_STNT1B_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_STNT1B_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_STNT1B_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_STNT1H_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1H_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 16
  match VL with
  | 128 => (execute_STNT1H_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_STNT1H_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_STNT1H_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_STNT1H_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_STNT1H_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1W_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 32
  match VL with
  | 128 => (execute_STNT1W_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_STNT1W_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_STNT1W_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_STNT1W_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_STNT1W_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, m : Nat, n : Nat, nreg : Nat, t : Nat, 0 ≤ t
  ∧
  t ≤ 31 ∧
  nreg = 4 ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_MZ_P_BR_4 (VL : Nat) (esize : Nat) (g : Nat) (m : Nat) (n : Nat) (nreg : Nat) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let offset ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := true
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let (base, offset) ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure (base, offset)))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        let base ←
          bif (BEq.beq n 31)
          then (SP_read ())
          else (X_read n 64)
        let offset ← (X_read m 64)
        (pure (base, offset))) ) : SailM ((BitVec 64) × (BitVec 64)) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base ((((BitVec.toNat offset) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1D_MZ_P_BR_4 (Rm : (BitVec 5)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let m := (BitVec.toNat Rm)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 64
  match VL with
  | 128 => (execute_STNT1D_MZ_P_BR_4 128 esize g m n nreg t)
  | 256 => (execute_STNT1D_MZ_P_BR_4 256 esize g m n nreg t)
  | 512 => (execute_STNT1D_MZ_P_BR_4 512 esize g m n nreg t)
  | 1024 => (execute_STNT1D_MZ_P_BR_4 1024 esize g m n nreg t)
  | 2048 => (execute_STNT1D_MZ_P_BR_4 2048 esize g m n nreg t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1B_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1B_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_LD1B_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_LD1B_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_LD1B_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_LD1B_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1H_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1H_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_LD1H_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_LD1H_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_LD1H_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_LD1H_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1W_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1W_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_LD1W_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_LD1W_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_LD1W_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_LD1W_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1D_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1D_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_LD1D_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_LD1D_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_LD1D_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_LD1D_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LD1B_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1B_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1B_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_LD1B_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_LD1B_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_LD1B_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_LD1B_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LD1H_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1H_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1H_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_LD1H_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_LD1H_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_LD1H_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_LD1H_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LD1W_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1W_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1W_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_LD1W_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_LD1W_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_LD1W_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_LD1W_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LD1D_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LD1D_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LD1D_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_LD1D_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_LD1D_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_LD1D_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_LD1D_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNT1B_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1B_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1B_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_LDNT1B_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_LDNT1B_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_LDNT1B_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_LDNT1B_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNT1H_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1H_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1H_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_LDNT1H_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_LDNT1H_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_LDNT1H_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_LDNT1H_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1W_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1W_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_LDNT1W_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_LDNT1W_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_LDNT1W_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_LDNT1W_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1D_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1D_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_LDNT1D_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_LDNT1D_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_LDNT1D_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_LDNT1D_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_LDNT1B_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1B_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1B_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_LDNT1B_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_LDNT1B_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_LDNT1B_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_LDNT1B_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_LDNT1H_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1H_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1H_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_LDNT1H_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_LDNT1H_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_LDNT1H_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_LDNT1H_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_LDNT1W_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1W_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1W_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_LDNT1W_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_LDNT1W_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_LDNT1W_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_LDNT1W_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_LDNT1D_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let values_name ← (( do (undefined_vector 4 (← (undefined_bitvector VL))) ) : SailM
    (Vector (BitVec VL) 4) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_LOAD nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let values_name ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := values_name
    for r in [loop_r_lower:loop_r_upper:1]i do
      let values_name := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := values_name
        for e in [loop_e_lower:loop_e_upper:1]i do
          let values_name := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize
                        (← (Mem_read addr mbytes accdesc)))))))
            else
              (do
                (pure (vectorUpdate values_name r
                    (← (Elem_set (GetElem?.getElem! values_name r) e esize (Zeros (n := esize)))))))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (Vector (BitVec VL) 4) )
  let loop_r_lower := 0
  let loop_r_upper := (nreg -i 1)
  let mut loop_vars_2 := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars_2
    loop_vars_2 ← do (Z_set (t +i r) VL (GetElem?.getElem! values_name r))
  (pure loop_vars_2)

def decode_LDNT1D_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_LDNT1D_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_LDNT1D_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_LDNT1D_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_LDNT1D_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_LDNT1D_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST1B_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1B_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1B_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_ST1B_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_ST1B_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_ST1B_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_ST1B_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST1H_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1H_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1H_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_ST1H_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_ST1H_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_ST1H_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_ST1H_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1W_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1W_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_ST1W_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_ST1W_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_ST1W_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_ST1W_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1D_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1D_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_ST1D_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_ST1D_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_ST1D_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_ST1D_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_ST1B_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1B_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1B_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_ST1B_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_ST1B_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_ST1B_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_ST1B_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_ST1H_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1H_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1H_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_ST1H_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_ST1H_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_ST1H_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_ST1H_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_ST1W_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1W_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1W_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_ST1W_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_ST1W_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_ST1W_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_ST1W_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_ST1D_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := false
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_ST1D_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_ST1D_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_ST1D_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_ST1D_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_ST1D_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_ST1D_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_STNT1B_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1B_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1B_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_STNT1B_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_STNT1B_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_STNT1B_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_STNT1B_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_STNT1H_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1H_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1H_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_STNT1H_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_STNT1H_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_STNT1H_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_STNT1H_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1W_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1W_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_STNT1W_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_STNT1W_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_STNT1W_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_STNT1W_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 2 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_MZ_P_BI_2 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1D_MZ_P_BI_2 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 2
  let t := (BitVec.toNat (Zt ++ (0b0 : (BitVec 1))))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1D_MZ_P_BI_2 128 esize g n nreg offset t)
  | 256 => (execute_STNT1D_MZ_P_BI_2 256 esize g n nreg offset t)
  | 512 => (execute_STNT1D_MZ_P_BI_2 512 esize g n nreg offset t)
  | 1024 => (execute_STNT1D_MZ_P_BI_2 1024 esize g n nreg offset t)
  | 2048 => (execute_STNT1D_MZ_P_BI_2 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 8 ∧ is_VL(VL) -/
def execute_STNT1B_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1B_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 8
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1B_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_STNT1B_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_STNT1B_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_STNT1B_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_STNT1B_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 16 ∧ is_VL(VL) -/
def execute_STNT1H_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1H_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 16
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1H_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_STNT1H_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_STNT1H_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_STNT1H_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_STNT1H_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 32 ∧ is_VL(VL) -/
def execute_STNT1W_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1W_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 32
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1W_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_STNT1W_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_STNT1W_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_STNT1W_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_STNT1W_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

/-- Type quantifiers: VL : Nat, esize : Nat, g : Nat, n : Nat, nreg : Nat, offset : Int, t : Nat, 0
  ≤ t ∧
  t ≤ 31 ∧
  nreg = 4 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ g ∧ g ≤ 15 ∧ esize = 64 ∧ is_VL(VL) -/
def execute_STNT1D_MZ_P_BI_4 (VL : Nat) (esize : Nat) (g : Nat) (n : Nat) (nreg : Nat) (offset : Int) (t : Nat) : SailM Unit := do
  bif (← (HaveSVE2p1 ()))
  then (CheckSVEEnabled ())
  else (CheckStreamingSVEEnabled ())
  let VL := VL
  let PL := (Int.ediv VL 8)
  let elements := (Int.ediv VL esize)
  let mbytes := (Int.ediv esize 8)
  let base ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let src ← (( do (undefined_bitvector VL) ) : SailM (BitVec VL) )
  let pred ← (( do (P_read g PL) ) : SailM (BitVec PL) )
  let mask ← (( do (CounterToPredicate (Sail.BitVec.extractLsb pred 15 0) (PL *i nreg)) ) : SailM
    (BitVec (PL * nreg)) )
  let contiguous : Bool := true
  let nontemporal : Bool := true
  let tagchecked : Bool := (bne n 31)
  let accdesc ← (( do (CreateAccDescSVE MemOp_STORE nontemporal contiguous tagchecked) ) : SailM
    AccessDescriptor )
  let base ← (( do
    bif (Bool.not (← (AnyActiveElement mask esize)))
    then
      (do
        bif (Bool.and (BEq.beq n 31)
             (← (ConstrainUnpredictableBool Unpredictable_CHECKSPNONEACTIVE)))
        then (CheckSPAlignment ())
        else (pure ())
        (pure base))
    else
      (do
        bif (BEq.beq n 31)
        then (CheckSPAlignment ())
        else (pure ())
        bif (BEq.beq n 31)
        then (SP_read ())
        else (X_read n 64)) ) : SailM (BitVec 64) )
  let src ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (nreg -i 1)
    let mut loop_vars := src
    for r in [loop_r_lower:loop_r_upper:1]i do
      let src := loop_vars
      loop_vars ← do
        let src ← (Z_read (t +i r) VL)
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := ()
        for e in [loop_e_lower:loop_e_upper:1]i do
          let () := loop_vars_1
          loop_vars_1 ← do
            bif (← (ActivePredicateElement mask ((r *i elements) +i e) esize))
            then
              (do
                let addr : (BitVec 64) :=
                  (BitVec.addInt base
                    (((((offset *i nreg) *i elements) +i (r *i elements)) +i e) *i mbytes))
                (Mem_set addr mbytes accdesc (← (Elem_read src e esize))))
            else (pure ())
        (pure loop_vars_1)
        (pure src)
    (pure loop_vars) ) : SailM (BitVec VL) )
  (pure ())

def decode_STNT1D_MZ_P_BI_4 (imm4 : (BitVec 4)) (msz : (BitVec 2)) (PNg : (BitVec 3)) (Rn : (BitVec 5)) (Zt : (BitVec 3)) (N : (BitVec 1)) : SailM Unit := do
  let VL ← do (CurrentVL_read ())
  bif (Bool.and (Bool.not (← (HaveSME2 ()))) (Bool.not (← (HaveSVE2p1 ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let n := (BitVec.toNat Rn)
  let g := (BitVec.toNat ((0b1 : (BitVec 1)) ++ PNg))
  let nreg := 4
  let t := (BitVec.toNat (Zt ++ (0b00 : (BitVec 2))))
  let esize := 64
  let offset := (BitVec.toInt imm4)
  match VL with
  | 128 => (execute_STNT1D_MZ_P_BI_4 128 esize g n nreg offset t)
  | 256 => (execute_STNT1D_MZ_P_BI_4 256 esize g n nreg offset t)
  | 512 => (execute_STNT1D_MZ_P_BI_4 512 esize g n nreg offset t)
  | 1024 => (execute_STNT1D_MZ_P_BI_4 1024 esize g n nreg offset t)
  | 2048 => (execute_STNT1D_MZ_P_BI_4 2048 esize g n nreg offset t)
  | _ => (pure ())

