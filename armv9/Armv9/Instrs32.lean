import Armv9.Reset

set_option maxHeartbeats 1_000_000_000
set_option maxRecDepth 10_000
set_option linter.unusedVariables false
set_option match.ignoreUnusedAlts true

open Sail

noncomputable section

namespace Armv9.Functions

open signal
open option
open exception
open arm_acc_type
open __InstrEnc
open WFxType
open VFPNegMul
open VCGTtype
open VCGEType
open VBitOps
open VBitOp
open VARange
open Unpredictable
open TranslationStage
open TimeStamp
open TMFailure
open TLBIOp
open TLBIMemAttr
open TLBILevel
open TGx
open SystemHintOp
open Signal
open ShiftType
open Shareability
open SecurityState
open SVECmp
open SRType
open SMEExceptionType
open SDFType
open RestrictType
open Register
open Regime
open ReduceOp
open PrivilegeLevel
open PrefetchHint
open PSTATEField
open PGSe
open PASpace
open PARTIDspaceType
open OpType
open MoveWideOp
open MemType
open MemTagType
open MemOp
open MemAtomicOp
open MOPSStage
open MBReqTypes
open MBReqDomain
open LogicalOp
open InterruptID
open InstrSet
open ImmediateOp
open GPCF
open GCSInstruction
open Feature
open Fault
open FPUnaryOp
open FPType
open FPRounding
open FPMaxMinOp
open FPExc
open FPConvOp
open ExtendType
open ExceptionalOccurrenceTargetState
open Exception
open ErrorState
open DeviceType
open DescriptorType
open DSBAlias
open CrossTriggerIn
open CountOp
open Constraint
open CompareOp
open CacheType
open CachePASpace
open CacheOpScope
open CacheOp
open BranchType
open Barrier
open ArchVersion
open AccessType
open ATAccess

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ADC_i_Op_A_txt (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read n)) imm32 (← readReg PSTATE).C))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_ADC_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:68.29-68.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      (execute_aarch32_instrs_ADC_i_Op_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_ADC_i_T1enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (T32ExpandImm ((i ++ imm3) ++ imm8)) ) : SailM (BitVec 32) )
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADC_i_Op_A_txt d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ADC_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read n)) shifted (← readReg PSTATE).C))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_ADC_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:143.29-143.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_ADC_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_ADC_r_T1enc_A_txt (Rm : (BitVec 3)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_ADC_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_ADC_r_T2enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_ADC_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ADC_rr_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read n)) shifted (← readReg PSTATE).C))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_aarch32_instrs_ADC_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:252.29-252.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADC_rr_Op_A_txt d m n s setflags shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ADD_i_OpA_A_txt (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read n)) imm32 (0b0 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_ADD_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:306.29-306.30"
      bif (Bool.and (BEq.beq Rn (0xF : (BitVec 4))) (BEq.beq S (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "ADR"))
      else (pure ())
      bif (BEq.beq Rn (0xD : (BitVec 4)))
      then sailThrow ((Error_See "ADD (SP plus immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      (execute_aarch32_instrs_ADD_i_OpA_A_txt d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ADD_i_OpT_A_txt (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read n)) imm32 (0b0 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_aarch32_instrs_ADD_i_T1enc_A_txt (imm3 : (BitVec 3)) (Rn : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let imm32 : (BitVec 32) := (zero_extend imm3 32)
      (execute_aarch32_instrs_ADD_i_OpT_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_ADD_i_T2enc_A_txt (Rdn : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      (execute_aarch32_instrs_ADD_i_OpT_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_ADD_i_T3enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "CMN (immediate)"))
      else (pure ())
      bif (BEq.beq Rn (0xD : (BitVec 4)))
      then sailThrow ((Error_See "ADD (SP plus immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (T32ExpandImm ((i ++ imm3) ++ imm8)) ) : SailM (BitVec 32) )
      bif (Bool.or (Bool.and (BEq.beq d 15) (Bool.not setflags)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADD_i_OpT_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_ADD_i_T4enc_A_txt (i : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "ADR"))
      else (pure ())
      bif (BEq.beq Rn (0xD : (BitVec 4)))
      then sailThrow ((Error_See "ADD (SP plus immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := false
      let imm32 : (BitVec 32) := (zero_extend ((i ++ imm3) ++ imm8) 32)
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADD_i_OpT_A_txt d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ADD_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read n)) shifted (0b0 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_ADD_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:481.29-481.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xD : (BitVec 4)))
      then sailThrow ((Error_See "ADD (SP plus register)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_ADD_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_ADD_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_ADD_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_ADD_r_T2enc_A_txt (DN : (BitVec 1)) (Rm : (BitVec 4)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.or (BEq.beq (DN ++ Rdn) (0xD : (BitVec 4))) (BEq.beq Rm (0xD : (BitVec 4))))
      then sailThrow ((Error_See "ADD (SP plus register)"))
      else (pure ())
      let d := (UInt0 (DN ++ Rdn))
      let n := d
      let m := (UInt0 Rm)
      let setflags : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.and (BEq.beq n 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq d 15) (← (InITBlock ())))
           (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADD_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_ADD_r_T3enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "CMN (register)"))
      else (pure ())
      bif (BEq.beq Rn (0xD : (BitVec 4)))
      then sailThrow ((Error_See "ADD (SP plus register)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (Bool.and (BEq.beq d 15) (Bool.not setflags)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADD_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ADD_rr_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read n)) shifted (0b0 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_aarch32_instrs_ADD_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:632.29-632.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADD_rr_Op_A_txt d m n s setflags shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, k_setflags : Bool, 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ADD_SP_i_Op_A_txt (d : Nat) (imm32 : (BitVec 32)) (setflags : Bool) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read 13)) imm32 (0b0 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_ADD_SP_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:685.29-685.30"
      let d := (UInt0 Rd)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      (execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_ADD_SP_i_T1enc_A_txt (Rd : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let setflags : Bool := false
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      (execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_ADD_SP_i_T2enc_A_txt (imm7 : (BitVec 7)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := 13
      let setflags : Bool := false
      let imm32 : (BitVec 32) := (zero_extend (imm7 ++ (0b00 : (BitVec 2))) 32)
      (execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_ADD_SP_i_T3enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "CMN (immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (T32ExpandImm ((i ++ imm3) ++ imm8)) ) : SailM (BitVec 32) )
      bif (Bool.and (BEq.beq d 15) (Bool.not setflags))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_ADD_SP_i_T4enc_A_txt (i : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let setflags : Bool := false
      let imm32 : (BitVec 32) := (zero_extend ((i ++ imm3) ++ imm8) 32)
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADD_SP_i_Op_A_txt d imm32 setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ m ∧
  m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ADD_SP_r_Op_A_txt (d : Nat) (m : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read 13)) shifted (0b0 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_ADD_SP_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:820.29-820.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_ADD_SP_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_ADD_SP_r_T1enc_A_txt (DM : (BitVec 1)) (Rdm : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 (DM ++ Rdm))
      let m := (UInt0 (DM ++ Rdm))
      let setflags : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.and (Bool.and (BEq.beq d 15) (← (InITBlock ())))
           (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_ADD_SP_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_ADD_SP_r_T2enc_A_txt (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rm (0xD : (BitVec 4)))
      then sailThrow ((Error_See "encoding T1"))
      else (pure ())
      let d := 13
      let m := (UInt0 Rm)
      let setflags : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_ADD_SP_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_ADD_SP_r_T3enc_A_txt (S : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "CMN (register)"))
      else (pure ())
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.and (BEq.beq d 15) (Bool.not setflags)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADD_SP_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, d : Nat, 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ADR_Op_A_txt (add : Bool) (d : Nat) (imm32 : (BitVec 32)) : SailM Unit := do
  let result ← (( do
    bif add
    then (pure ((Align_bits (← (PC_read__1 ())) 4) + imm32))
    else (pure ((Align_bits (← (PC_read__1 ())) 4) - imm32)) ) : SailM (BitVec 32) )
  bif (BEq.beq d 15)
  then (ALUWritePC result)
  else (R_set d result)

def decode_aarch32_instrs_ADR_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:951.29-951.30"
      let d := (UInt0 Rd)
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      let add : Bool := true
      (execute_aarch32_instrs_ADR_Op_A_txt add d imm32))
  else (pure ())

def decode_aarch32_instrs_ADR_A2enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:972.29-972.30"
      let d := (UInt0 Rd)
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      let add : Bool := false
      (execute_aarch32_instrs_ADR_Op_A_txt add d imm32))
  else (pure ())

def decode_aarch32_instrs_ADR_T1enc_A_txt (Rd : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let add : Bool := true
      (execute_aarch32_instrs_ADR_Op_A_txt add d imm32))
  else (pure ())

def decode_aarch32_instrs_ADR_T2enc_A_txt (i : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let imm32 : (BitVec 32) := (zero_extend ((i ++ imm3) ++ imm8) 32)
      let add : Bool := false
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADR_Op_A_txt add d imm32))
  else (pure ())

def decode_aarch32_instrs_ADR_T3enc_A_txt (i : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let imm32 : (BitVec 32) := (zero_extend ((i ++ imm3) ++ imm8) 32)
      let add : Bool := true
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ADR_Op_A_txt add d imm32))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_AND_i_Op_A_txt (carry : (BitVec 1)) (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let result ← (( do (pure ((← (R_read n)) &&& imm32)) ) : SailM (BitVec 32) )
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_AND_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1083.29-1083.30"
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (A32ExpandImm_C imm12 (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      (execute_aarch32_instrs_AND_i_Op_A_txt carry d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_AND_i_T1enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "TST (immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (T32ExpandImm_C ((i ++ imm3) ++ imm8) (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      bif (Bool.or (Bool.and (BEq.beq d 15) (Bool.not setflags)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_AND_i_Op_A_txt carry d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_AND_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) &&& shifted)) ) : SailM (BitVec 32) )
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_AND_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1167.29-1167.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_AND_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_AND_r_T1enc_A_txt (Rm : (BitVec 3)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_AND_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_AND_r_T2enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "TST (register)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (Bool.and (BEq.beq d 15) (Bool.not setflags)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_AND_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_AND_rr_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) &&& shifted)) ) : SailM (BitVec 32) )
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_AND_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1279.29-1279.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_AND_rr_Op_A_txt d m n s setflags shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_setflags : Bool, shift_n : Int, m ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ d ∈ {0, 1, 2, 3, 4, 5, 6, 7} -/
def execute_aarch32_instrs_ASR_i_Op_A_txt (d : Nat) (m : Nat) (setflags : Bool) (shift_n : Int) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) SRType_ASR shift_n (← readReg PSTATE).C)
  let result : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_ASR_i_T1enc_A_txt (imm5 : (BitVec 5)) (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let (_, __tup_1) ← do (DecodeImmShift (0b10 : (BitVec 2)) imm5)
      let shift_n : Int := __tup_1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_ASR_i_Op_A_txt d m setflags shift_n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, n ∈ {0, 1, 2, 3, 4, 5, 6, 7}
  ∧ m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ d ∈ {0, 1, 2, 3, 4, 5, 6, 7} -/
def execute_aarch32_instrs_ASR_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read m)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read n)) SRType_ASR shift_n (← readReg PSTATE).C)
  let result : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_ASR_r_T1enc_A_txt (Rm : (BitVec 3)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      (execute_aarch32_instrs_ASR_r_Op_A_txt d m n setflags))
  else (pure ())

def execute_aarch32_instrs_B_Op_A_txt (imm32 : (BitVec 32)) : SailM Unit := do
  (BranchWritePC ((← (PC_read__1 ())) + imm32) BranchType_DIR)

def decode_aarch32_instrs_B_A1enc_A_txt (cond : (BitVec 4)) (imm24 : (BitVec 24)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1401.29-1401.30"
      let imm32 : (BitVec 32) := (sign_extend (imm24 ++ (0b00 : (BitVec 2))) 32)
      (execute_aarch32_instrs_B_Op_A_txt imm32))
  else (pure ())

def decode_aarch32_instrs_B_T1enc_A_txt (cond : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1419.29-1419.30"
      bif (BEq.beq cond (0xE : (BitVec 4)))
      then sailThrow ((Error_See "UDF"))
      else (pure ())
      bif (BEq.beq cond (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SVC"))
      else (pure ())
      let imm32 : (BitVec 32) := (sign_extend (imm8 ++ (0b0 : (BitVec 1))) 32)
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_B_Op_A_txt imm32))
  else (pure ())

def decode_aarch32_instrs_B_T2enc_A_txt (imm11 : (BitVec 11)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 : (BitVec 32) := (sign_extend (imm11 ++ (0b0 : (BitVec 1))) 32)
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_B_Op_A_txt imm32))
  else (pure ())

def decode_aarch32_instrs_B_T3enc_A_txt (S : (BitVec 1)) (cond : (BitVec 4)) (imm6 : (BitVec 6)) (J1 : (BitVec 1)) (J2 : (BitVec 1)) (imm11 : (BitVec 11)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1465.29-1465.30"
      bif (BEq.beq (Sail.BitVec.extractLsb cond 3 1) (0b111 : (BitVec 3)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let imm32 : (BitVec 32) :=
        (sign_extend (((((S ++ J2) ++ J1) ++ imm6) ++ imm11) ++ (0b0 : (BitVec 1))) 32)
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_B_Op_A_txt imm32))
  else (pure ())

def decode_aarch32_instrs_B_T4enc_A_txt (S : (BitVec 1)) (imm10 : (BitVec 10)) (J1 : (BitVec 1)) (J2 : (BitVec 1)) (imm11 : (BitVec 11)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let I1 : (BitVec 1) := (Complement.complement (J1 ^^^ S))
      let I2 : (BitVec 1) := (Complement.complement (J2 ^^^ S))
      let imm32 : (BitVec 32) :=
        (sign_extend (((((S ++ I1) ++ I2) ++ imm10) ++ imm11) ++ (0b0 : (BitVec 1))) 32)
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_B_Op_A_txt imm32))
  else (pure ())

/-- Type quantifiers: d : Nat, lsbit : Nat, msbit : Nat, 0 ≤ msbit ∧
  msbit ≤ 31 ∧ 0 ≤ lsbit ∧ lsbit ≤ 31 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_BFC_Op_A_txt (d : Nat) (lsbit : Nat) (msbit : Nat) : SailM Unit := do
  assert (lsbit ≤b msbit) "src/instrs32.sail:1519.39-1519.40"
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) msbit lsbit
      (BitVec.replicateBits (0b0 : (BitVec 1)) ((msbit -i lsbit) +i 1))))

def decode_aarch32_instrs_BFC_A1enc_A_txt (cond : (BitVec 4)) (msb : (BitVec 5)) (Rd : (BitVec 4)) (lsb : (BitVec 5)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1527.29-1527.30"
      let d := (UInt0 Rd)
      let msbit := (UInt0 msb)
      let lsbit := (UInt0 lsb)
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (msbit <b lsbit)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BFC_Op_A_txt d lsbit msbit))
  else (pure ())

def decode_aarch32_instrs_BFC_T1enc_A_txt (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (msb : (BitVec 5)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let msbit := (UInt0 msb)
      let lsbit := (UInt0 (imm3 ++ imm2))
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (msbit <b lsbit)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BFC_Op_A_txt d lsbit msbit))
  else (pure ())

/-- Type quantifiers: d : Nat, lsbit : Nat, msbit : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ msbit ∧ msbit ≤ 31 ∧ 0 ≤ lsbit ∧ lsbit ≤ 31 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_BFI_Op_A_txt (d : Nat) (lsbit : Nat) (msbit : Nat) (n : Nat) : SailM Unit := do
  assert (0 ≤b (msbit -i lsbit)) "src/instrs32.sail:1587.43-1587.44"
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) msbit lsbit
      (Sail.BitVec.extractLsb (← (R_read n)) (msbit -i lsbit) 0)))

def decode_aarch32_instrs_BFI_A1enc_A_txt (cond : (BitVec 4)) (msb : (BitVec 5)) (Rd : (BitVec 4)) (lsb : (BitVec 5)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1595.29-1595.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "BFC"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let msbit := (UInt0 msb)
      let lsbit := (UInt0 lsb)
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (msbit <b lsbit)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BFI_Op_A_txt d lsbit msbit n))
  else (pure ())

def decode_aarch32_instrs_BFI_T1enc_A_txt (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (msb : (BitVec 5)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "BFC"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let msbit := (UInt0 msb)
      let lsbit := (UInt0 (imm3 ++ imm2))
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (msbit <b lsbit)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BFI_Op_A_txt d lsbit msbit n))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_BIC_i_Op_A_txt (carry : (BitVec 1)) (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let result ← (( do (pure ((← (R_read n)) &&& (Complement.complement imm32))) ) : SailM
    (BitVec 32) )
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_BIC_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1687.29-1687.30"
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (A32ExpandImm_C imm12 (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      (execute_aarch32_instrs_BIC_i_Op_A_txt carry d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_BIC_i_T1enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (T32ExpandImm_C ((i ++ imm3) ++ imm8) (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      let carry := carry
      (execute_aarch32_instrs_BIC_i_Op_A_txt carry d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_BIC_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) &&& (Complement.complement shifted))) ) : SailM
    (BitVec 32) )
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_BIC_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1770.29-1770.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_BIC_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_BIC_r_T1enc_A_txt (Rm : (BitVec 3)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_BIC_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_BIC_r_T2enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_BIC_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_BIC_rr_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) &&& (Complement.complement shifted))) ) : SailM
    (BitVec 32) )
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_BIC_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1881.29-1881.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BIC_rr_Op_A_txt d m n s setflags shift_t))
  else (pure ())

def execute_aarch32_instrs_BKPT_Op_A_txt (imm16 : (BitVec 16)) : SailM Unit := do
  (AArch32_SoftwareBreakpoint imm16)

def decode_aarch32_instrs_BKPT_A1enc_A_txt (cond : (BitVec 4)) (imm12 : (BitVec 12)) (imm4 : (BitVec 4)) : SailM Unit := do
  assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1917.25-1917.26"
  let imm16 : (BitVec 16) := (imm12 ++ imm4)
  bif (bne cond (0xE : (BitVec 4)))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_BKPT_Op_A_txt imm16)

def decode_aarch32_instrs_BKPT_T1enc_A_txt (imm8 : (BitVec 8)) : SailM Unit := do
  let imm16 : (BitVec 16) := (zero_extend imm8 16)
  (execute_aarch32_instrs_BKPT_Op_A_txt imm16)

def execute_aarch32_instrs_BL_i_Op_A_txt (imm32 : (BitVec 32)) (targetInstrSet : InstrSet) : SailM Unit := do
  bif (eq_any (← (CurrentInstrSet ())) InstrSet_A32)
  then (LR_write (sub_vec_int (← (PC_read__1 ())) 4))
  else (LR_write ((Sail.BitVec.extractLsb (← (PC_read__1 ())) 31 1) ++ (0b1 : (BitVec 1))))
  let targetAddress ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let targetAddress ← (( do
    bif (eq_any targetInstrSet InstrSet_A32)
    then
      (do
        (pure ((Align_bits (← (PC_read__1 ())) 4) + imm32)))
    else
      (do
        (pure ((← (PC_read__1 ())) + imm32))) ) : SailM (BitVec 32) )
  (SelectInstrSet targetInstrSet)
  (BranchWritePC targetAddress BranchType_DIRCALL)

def decode_aarch32_instrs_BL_i_A1enc_A_txt (cond : (BitVec 4)) (imm24 : (BitVec 24)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:1968.29-1968.30"
      let imm32 : (BitVec 32) := (sign_extend (imm24 ++ (0b00 : (BitVec 2))) 32)
      let targetInstrSet : InstrSet := InstrSet_A32
      (execute_aarch32_instrs_BL_i_Op_A_txt imm32 targetInstrSet))
  else (pure ())

def decode_aarch32_instrs_BL_i_A2enc_A_txt (H : (BitVec 1)) (imm24 : (BitVec 24)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 : (BitVec 32) := (sign_extend ((imm24 ++ H) ++ (0b0 : (BitVec 1))) 32)
      let targetInstrSet : InstrSet := InstrSet_T32
      (execute_aarch32_instrs_BL_i_Op_A_txt imm32 targetInstrSet))
  else (pure ())

def decode_aarch32_instrs_BL_i_T1enc_A_txt (S : (BitVec 1)) (imm10 : (BitVec 10)) (J1 : (BitVec 1)) (J2 : (BitVec 1)) (imm11 : (BitVec 11)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let I1 : (BitVec 1) := (Complement.complement (J1 ^^^ S))
      let I2 : (BitVec 1) := (Complement.complement (J2 ^^^ S))
      let imm32 : (BitVec 32) :=
        (sign_extend (((((S ++ I1) ++ I2) ++ imm10) ++ imm11) ++ (0b0 : (BitVec 1))) 32)
      let targetInstrSet : InstrSet := InstrSet_T32
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BL_i_Op_A_txt imm32 targetInstrSet))
  else (pure ())

def decode_aarch32_instrs_BL_i_T2enc_A_txt (S : (BitVec 1)) (imm10H : (BitVec 10)) (J1 : (BitVec 1)) (J2 : (BitVec 1)) (imm10L : (BitVec 10)) (H : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq H (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let I1 : (BitVec 1) := (Complement.complement (J1 ^^^ S))
      let I2 : (BitVec 1) := (Complement.complement (J2 ^^^ S))
      let imm32 : (BitVec 32) :=
        (sign_extend (((((S ++ I1) ++ I2) ++ imm10H) ++ imm10L) ++ (0b00 : (BitVec 2))) 32)
      let targetInstrSet : InstrSet := InstrSet_A32
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BL_i_Op_A_txt imm32 targetInstrSet))
  else (pure ())

/-- Type quantifiers: m : Nat, 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_BLX_r_Op_A_txt (m : Nat) : SailM Unit := do
  let target ← (( do (R_read m) ) : SailM (BitVec 32) )
  let next_instr_addr ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  bif (eq_any (← (CurrentInstrSet ())) InstrSet_A32)
  then
    (do
      let next_instr_addr ← (( do (pure (sub_vec_int (← (PC_read__1 ())) 4)) ) : SailM
        (BitVec 32) )
      (LR_write next_instr_addr))
  else
    (do
      let next_instr_addr ← (( do (pure (sub_vec_int (← (PC_read__1 ())) 2)) ) : SailM
        (BitVec 32) )
      (LR_write ((Sail.BitVec.extractLsb next_instr_addr 31 1) ++ (0b1 : (BitVec 1)))))
  (BXWritePC target BranchType_INDCALL)

def decode_aarch32_instrs_BLX_r_A1enc_A_txt (cond : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2077.29-2077.30"
      let m := (UInt0 Rm)
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BLX_r_Op_A_txt m))
  else (pure ())

def decode_aarch32_instrs_BLX_r_T1enc_A_txt (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m := (UInt0 Rm)
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BLX_r_Op_A_txt m))
  else (pure ())

/-- Type quantifiers: m : Nat, 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_BX_Op_A_txt (m : Nat) : SailM Unit := do
  (BXWritePC (← (R_read m)) BranchType_INDIR)

def decode_aarch32_instrs_BX_A1enc_A_txt (cond : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2135.29-2135.30"
      let m := (UInt0 Rm)
      (execute_aarch32_instrs_BX_Op_A_txt m))
  else (pure ())

def decode_aarch32_instrs_BX_T1enc_A_txt (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m := (UInt0 Rm)
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BX_Op_A_txt m))
  else (pure ())

/-- Type quantifiers: m : Nat, 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_BXJ_Op_A_txt (m : Nat) : SailM Unit := do
  (BXWritePC (← (R_read m)) BranchType_INDIR)

def decode_aarch32_instrs_BXJ_A1enc_A_txt (cond : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2187.29-2187.30"
      let m := (UInt0 Rm)
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BXJ_Op_A_txt m))
  else (pure ())

def decode_aarch32_instrs_BXJ_T1enc_A_txt (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m := (UInt0 Rm)
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_BXJ_Op_A_txt m))
  else (pure ())

/-- Type quantifiers: n : Nat, k_nonzero : Bool, n ∈ {0, 1, 2, 3, 4, 5, 6, 7} -/
def execute_aarch32_instrs_CBNZ_Op_A_txt (imm32 : (BitVec 32)) (n : Nat) (nonzero : Bool) : SailM Unit := do
  bif (neq_bool nonzero (IsZero (← (R_read n))))
  then (CBWritePC ((← (PC_read__1 ())) + imm32))
  else (pure ())

def decode_aarch32_instrs_CBNZ_T1enc_A_txt (op : (BitVec 1)) (i : (BitVec 1)) (imm5 : (BitVec 5)) (Rn : (BitVec 3)) : SailM Unit := do
  let n := (UInt0 Rn)
  let imm32 : (BitVec 32) := (zero_extend ((i ++ imm5) ++ (0b0 : (BitVec 1))) 32)
  let nonzero : Bool := (BEq.beq op (0b1 : (BitVec 1)))
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_CBNZ_Op_A_txt imm32 n nonzero)

def execute_aarch32_instrs_CLREX_Op_A_txt (_ : Unit) : Unit :=
  (ClearExclusiveLocal (ProcessorID ()))

def decode_aarch32_instrs_CLREX_A1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_CLREX_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_CLREX_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_CLREX_Op_A_txt ()))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_CLZ_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  let result ← do (pure (CountLeadingZeroBits (← (R_read m))))
  (R_set d (integer_subrange result 31 0))

def decode_aarch32_instrs_CLZ_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2321.29-2321.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_CLZ_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_CLZ_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (bne m n) (BEq.beq d 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_CLZ_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: n : Nat, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_CMN_i_Op_A_txt (imm32 : (BitVec 32)) (n : Nat) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read n)) imm32 (0b0 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }

def decode_aarch32_instrs_CMN_i_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2381.29-2381.30"
      let n := (UInt0 Rn)
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      (execute_aarch32_instrs_CMN_i_Op_A_txt imm32 n))
  else (pure ())

def decode_aarch32_instrs_CMN_i_T1enc_A_txt (i : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let imm32 ← (( do (T32ExpandImm ((i ++ imm3) ++ imm8)) ) : SailM (BitVec 32) )
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_CMN_i_Op_A_txt imm32 n))
  else (pure ())

/-- Type quantifiers: m : Nat, n : Nat, shift_n : Int, 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_CMN_r_Op_A_txt (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read n)) shifted (0b0 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }

def decode_aarch32_instrs_CMN_r_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2440.29-2440.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_CMN_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_CMN_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_CMN_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_CMN_r_T2enc_A_txt (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq n 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_CMN_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

/-- Type quantifiers: m : Nat, n : Nat, s : Nat, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_CMN_rr_Op_A_txt (m : Nat) (n : Nat) (s : Nat) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do (pure (AddWithCarry (← (R_read n)) shifted (0b0 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }

def decode_aarch32_instrs_CMN_rr_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2539.29-2539.30"
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (BEq.beq n 15) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_CMN_rr_Op_A_txt m n s shift_t))
  else (pure ())

/-- Type quantifiers: n : Nat, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_CMP_i_Op_A_txt (imm32 : (BitVec 32)) (n : Nat) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read n)) (Complement.complement imm32) (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }

def decode_aarch32_instrs_CMP_i_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2580.29-2580.30"
      let n := (UInt0 Rn)
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      (execute_aarch32_instrs_CMP_i_Op_A_txt imm32 n))
  else (pure ())

def decode_aarch32_instrs_CMP_i_T1enc_A_txt (Rn : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      (execute_aarch32_instrs_CMP_i_Op_A_txt imm32 n))
  else (pure ())

def decode_aarch32_instrs_CMP_i_T2enc_A_txt (i : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let imm32 ← (( do (T32ExpandImm ((i ++ imm3) ++ imm8)) ) : SailM (BitVec 32) )
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_CMP_i_Op_A_txt imm32 n))
  else (pure ())

/-- Type quantifiers: m : Nat, n : Nat, shift_n : Int, 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_CMP_r_Op_A_txt (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read n)) (Complement.complement shifted) (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }

def decode_aarch32_instrs_CMP_r_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2657.29-2657.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_CMP_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_CMP_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_CMP_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_CMP_r_T2enc_A_txt (N : (BitVec 1)) (Rm : (BitVec 4)) (Rn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 (N ++ Rn))
      let m := (UInt0 Rm)
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.and (n <b 8) (m <b 8))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq n 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_CMP_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_CMP_r_T3enc_A_txt (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq n 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_CMP_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

/-- Type quantifiers: m : Nat, n : Nat, s : Nat, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_CMP_rr_Op_A_txt (m : Nat) (n : Nat) (s : Nat) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read n)) (Complement.complement shifted) (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
  writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
  writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) }

def decode_aarch32_instrs_CMP_rr_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2787.29-2787.30"
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (BEq.beq n 15) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_CMP_rr_Op_A_txt m n s shift_t))
  else (pure ())

def execute_aarch32_instrs_DBG_Op_A_txt (_ : Unit) : Unit :=
  ()

def decode_aarch32_instrs_DBG_A1enc_A_txt (cond : (BitVec 4)) (option_name : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:2824.29-2824.30"
      (pure (execute_aarch32_instrs_DBG_Op_A_txt ())))
  else (pure ())

def decode_aarch32_instrs_DBG_T1enc_A_txt (option_name : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_DBG_Op_A_txt ()))
  else (pure ())

def execute_aarch32_instrs_DMB_Op_A_txt (option_name : (BitVec 4)) : SailM Unit := do
  let domain ← (( do (undefined_MBReqDomain ()) ) : SailM MBReqDomain )
  let types ← (( do (undefined_MBReqTypes ()) ) : SailM MBReqTypes )
  let _ : Unit :=
    let b__0 := option_name
    bif (BEq.beq b__0 (0x1 : (BitVec 4)))
    then
      (let domain : MBReqDomain := MBReqDomain_OuterShareable
      let types : MBReqTypes := MBReqTypes_Reads
      ())
    else
      (bif (BEq.beq b__0 (0x2 : (BitVec 4)))
      then
        (let domain : MBReqDomain := MBReqDomain_OuterShareable
        let types : MBReqTypes := MBReqTypes_Writes
        ())
      else
        (bif (BEq.beq b__0 (0x3 : (BitVec 4)))
        then
          (let domain : MBReqDomain := MBReqDomain_OuterShareable
          let types : MBReqTypes := MBReqTypes_All
          ())
        else
          (bif (BEq.beq b__0 (0x5 : (BitVec 4)))
          then
            (let domain : MBReqDomain := MBReqDomain_Nonshareable
            let types : MBReqTypes := MBReqTypes_Reads
            ())
          else
            (bif (BEq.beq b__0 (0x6 : (BitVec 4)))
            then
              (let domain : MBReqDomain := MBReqDomain_Nonshareable
              let types : MBReqTypes := MBReqTypes_Writes
              ())
            else
              (bif (BEq.beq b__0 (0x7 : (BitVec 4)))
              then
                (let domain : MBReqDomain := MBReqDomain_Nonshareable
                let types : MBReqTypes := MBReqTypes_All
                ())
              else
                (bif (BEq.beq b__0 (0x9 : (BitVec 4)))
                then
                  (let domain : MBReqDomain := MBReqDomain_InnerShareable
                  let types : MBReqTypes := MBReqTypes_Reads
                  ())
                else
                  (bif (BEq.beq b__0 (0xA : (BitVec 4)))
                  then
                    (let domain : MBReqDomain := MBReqDomain_InnerShareable
                    let types : MBReqTypes := MBReqTypes_Writes
                    ())
                  else
                    (bif (BEq.beq b__0 (0xB : (BitVec 4)))
                    then
                      (let domain : MBReqDomain := MBReqDomain_InnerShareable
                      let types : MBReqTypes := MBReqTypes_All
                      ())
                    else
                      (bif (BEq.beq b__0 (0xD : (BitVec 4)))
                      then
                        (let domain : MBReqDomain := MBReqDomain_FullSystem
                        let types : MBReqTypes := MBReqTypes_Reads
                        ())
                      else
                        (bif (BEq.beq b__0 (0xE : (BitVec 4)))
                        then
                          (let domain : MBReqDomain := MBReqDomain_FullSystem
                          let types : MBReqTypes := MBReqTypes_Writes
                          ())
                        else
                          (let domain : MBReqDomain := MBReqDomain_FullSystem
                          let types : MBReqTypes := MBReqTypes_All
                          ())))))))))))
  let types := types
  let domain ← (( do
    bif (Bool.and
         (Bool.or (BEq.beq (← readReg PSTATE).EL EL0) (BEq.beq (← readReg PSTATE).EL EL1))
         (← (EL2Enabled ())))
    then
      (do
        let domain ← (( do
          bif (BEq.beq (_get_HCR_Type_BSU (← (HCR_read ()))) (0b11 : (BitVec 2)))
          then (pure MBReqDomain_FullSystem)
          else (pure domain) ) : SailM MBReqDomain )
        let domain ← (( do
          bif (Bool.and (BEq.beq (_get_HCR_Type_BSU (← (HCR_read ()))) (0b10 : (BitVec 2)))
               (neq_any domain MBReqDomain_FullSystem))
          then (pure MBReqDomain_OuterShareable)
          else (pure domain) ) : SailM MBReqDomain )
        bif (Bool.and (BEq.beq (_get_HCR_Type_BSU (← (HCR_read ()))) (0b01 : (BitVec 2)))
             (eq_any domain MBReqDomain_Nonshareable))
        then (pure MBReqDomain_InnerShareable)
        else (pure domain))
    else (pure domain) ) : SailM MBReqDomain )
  (DataMemoryBarrier domain types)

def decode_aarch32_instrs_DMB_A1enc_A_txt (option_name : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_DMB_Op_A_txt option_name)
  else (pure ())

def decode_aarch32_instrs_DMB_T1enc_A_txt (option_name : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_DMB_Op_A_txt option_name)
  else (pure ())

def execute_aarch32_instrs_DSB_Op_A_txt (option_name : (BitVec 4)) : SailM Unit := do
  let nXS ← (( do (undefined_bool ()) ) : SailM Bool )
  let nXS ← (( do
    bif (← (HaveFeatXS ()))
    then
      (do
        (pure (Bool.and
            (Bool.and
              (Bool.and
                (Bool.or (BEq.beq (← readReg PSTATE).EL EL0) (BEq.beq (← readReg PSTATE).EL EL1))
                (Bool.not (← (ELUsingAArch32 EL2)))) (← (IsHCRXEL2Enabled ())))
            (BEq.beq (_get_HCRX_EL2_Type_FnXS (← readReg HCRX_EL2)) (0b1 : (BitVec 1))))))
    else (pure false) ) : SailM Bool )
  let domain ← (( do (undefined_MBReqDomain ()) ) : SailM MBReqDomain )
  let types ← (( do (undefined_MBReqTypes ()) ) : SailM MBReqTypes )
  let b__0 := option_name
  bif (BEq.beq b__0 (0x1 : (BitVec 4)))
  then
    (let domain : MBReqDomain := MBReqDomain_OuterShareable
    let types : MBReqTypes := MBReqTypes_Reads
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0x2 : (BitVec 4)))
      then
        (let domain : MBReqDomain := MBReqDomain_OuterShareable
        let types : MBReqTypes := MBReqTypes_Writes
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0x3 : (BitVec 4)))
          then
            (let domain : MBReqDomain := MBReqDomain_OuterShareable
            let types : MBReqTypes := MBReqTypes_All
            (pure ()))
          else
            (do
              bif (BEq.beq b__0 (0x5 : (BitVec 4)))
              then
                (let domain : MBReqDomain := MBReqDomain_Nonshareable
                let types : MBReqTypes := MBReqTypes_Reads
                (pure ()))
              else
                (do
                  bif (BEq.beq b__0 (0x6 : (BitVec 4)))
                  then
                    (let domain : MBReqDomain := MBReqDomain_Nonshareable
                    let types : MBReqTypes := MBReqTypes_Writes
                    (pure ()))
                  else
                    (do
                      bif (BEq.beq b__0 (0x7 : (BitVec 4)))
                      then
                        (let domain : MBReqDomain := MBReqDomain_Nonshareable
                        let types : MBReqTypes := MBReqTypes_All
                        (pure ()))
                      else
                        (do
                          bif (BEq.beq b__0 (0x9 : (BitVec 4)))
                          then
                            (let domain : MBReqDomain := MBReqDomain_InnerShareable
                            let types : MBReqTypes := MBReqTypes_Reads
                            (pure ()))
                          else
                            (do
                              bif (BEq.beq b__0 (0xA : (BitVec 4)))
                              then
                                (let domain : MBReqDomain := MBReqDomain_InnerShareable
                                let types : MBReqTypes := MBReqTypes_Writes
                                (pure ()))
                              else
                                (do
                                  bif (BEq.beq b__0 (0xB : (BitVec 4)))
                                  then
                                    (let domain : MBReqDomain := MBReqDomain_InnerShareable
                                    let types : MBReqTypes := MBReqTypes_All
                                    (pure ()))
                                  else
                                    (do
                                      bif (BEq.beq b__0 (0xD : (BitVec 4)))
                                      then
                                        (let domain : MBReqDomain := MBReqDomain_FullSystem
                                        let types : MBReqTypes := MBReqTypes_Reads
                                        (pure ()))
                                      else
                                        (do
                                          bif (BEq.beq b__0 (0xE : (BitVec 4)))
                                          then
                                            (let domain : MBReqDomain := MBReqDomain_FullSystem
                                            let types : MBReqTypes := MBReqTypes_Writes
                                            (pure ()))
                                          else
                                            (do
                                              assert (Bool.not
                                                (let b__11 := option_name
                                                bif (Bool.and
                                                     (BEq.beq (Sail.BitVec.extractLsb b__11 3 3)
                                                       (0b0 : (BitVec 1)))
                                                     (BEq.beq (Sail.BitVec.extractLsb b__11 1 0)
                                                       (0b00 : (BitVec 2))))
                                                then true
                                                else false : Bool)) "src/instrs32.sail:3029.20-3029.21"
                                              let domain : MBReqDomain := MBReqDomain_FullSystem
                                              let types : MBReqTypes := MBReqTypes_All
                                              (pure ()))))))))))))
  let types := types
  let domain ← (( do
    bif (Bool.and
         (Bool.or (BEq.beq (← readReg PSTATE).EL EL0) (BEq.beq (← readReg PSTATE).EL EL1))
         (← (EL2Enabled ())))
    then
      (do
        let domain ← (( do
          bif (BEq.beq (_get_HCR_Type_BSU (← (HCR_read ()))) (0b11 : (BitVec 2)))
          then (pure MBReqDomain_FullSystem)
          else (pure domain) ) : SailM MBReqDomain )
        let domain ← (( do
          bif (Bool.and (BEq.beq (_get_HCR_Type_BSU (← (HCR_read ()))) (0b10 : (BitVec 2)))
               (neq_any domain MBReqDomain_FullSystem))
          then (pure MBReqDomain_OuterShareable)
          else (pure domain) ) : SailM MBReqDomain )
        bif (Bool.and (BEq.beq (_get_HCR_Type_BSU (← (HCR_read ()))) (0b01 : (BitVec 2)))
             (eq_any domain MBReqDomain_Nonshareable))
        then (pure MBReqDomain_InnerShareable)
        else (pure domain))
    else (pure domain) ) : SailM MBReqDomain )
  (DataSynchronizationBarrier domain types nXS)

def decode_aarch32_instrs_DSB_A1enc_A_txt (option_name : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_DSB_Op_A_txt option_name)
  else (pure ())

def decode_aarch32_instrs_DSB_T1enc_A_txt (option_name : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_DSB_Op_A_txt option_name)
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_EOR_i_Op_A_txt (carry : (BitVec 1)) (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let result ← (( do (pure ((← (R_read n)) ^^^ imm32)) ) : SailM (BitVec 32) )
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_EOR_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:3115.29-3115.30"
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (A32ExpandImm_C imm12 (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      (execute_aarch32_instrs_EOR_i_Op_A_txt carry d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_EOR_i_T1enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "TEQ (immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (T32ExpandImm_C ((i ++ imm3) ++ imm8) (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      bif (Bool.or (Bool.and (BEq.beq d 15) (Bool.not setflags)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_EOR_i_Op_A_txt carry d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_EOR_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) ^^^ shifted)) ) : SailM (BitVec 32) )
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_EOR_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:3199.29-3199.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_EOR_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_EOR_r_T1enc_A_txt (Rm : (BitVec 3)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_EOR_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_EOR_r_T2enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "TEQ (register)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (Bool.and (BEq.beq d 15) (Bool.not setflags)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_EOR_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_EOR_rr_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) ^^^ shifted)) ) : SailM (BitVec 32) )
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_EOR_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:3311.29-3311.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_EOR_rr_Op_A_txt d m n s setflags shift_t))
  else (pure ())

def execute_aarch32_instrs_ISB_Op_A_txt (_ : Unit) : SailM Unit := do
  (InstructionSynchronizationBarrier ())

def decode_aarch32_instrs_ISB_A1enc_A_txt (option_name : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_ISB_Op_A_txt ())
  else (pure ())

def decode_aarch32_instrs_ISB_T1enc_A_txt (option_name : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_ISB_Op_A_txt ())
  else (pure ())

def execute_aarch32_instrs_IT_Op_A_txt (firstcond : (BitVec 4)) (mask : (BitVec 4)) : SailM Unit := do
  (AArch32_CheckITEnabled mask)
  writeReg PSTATE { (← readReg PSTATE) with IT := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).IT 7 0 (firstcond ++ mask)) }
  writeReg ShouldAdvanceIT false

def decode_aarch32_instrs_IT_T1enc_A_txt (firstcond : (BitVec 4)) (mask : (BitVec 4)) : SailM Unit := do
  bif (BEq.beq mask (0x0 : (BitVec 4)))
  then sailThrow ((Error_See "Related encodings"))
  else (pure ())
  bif (Bool.or (BEq.beq firstcond (0xF : (BitVec 4)))
       (Bool.and (BEq.beq firstcond (0xE : (BitVec 4))) (bne (BitCount mask) 1)))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_IT_Op_A_txt firstcond mask)

/-- Type quantifiers: k_add : Bool, cp : Nat, k_index : Bool, n : Nat, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ cp = 14 -/
def execute_aarch32_instrs_LDC_i_Op_A_txt (add : Bool) (cp : Nat) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  (AArch32_SysRegWriteM cp (← (ThisInstr ())) address)
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_LDC_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:3431.29-3431.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDC (literal)"))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let n := (UInt0 Rn)
      let cp := 14
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_LDC_i_Op_A_txt add cp imm32 index n wback))
  else (pure ())

def decode_aarch32_instrs_LDC_i_T1enc_A_txt (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDC (literal)"))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let n := (UInt0 Rn)
      let cp := 14
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_LDC_i_Op_A_txt add cp imm32 index n wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, cp : Nat, k_index : Bool, cp = 14 -/
def execute_aarch32_instrs_LDC_l_Op_A_txt (add : Bool) (cp : Nat) (imm32 : (BitVec 32)) (index : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((Align_bits (← (PC_read__1 ())) 4) + imm32))
    else (pure ((Align_bits (← (PC_read__1 ())) 4) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (pure (Align_bits (← (PC_read__1 ())) 4)) ) : SailM (BitVec 32) )
  (AArch32_SysRegWriteM cp (← (ThisInstr ())) address)

def decode_aarch32_instrs_LDC_l_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:3507.29-3507.30"
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let cp := 14
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      bif (Bool.or (BEq.beq W (0b1 : (BitVec 1)))
           (Bool.and (BEq.beq P (0b0 : (BitVec 1)))
             (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDC_l_Op_A_txt add cp imm32 index))
  else (pure ())

def decode_aarch32_instrs_LDC_l_T1enc_A_txt (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let cp := 14
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      bif (Bool.or (BEq.beq W (0b1 : (BitVec 1)))
           (Bool.and (BEq.beq P (0b0 : (BitVec 1)))
             (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDC_l_Op_A_txt add cp imm32 index))
  else (pure ())

/-- Type quantifiers: n : Nat, k_wback : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDM_Op_A_txt (n : Nat) (registers : (BitVec 16)) (wback : Bool) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 14
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
        then
          (do
            (R_set i (← (MemS_read address 4)))
            (pure (BitVec.addInt address 4)))
        else (pure address)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
  then (LoadWritePC (← (MemS_read address 4)))
  else (pure ())
  bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b0 : (BitVec 1))))
  then (R_set n (BitVec.addInt (← (R_read n)) (4 *i (BitCount registers))))
  else (pure ())
  bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
  then (R_set n (← (__UNKNOWN_bits 32)))
  else (pure ())

def decode_aarch32_instrs_LDM_A1enc_A_txt (cond : (BitVec 4)) (W : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 16)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:3589.29-3589.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := register_list
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 1))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDM_Op_A_txt n registers wback))
  else (pure ())

def decode_aarch32_instrs_LDM_T1enc_A_txt (Rn : (BitVec 3)) (register_list : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := ((0x00 : (BitVec 8)) ++ register_list)
      let wback : Bool := (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b0 : (BitVec 1)))
      bif ((BitCount registers) <b 1)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDM_Op_A_txt n registers wback))
  else (pure ())

def decode_aarch32_instrs_LDM_T2enc_A_txt (W : (BitVec 1)) (Rn : (BitVec 4)) (P : (BitVec 1)) (M : (BitVec 1)) (register_list : (BitVec 14)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := ((P ++ M) ++ register_list)
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq n 15) ((BitCount registers) <b 2))
           (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq M (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access registers 13)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and
           (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
             (← (InITBlock ()))) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDM_Op_A_txt n registers wback))
  else (pure ())

/-- Type quantifiers: n : Nat, k_wback : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDMDA_Op_A_txt (n : Nat) (registers : (BitVec 16)) (wback : Bool) : SailM Unit := do
  let address ← (( do
    (pure (BitVec.addInt (sub_vec_int (← (R_read n)) (4 *i (BitCount registers))) 4)) ) : SailM
    (BitVec 32) )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 14
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
        then
          (do
            (R_set i (← (MemS_read address 4)))
            (pure (BitVec.addInt address 4)))
        else (pure address)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
  then (LoadWritePC (← (MemS_read address 4)))
  else (pure ())
  bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b0 : (BitVec 1))))
  then (R_set n (sub_vec_int (← (R_read n)) (4 *i (BitCount registers))))
  else (pure ())
  bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
  then (R_set n (← (__UNKNOWN_bits 32)))
  else (pure ())

def decode_aarch32_instrs_LDMDA_A1enc_A_txt (cond : (BitVec 4)) (W : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 16)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:3697.29-3697.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := register_list
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 1))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDMDA_Op_A_txt n registers wback))
  else (pure ())

/-- Type quantifiers: n : Nat, k_wback : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDMDB_Op_A_txt (n : Nat) (registers : (BitVec 16)) (wback : Bool) : SailM Unit := do
  let address ← (( do (pure (sub_vec_int (← (R_read n)) (4 *i (BitCount registers)))) ) : SailM
    (BitVec 32) )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 14
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
        then
          (do
            (R_set i (← (MemS_read address 4)))
            (pure (BitVec.addInt address 4)))
        else (pure address)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
  then (LoadWritePC (← (MemS_read address 4)))
  else (pure ())
  bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b0 : (BitVec 1))))
  then (R_set n (sub_vec_int (← (R_read n)) (4 *i (BitCount registers))))
  else (pure ())
  bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
  then (R_set n (← (__UNKNOWN_bits 32)))
  else (pure ())

def decode_aarch32_instrs_LDMDB_A1enc_A_txt (cond : (BitVec 4)) (W : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 16)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:3749.29-3749.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := register_list
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 1))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDMDB_Op_A_txt n registers wback))
  else (pure ())

def decode_aarch32_instrs_LDMDB_T1enc_A_txt (W : (BitVec 1)) (Rn : (BitVec 4)) (P : (BitVec 1)) (M : (BitVec 1)) (register_list : (BitVec 14)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := ((P ++ M) ++ register_list)
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq n 15) ((BitCount registers) <b 2))
           (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq M (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access registers 13)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and
           (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
             (← (InITBlock ()))) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDMDB_Op_A_txt n registers wback))
  else (pure ())

/-- Type quantifiers: n : Nat, k_wback : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDMIB_Op_A_txt (n : Nat) (registers : (BitVec 16)) (wback : Bool) : SailM Unit := do
  let address ← (( do (pure (BitVec.addInt (← (R_read n)) 4)) ) : SailM (BitVec 32) )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 14
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
        then
          (do
            (R_set i (← (MemS_read address 4)))
            (pure (BitVec.addInt address 4)))
        else (pure address)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
  then (LoadWritePC (← (MemS_read address 4)))
  else (pure ())
  bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b0 : (BitVec 1))))
  then (R_set n (BitVec.addInt (← (R_read n)) (4 *i (BitCount registers))))
  else (pure ())
  bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
  then (R_set n (← (__UNKNOWN_bits 32)))
  else (pure ())

def decode_aarch32_instrs_LDMIB_A1enc_A_txt (cond : (BitVec 4)) (W : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 16)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:3835.29-3835.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := register_list
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 1))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDMIB_Op_A_txt n registers wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRB_i_OpA_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 1 false t false)
    else ()
  (R_set t (zero_extend (← (MemU_read address 1)) 32))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_LDRB_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:3881.29-3881.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRB (literal)"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRBT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.or (BEq.beq t 15) (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRB_i_OpA_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRB_i_OpT_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 1 false t false)
    else ()
  (R_set t (zero_extend (← (MemU_read address 1)) 32))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_LDRB_i_T1enc_A_txt (imm5 : (BitVec 5)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm5 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_LDRB_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDRB_i_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLD"))
      else (pure ())
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRB (literal)"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_LDRB_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDRB_i_T3enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and
           (Bool.and (Bool.and (BEq.beq Rt (0xF : (BitVec 4))) (BEq.beq P (0b1 : (BitVec 1))))
             (BEq.beq U (0b0 : (BitVec 1)))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "PLD, PLDW (immediate)"))
      else (pure ())
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRB (literal)"))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq U (0b1 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "LDRBT"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.and (BEq.beq t 15) (BEq.beq W (0b1 : (BitVec 1))))
           (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRB_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, t : Nat, 0 ≤ t ∧ t ≤ 15 -/
def execute_aarch32_instrs_LDRB_l_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (t : Nat) : SailM Unit := do
  let base ← (( do (pure (Align_bits (← (PC_read__1 ())) 4)) ) : SailM (BitVec 32) )
  let address : (BitVec 32) :=
    bif add
    then (base + imm32)
    else (base - imm32)
  let _ : Unit :=
    bif (bne t 15)
    then (AArch32_SetLSInstructionSyndrome 1 false t false)
    else ()
  (R_set t (zero_extend (← (MemU_read address 1)) 32))

def decode_aarch32_instrs_LDRB_l_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4041.29-4041.30"
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRBT"))
      else (pure ())
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.or (BEq.beq t 15) wback)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRB_l_Op_A_txt add imm32 t))
  else (pure ())

def decode_aarch32_instrs_LDRB_l_T1enc_A_txt (U : (BitVec 1)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLD"))
      else (pure ())
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_LDRB_l_Op_A_txt add imm32 t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, m : Nat, n : Nat, shift_n : Int, t : Nat, k_wback
  : Bool, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_LDRB_r_Op_A_txt (add : Bool) (index : Bool) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 1 false t false)
    else ()
  (R_set t (zero_extend (← (MemU_read address 1)) 32))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_LDRB_r_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4114.29-4114.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRBT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq t 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRB_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_LDRB_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_LDRB_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_LDRB_r_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm2 : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLD"))
      else (pure ())
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRB (literal)"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, (UInt0 imm2)) : (SRType × Int))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRB_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, m : Int, n : Nat, k_postindex : Bool, k_register_form : Bool, shift_n
  : Int, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRBT_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (m : Int) (n : Nat) (postindex : Bool) (register_form : Bool) (shift_n : Int) (shift_t : SRType) (t : Nat) : SailM Unit := do
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let offset ← (( do
    bif register_form
    then (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
    else (pure imm32) ) : SailM (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif postindex
    then (R_read n)
    else (pure offset_addr) ) : SailM (BitVec 32) )
  bif (Bool.and (Bool.and (Bool.not postindex) (bne t 15))
       (BEq.beq (← readReg PSTATE).T (0b1 : (BitVec 1))))
  then (pure (AArch32_SetLSInstructionSyndrome 1 false t false))
  else (pure ())
  (R_set t (zero_extend (← (MemU_unpriv_read address 1)) 32))
  bif postindex
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_LDRBT_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4246.29-4246.30"
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      (execute_aarch32_instrs_LDRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

def decode_aarch32_instrs_LDRBT_A2enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4281.29-4281.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := true
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_LDRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

def decode_aarch32_instrs_LDRBT_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRB (literal)"))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := false
      let add : Bool := true
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, t2 : Nat, k_wback : Bool, 0
  ≤ t2 ∧ t2 ≤ 16 ∧ 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRD_i_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (t2 : Nat) (wback : Bool) : SailM Unit := do
  let data ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  bif (IsAligned__1 address 8)
  then
    (do
      let data ← (( do (MemA_read address 8) ) : SailM (BitVec 64) )
      bif (← (BigEndian AccessType_GPR))
      then
        (do
          (R_set t (Sail.BitVec.extractLsb data 63 32))
          (R_set t2 (Sail.BitVec.extractLsb data 31 0)))
      else
        (do
          (R_set t (Sail.BitVec.extractLsb data 31 0))
          (R_set t2 (Sail.BitVec.extractLsb data 63 32))))
  else
    (do
      (R_set t (← (MemA_read address 4)))
      (R_set t2 (← (MemA_read (BitVec.addInt address 4) 4))))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_LDRD_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4383.29-4383.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRD (literal)"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Rt 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let t := (UInt0 Rt)
      let t2 := (t +i 1)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n t) (BEq.beq n t2)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq t2 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRD_i_Op_A_txt add imm32 index n t t2 wback))
  else (pure ())

def decode_aarch32_instrs_LDRD_i_T1enc_A_txt (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rt2 : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRD (literal)"))
      else (pure ())
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.and wback (Bool.or (BEq.beq n t) (BEq.beq n t2)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq t2 15)) (BEq.beq t t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRD_i_Op_A_txt add imm32 index n t t2 wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, t : Nat, t2 : Nat, 0 ≤ t2 ∧
  t2 ≤ 16 ∧ 0 ≤ t ∧ t ≤ 15 -/
def execute_aarch32_instrs_LDRD_l_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (t : Nat) (t2 : Nat) : SailM Unit := do
  let data ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let address ← (( do
    bif add
    then (pure ((Align_bits (← (PC_read__1 ())) 4) + imm32))
    else (pure ((Align_bits (← (PC_read__1 ())) 4) - imm32)) ) : SailM (BitVec 32) )
  bif (IsAligned__1 address 8)
  then
    (do
      let data ← (( do (MemA_read address 8) ) : SailM (BitVec 64) )
      bif (← (BigEndian AccessType_GPR))
      then
        (do
          (R_set t (Sail.BitVec.extractLsb data 63 32))
          (R_set t2 (Sail.BitVec.extractLsb data 31 0)))
      else
        (do
          (R_set t (Sail.BitVec.extractLsb data 31 0))
          (R_set t2 (Sail.BitVec.extractLsb data 63 32))))
  else
    (do
      (R_set t (← (MemA_read address 4)))
      (R_set t2 (← (MemA_read (BitVec.addInt address 4) 4))))

def decode_aarch32_instrs_LDRD_l_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4491.29-4491.30"
      bif (BEq.beq (BitVec.join1 [(BitVec.access Rt 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let t := (UInt0 Rt)
      let t2 := (t +i 1)
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      bif (BEq.beq t2 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRD_l_Op_A_txt add imm32 t t2))
  else (pure ())

def decode_aarch32_instrs_LDRD_l_T1enc_A_txt (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rt : (BitVec 4)) (Rt2 : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq t2 15)) (BEq.beq t t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq W (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRD_l_Op_A_txt add imm32 t t2))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, m : Nat, n : Nat, t : Nat, t2 : Nat, k_wback :
  Bool, 1 ≤ t2 ∧
  t2 ≤ 16 ∧ 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_LDRD_r_Op_A_txt (add : Bool) (index : Bool) (m : Nat) (n : Nat) (t : Nat) (t2 : Nat) (wback : Bool) : SailM Unit := do
  let data ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + (← (R_read m))))
    else (pure ((← (R_read n)) - (← (R_read m)))) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  bif (IsAligned__1 address 8)
  then
    (do
      let data ← (( do (MemA_read address 8) ) : SailM (BitVec 64) )
      bif (← (BigEndian AccessType_GPR))
      then
        (do
          (R_set t (Sail.BitVec.extractLsb data 63 32))
          (R_set t2 (Sail.BitVec.extractLsb data 31 0)))
      else
        (do
          (R_set t (Sail.BitVec.extractLsb data 31 0))
          (R_set t2 (Sail.BitVec.extractLsb data 63 32))))
  else
    (do
      (R_set t (← (MemA_read address 4)))
      (R_set t2 (← (MemA_read (BitVec.addInt address 4) 4))))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_LDRD_r_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4586.29-4586.30"
      bif (BEq.beq (BitVec.join1 [(BitVec.access Rt 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let t := (UInt0 Rt)
      let t2 := (t +i 1)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (Bool.or (BEq.beq t2 15) (BEq.beq m 15)) (BEq.beq m t)) (BEq.beq m t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (Bool.or (BEq.beq n 15) (BEq.beq n t)) (BEq.beq n t2)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRD_r_Op_A_txt add index m n t t2 wback))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDREX_Op_A_txt (imm32 : (BitVec 32)) (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (pure ((← (R_read n)) + imm32)) ) : SailM (BitVec 32) )
  (AArch32_SetExclusiveMonitors address 4)
  (R_set t (← (MemA_read address 4)))

def decode_aarch32_instrs_LDREX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4641.29-4641.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (Zeros (n := 32))
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDREX_Op_A_txt imm32 n t))
  else (pure ())

def decode_aarch32_instrs_LDREX_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDREX_Op_A_txt imm32 n t))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDREXB_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  (AArch32_SetExclusiveMonitors address 1)
  (R_set t (zero_extend (← (MemA_read address 1)) 32))

def decode_aarch32_instrs_LDREXB_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4706.29-4706.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDREXB_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_LDREXB_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDREXB_Op_A_txt n t))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, t2 : Nat, 0 ≤ t2 ∧
  t2 ≤ 16 ∧ 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDREXD_Op_A_txt (n : Nat) (t : Nat) (t2 : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  (AArch32_SetExclusiveMonitors address 8)
  let value_name ← (( do (MemA_read address 8) ) : SailM (BitVec 64) )
  (R_set t
    (← do
      bif (← (BigEndian AccessType_GPR))
      then (pure (Sail.BitVec.extractLsb value_name 63 32))
      else (pure (Sail.BitVec.extractLsb value_name 31 0))))
  (R_set t2
    (← do
      bif (← (BigEndian AccessType_GPR))
      then (pure (Sail.BitVec.extractLsb value_name 31 0))
      else (pure (Sail.BitVec.extractLsb value_name 63 32))))

def decode_aarch32_instrs_LDREXD_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4772.29-4772.30"
      let t := (UInt0 Rt)
      let t2 := (t +i 1)
      let n := (UInt0 Rn)
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Rt 0)]) (0b1 : (BitVec 1)))
             (BEq.beq t2 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDREXD_Op_A_txt n t t2))
  else (pure ())

def decode_aarch32_instrs_LDREXD_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rt2 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq t2 15)) (BEq.beq t t2)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDREXD_Op_A_txt n t t2))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDREXH_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  (AArch32_SetExclusiveMonitors address 2)
  (R_set t (zero_extend (← (MemA_read address 2)) 32))

def decode_aarch32_instrs_LDREXH_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4837.29-4837.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDREXH_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_LDREXH_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDREXH_Op_A_txt n t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRH_i_OpA_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 2 false t false)
    else ()
  let data ← (( do (MemU_read address 2) ) : SailM (BitVec 16) )
  bif wback
  then (R_set n offset_addr)
  else (pure ())
  (R_set t (zero_extend data 32))

def decode_aarch32_instrs_LDRH_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:4907.29-4907.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRH (literal)"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRHT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.or (BEq.beq t 15) (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRH_i_OpA_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRH_i_OpT_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 2 false t false)
    else ()
  let data ← (( do (MemU_read address 2) ) : SailM (BitVec 16) )
  bif wback
  then (R_set n offset_addr)
  else (pure ())
  (R_set t (zero_extend data 32))

def decode_aarch32_instrs_LDRH_i_T1enc_A_txt (imm5 : (BitVec 5)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm5 ++ (0b0 : (BitVec 1))) 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_LDRH_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDRH_i_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLD (immediate)"))
      else (pure ())
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRH (literal)"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_LDRH_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDRH_i_T3enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRH (literal)"))
      else (pure ())
      bif (Bool.and
           (Bool.and (Bool.and (BEq.beq Rt (0xF : (BitVec 4))) (BEq.beq P (0b1 : (BitVec 1))))
             (BEq.beq U (0b0 : (BitVec 1)))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "PLDW (immediate)"))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq U (0b1 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "LDRHT"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.and (BEq.beq t 15) (BEq.beq W (0b1 : (BitVec 1))))
           (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRH_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, t : Nat, 0 ≤ t ∧ t ≤ 15 -/
def execute_aarch32_instrs_LDRH_l_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (t : Nat) : SailM Unit := do
  let base ← (( do (pure (Align_bits (← (PC_read__1 ())) 4)) ) : SailM (BitVec 32) )
  let address : (BitVec 32) :=
    bif add
    then (base + imm32)
    else (base - imm32)
  let _ : Unit :=
    bif (bne t 15)
    then (AArch32_SetLSInstructionSyndrome 2 false t false)
    else ()
  let data ← (( do (MemU_read address 2) ) : SailM (BitVec 16) )
  (R_set t (zero_extend data 32))

def decode_aarch32_instrs_LDRH_l_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:5069.29-5069.30"
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRHT"))
      else (pure ())
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.or (BEq.beq t 15) wback)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRH_l_Op_A_txt add imm32 t))
  else (pure ())

def decode_aarch32_instrs_LDRH_l_T1enc_A_txt (U : (BitVec 1)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLD (literal)"))
      else (pure ())
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_LDRH_l_Op_A_txt add imm32 t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, m : Nat, n : Nat, shift_n : Int, t : Nat, k_wback
  : Bool, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_LDRH_r_Op_A_txt (add : Bool) (index : Bool) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (bne t 15)
    then (AArch32_SetLSInstructionSyndrome 2 false t false)
    else ()
  let data ← (( do (MemU_read address 2) ) : SailM (BitVec 16) )
  bif wback
  then (R_set n offset_addr)
  else (pure ())
  (R_set t (zero_extend data 32))

def decode_aarch32_instrs_LDRH_r_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:5143.29-5143.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRHT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.or (BEq.beq t 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRH_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_LDRH_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_LDRH_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_LDRH_r_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm2 : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRH (literal)"))
      else (pure ())
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLDW (register)"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, (UInt0 imm2)) : (SRType × Int))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRH_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, m : Int, n : Nat, k_postindex : Bool, k_register_form : Bool, t
  : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRHT_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (m : Int) (n : Nat) (postindex : Bool) (register_form : Bool) (t : Nat) : SailM Unit := do
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let offset ← (( do
    bif register_form
    then (R_read m)
    else (pure imm32) ) : SailM (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif postindex
    then (R_read n)
    else (pure offset_addr) ) : SailM (BitVec 32) )
  bif (Bool.and (Bool.and (Bool.not postindex) (bne t 15))
       (BEq.beq (← readReg PSTATE).T (0b1 : (BitVec 1))))
  then (pure (AArch32_SetLSInstructionSyndrome 2 false t false))
  else (pure ())
  let data ← (( do (MemU_unpriv_read address 2) ) : SailM (BitVec 16) )
  bif postindex
  then (R_set n offset_addr)
  else (pure ())
  (R_set t (zero_extend data 32))

def decode_aarch32_instrs_LDRHT_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:5274.29-5274.30"
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      (execute_aarch32_instrs_LDRHT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

def decode_aarch32_instrs_LDRHT_A2enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:5310.29-5310.30"
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := true
      bif (Bool.or (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      (execute_aarch32_instrs_LDRHT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

def decode_aarch32_instrs_LDRHT_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRH (literal)"))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := false
      let add : Bool := true
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRHT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDR_i_OpA_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 4 false t false)
    else ()
  let data ← (( do (MemU_read address 4) ) : SailM (BitVec 32) )
  bif wback
  then (R_set n offset_addr)
  else (pure ())
  bif (BEq.beq t 15)
  then
    (do
      bif (BEq.beq (Sail.BitVec.extractLsb address 1 0) (0b00 : (BitVec 2)))
      then (LoadWritePC data)
      else sailThrow ((Error_Unpredictable ())))
  else (R_set t data)

def decode_aarch32_instrs_LDR_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:5406.29-5406.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDR (literal)"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.and wback (BEq.beq n t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDR_i_OpA_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDR_i_OpT_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 4 false t false)
    else ()
  let data ← (( do (MemU_read address 4) ) : SailM (BitVec 32) )
  bif wback
  then (R_set n offset_addr)
  else (pure ())
  bif (BEq.beq t 15)
  then
    (do
      bif (BEq.beq (Sail.BitVec.extractLsb address 1 0) (0b00 : (BitVec 2)))
      then (LoadWritePC data)
      else sailThrow ((Error_Unpredictable ())))
  else (R_set t data)

def decode_aarch32_instrs_LDR_i_T1enc_A_txt (imm5 : (BitVec 5)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm5 ++ (0b00 : (BitVec 2))) 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_LDR_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDR_i_T2enc_A_txt (Rt : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := 13
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_LDR_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDR_i_T3enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDR (literal)"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      bif (Bool.and (Bool.and (BEq.beq t 15) (← (InITBlock ())))
           (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDR_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDR_i_T4enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDR (literal)"))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq U (0b1 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "LDRT"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.and wback (BEq.beq n t))
           (Bool.and (Bool.and (BEq.beq t 15) (← (InITBlock ())))
             (Bool.not (← (LastInITBlock ())))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDR_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, t : Nat, 0 ≤ t ∧ t ≤ 15 -/
def execute_aarch32_instrs_LDR_l_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (t : Nat) : SailM Unit := do
  let base ← (( do (pure (Align_bits (← (PC_read__1 ())) 4)) ) : SailM (BitVec 32) )
  let address : (BitVec 32) :=
    bif add
    then (base + imm32)
    else (base - imm32)
  let _ : Unit :=
    bif (bne t 15)
    then (AArch32_SetLSInstructionSyndrome 4 false t false)
    else ()
  let data ← (( do (MemU_read address 4) ) : SailM (BitVec 32) )
  bif (BEq.beq t 15)
  then
    (do
      bif (BEq.beq (Sail.BitVec.extractLsb address 1 0) (0b00 : (BitVec 2)))
      then (LoadWritePC data)
      else sailThrow ((Error_Unpredictable ())))
  else (R_set t data)

def decode_aarch32_instrs_LDR_l_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:5602.29-5602.30"
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRT"))
      else (pure ())
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif wback
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDR_l_Op_A_txt add imm32 t))
  else (pure ())

def decode_aarch32_instrs_LDR_l_T1enc_A_txt (Rt : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let add : Bool := true
      (execute_aarch32_instrs_LDR_l_Op_A_txt add imm32 t))
  else (pure ())

def decode_aarch32_instrs_LDR_l_T2enc_A_txt (U : (BitVec 1)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      bif (Bool.and (Bool.and (BEq.beq t 15) (← (InITBlock ())))
           (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDR_l_Op_A_txt add imm32 t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, m : Nat, n : Nat, shift_n : Int, t : Nat, k_wback
  : Bool, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_LDR_r_OpA_A_txt (add : Bool) (index : Bool) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 4 false t false)
    else ()
  let data ← (( do (MemU_read address 4) ) : SailM (BitVec 32) )
  bif wback
  then (R_set n offset_addr)
  else (pure ())
  bif (BEq.beq t 15)
  then
    (do
      bif (BEq.beq (Sail.BitVec.extractLsb address 1 0) (0b00 : (BitVec 2)))
      then (LoadWritePC data)
      else sailThrow ((Error_Unpredictable ())))
  else (R_set t data)

def decode_aarch32_instrs_LDR_r_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:5702.29-5702.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDR_r_OpA_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

/-- Type quantifiers: m : Nat, n : Nat, shift_n : Int, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_LDR_r_OpT_A_txt (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) (t : Nat) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let offset_addr ← (( do (pure ((← (R_read n)) + offset)) ) : SailM (BitVec 32) )
  let address : (BitVec 32) := offset_addr
  let _ : Unit :=
    bif (bne t 15)
    then (AArch32_SetLSInstructionSyndrome 4 false t false)
    else ()
  let data ← (( do (MemU_read address 4) ) : SailM (BitVec 32) )
  bif (BEq.beq t 15)
  then
    (do
      bif (BEq.beq (Sail.BitVec.extractLsb address 1 0) (0b00 : (BitVec 2)))
      then (LoadWritePC data)
      else sailThrow ((Error_Unpredictable ())))
  else (R_set t data)

def decode_aarch32_instrs_LDR_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_LDR_r_OpT_A_txt m n shift_n shift_t t))
  else (pure ())

def decode_aarch32_instrs_LDR_r_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm2 : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDR (literal)"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, (UInt0 imm2)) : (SRType × Int))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq t 15) (← (InITBlock ())))
           (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDR_r_OpT_A_txt m n shift_n shift_t t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRSB_i_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 1 true t false)
    else ()
  (R_set t (sign_extend (← (MemU_read address 1)) 32))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_LDRSB_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:5844.29-5844.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRSB (literal)"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRSBT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.or (BEq.beq t 15) (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSB_i_Op_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDRSB_i_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLI"))
      else (pure ())
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRSB (literal)"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_LDRSB_i_Op_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDRSB_i_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and
           (Bool.and (Bool.and (BEq.beq Rt (0xF : (BitVec 4))) (BEq.beq P (0b1 : (BitVec 1))))
             (BEq.beq U (0b0 : (BitVec 1)))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "PLI"))
      else (pure ())
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRSB (literal)"))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq U (0b1 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "LDRSBT"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.and (BEq.beq t 15) (BEq.beq W (0b1 : (BitVec 1))))
           (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSB_i_Op_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, t : Nat, 0 ≤ t ∧ t ≤ 15 -/
def execute_aarch32_instrs_LDRSB_l_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (t : Nat) : SailM Unit := do
  let base ← (( do (pure (Align_bits (← (PC_read__1 ())) 4)) ) : SailM (BitVec 32) )
  let address : (BitVec 32) :=
    bif add
    then (base + imm32)
    else (base - imm32)
  let _ : Unit :=
    bif (bne t 15)
    then (AArch32_SetLSInstructionSyndrome 1 true t false)
    else ()
  (R_set t (sign_extend (← (MemU_read address 1)) 32))

def decode_aarch32_instrs_LDRSB_l_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:5964.29-5964.30"
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRSBT"))
      else (pure ())
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.or (BEq.beq t 15) wback)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSB_l_Op_A_txt add imm32 t))
  else (pure ())

def decode_aarch32_instrs_LDRSB_l_T1enc_A_txt (U : (BitVec 1)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLI"))
      else (pure ())
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_LDRSB_l_Op_A_txt add imm32 t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, m : Nat, n : Nat, shift_n : Int, t : Nat, k_wback
  : Bool, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_LDRSB_r_Op_A_txt (add : Bool) (index : Bool) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 1 true t false)
    else ()
  (R_set t (sign_extend (← (MemU_read address 1)) 32))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_LDRSB_r_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:6038.29-6038.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRSBT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.or (BEq.beq t 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSB_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_LDRSB_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_LDRSB_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_LDRSB_r_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm2 : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLI"))
      else (pure ())
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRSB (literal)"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, (UInt0 imm2)) : (SRType × Int))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSB_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, m : Int, n : Nat, k_postindex : Bool, k_register_form : Bool, t
  : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRSBT_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (m : Int) (n : Nat) (postindex : Bool) (register_form : Bool) (t : Nat) : SailM Unit := do
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let offset ← (( do
    bif register_form
    then (R_read m)
    else (pure imm32) ) : SailM (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif postindex
    then (R_read n)
    else (pure offset_addr) ) : SailM (BitVec 32) )
  bif (Bool.and (Bool.and (Bool.not postindex) (bne t 15))
       (BEq.beq (← readReg PSTATE).T (0b1 : (BitVec 1))))
  then (pure (AArch32_SetLSInstructionSyndrome 1 true t false))
  else (pure ())
  (R_set t (sign_extend (← (MemU_unpriv_read address 1)) 32))
  bif postindex
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_LDRSBT_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:6169.29-6169.30"
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      (execute_aarch32_instrs_LDRSBT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

def decode_aarch32_instrs_LDRSBT_A2enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:6205.29-6205.30"
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := true
      bif (Bool.or (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      (execute_aarch32_instrs_LDRSBT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

def decode_aarch32_instrs_LDRSBT_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRSB (literal)"))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := false
      let add : Bool := true
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSBT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRSH_i_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 2 true t false)
    else ()
  let data ← (( do (MemU_read address 2) ) : SailM (BitVec 16) )
  bif wback
  then (R_set n offset_addr)
  else (pure ())
  (R_set t (sign_extend data 32))

def decode_aarch32_instrs_LDRSH_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:6293.29-6293.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRSH (literal)"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRSHT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.or (BEq.beq t 15) (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSH_i_Op_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDRSH_i_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRSH (literal)"))
      else (pure ())
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "Related instructions"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_LDRSH_i_Op_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_LDRSH_i_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRSH (literal)"))
      else (pure ())
      bif (Bool.and
           (Bool.and (Bool.and (BEq.beq Rt (0xF : (BitVec 4))) (BEq.beq P (0b1 : (BitVec 1))))
             (BEq.beq U (0b0 : (BitVec 1)))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related instructions"))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq U (0b1 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "LDRSHT"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.and (BEq.beq t 15) (BEq.beq W (0b1 : (BitVec 1))))
           (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSH_i_Op_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, t : Nat, 0 ≤ t ∧ t ≤ 15 -/
def execute_aarch32_instrs_LDRSH_l_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (t : Nat) : SailM Unit := do
  let base ← (( do (pure (Align_bits (← (PC_read__1 ())) 4)) ) : SailM (BitVec 32) )
  let address : (BitVec 32) :=
    bif add
    then (base + imm32)
    else (base - imm32)
  let _ : Unit :=
    bif (bne t 15)
    then (AArch32_SetLSInstructionSyndrome 2 true t false)
    else ()
  let data ← (( do (MemU_read address 2) ) : SailM (BitVec 16) )
  (R_set t (sign_extend data 32))

def decode_aarch32_instrs_LDRSH_l_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:6414.29-6414.30"
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRSHT"))
      else (pure ())
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.or (BEq.beq t 15) wback)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSH_l_Op_A_txt add imm32 t))
  else (pure ())

def decode_aarch32_instrs_LDRSH_l_T1enc_A_txt (U : (BitVec 1)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "Related instructions"))
      else (pure ())
      let t := (UInt0 Rt)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_LDRSH_l_Op_A_txt add imm32 t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, m : Nat, n : Nat, shift_n : Int, t : Nat, k_wback
  : Bool, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_LDRSH_r_Op_A_txt (add : Bool) (index : Bool) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 2 true t false)
    else ()
  let data ← (( do (MemU_read address 2) ) : SailM (BitVec 16) )
  bif wback
  then (R_set n offset_addr)
  else (pure ())
  (R_set t (sign_extend data 32))

def decode_aarch32_instrs_LDRSH_r_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:6488.29-6488.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "LDRSHT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.or (BEq.beq t 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSH_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_LDRSH_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_LDRSH_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_LDRSH_r_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm2 : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRSH (literal)"))
      else (pure ())
      bif (BEq.beq Rt (0xF : (BitVec 4)))
      then sailThrow ((Error_See "Related instructions"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, (UInt0 imm2)) : (SRType × Int))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSH_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, m : Int, n : Nat, k_postindex : Bool, k_register_form : Bool, t
  : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRSHT_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (m : Int) (n : Nat) (postindex : Bool) (register_form : Bool) (t : Nat) : SailM Unit := do
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let offset ← (( do
    bif register_form
    then (R_read m)
    else (pure imm32) ) : SailM (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif postindex
    then (R_read n)
    else (pure offset_addr) ) : SailM (BitVec 32) )
  bif (Bool.and (Bool.and (Bool.not postindex) (bne t 15))
       (BEq.beq (← readReg PSTATE).T (0b1 : (BitVec 1))))
  then (pure (AArch32_SetLSInstructionSyndrome 2 true t false))
  else (pure ())
  let data ← (( do (MemU_unpriv_read address 2) ) : SailM (BitVec 16) )
  bif postindex
  then (R_set n offset_addr)
  else (pure ())
  (R_set t (sign_extend data 32))

def decode_aarch32_instrs_LDRSHT_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:6619.29-6619.30"
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      (execute_aarch32_instrs_LDRSHT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

def decode_aarch32_instrs_LDRSHT_A2enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:6655.29-6655.30"
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := true
      bif (Bool.or (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      (execute_aarch32_instrs_LDRSHT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

def decode_aarch32_instrs_LDRSHT_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDRSH (literal)"))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := false
      let add : Bool := true
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRSHT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, m : Int, n : Nat, k_postindex : Bool, k_register_form : Bool, shift_n
  : Int, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDRT_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (m : Int) (n : Nat) (postindex : Bool) (register_form : Bool) (shift_n : Int) (shift_t : SRType) (t : Nat) : SailM Unit := do
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let offset ← (( do
    bif register_form
    then (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
    else (pure imm32) ) : SailM (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif postindex
    then (R_read n)
    else (pure offset_addr) ) : SailM (BitVec 32) )
  bif (Bool.and (Bool.and (Bool.not postindex) (bne t 15))
       (BEq.beq (← readReg PSTATE).T (0b1 : (BitVec 1))))
  then (pure (AArch32_SetLSInstructionSyndrome 4 false t false))
  else (pure ())
  let data ← (( do (MemU_unpriv_read address 4) ) : SailM (BitVec 32) )
  bif postindex
  then (R_set n offset_addr)
  else (pure ())
  (R_set t data)

def decode_aarch32_instrs_LDRT_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:6750.29-6750.30"
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      (execute_aarch32_instrs_LDRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

def decode_aarch32_instrs_LDRT_A2enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:6785.29-6785.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := true
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_LDRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

def decode_aarch32_instrs_LDRT_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "LDR (literal)"))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := false
      let add : Bool := true
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_setflags : Bool, shift_n : Int, m ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ d ∈ {0, 1, 2, 3, 4, 5, 6, 7} -/
def execute_aarch32_instrs_LSL_i_Op_A_txt (d : Nat) (m : Nat) (setflags : Bool) (shift_n : Int) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) SRType_LSL shift_n (← readReg PSTATE).C)
  let result : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_LSL_i_T1enc_A_txt (imm5 : (BitVec 5)) (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      bif (BEq.beq imm5 (0b00000 : (BitVec 5)))
      then sailThrow ((Error_See "MOV (register)"))
      else (pure ())
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let (_, __tup_1) ← do (DecodeImmShift (0b00 : (BitVec 2)) imm5)
      let shift_n : Int := __tup_1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_LSL_i_Op_A_txt d m setflags shift_n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_LSL_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read m)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read n)) SRType_LSL shift_n (← readReg PSTATE).C)
  let result : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_LSL_r_T1enc_A_txt (Rm : (BitVec 3)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      (execute_aarch32_instrs_LSL_r_Op_A_txt d m n setflags))
  else (pure ())

def decode_aarch32_instrs_LSL_r_T2enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LSL_r_Op_A_txt d m n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_setflags : Bool, shift_n : Int, m ∈
  {0, 1, 2, 3, 4, 5, 6, 7} ∧ d ∈ {0, 1, 2, 3, 4, 5, 6, 7} -/
def execute_aarch32_instrs_LSR_i_Op_A_txt (d : Nat) (m : Nat) (setflags : Bool) (shift_n : Int) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) SRType_LSR shift_n (← readReg PSTATE).C)
  let result : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_LSR_i_T1enc_A_txt (imm5 : (BitVec 5)) (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let (_, __tup_1) ← do (DecodeImmShift (0b01 : (BitVec 2)) imm5)
      let shift_n : Int := __tup_1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_LSR_i_Op_A_txt d m setflags shift_n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, n ∈ {0, 1, 2, 3, 4, 5, 6, 7}
  ∧ m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ d ∈ {0, 1, 2, 3, 4, 5, 6, 7} -/
def execute_aarch32_instrs_LSR_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read m)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read n)) SRType_LSR shift_n (← readReg PSTATE).C)
  let result : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_LSR_r_T1enc_A_txt (Rm : (BitVec 3)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      (execute_aarch32_instrs_LSR_r_Op_A_txt d m n setflags))
  else (pure ())

/-- Type quantifiers: cp : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ cp ∈ {14, 15} -/
def execute_aarch32_instrs_MCR_Op_A_txt (cp : Nat) (t : Nat) : SailM Unit := do
  (AArch32_SysRegWrite cp (← (ThisInstr ())) t)

def decode_aarch32_instrs_MCR_A1enc_A_txt (cond : (BitVec 4)) (opc1 : (BitVec 3)) (CRn : (BitVec 4)) (Rt : (BitVec 4)) (coproc : (BitVec 1)) (opc2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7065.29-7065.30"
      let t := (UInt0 Rt)
      let cp :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access coproc 0)]) (0b0 : (BitVec 1)))
        then 14
        else 15
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MCR_Op_A_txt cp t))
  else (pure ())

def decode_aarch32_instrs_MCR_T1enc_A_txt (opc1 : (BitVec 3)) (CRn : (BitVec 4)) (Rt : (BitVec 4)) (coproc : (BitVec 1)) (opc2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let cp :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access coproc 0)]) (0b0 : (BitVec 1)))
        then 14
        else 15
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MCR_Op_A_txt cp t))
  else (pure ())

/-- Type quantifiers: cp : Nat, t : Nat, t2 : Nat, 0 ≤ t2 ∧
  t2 ≤ 15 ∧ 0 ≤ t ∧ t ≤ 15 ∧ cp ∈ {14, 15} -/
def execute_aarch32_instrs_MCRR_Op_A_txt (cp : Nat) (t : Nat) (t2 : Nat) : SailM Unit := do
  (AArch32_SysRegWrite64 cp (← (ThisInstr ())) t t2)

def decode_aarch32_instrs_MCRR_A1enc_A_txt (cond : (BitVec 4)) (Rt2 : (BitVec 4)) (Rt : (BitVec 4)) (coproc : (BitVec 1)) (opc1 : (BitVec 4)) (CRm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7125.29-7125.30"
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let cp :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access coproc 0)]) (0b0 : (BitVec 1)))
        then 14
        else 15
      bif (Bool.or (BEq.beq t 15) (BEq.beq t2 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MCRR_Op_A_txt cp t t2))
  else (pure ())

def decode_aarch32_instrs_MCRR_T1enc_A_txt (Rt2 : (BitVec 4)) (Rt : (BitVec 4)) (coproc : (BitVec 1)) (opc1 : (BitVec 4)) (CRm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let cp :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access coproc 0)]) (0b0 : (BitVec 1)))
        then 14
        else 15
      bif (Bool.or (BEq.beq t 15) (BEq.beq t2 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MCRR_Op_A_txt cp t t2))
  else (pure ())

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ 0 ≤ a ∧ a ≤ 15 -/
def execute_aarch32_instrs_MLA_Op_A_txt (a : Nat) (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let operand1 ← do (pure (sint (← (R_read n))))
  let operand2 ← do (pure (sint (← (R_read m))))
  let addend ← do (pure (sint (← (R_read a))))
  let result := ((operand1 *i operand2) +i addend)
  (R_set d (integer_subrange result 31 0))
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(integer_access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit (integer_subrange result 31 0)) })
  else (pure ())

def decode_aarch32_instrs_MLA_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7194.29-7194.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MLA_Op_A_txt a d m n setflags))
  else (pure ())

def decode_aarch32_instrs_MLA_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "MUL"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let setflags : Bool := false
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MLA_Op_A_txt a d m n setflags))
  else (pure ())

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ 0 ≤ a ∧ a ≤ 15 -/
def execute_aarch32_instrs_MLS_Op_A_txt (a : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let operand1 ← do (pure (sint (← (R_read n))))
  let operand2 ← do (pure (sint (← (R_read m))))
  let addend ← do (pure (sint (← (R_read a))))
  let result := (addend -i (operand1 *i operand2))
  (R_set d (integer_subrange result 31 0))

def decode_aarch32_instrs_MLS_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7264.29-7264.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MLS_Op_A_txt a d m n))
  else (pure ())

def decode_aarch32_instrs_MLS_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MLS_Op_A_txt a d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, k_setflags : Bool, 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_MOV_i_Op_A_txt (carry : (BitVec 1)) (d : Nat) (imm32 : (BitVec 32)) (setflags : Bool) : SailM Unit := do
  let result : (BitVec 32) := imm32
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_MOV_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7338.29-7338.30"
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let d := (UInt0 Rd)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (A32ExpandImm_C imm12 (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      (execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_MOV_i_A2enc_A_txt (cond : (BitVec 4)) (imm4 : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7366.29-7366.30"
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let d := (UInt0 Rd)
      let setflags : Bool := false
      let imm32 : (BitVec 32) := (zero_extend (imm4 ++ imm12) 32)
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let carry := carry
      (execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_MOV_i_T1enc_A_txt (Rd : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let carry ← (( do (pure (← readReg PSTATE).C) ) : SailM (BitVec 1) )
      (execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_MOV_i_T2enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let d := (UInt0 Rd)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (T32ExpandImm_C ((i ++ imm3) ++ imm8) (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      let carry := carry
      (execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_MOV_i_T3enc_A_txt (i : (BitVec 1)) (imm4 : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let d := (UInt0 Rd)
      let setflags : Bool := false
      let imm32 : (BitVec 32) := (zero_extend (((imm4 ++ i) ++ imm3) ++ imm8) 32)
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let carry := carry
      (execute_aarch32_instrs_MOV_i_Op_A_txt carry d imm32 setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ m ∧
  m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_MOV_r_Op_A_txt (d : Nat) (m : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result : (BitVec 32) := shifted
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_MOV_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7495.29-7495.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_MOV_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_MOV_r_T1enc_A_txt (D : (BitVec 1)) (Rm : (BitVec 4)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 (D ++ Rd))
      let m := (UInt0 Rm)
      let setflags : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.and (Bool.and (BEq.beq d 15) (← (InITBlock ())))
           (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_MOV_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_MOV_r_T2enc_A_txt (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags : Bool := true
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_MOV_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_MOV_r_T3enc_A_txt (S : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_MOV_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_MOV_rr_Op_A_txt (d : Nat) (m : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let result : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_MOV_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7638.29-7638.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MOV_rr_Op_A_txt d m s setflags shift_t))
  else (pure ())

def decode_aarch32_instrs_MOV_rr_T1enc_A_txt (op : (BitVec 4)) (Rs : (BitVec 3)) (Rdm : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not
           (Bool.or (BEq.beq op (0x2 : (BitVec 4)))
             (Bool.or (BEq.beq op (0x3 : (BitVec 4)))
               (Bool.or (BEq.beq op (0x4 : (BitVec 4))) (BEq.beq op (0x7 : (BitVec 4)))))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let d := (UInt0 Rdm)
      let m := (UInt0 Rdm)
      let s := (UInt0 Rs)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let shift_t ← (( do
        (DecodeRegShift
          ((BitVec.join1 [(BitVec.access op 2)]) ++ (BitVec.join1 [(BitVec.access op 0)]))) ) :
        SailM SRType )
      (execute_aarch32_instrs_MOV_rr_Op_A_txt d m s setflags shift_t))
  else (pure ())

def decode_aarch32_instrs_MOV_rr_T2enc_A_txt (stype : (BitVec 2)) (S : (BitVec 1)) (Rm : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MOV_rr_Op_A_txt d m s setflags shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_MOVT_Op_A_txt (d : Nat) (imm16 : (BitVec 16)) : SailM Unit := do
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 imm16))

def decode_aarch32_instrs_MOVT_A1enc_A_txt (cond : (BitVec 4)) (imm4 : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7730.29-7730.30"
      let d := (UInt0 Rd)
      let imm16 : (BitVec 16) := (imm4 ++ imm12)
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MOVT_Op_A_txt d imm16))
  else (pure ())

def decode_aarch32_instrs_MOVT_T1enc_A_txt (i : (BitVec 1)) (imm4 : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let imm16 : (BitVec 16) := (((imm4 ++ i) ++ imm3) ++ imm8)
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MOVT_Op_A_txt d imm16))
  else (pure ())

/-- Type quantifiers: cp : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ cp ∈ {14, 15} -/
def execute_aarch32_instrs_MRC_Op_A_txt (cp : Nat) (t : Nat) : SailM Unit := do
  bif (Bool.or (bne t 15) (← (AArch32_SysRegReadCanWriteAPSR cp (← (ThisInstr ())))))
  then (AArch32_SysRegRead__1 cp (← (ThisInstr ())) t)
  else sailThrow ((Error_Unpredictable ()))

def decode_aarch32_instrs_MRC_A1enc_A_txt (cond : (BitVec 4)) (opc1 : (BitVec 3)) (CRn : (BitVec 4)) (Rt : (BitVec 4)) (coproc : (BitVec 1)) (opc2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7790.29-7790.30"
      let t := (UInt0 Rt)
      let cp :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access coproc 0)]) (0b0 : (BitVec 1)))
        then 14
        else 15
      (execute_aarch32_instrs_MRC_Op_A_txt cp t))
  else (pure ())

def decode_aarch32_instrs_MRC_T1enc_A_txt (opc1 : (BitVec 3)) (CRn : (BitVec 4)) (Rt : (BitVec 4)) (coproc : (BitVec 1)) (opc2 : (BitVec 3)) (CRm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let cp :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access coproc 0)]) (0b0 : (BitVec 1)))
        then 14
        else 15
      (execute_aarch32_instrs_MRC_Op_A_txt cp t))
  else (pure ())

/-- Type quantifiers: cp : Nat, t : Nat, t2 : Nat, 0 ≤ t2 ∧
  t2 ≤ 15 ∧ 0 ≤ t ∧ t ≤ 15 ∧ cp ∈ {14, 15} -/
def execute_aarch32_instrs_MRRC_Op_A_txt (cp : Nat) (t : Nat) (t2 : Nat) : SailM Unit := do
  (AArch32_SysRegRead64 cp (← (ThisInstr ())) t t2)

def decode_aarch32_instrs_MRRC_A1enc_A_txt (cond : (BitVec 4)) (Rt2 : (BitVec 4)) (Rt : (BitVec 4)) (coproc : (BitVec 1)) (opc1 : (BitVec 4)) (CRm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7844.29-7844.30"
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let cp :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access coproc 0)]) (0b0 : (BitVec 1)))
        then 14
        else 15
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq t2 15)) (BEq.beq t t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MRRC_Op_A_txt cp t t2))
  else (pure ())

def decode_aarch32_instrs_MRRC_T1enc_A_txt (Rt2 : (BitVec 4)) (Rt : (BitVec 4)) (coproc : (BitVec 1)) (opc1 : (BitVec 4)) (CRm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let cp :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access coproc 0)]) (0b0 : (BitVec 1)))
        then 14
        else 15
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq t2 15)) (BEq.beq t t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MRRC_Op_A_txt cp t t2))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_MUL_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let operand1 ← do (pure (sint (← (R_read n))))
  let operand2 ← do (pure (sint (← (R_read m))))
  let result := (operand1 *i operand2)
  (R_set d (integer_subrange result 31 0))
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(integer_access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit (integer_subrange result 31 0)) })
  else (pure ())

def decode_aarch32_instrs_MUL_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:7912.29-7912.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MUL_Op_A_txt d m n setflags))
  else (pure ())

def decode_aarch32_instrs_MUL_T1enc_A_txt (Rn : (BitVec 3)) (Rdm : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rdm)
      let n := (UInt0 Rn)
      let m := (UInt0 Rdm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      (execute_aarch32_instrs_MUL_Op_A_txt d m n setflags))
  else (pure ())

def decode_aarch32_instrs_MUL_T2enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := false
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MUL_Op_A_txt d m n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, k_setflags : Bool, 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_MVN_i_Op_A_txt (carry : (BitVec 1)) (d : Nat) (imm32 : (BitVec 32)) (setflags : Bool) : SailM Unit := do
  let result : (BitVec 32) := (Complement.complement imm32)
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_MVN_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:8009.29-8009.30"
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let d := (UInt0 Rd)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (A32ExpandImm_C imm12 (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      (execute_aarch32_instrs_MVN_i_Op_A_txt carry d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_MVN_i_T1enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let d := (UInt0 Rd)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (T32ExpandImm_C ((i ++ imm3) ++ imm8) (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      let carry := carry
      (execute_aarch32_instrs_MVN_i_Op_A_txt carry d imm32 setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ m ∧
  m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_MVN_r_Op_A_txt (d : Nat) (m : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result : (BitVec 32) := (Complement.complement shifted)
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_MVN_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:8092.29-8092.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_MVN_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_MVN_r_T1enc_A_txt (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_MVN_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_MVN_r_T2enc_A_txt (S : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_MVN_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_MVN_rr_Op_A_txt (d : Nat) (m : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result : (BitVec 32) := (Complement.complement shifted)
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_MVN_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:8202.29-8202.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MVN_rr_Op_A_txt d m s setflags shift_t))
  else (pure ())

def execute_aarch32_instrs_NOP_Op_A_txt (_ : Unit) : Unit :=
  ()

def decode_aarch32_instrs_NOP_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:8241.29-8241.30"
      (pure (execute_aarch32_instrs_NOP_Op_A_txt ())))
  else (pure ())

def decode_aarch32_instrs_NOP_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_NOP_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_NOP_T2enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_NOP_Op_A_txt ()))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ORN_i_Op_A_txt (carry : (BitVec 1)) (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let result ← (( do (pure ((← (R_read n)) ||| (Complement.complement imm32))) ) : SailM
    (BitVec 32) )
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_ORN_i_T1enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "MVN (immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (T32ExpandImm_C ((i ++ imm3) ++ imm8) (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ORN_i_Op_A_txt carry d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ORN_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) ||| (Complement.complement shifted))) ) : SailM
    (BitVec 32) )
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_ORN_r_T1enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "MVN (register)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ORN_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ORR_i_Op_A_txt (carry : (BitVec 1)) (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let result ← (( do (pure ((← (R_read n)) ||| imm32)) ) : SailM (BitVec 32) )
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_ORR_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:8420.29-8420.30"
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (A32ExpandImm_C imm12 (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      (execute_aarch32_instrs_ORR_i_Op_A_txt carry d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_ORR_i_T1enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "MOV (immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (T32ExpandImm_C ((i ++ imm3) ++ imm8) (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ORR_i_Op_A_txt carry d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ORR_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) ||| shifted)) ) : SailM (BitVec 32) )
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
          writeReg PSTATE { (← readReg PSTATE) with C := carry })
      else (pure ()))

def decode_aarch32_instrs_ORR_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:8504.29-8504.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_ORR_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_ORR_r_T1enc_A_txt (Rm : (BitVec 3)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_ORR_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_ORR_r_T2enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ORR_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_ORR_rr_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) ||| shifted)) ) : SailM (BitVec 32) )
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_ORR_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:8616.29-8616.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ORR_rr_Op_A_txt d m n s setflags shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, shift_n : Int, k_tbform : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_PKH_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) (tbform : Bool) : SailM Unit := do
  let operand2 ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 15 0
      (← do
        bif tbform
        then (pure (Sail.BitVec.extractLsb operand2 15 0))
        else (pure (Sail.BitVec.extractLsb (← (R_read n)) 15 0)))))
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 31 16
      (← do
        bif tbform
        then (pure (Sail.BitVec.extractLsb (← (R_read n)) 31 16))
        else (pure (Sail.BitVec.extractLsb operand2 31 16)))))

def decode_aarch32_instrs_PKH_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (tb : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:8660.29-8660.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let tbform : Bool := (BEq.beq tb (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift (tb ++ (0b0 : (BitVec 1))) imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_PKH_Op_A_txt d m n shift_n shift_t tbform))
  else (pure ())

def decode_aarch32_instrs_PKH_T1enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (tb : (BitVec 1)) (T : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.or (BEq.beq S (0b1 : (BitVec 1))) (BEq.beq T (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let tbform : Bool := (BEq.beq tb (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift (tb ++ (0b0 : (BitVec 1))) (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_PKH_Op_A_txt d m n shift_n shift_t tbform))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_is_pldw : Bool, n : Nat, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_PLD_i_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (is_pldw : Bool) (n : Nat) : SailM Unit := do
  let address ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  bif is_pldw
  then (pure (Hint_PreloadDataForWrite address))
  else (pure (Hint_PreloadData address))

def decode_aarch32_instrs_PLD_i_A1enc_A_txt (U : (BitVec 1)) (R : (BitVec 1)) (Rn : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLD (literal)"))
      else (pure ())
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let is_pldw : Bool := (BEq.beq R (0b0 : (BitVec 1)))
      (execute_aarch32_instrs_PLD_i_Op_A_txt add imm32 is_pldw n))
  else (pure ())

def decode_aarch32_instrs_PLD_i_T1enc_A_txt (W : (BitVec 1)) (Rn : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLD (literal)"))
      else (pure ())
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := true
      let is_pldw : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_PLD_i_Op_A_txt add imm32 is_pldw n))
  else (pure ())

def decode_aarch32_instrs_PLD_i_T2enc_A_txt (W : (BitVec 1)) (Rn : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLD (literal)"))
      else (pure ())
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let add : Bool := false
      let is_pldw : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_PLD_i_Op_A_txt add imm32 is_pldw n))
  else (pure ())

/-- Type quantifiers: k_add : Bool -/
def execute_aarch32_instrs_PLD_l_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) : SailM Unit := do
  let address ← (( do
    bif add
    then (pure ((Align_bits (← (PC_read__1 ())) 4) + imm32))
    else (pure ((Align_bits (← (PC_read__1 ())) 4) - imm32)) ) : SailM (BitVec 32) )
  (pure (Hint_PreloadData address))

def decode_aarch32_instrs_PLD_l_A1enc_A_txt (U : (BitVec 1)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_PLD_l_Op_A_txt add imm32))
  else (pure ())

def decode_aarch32_instrs_PLD_l_T1enc_A_txt (U : (BitVec 1)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_PLD_l_Op_A_txt add imm32))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_is_pldw : Bool, m : Nat, n : Nat, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_PLD_r_Op_A_txt (add : Bool) (is_pldw : Bool) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let address ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  bif is_pldw
  then (pure (Hint_PreloadDataForWrite address))
  else (pure (Hint_PreloadData address))

def decode_aarch32_instrs_PLD_r_A1enc_A_txt (U : (BitVec 1)) (R : (BitVec 1)) (Rn : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let is_pldw : Bool := (BEq.beq R (0b0 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq m 15) (Bool.and (BEq.beq n 15) is_pldw))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_PLD_r_Op_A_txt add is_pldw m n shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_PLD_r_T1enc_A_txt (W : (BitVec 1)) (Rn : (BitVec 4)) (imm2 : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLD (literal)"))
      else (pure ())
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let add : Bool := true
      let is_pldw : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, (UInt0 imm2)) : (SRType × Int))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_PLD_r_Op_A_txt add is_pldw m n shift_n shift_t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, n : Nat, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_PLI_i_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (n : Nat) : SailM Unit := do
  let base ← (( do
    bif (BEq.beq n 15)
    then (pure (Align_bits (← (PC_read__1 ())) 4))
    else (R_read n) ) : SailM (BitVec 32) )
  let address : (BitVec 32) :=
    bif add
    then (base + imm32)
    else (base - imm32)
  (pure (Hint_PreloadInstr address))

def decode_aarch32_instrs_PLI_i_A1enc_A_txt (U : (BitVec 1)) (Rn : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_PLI_i_Op_A_txt add imm32 n))
  else (pure ())

def decode_aarch32_instrs_PLI_i_T1enc_A_txt (Rn : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "encoding T3"))
      else (pure ())
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := true
      (execute_aarch32_instrs_PLI_i_Op_A_txt add imm32 n))
  else (pure ())

def decode_aarch32_instrs_PLI_i_T2enc_A_txt (Rn : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "encoding T3"))
      else (pure ())
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let add : Bool := false
      (execute_aarch32_instrs_PLI_i_Op_A_txt add imm32 n))
  else (pure ())

def decode_aarch32_instrs_PLI_i_T3enc_A_txt (U : (BitVec 1)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := 15
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      (execute_aarch32_instrs_PLI_i_Op_A_txt add imm32 n))
  else (pure ())

/-- Type quantifiers: k_add : Bool, m : Nat, n : Nat, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_PLI_r_Op_A_txt (add : Bool) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let address ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  (pure (Hint_PreloadInstr address))

def decode_aarch32_instrs_PLI_r_A1enc_A_txt (U : (BitVec 1)) (Rn : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_PLI_r_Op_A_txt add m n shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_PLI_r_T1enc_A_txt (Rn : (BitVec 4)) (imm2 : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "PLI (immediate, literal)"))
      else (pure ())
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let add : Bool := true
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, (UInt0 imm2)) : (SRType × Int))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_PLI_r_Op_A_txt add m n shift_n shift_t))
  else (pure ())

/-- Type quantifiers: k_UnalignedAllowed : Bool -/
def execute_aarch32_instrs_POP_Op_A_txt (UnalignedAllowed : Bool) (registers : (BitVec 16)) : SailM Unit := do
  let address ← (( do (R_read 13) ) : SailM (BitVec 32) )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 14
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
        then
          (do
            (R_set i
              (← do
                bif UnalignedAllowed
                then (MemU_read address 4)
                else (MemA_read address 4)))
            (pure (BitVec.addInt address 4)))
        else (pure address)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
  then
    (do
      bif UnalignedAllowed
      then
        (do
          bif (BEq.beq (Sail.BitVec.extractLsb address 1 0) (0b00 : (BitVec 2)))
          then (LoadWritePC (← (MemU_read address 4)))
          else sailThrow ((Error_Unpredictable ())))
      else (LoadWritePC (← (MemA_read address 4))))
  else (pure ())
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 13)]) (0b0 : (BitVec 1)))
  then (R_set 13 (BitVec.addInt (← (R_read 13)) (4 *i (BitCount registers))))
  else (pure ())
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 13)]) (0b1 : (BitVec 1)))
  then (R_set 13 (← (__UNKNOWN_bits 32)))
  else (pure ())

def decode_aarch32_instrs_POP_T1enc_A_txt (P : (BitVec 1)) (register_list : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let registers : (BitVec 16) := ((P ++ (0b0000000 : (BitVec 7))) ++ register_list)
      let UnalignedAllowed : Bool := false
      bif ((BitCount registers) <b 1)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and
           (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
             (← (InITBlock ()))) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_POP_Op_A_txt UnalignedAllowed registers))
  else (pure ())

/-- Type quantifiers: k_UnalignedAllowed : Bool -/
def execute_aarch32_instrs_PUSH_Op_A_txt (UnalignedAllowed : Bool) (registers : (BitVec 16)) : SailM Unit := do
  let address ← (( do (pure (sub_vec_int (← (R_read 13)) (4 *i (BitCount registers)))) ) : SailM
    (BitVec 32) )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 14
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
        then
          (do
            bif (Bool.and (BEq.beq i 13) (bne i (LowestSetBit registers)))
            then (MemA_set address 4 (← (__UNKNOWN_bits 32)))
            else
              (do
                bif UnalignedAllowed
                then (MemU_set address 4 (← (R_read i)))
                else (MemA_set address 4 (← (R_read i))))
            (pure (BitVec.addInt address 4)))
        else (pure address)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
  then
    (do
      bif UnalignedAllowed
      then (MemU_set address 4 (← (PCStoreValue ())))
      else (MemA_set address 4 (← (PCStoreValue ()))))
  else (pure ())
  (R_set 13 (sub_vec_int (← (R_read 13)) (4 *i (BitCount registers))))

def decode_aarch32_instrs_PUSH_T1enc_A_txt (M : (BitVec 1)) (register_list : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let registers : (BitVec 16) :=
        ((((0b0 : (BitVec 1)) ++ M) ++ (0b000000 : (BitVec 6))) ++ register_list)
      let UnalignedAllowed : Bool := false
      bif ((BitCount registers) <b 1)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_PUSH_Op_A_txt UnalignedAllowed registers))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_QADD16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let sum2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (← (SignedSat sum1 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (← (SignedSat sum2 16))))

def decode_aarch32_instrs_QADD16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9237.29-9237.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QADD16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_QADD16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QADD16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_QADD8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let sum2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let sum3 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let sum4 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (← (SignedSat sum1 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (← (SignedSat sum2 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (← (SignedSat sum3 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (← (SignedSat sum4 8))))

def decode_aarch32_instrs_QADD8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9304.29-9304.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QADD8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_QADD8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QADD8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_QADD_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (__tup_0, __tup_1) ← do (SignedSatQ ((sint (← (R_read m))) +i (sint (← (R_read n)))) 32)
  (R_set d __tup_0)
  let sat : Bool := __tup_1
  (pure ())
  bif sat
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_QADD_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9375.29-9375.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QADD_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_QADD_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QADD_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_QASX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let sum ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (← (SignedSat diff 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (← (SignedSat sum 16))))

def decode_aarch32_instrs_QASX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9438.29-9438.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QASX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_QASX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QASX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_QDADD_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let doubled ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let sat1 ← (( do (undefined_bool ()) ) : SailM Bool )
  let (tup__0, tup__1) ← do (SignedSatQ (2 *i (sint (← (R_read n)))) 32)
  let doubled : (BitVec 32) := tup__0
  let sat1 : Bool := tup__1
  (pure ())
  let sat2 ← (( do (undefined_bool ()) ) : SailM Bool )
  let (__tup_0, __tup_1) ← do (SignedSatQ ((sint (← (R_read m))) +i (sint doubled)) 32)
  (R_set d __tup_0)
  let sat2 : Bool := __tup_1
  (pure ())
  bif (Bool.or sat1 sat2)
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_QDADD_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9512.29-9512.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QDADD_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_QDADD_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QDADD_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_QDSUB_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let doubled ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let sat1 ← (( do (undefined_bool ()) ) : SailM Bool )
  let (tup__0, tup__1) ← do (SignedSatQ (2 *i (sint (← (R_read n)))) 32)
  let doubled : (BitVec 32) := tup__0
  let sat1 : Bool := tup__1
  (pure ())
  let sat2 ← (( do (undefined_bool ()) ) : SailM Bool )
  let (__tup_0, __tup_1) ← do (SignedSatQ ((sint (← (R_read m))) -i (sint doubled)) 32)
  (R_set d __tup_0)
  let sat2 : Bool := __tup_1
  (pure ())
  bif (Bool.or sat1 sat2)
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_QDSUB_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9586.29-9586.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QDSUB_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_QDSUB_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QDSUB_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_QSAX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let diff ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (← (SignedSat sum 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (← (SignedSat diff 16))))

def decode_aarch32_instrs_QSAX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9649.29-9649.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QSAX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_QSAX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QSAX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_QSUB16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let diff2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (← (SignedSat diff1 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (← (SignedSat diff2 16))))

def decode_aarch32_instrs_QSUB16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9712.29-9712.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QSUB16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_QSUB16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QSUB16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_QSUB8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let diff2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let diff3 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let diff4 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (← (SignedSat diff1 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (← (SignedSat diff2 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (← (SignedSat diff3 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (← (SignedSat diff4 8))))

def decode_aarch32_instrs_QSUB8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9779.29-9779.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QSUB8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_QSUB8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QSUB8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_QSUB_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (__tup_0, __tup_1) ← do (SignedSatQ ((sint (← (R_read m))) -i (sint (← (R_read n)))) 32)
  (R_set d __tup_0)
  let sat : Bool := __tup_1
  (pure ())
  bif sat
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_QSUB_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9850.29-9850.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QSUB_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_QSUB_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_QSUB_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_RBIT_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let result ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 31
    let mut loop_vars := result
    for i in [loop_i_lower:loop_i_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        (pure (BitVec.update result (31 -i i)
            (Bit (BitVec.join1 [(BitVec.access (← (R_read m)) i)]))))
    (pure loop_vars) ) : SailM (BitVec 32) )
  (R_set d result)

def decode_aarch32_instrs_RBIT_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9914.29-9914.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_RBIT_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_RBIT_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (bne m n) (BEq.beq d 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_RBIT_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_REV16_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let result ←
    (pure (Sail.BitVec.updateSubrange result 31 24 (Sail.BitVec.extractLsb (← (R_read m)) 23 16)))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 23 16 (Sail.BitVec.extractLsb (← (R_read m)) 31 24)))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 15 8 (Sail.BitVec.extractLsb (← (R_read m)) 7 0)))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 7 0 (Sail.BitVec.extractLsb (← (R_read m)) 15 8)))
  (R_set d result)

def decode_aarch32_instrs_REV16_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:9977.29-9977.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_REV16_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_REV16_T1enc_A_txt (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      (execute_aarch32_instrs_REV16_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_REV16_T2enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (bne m n) (BEq.beq d 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_REV16_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_REV_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let result ←
    (pure (Sail.BitVec.updateSubrange result 31 24 (Sail.BitVec.extractLsb (← (R_read m)) 7 0)))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 23 16 (Sail.BitVec.extractLsb (← (R_read m)) 15 8)))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 15 8 (Sail.BitVec.extractLsb (← (R_read m)) 23 16)))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 7 0 (Sail.BitVec.extractLsb (← (R_read m)) 31 24)))
  (R_set d result)

def decode_aarch32_instrs_REV_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10058.29-10058.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_REV_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_REV_T1enc_A_txt (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      (execute_aarch32_instrs_REV_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_REV_T2enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (bne m n) (BEq.beq d 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_REV_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_REVSH_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let result ←
    (pure (Sail.BitVec.updateSubrange result 31 8
        (sign_extend (Sail.BitVec.extractLsb (← (R_read m)) 7 0) 24)))
  let result ←
    (pure (Sail.BitVec.updateSubrange result 7 0 (Sail.BitVec.extractLsb (← (R_read m)) 15 8)))
  (R_set d result)

def decode_aarch32_instrs_REVSH_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10137.29-10137.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_REVSH_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_REVSH_T1enc_A_txt (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      (execute_aarch32_instrs_REVSH_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_REVSH_T2enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (bne m n) (BEq.beq d 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_REVSH_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, n ∈ {0, 1, 2, 3, 4, 5, 6, 7}
  ∧ m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ d ∈ {0, 1, 2, 3, 4, 5, 6, 7} -/
def execute_aarch32_instrs_ROR_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read m)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read n)) SRType_ROR shift_n (← readReg PSTATE).C)
  let result : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
      writeReg PSTATE { (← readReg PSTATE) with C := carry })
  else (pure ())

def decode_aarch32_instrs_ROR_r_T1enc_A_txt (Rm : (BitVec 3)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      (execute_aarch32_instrs_ROR_r_Op_A_txt d m n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_RSB_i_Op_A_txt (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (Complement.complement (← (R_read n))) imm32 (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_RSB_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10266.29-10266.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      (execute_aarch32_instrs_RSB_i_Op_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_RSB_i_T1enc_A_txt (Rn : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let imm32 : (BitVec 32) := (Zeros (n := 32))
      (execute_aarch32_instrs_RSB_i_Op_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_RSB_i_T2enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (T32ExpandImm ((i ++ imm3) ++ imm8)) ) : SailM (BitVec 32) )
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_RSB_i_Op_A_txt d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_RSB_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (Complement.complement (← (R_read n))) shifted (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_RSB_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10361.29-10361.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_RSB_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_RSB_r_T1enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_RSB_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_RSB_rr_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (Complement.complement (← (R_read n))) shifted (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_aarch32_instrs_RSB_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10446.29-10446.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_RSB_rr_Op_A_txt d m n s setflags shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_RSC_i_Op_A_txt (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (Complement.complement (← (R_read n))) imm32 (← readReg PSTATE).C))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_RSC_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10500.29-10500.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      (execute_aarch32_instrs_RSC_i_Op_A_txt d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_RSC_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (Complement.complement (← (R_read n))) shifted (← readReg PSTATE).C))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_RSC_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10548.29-10548.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_RSC_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_RSC_rr_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (Complement.complement (← (R_read n))) shifted (← readReg PSTATE).C))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_aarch32_instrs_RSC_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10595.29-10595.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_RSC_rr_Op_A_txt d m n s setflags shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SADD16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let sum2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange sum1 15 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange sum2 15 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 1 0
    (bif (sum1 ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 3 2
    (bif (sum2 ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }

def decode_aarch32_instrs_SADD16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10639.29-10639.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SADD16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SADD16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SADD16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SADD8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let sum2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let sum3 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let sum4 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (integer_subrange sum1 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (integer_subrange sum2 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (integer_subrange sum3 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (integer_subrange sum4 7 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 0
    (Bit
      (bif (sum1 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 1
    (Bit
      (bif (sum2 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 2
    (Bit
      (bif (sum3 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 3
    (Bit
      (bif (sum4 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }

def decode_aarch32_instrs_SADD8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10710.29-10710.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SADD8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SADD8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SADD8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SASX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let sum ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange diff 15 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange sum 15 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 1 0
    (bif (diff ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 3 2
    (bif (sum ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }

def decode_aarch32_instrs_SASX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10775.29-10775.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SASX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SASX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SASX_Op_A_txt d m n))
  else (pure ())

def execute_aarch32_instrs_SB_Op_A_txt (_ : Unit) : SailM Unit := do
  (SpeculationBarrier ())

def decode_aarch32_instrs_SB_A1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_SB_Op_A_txt ())
  else (pure ())

def decode_aarch32_instrs_SB_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SB_Op_A_txt ()))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SBC_i_Op_A_txt (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read n)) (Complement.complement imm32) (← readReg PSTATE).C))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_SBC_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10895.29-10895.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      (execute_aarch32_instrs_SBC_i_Op_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_SBC_i_T1enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (T32ExpandImm ((i ++ imm3) ++ imm8)) ) : SailM (BitVec 32) )
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SBC_i_Op_A_txt d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SBC_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read n)) (Complement.complement shifted) (← readReg PSTATE).C))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_SBC_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:10970.29-10970.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_SBC_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_SBC_r_T1enc_A_txt (Rm : (BitVec 3)) (Rdn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_SBC_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_SBC_r_T2enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_SBC_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SBC_rr_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read n)) (Complement.complement shifted) (← readReg PSTATE).C))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_aarch32_instrs_SBC_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11079.29-11079.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SBC_rr_Op_A_txt d m n s setflags shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, lsbit : Nat, msbit : Int, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ lsbit ∧ lsbit ≤ 31 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SBFX_Op_A_txt (d : Nat) (lsbit : Nat) (msbit : Int) (n : Nat) : SailM Unit := do
  assert (Bool.and (lsbit ≤b msbit) (msbit <b 32)) "src/instrs32.sail:11111.55-11111.56"
  (R_set d (sign_extend (Sail.BitVec.extractLsb (← (R_read n)) msbit lsbit) 32))

def decode_aarch32_instrs_SBFX_A1enc_A_txt (cond : (BitVec 4)) (widthm1 : (BitVec 5)) (Rd : (BitVec 4)) (lsb : (BitVec 5)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11119.29-11119.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let lsbit := (UInt0 lsb)
      let widthminus1 := (UInt0 widthm1)
      let msbit := (lsbit +i widthminus1)
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (msbit >b 31)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SBFX_Op_A_txt d lsbit msbit n))
  else (pure ())

def decode_aarch32_instrs_SBFX_T1enc_A_txt (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (widthm1 : (BitVec 5)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let lsbit := (UInt0 (imm3 ++ imm2))
      let widthminus1 := (UInt0 widthm1)
      let msbit := (lsbit +i widthminus1)
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (msbit >b 31)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SBFX_Op_A_txt d lsbit msbit n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SDIV_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let result ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do
    bif (BEq.beq (sint (← (R_read m))) 0)
    then (pure 0)
    else
      (do
        (pure (RoundTowardsZero
            (div_real (to_real (sint (← (R_read n)))) (to_real (sint (← (R_read m)))))))) ) :
    SailM Int )
  let result := result
  (R_set d (integer_subrange result 31 0))

def decode_aarch32_instrs_SDIV_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11199.29-11199.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (bne a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SDIV_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SDIV_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (bne a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SDIV_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SEL_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 7 0
      (← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access (← readReg PSTATE).GE 0)]) (0b1 : (BitVec 1)))
        then (pure (Sail.BitVec.extractLsb (← (R_read n)) 7 0))
        else (pure (Sail.BitVec.extractLsb (← (R_read m)) 7 0)))))
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 15 8
      (← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access (← readReg PSTATE).GE 1)]) (0b1 : (BitVec 1)))
        then (pure (Sail.BitVec.extractLsb (← (R_read n)) 15 8))
        else (pure (Sail.BitVec.extractLsb (← (R_read m)) 15 8)))))
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 23 16
      (← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access (← readReg PSTATE).GE 2)]) (0b1 : (BitVec 1)))
        then (pure (Sail.BitVec.extractLsb (← (R_read n)) 23 16))
        else (pure (Sail.BitVec.extractLsb (← (R_read m)) 23 16)))))
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 31 24
      (← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access (← readReg PSTATE).GE 3)]) (0b1 : (BitVec 1)))
        then (pure (Sail.BitVec.extractLsb (← (R_read n)) 31 24))
        else (pure (Sail.BitVec.extractLsb (← (R_read m)) 31 24)))))

def decode_aarch32_instrs_SEL_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11274.29-11274.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SEL_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SEL_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SEL_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: k_set_bigend : Bool -/
def execute_aarch32_instrs_SETEND_Op_A_txt (set_bigend : Bool) : SailM Unit := do
  (AArch32_CheckSETENDEnabled ())
  writeReg PSTATE { (← readReg PSTATE) with E := bif set_bigend
  then (0b1 : (BitVec 1))
  else (0b0 : (BitVec 1)) }

def decode_aarch32_instrs_SETEND_A1enc_A_txt (E : (BitVec 1)) : SailM Unit := do
  let set_bigend : Bool := (BEq.beq E (0b1 : (BitVec 1)))
  (execute_aarch32_instrs_SETEND_Op_A_txt set_bigend)

def decode_aarch32_instrs_SETEND_T1enc_A_txt (E : (BitVec 1)) : SailM Unit := do
  let set_bigend : Bool := (BEq.beq E (0b1 : (BitVec 1)))
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_SETEND_Op_A_txt set_bigend)

def execute_aarch32_instrs_SEV_Op_A_txt (_ : Unit) : Unit :=
  (SendEvent ())

def decode_aarch32_instrs_SEV_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11377.29-11377.30"
      (pure (execute_aarch32_instrs_SEV_Op_A_txt ())))
  else (pure ())

def decode_aarch32_instrs_SEV_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_SEV_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_SEV_T2enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_SEV_Op_A_txt ()))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SHADD16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let sum2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange sum1 16 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange sum2 16 1)))

def decode_aarch32_instrs_SHADD16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11440.29-11440.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHADD16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHADD16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHADD16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SHADD8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let sum2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let sum3 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let sum4 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (integer_subrange sum1 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (integer_subrange sum2 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (integer_subrange sum3 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (integer_subrange sum4 8 1)))

def decode_aarch32_instrs_SHADD8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11507.29-11507.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHADD8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHADD8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHADD8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SHASX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let sum ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange diff 16 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange sum 16 1)))

def decode_aarch32_instrs_SHASX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11570.29-11570.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHASX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHASX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHASX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SHSAX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let diff ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange sum 16 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange diff 16 1)))

def decode_aarch32_instrs_SHSAX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11633.29-11633.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHSAX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHSAX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHSAX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SHSUB16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let diff2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange diff1 16 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange diff2 16 1)))

def decode_aarch32_instrs_SHSUB16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11696.29-11696.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHSUB16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHSUB16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHSUB16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SHSUB8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let diff2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let diff3 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let diff4 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (integer_subrange diff1 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (integer_subrange diff2 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (integer_subrange diff3 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (integer_subrange diff4 8 1)))

def decode_aarch32_instrs_SHSUB8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11763.29-11763.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHSUB8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHSUB8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SHSUB8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, k_m_high : Bool, n : Nat, k_n_high : Bool, 0 ≤ n
  ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ 0 ≤ a ∧ a ≤ 15 -/
def execute_aarch32_instrs_SMLABB_Op_A_txt (a : Nat) (d : Nat) (m : Nat) (m_high : Bool) (n : Nat) (n_high : Bool) : SailM Unit := do
  let operand1 ← (( do
    bif n_high
    then (pure (Sail.BitVec.extractLsb (← (R_read n)) 31 16))
    else (pure (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) ) : SailM (BitVec 16) )
  let operand2 ← (( do
    bif m_high
    then (pure (Sail.BitVec.extractLsb (← (R_read m)) 31 16))
    else (pure (Sail.BitVec.extractLsb (← (R_read m)) 15 0)) ) : SailM (BitVec 16) )
  let result ← do (pure (((sint operand1) *i (sint operand2)) +i (sint (← (R_read a)))))
  (R_set d (integer_subrange result 31 0))
  bif (bne result (sint (integer_subrange result 31 0)))
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_SMLABB_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (N : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11832.29-11832.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let n_high : Bool := (BEq.beq N (0b1 : (BitVec 1)))
      let m_high : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLABB_Op_A_txt a d m m_high n n_high))
  else (pure ())

def decode_aarch32_instrs_SMLABB_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SMULBB, SMULBT, SMULTB, SMULTT"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let n_high : Bool := (BEq.beq N (0b1 : (BitVec 1)))
      let m_high : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLABB_Op_A_txt a d m m_high n n_high))
  else (pure ())

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, k_m_swap : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ 0 ≤ a ∧ a ≤ 15 -/
def execute_aarch32_instrs_SMLAD_Op_A_txt (a : Nat) (d : Nat) (m : Nat) (m_swap : Bool) (n : Nat) : SailM Unit := do
  let operand2 ← (( do
    bif m_swap
    then (pure (ROR (← (R_read m)) 16))
    else (R_read m) ) : SailM (BitVec 32) )
  let product1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) *i (sint
          (Sail.BitVec.extractLsb operand2 15 0))))
  let product2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) *i (sint
          (Sail.BitVec.extractLsb operand2 31 16))))
  let result ← do (pure ((product1 +i product2) +i (sint (← (R_read a)))))
  (R_set d (integer_subrange result 31 0))
  bif (bne result (sint (integer_subrange result 31 0)))
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_SMLAD_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11911.29-11911.30"
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SMUAD"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLAD_Op_A_txt a d m m_swap n))
  else (pure ())

def decode_aarch32_instrs_SMLAD_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SMUAD"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLAD_Op_A_txt a d m m_swap n))
  else (pure ())

/-- Type quantifiers: dHi : Nat, dLo : Nat, m : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ dLo ∧ dLo ≤ 15 ∧ 0 ≤ dHi ∧ dHi ≤ 15 -/
def execute_aarch32_instrs_SMLAL_Op_A_txt (dHi : Nat) (dLo : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let result ← do
    (pure (((sint (← (R_read n))) *i (sint (← (R_read m)))) +i (sint
          ((← (R_read dHi)) ++ (← (R_read dLo))))))
  (R_set dHi (integer_subrange result 63 32))
  (R_set dLo (integer_subrange result 31 0))
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(integer_access result 63)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit (integer_subrange result 63 0)) })
  else (pure ())

def decode_aarch32_instrs_SMLAL_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (RdHi : (BitVec 4)) (RdLo : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:11988.29-11988.30"
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLAL_Op_A_txt dHi dLo m n setflags))
  else (pure ())

def decode_aarch32_instrs_SMLAL_T1enc_A_txt (Rn : (BitVec 4)) (RdLo : (BitVec 4)) (RdHi : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := false
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLAL_Op_A_txt dHi dLo m n setflags))
  else (pure ())

/-- Type quantifiers: dHi : Nat, dLo : Nat, m : Nat, k_m_high : Bool, n : Nat, k_n_high : Bool, 0
  ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ dLo ∧ dLo ≤ 15 ∧ 0 ≤ dHi ∧ dHi ≤ 15 -/
def execute_aarch32_instrs_SMLALBB_Op_A_txt (dHi : Nat) (dLo : Nat) (m : Nat) (m_high : Bool) (n : Nat) (n_high : Bool) : SailM Unit := do
  let operand1 ← (( do
    bif n_high
    then (pure (Sail.BitVec.extractLsb (← (R_read n)) 31 16))
    else (pure (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) ) : SailM (BitVec 16) )
  let operand2 ← (( do
    bif m_high
    then (pure (Sail.BitVec.extractLsb (← (R_read m)) 31 16))
    else (pure (Sail.BitVec.extractLsb (← (R_read m)) 15 0)) ) : SailM (BitVec 16) )
  let result ← do
    (pure (((sint operand1) *i (sint operand2)) +i (sint ((← (R_read dHi)) ++ (← (R_read dLo))))))
  (R_set dHi (integer_subrange result 63 32))
  (R_set dLo (integer_subrange result 31 0))

def decode_aarch32_instrs_SMLALBB_A1enc_A_txt (cond : (BitVec 4)) (RdHi : (BitVec 4)) (RdLo : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (N : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12063.29-12063.30"
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let n_high : Bool := (BEq.beq N (0b1 : (BitVec 1)))
      let m_high : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLALBB_Op_A_txt dHi dLo m m_high n n_high))
  else (pure ())

def decode_aarch32_instrs_SMLALBB_T1enc_A_txt (Rn : (BitVec 4)) (RdLo : (BitVec 4)) (RdHi : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let n_high : Bool := (BEq.beq N (0b1 : (BitVec 1)))
      let m_high : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLALBB_Op_A_txt dHi dLo m m_high n n_high))
  else (pure ())

/-- Type quantifiers: dHi : Nat, dLo : Nat, m : Nat, k_m_swap : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ dLo ∧ dLo ≤ 15 ∧ 0 ≤ dHi ∧ dHi ≤ 15 -/
def execute_aarch32_instrs_SMLALD_Op_A_txt (dHi : Nat) (dLo : Nat) (m : Nat) (m_swap : Bool) (n : Nat) : SailM Unit := do
  let operand2 ← (( do
    bif m_swap
    then (pure (ROR (← (R_read m)) 16))
    else (R_read m) ) : SailM (BitVec 32) )
  let product1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) *i (sint
          (Sail.BitVec.extractLsb operand2 15 0))))
  let product2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) *i (sint
          (Sail.BitVec.extractLsb operand2 31 16))))
  let result ← do
    (pure ((product1 +i product2) +i (sint ((← (R_read dHi)) ++ (← (R_read dLo))))))
  (R_set dHi (integer_subrange result 63 32))
  (R_set dLo (integer_subrange result 31 0))

def decode_aarch32_instrs_SMLALD_A1enc_A_txt (cond : (BitVec 4)) (RdHi : (BitVec 4)) (RdLo : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12142.29-12142.30"
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLALD_Op_A_txt dHi dLo m m_swap n))
  else (pure ())

def decode_aarch32_instrs_SMLALD_T1enc_A_txt (Rn : (BitVec 4)) (RdLo : (BitVec 4)) (RdHi : (BitVec 4)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLALD_Op_A_txt dHi dLo m m_swap n))
  else (pure ())

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, k_m_high : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ 0 ≤ a ∧ a ≤ 15 -/
def execute_aarch32_instrs_SMLAWB_Op_A_txt (a : Nat) (d : Nat) (m : Nat) (m_high : Bool) (n : Nat) : SailM Unit := do
  let operand2 ← (( do
    bif m_high
    then (pure (Sail.BitVec.extractLsb (← (R_read m)) 31 16))
    else (pure (Sail.BitVec.extractLsb (← (R_read m)) 15 0)) ) : SailM (BitVec 16) )
  let result ← do
    (pure (((sint (← (R_read n))) *i (sint operand2)) +i (Int.shiftl (sint (← (R_read a))) 16)))
  (R_set d (integer_subrange result 47 16))
  bif (bne (Int.shiftr result 16) (sint (← (R_read d))))
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_SMLAWB_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12219.29-12219.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let m_high : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLAWB_Op_A_txt a d m m_high n))
  else (pure ())

def decode_aarch32_instrs_SMLAWB_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SMULWB, SMULWT"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let m_high : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLAWB_Op_A_txt a d m m_high n))
  else (pure ())

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, k_m_swap : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ 0 ≤ a ∧ a ≤ 15 -/
def execute_aarch32_instrs_SMLSD_Op_A_txt (a : Nat) (d : Nat) (m : Nat) (m_swap : Bool) (n : Nat) : SailM Unit := do
  let operand2 ← (( do
    bif m_swap
    then (pure (ROR (← (R_read m)) 16))
    else (R_read m) ) : SailM (BitVec 32) )
  let product1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) *i (sint
          (Sail.BitVec.extractLsb operand2 15 0))))
  let product2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) *i (sint
          (Sail.BitVec.extractLsb operand2 31 16))))
  let result ← do (pure ((product1 -i product2) +i (sint (← (R_read a)))))
  (R_set d (integer_subrange result 31 0))
  bif (bne result (sint (integer_subrange result 31 0)))
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_SMLSD_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12294.29-12294.30"
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SMUSD"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLSD_Op_A_txt a d m m_swap n))
  else (pure ())

def decode_aarch32_instrs_SMLSD_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SMUSD"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLSD_Op_A_txt a d m m_swap n))
  else (pure ())

/-- Type quantifiers: dHi : Nat, dLo : Nat, m : Nat, k_m_swap : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ dLo ∧ dLo ≤ 15 ∧ 0 ≤ dHi ∧ dHi ≤ 15 -/
def execute_aarch32_instrs_SMLSLD_Op_A_txt (dHi : Nat) (dLo : Nat) (m : Nat) (m_swap : Bool) (n : Nat) : SailM Unit := do
  let operand2 ← (( do
    bif m_swap
    then (pure (ROR (← (R_read m)) 16))
    else (R_read m) ) : SailM (BitVec 32) )
  let product1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) *i (sint
          (Sail.BitVec.extractLsb operand2 15 0))))
  let product2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) *i (sint
          (Sail.BitVec.extractLsb operand2 31 16))))
  let result ← do
    (pure ((product1 -i product2) +i (sint ((← (R_read dHi)) ++ (← (R_read dLo))))))
  (R_set dHi (integer_subrange result 63 32))
  (R_set dLo (integer_subrange result 31 0))

def decode_aarch32_instrs_SMLSLD_A1enc_A_txt (cond : (BitVec 4)) (RdHi : (BitVec 4)) (RdLo : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12369.29-12369.30"
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLSLD_Op_A_txt dHi dLo m m_swap n))
  else (pure ())

def decode_aarch32_instrs_SMLSLD_T1enc_A_txt (Rn : (BitVec 4)) (RdLo : (BitVec 4)) (RdHi : (BitVec 4)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMLSLD_Op_A_txt dHi dLo m m_swap n))
  else (pure ())

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, n : Nat, k_round : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ 0 ≤ a ∧ a ≤ 15 -/
def execute_aarch32_instrs_SMMLA_Op_A_txt (a : Nat) (d : Nat) (m : Nat) (n : Nat) (round : Bool) : SailM Unit := do
  let result ← (( do
    (pure ((Int.shiftl (sint (← (R_read a))) 32) +i ((sint (← (R_read n))) *i (sint
            (← (R_read m)))))) ) : SailM Int )
  let result : Int :=
    bif round
    then (result +i (UInt0 (0x80000000 : (BitVec 32))))
    else result
  let result := result
  (R_set d (integer_subrange result 63 32))

def decode_aarch32_instrs_SMMLA_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (R : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12444.29-12444.30"
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SMMUL"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let round : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMMLA_Op_A_txt a d m n round))
  else (pure ())

def decode_aarch32_instrs_SMMLA_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (R : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SMMUL"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let round : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMMLA_Op_A_txt a d m n round))
  else (pure ())

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, n : Nat, k_round : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ 0 ≤ a ∧ a ≤ 15 -/
def execute_aarch32_instrs_SMMLS_Op_A_txt (a : Nat) (d : Nat) (m : Nat) (n : Nat) (round : Bool) : SailM Unit := do
  let result ← (( do
    (pure ((Int.shiftl (sint (← (R_read a))) 32) -i ((sint (← (R_read n))) *i (sint
            (← (R_read m)))))) ) : SailM Int )
  let result : Int :=
    bif round
    then (result +i (UInt0 (0x80000000 : (BitVec 32))))
    else result
  let result := result
  (R_set d (integer_subrange result 63 32))

def decode_aarch32_instrs_SMMLS_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (R : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12519.29-12519.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let round : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMMLS_Op_A_txt a d m n round))
  else (pure ())

def decode_aarch32_instrs_SMMLS_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (R : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      let round : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMMLS_Op_A_txt a d m n round))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_round : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SMMUL_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (round : Bool) : SailM Unit := do
  let result ← (( do (pure ((sint (← (R_read n))) *i (sint (← (R_read m))))) ) : SailM Int )
  let result : Int :=
    bif round
    then (result +i (UInt0 (0x80000000 : (BitVec 32))))
    else result
  let result := result
  (R_set d (integer_subrange result 63 32))

def decode_aarch32_instrs_SMMUL_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) (R : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12588.29-12588.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let round : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMMUL_Op_A_txt d m n round))
  else (pure ())

def decode_aarch32_instrs_SMMUL_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (R : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let round : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMMUL_Op_A_txt d m n round))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_m_swap : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SMUAD_Op_A_txt (d : Nat) (m : Nat) (m_swap : Bool) (n : Nat) : SailM Unit := do
  let operand2 ← (( do
    bif m_swap
    then (pure (ROR (← (R_read m)) 16))
    else (R_read m) ) : SailM (BitVec 32) )
  let product1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) *i (sint
          (Sail.BitVec.extractLsb operand2 15 0))))
  let product2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) *i (sint
          (Sail.BitVec.extractLsb operand2 31 16))))
  let result := (product1 +i product2)
  (R_set d (integer_subrange result 31 0))
  bif (bne result (sint (integer_subrange result 31 0)))
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_SMUAD_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12656.29-12656.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMUAD_Op_A_txt d m m_swap n))
  else (pure ())

def decode_aarch32_instrs_SMUAD_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMUAD_Op_A_txt d m m_swap n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_m_high : Bool, n : Nat, k_n_high : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SMULBB_Op_A_txt (d : Nat) (m : Nat) (m_high : Bool) (n : Nat) (n_high : Bool) : SailM Unit := do
  let operand1 ← (( do
    bif n_high
    then (pure (Sail.BitVec.extractLsb (← (R_read n)) 31 16))
    else (pure (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) ) : SailM (BitVec 16) )
  let operand2 ← (( do
    bif m_high
    then (pure (Sail.BitVec.extractLsb (← (R_read m)) 31 16))
    else (pure (Sail.BitVec.extractLsb (← (R_read m)) 15 0)) ) : SailM (BitVec 16) )
  let result := ((sint operand1) *i (sint operand2))
  (R_set d (integer_subrange result 31 0))

def decode_aarch32_instrs_SMULBB_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (N : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12721.29-12721.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let n_high : Bool := (BEq.beq N (0b1 : (BitVec 1)))
      let m_high : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMULBB_Op_A_txt d m m_high n n_high))
  else (pure ())

def decode_aarch32_instrs_SMULBB_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let n_high : Bool := (BEq.beq N (0b1 : (BitVec 1)))
      let m_high : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMULBB_Op_A_txt d m m_high n n_high))
  else (pure ())

/-- Type quantifiers: dHi : Nat, dLo : Nat, m : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ dLo ∧ dLo ≤ 15 ∧ 0 ≤ dHi ∧ dHi ≤ 15 -/
def execute_aarch32_instrs_SMULL_Op_A_txt (dHi : Nat) (dLo : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let result ← do (pure ((sint (← (R_read n))) *i (sint (← (R_read m)))))
  (R_set dHi (integer_subrange result 63 32))
  (R_set dLo (integer_subrange result 31 0))
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(integer_access result 63)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit (integer_subrange result 63 0)) })
  else (pure ())

def decode_aarch32_instrs_SMULL_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (RdHi : (BitVec 4)) (RdLo : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12796.29-12796.30"
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMULL_Op_A_txt dHi dLo m n setflags))
  else (pure ())

def decode_aarch32_instrs_SMULL_T1enc_A_txt (Rn : (BitVec 4)) (RdLo : (BitVec 4)) (RdHi : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := false
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMULL_Op_A_txt dHi dLo m n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_m_high : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SMULWB_Op_A_txt (d : Nat) (m : Nat) (m_high : Bool) (n : Nat) : SailM Unit := do
  let operand2 ← (( do
    bif m_high
    then (pure (Sail.BitVec.extractLsb (← (R_read m)) 31 16))
    else (pure (Sail.BitVec.extractLsb (← (R_read m)) 15 0)) ) : SailM (BitVec 16) )
  let product ← do (pure ((sint (← (R_read n))) *i (sint operand2)))
  (R_set d (integer_subrange product 47 16))

def decode_aarch32_instrs_SMULWB_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12868.29-12868.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let m_high : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMULWB_Op_A_txt d m m_high n))
  else (pure ())

def decode_aarch32_instrs_SMULWB_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let m_high : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMULWB_Op_A_txt d m m_high n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_m_swap : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SMUSD_Op_A_txt (d : Nat) (m : Nat) (m_swap : Bool) (n : Nat) : SailM Unit := do
  let operand2 ← (( do
    bif m_swap
    then (pure (ROR (← (R_read m)) 16))
    else (R_read m) ) : SailM (BitVec 32) )
  let product1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) *i (sint
          (Sail.BitVec.extractLsb operand2 15 0))))
  let product2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) *i (sint
          (Sail.BitVec.extractLsb operand2 31 16))))
  let result := (product1 -i product2)
  (R_set d (integer_subrange result 31 0))

def decode_aarch32_instrs_SMUSD_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) (M : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:12936.29-12936.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMUSD_Op_A_txt d m m_swap n))
  else (pure ())

def decode_aarch32_instrs_SMUSD_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (M : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let m_swap : Bool := (BEq.beq M (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMUSD_Op_A_txt d m m_swap n))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, saturate_to : Nat, 1 ≤ saturate_to ∧
  saturate_to ≤ 16 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SSAT16_Op_A_txt (d : Nat) (n : Nat) (saturate_to : Nat) : SailM Unit := do
  let result1 ← (( do (undefined_bitvector saturate_to) ) : SailM (BitVec saturate_to) )
  let result2 ← (( do (undefined_bitvector saturate_to) ) : SailM (BitVec saturate_to) )
  let sat1 ← (( do (undefined_bool ()) ) : SailM Bool )
  let sat2 ← (( do (undefined_bool ()) ) : SailM Bool )
  let (tup__0, tup__1) ← do
    (SignedSatQ (sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) saturate_to)
  let result1 : (BitVec saturate_to) := tup__0
  let sat1 : Bool := tup__1
  (pure ())
  let (tup__0, tup__1) ← do
    (SignedSatQ (sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) saturate_to)
  let result2 : (BitVec saturate_to) := tup__0
  let sat2 : Bool := tup__1
  (pure ())
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (sign_extend result1 16)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (sign_extend result2 16)))
  bif (Bool.or sat1 sat2)
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_SSAT16_A1enc_A_txt (cond : (BitVec 4)) (sat_imm : (BitVec 4)) (Rd : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13007.29-13007.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let saturate_to := ((UInt0 sat_imm) +i 1)
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SSAT16_Op_A_txt d n saturate_to))
  else (pure ())

def decode_aarch32_instrs_SSAT16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (sat_imm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let saturate_to := ((UInt0 sat_imm) +i 1)
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SSAT16_Op_A_txt d n saturate_to))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, saturate_to : Nat, shift_n : Int, 1 ≤ saturate_to ∧
  saturate_to ≤ 32 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SSAT_Op_A_txt (d : Nat) (n : Nat) (saturate_to : Nat) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let result ← (( do (undefined_bitvector saturate_to) ) : SailM (BitVec saturate_to) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let operand ← (( do (Shift (← (R_read n)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do (SignedSatQ (sint operand) saturate_to)
  let result : (BitVec saturate_to) := tup__0
  let sat : Bool := tup__1
  (pure ())
  (R_set d (sign_extend result 32))
  bif sat
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_SSAT_A1enc_A_txt (cond : (BitVec 4)) (sat_imm : (BitVec 5)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (sh : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13079.29-13079.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let saturate_to := ((UInt0 sat_imm) +i 1)
      let (tup__0, tup__1) ← do (DecodeImmShift (sh ++ (0b0 : (BitVec 1))) imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_SSAT_Op_A_txt d n saturate_to shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_SSAT_T1enc_A_txt (sh : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (sat_imm : (BitVec 5)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq sh (0b1 : (BitVec 1))) (BEq.beq (imm3 ++ imm2) (0b00000 : (BitVec 5))))
      then sailThrow ((Error_See "SSAT16"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let saturate_to := ((UInt0 sat_imm) +i 1)
      let (tup__0, tup__1) ← do (DecodeImmShift (sh ++ (0b0 : (BitVec 1))) (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SSAT_Op_A_txt d n saturate_to shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SSAX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let diff ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange sum 15 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange diff 15 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 1 0
    (bif (sum ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 3 2
    (bif (diff ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }

def decode_aarch32_instrs_SSAX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13162.29-13162.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SSAX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SSAX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SSAX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SSUB16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let diff2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange diff1 15 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange diff2 15 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 1 0
    (bif (diff1 ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 3 2
    (bif (diff2 ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }

def decode_aarch32_instrs_SSUB16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13227.29-13227.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SSUB16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SSUB16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SSUB16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SSUB8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let diff2 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let diff3 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let diff4 ← do
    (pure ((sint (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) -i (sint
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (integer_subrange diff1 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (integer_subrange diff2 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (integer_subrange diff3 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (integer_subrange diff4 7 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 0
    (Bit
      (bif (diff1 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 1
    (Bit
      (bif (diff2 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 2
    (Bit
      (bif (diff3 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 3
    (Bit
      (bif (diff4 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }

def decode_aarch32_instrs_SSUB8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13298.29-13298.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SSUB8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SSUB8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SSUB8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: k_add : Bool, cp : Nat, k_index : Bool, n : Nat, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ cp = 14 -/
def execute_aarch32_instrs_STC_Op_A_txt (add : Bool) (cp : Nat) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  (AArch32_SysRegRead cp (← (ThisInstr ())) (Sail.BitVec.extractLsb address 31 0))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STC_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13365.29-13365.30"
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let n := (UInt0 Rn)
      let cp := 14
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.and (BEq.beq n 15) (Bool.or wback (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STC_Op_A_txt add cp imm32 index n wback))
  else (pure ())

def decode_aarch32_instrs_STC_T1enc_A_txt (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let n := (UInt0 Rn)
      let cp := 14
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.and (BEq.beq n 15) (Bool.or wback (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STC_Op_A_txt add cp imm32 index n wback))
  else (pure ())

/-- Type quantifiers: n : Nat, k_wback : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STM_Op_A_txt (n : Nat) (registers : (BitVec 16)) (wback : Bool) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 14
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
        then
          (do
            bif (Bool.and (Bool.and (BEq.beq i n) wback) (bne i (LowestSetBit registers)))
            then (MemS_set address 4 (← (__UNKNOWN_bits 32)))
            else (MemS_set address 4 (← (R_read i)))
            (pure (BitVec.addInt address 4)))
        else (pure address)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
  then (MemS_set address 4 (← (PCStoreValue ())))
  else (pure ())
  bif wback
  then (R_set n (BitVec.addInt (← (R_read n)) (4 *i (BitCount registers))))
  else (pure ())

def decode_aarch32_instrs_STM_A1enc_A_txt (cond : (BitVec 4)) (W : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 16)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13454.29-13454.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := register_list
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 1))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STM_Op_A_txt n registers wback))
  else (pure ())

def decode_aarch32_instrs_STM_T1enc_A_txt (Rn : (BitVec 3)) (register_list : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := ((0x00 : (BitVec 8)) ++ register_list)
      let wback : Bool := true
      bif ((BitCount registers) <b 1)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STM_Op_A_txt n registers wback))
  else (pure ())

def decode_aarch32_instrs_STM_T2enc_A_txt (W : (BitVec 1)) (Rn : (BitVec 4)) (P : (BitVec 1)) (M : (BitVec 1)) (register_list : (BitVec 14)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := ((P ++ M) ++ register_list)
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access registers 13)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STM_Op_A_txt n registers wback))
  else (pure ())

/-- Type quantifiers: n : Nat, k_wback : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STMDA_Op_A_txt (n : Nat) (registers : (BitVec 16)) (wback : Bool) : SailM Unit := do
  let address ← (( do
    (pure (BitVec.addInt (sub_vec_int (← (R_read n)) (4 *i (BitCount registers))) 4)) ) : SailM
    (BitVec 32) )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 14
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
        then
          (do
            bif (Bool.and (Bool.and (BEq.beq i n) wback) (bne i (LowestSetBit registers)))
            then (MemS_set address 4 (← (__UNKNOWN_bits 32)))
            else (MemS_set address 4 (← (R_read i)))
            (pure (BitVec.addInt address 4)))
        else (pure address)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
  then (MemS_set address 4 (← (PCStoreValue ())))
  else (pure ())
  bif wback
  then (R_set n (sub_vec_int (← (R_read n)) (4 *i (BitCount registers))))
  else (pure ())

def decode_aarch32_instrs_STMDA_A1enc_A_txt (cond : (BitVec 4)) (W : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 16)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13560.29-13560.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := register_list
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 1))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STMDA_Op_A_txt n registers wback))
  else (pure ())

/-- Type quantifiers: n : Nat, k_wback : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STMDB_Op_A_txt (n : Nat) (registers : (BitVec 16)) (wback : Bool) : SailM Unit := do
  let address ← (( do (pure (sub_vec_int (← (R_read n)) (4 *i (BitCount registers)))) ) : SailM
    (BitVec 32) )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 14
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
        then
          (do
            bif (Bool.and (Bool.and (BEq.beq i n) wback) (bne i (LowestSetBit registers)))
            then (MemS_set address 4 (← (__UNKNOWN_bits 32)))
            else (MemS_set address 4 (← (R_read i)))
            (pure (BitVec.addInt address 4)))
        else (pure address)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
  then (MemS_set address 4 (← (PCStoreValue ())))
  else (pure ())
  bif wback
  then (R_set n (sub_vec_int (← (R_read n)) (4 *i (BitCount registers))))
  else (pure ())

def decode_aarch32_instrs_STMDB_A1enc_A_txt (cond : (BitVec 4)) (W : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 16)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13610.29-13610.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := register_list
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 1))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STMDB_Op_A_txt n registers wback))
  else (pure ())

def decode_aarch32_instrs_STMDB_T1enc_A_txt (W : (BitVec 1)) (Rn : (BitVec 4)) (P : (BitVec 1)) (M : (BitVec 1)) (register_list : (BitVec 14)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := ((P ++ M) ++ register_list)
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access registers 13)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STMDB_Op_A_txt n registers wback))
  else (pure ())

/-- Type quantifiers: n : Nat, k_wback : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STMIB_Op_A_txt (n : Nat) (registers : (BitVec 16)) (wback : Bool) : SailM Unit := do
  let address ← (( do (pure (BitVec.addInt (← (R_read n)) 4)) ) : SailM (BitVec 32) )
  let address ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 14
    let mut loop_vars := address
    for i in [loop_i_lower:loop_i_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
        then
          (do
            bif (Bool.and (Bool.and (BEq.beq i n) wback) (bne i (LowestSetBit registers)))
            then (MemS_set address 4 (← (__UNKNOWN_bits 32)))
            else (MemS_set address 4 (← (R_read i)))
            (pure (BitVec.addInt address 4)))
        else (pure address)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
  then (MemS_set address 4 (← (PCStoreValue ())))
  else (pure ())
  bif wback
  then (R_set n (BitVec.addInt (← (R_read n)) (4 *i (BitCount registers))))
  else (pure ())

def decode_aarch32_instrs_STMIB_A1enc_A_txt (cond : (BitVec 4)) (W : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 16)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13694.29-13694.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := register_list
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 1))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STMIB_Op_A_txt n registers wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STRB_i_OpA_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 1 false t false)
    else ()
  (MemU_set address 1 (Sail.BitVec.extractLsb (← (R_read t)) 7 0))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRB_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13737.29-13737.30"
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "STRBT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRB_i_OpA_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STRB_i_OpT_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 1 false t false)
    else ()
  (MemU_set address 1 (Sail.BitVec.extractLsb (← (R_read t)) 7 0))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRB_i_T1enc_A_txt (imm5 : (BitVec 5)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm5 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_STRB_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_STRB_i_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRB_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_STRB_i_T3enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq U (0b1 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "STRBT"))
      else (pure ())
      bif (Bool.or (BEq.beq Rn (0xF : (BitVec 4)))
           (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq t 15) (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRB_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, m : Nat, n : Nat, shift_n : Int, t : Nat, k_wback
  : Bool, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_STRB_r_Op_A_txt (add : Bool) (index : Bool) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 1 false t false)
    else ()
  (MemU_set address 1 (Sail.BitVec.extractLsb (← (R_read t)) 7 0))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRB_r_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:13898.29-13898.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "STRBT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq t 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRB_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_STRB_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_STRB_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_STRB_r_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm2 : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, (UInt0 imm2)) : (SRType × Int))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.or (BEq.beq t 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRB_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, m : Int, n : Nat, k_postindex : Bool, k_register_form : Bool, shift_n
  : Int, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STRBT_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (m : Int) (n : Nat) (postindex : Bool) (register_form : Bool) (shift_n : Int) (shift_t : SRType) (t : Nat) : SailM Unit := do
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let offset ← (( do
    bif register_form
    then (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
    else (pure imm32) ) : SailM (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif postindex
    then (R_read n)
    else (pure offset_addr) ) : SailM (BitVec 32) )
  bif (Bool.and (Bool.and (Bool.not postindex) (bne t 15))
       (BEq.beq (← readReg PSTATE).T (0b1 : (BitVec 1))))
  then (pure (AArch32_SetLSInstructionSyndrome 1 false t false))
  else (pure ())
  (MemU_unpriv_set address 1 (Sail.BitVec.extractLsb (← (R_read t)) 7 0))
  bif postindex
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRBT_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14027.29-14027.30"
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      (execute_aarch32_instrs_STRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

def decode_aarch32_instrs_STRBT_A2enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14062.29-14062.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := true
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_STRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

def decode_aarch32_instrs_STRBT_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := false
      let add : Bool := true
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRBT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, t2 : Nat, k_wback : Bool, 0
  ≤ t2 ∧ t2 ≤ 16 ∧ 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STRD_i_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (t2 : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  bif (IsAligned__1 address 8)
  then
    (do
      let data ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
      let data ← (( do
        bif (← (BigEndian AccessType_GPR))
        then
          (do
            let data ← (pure (Sail.BitVec.updateSubrange data 63 32 (← (R_read t))))
            (pure (Sail.BitVec.updateSubrange data 31 0 (← (R_read t2)))))
        else
          (do
            let data ← (pure (Sail.BitVec.updateSubrange data 31 0 (← (R_read t))))
            (pure (Sail.BitVec.updateSubrange data 63 32 (← (R_read t2))))) ) : SailM (BitVec 64)
        )
      (MemA_set address 8 data))
  else
    (do
      (MemA_set address 4 (← (R_read t)))
      (MemA_set (BitVec.addInt address 4) 4 (← (R_read t2))))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRD_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14164.29-14164.30"
      bif (BEq.beq (BitVec.join1 [(BitVec.access Rt 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let t := (UInt0 Rt)
      let t2 := (t +i 1)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (Bool.or (BEq.beq n 15) (BEq.beq n t)) (BEq.beq n t2)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq t2 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRD_i_Op_A_txt add imm32 index n t t2 wback))
  else (pure ())

def decode_aarch32_instrs_STRD_i_T1enc_A_txt (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rt2 : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.and wback (Bool.or (BEq.beq n t) (BEq.beq n t2)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (BEq.beq n 15) (BEq.beq t 15)) (BEq.beq t2 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRD_i_Op_A_txt add imm32 index n t t2 wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, m : Nat, n : Nat, t : Nat, t2 : Nat, k_wback :
  Bool, 1 ≤ t2 ∧
  t2 ≤ 16 ∧ 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_STRD_r_Op_A_txt (add : Bool) (index : Bool) (m : Nat) (n : Nat) (t : Nat) (t2 : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + (← (R_read m))))
    else (pure ((← (R_read n)) - (← (R_read m)))) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  bif (IsAligned__1 address 8)
  then
    (do
      let data ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
      let data ← (( do
        bif (← (BigEndian AccessType_GPR))
        then
          (do
            let data ← (pure (Sail.BitVec.updateSubrange data 63 32 (← (R_read t))))
            (pure (Sail.BitVec.updateSubrange data 31 0 (← (R_read t2)))))
        else
          (do
            let data ← (pure (Sail.BitVec.updateSubrange data 31 0 (← (R_read t))))
            (pure (Sail.BitVec.updateSubrange data 63 32 (← (R_read t2))))) ) : SailM (BitVec 64)
        )
      (MemA_set address 8 data))
  else
    (do
      (MemA_set address 4 (← (R_read t)))
      (MemA_set (BitVec.addInt address 4) 4 (← (R_read t2))))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRD_r_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14271.29-14271.30"
      bif (BEq.beq (BitVec.join1 [(BitVec.access Rt 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let t := (UInt0 Rt)
      let t2 := (t +i 1)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq t2 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (Bool.or (BEq.beq n 15) (BEq.beq n t)) (BEq.beq n t2)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRD_r_Op_A_txt add index m n t t2 wback))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_STREX_Op_A_txt (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (pure ((← (R_read n)) + imm32)) ) : SailM (BitVec 32) )
  bif (← (AArch32_ExclusiveMonitorsPass address 4))
  then
    (do
      (MemA_set address 4 (← (R_read t)))
      (R_set d (zero_extend (0b0 : (BitVec 1)) 32)))
  else (R_set d (zero_extend (0b1 : (BitVec 1)) 32))

def decode_aarch32_instrs_STREX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14330.29-14330.30"
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (Zeros (n := 32))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STREX_Op_A_txt d imm32 n t))
  else (pure ())

def decode_aarch32_instrs_STREX_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STREX_Op_A_txt d imm32 n t))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_STREXB_Op_A_txt (d : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  bif (← (AArch32_ExclusiveMonitorsPass address 1))
  then
    (do
      (MemA_set address 1 (Sail.BitVec.extractLsb (← (R_read t)) 7 0))
      (R_set d (zero_extend (0b0 : (BitVec 1)) 32)))
  else (R_set d (zero_extend (0b1 : (BitVec 1)) 32))

def decode_aarch32_instrs_STREXB_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14405.29-14405.30"
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STREXB_Op_A_txt d n t))
  else (pure ())

def decode_aarch32_instrs_STREXB_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rd : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STREXB_Op_A_txt d n t))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, t : Nat, t2 : Nat, 0 ≤ t2 ∧
  t2 ≤ 16 ∧ 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_STREXD_Op_A_txt (d : Nat) (n : Nat) (t : Nat) (t2 : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let value_name ← (( do
    bif (← (BigEndian AccessType_GPR))
    then (pure ((← (R_read t)) ++ (← (R_read t2))))
    else (pure ((← (R_read t2)) ++ (← (R_read t)))) ) : SailM (BitVec 64) )
  bif (← (AArch32_ExclusiveMonitorsPass address 8))
  then
    (do
      (MemA_set address 8 value_name)
      (R_set d (zero_extend (0b0 : (BitVec 1)) 32)))
  else (R_set d (zero_extend (0b1 : (BitVec 1)) 32))

def decode_aarch32_instrs_STREXD_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14485.29-14485.30"
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let t2 := (t +i 1)
      let n := (UInt0 Rn)
      bif (Bool.or
           (Bool.or
             (Bool.or (BEq.beq d 15)
               (BEq.beq (BitVec.join1 [(BitVec.access Rt 0)]) (0b1 : (BitVec 1)))) (BEq.beq t2 15))
           (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (BEq.beq d n) (BEq.beq d t)) (BEq.beq d t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STREXD_Op_A_txt d n t t2))
  else (pure ())

def decode_aarch32_instrs_STREXD_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rt2 : (BitVec 4)) (Rd : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq t2 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (BEq.beq d n) (BEq.beq d t)) (BEq.beq d t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STREXD_Op_A_txt d n t t2))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_STREXH_Op_A_txt (d : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  bif (← (AArch32_ExclusiveMonitorsPass address 2))
  then
    (do
      (MemA_set address 2 (Sail.BitVec.extractLsb (← (R_read t)) 15 0))
      (R_set d (zero_extend (0b0 : (BitVec 1)) 32)))
  else (R_set d (zero_extend (0b1 : (BitVec 1)) 32))

def decode_aarch32_instrs_STREXH_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14560.29-14560.30"
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STREXH_Op_A_txt d n t))
  else (pure ())

def decode_aarch32_instrs_STREXH_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rd : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STREXH_Op_A_txt d n t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STRH_i_OpA_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 2 false t false)
    else ()
  (MemU_set address 2 (Sail.BitVec.extractLsb (← (R_read t)) 15 0))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRH_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14640.29-14640.30"
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "STRHT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRH_i_OpA_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STRH_i_OpT_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 2 false t false)
    else ()
  (MemU_set address 2 (Sail.BitVec.extractLsb (← (R_read t)) 15 0))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRH_i_T1enc_A_txt (imm5 : (BitVec 5)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm5 ++ (0b0 : (BitVec 1))) 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_STRH_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_STRH_i_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRH_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_STRH_i_T3enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq U (0b1 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "STRHT"))
      else (pure ())
      bif (Bool.or (BEq.beq Rn (0xF : (BitVec 4)))
           (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq t 15) (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRH_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, m : Nat, n : Nat, shift_n : Int, t : Nat, k_wback
  : Bool, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_STRH_r_Op_A_txt (add : Bool) (index : Bool) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 2 false t false)
    else ()
  (MemU_set address 2 (Sail.BitVec.extractLsb (← (R_read t)) 15 0))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRH_r_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14802.29-14802.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "STRHT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.or (BEq.beq t 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRH_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_STRH_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_STRH_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_STRH_r_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm2 : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, (UInt0 imm2)) : (SRType × Int))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.or (BEq.beq t 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRH_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, m : Int, n : Nat, k_postindex : Bool, k_register_form : Bool, t
  : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STRHT_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (m : Int) (n : Nat) (postindex : Bool) (register_form : Bool) (t : Nat) : SailM Unit := do
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let offset ← (( do
    bif register_form
    then (R_read m)
    else (pure imm32) ) : SailM (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif postindex
    then (R_read n)
    else (pure offset_addr) ) : SailM (BitVec 32) )
  bif (Bool.and (bne t 15) (BEq.beq (← readReg PSTATE).T (0b1 : (BitVec 1))))
  then (pure (AArch32_SetLSInstructionSyndrome 2 false t false))
  else (pure ())
  (MemU_unpriv_set address 2 (Sail.BitVec.extractLsb (← (R_read t)) 15 0))
  bif postindex
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRHT_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm4H : (BitVec 4)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14930.29-14930.30"
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend (imm4H ++ imm4L) 32)
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      (execute_aarch32_instrs_STRHT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

def decode_aarch32_instrs_STRHT_A2enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:14966.29-14966.30"
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := true
      bif (Bool.or (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq n 15)) (BEq.beq n t)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      (execute_aarch32_instrs_STRHT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

def decode_aarch32_instrs_STRHT_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := false
      let add : Bool := true
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRHT_Op_A_txt add imm32 m n postindex register_form t))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STR_i_OpA_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 4 false t false)
    else ()
  (MemU_set address 4
    (← do
      bif (BEq.beq t 15)
      then (PCStoreValue ())
      else (R_read t)))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STR_i_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:15054.29-15054.30"
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "STRT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STR_i_OpA_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, n : Nat, t : Nat, k_wback : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STR_i_OpT_A_txt (add : Bool) (imm32 : (BitVec 32)) (index : Bool) (n : Nat) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 4 false t false)
    else ()
  (MemU_set address 4 (← (R_read t)))
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STR_i_T1enc_A_txt (imm5 : (BitVec 5)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm5 ++ (0b00 : (BitVec 2))) 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_STR_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_STR_i_T2enc_A_txt (Rt : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := 13
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      (execute_aarch32_instrs_STR_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_STR_i_T3enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STR_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

def decode_aarch32_instrs_STR_i_T4enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq U (0b1 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "STRT"))
      else (pure ())
      bif (Bool.or (BEq.beq Rn (0xF : (BitVec 4)))
           (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      bif (Bool.or (BEq.beq t 15) (Bool.and wback (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STR_i_OpT_A_txt add imm32 index n t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_index : Bool, m : Nat, n : Nat, shift_n : Int, t : Nat, k_wback
  : Bool, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_STR_r_Op_A_txt (add : Bool) (index : Bool) (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) (t : Nat) (wback : Bool) : SailM Unit := do
  let offset ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif index
    then (pure offset_addr)
    else (R_read n) ) : SailM (BitVec 32) )
  let data ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let data ← (( do
    bif (BEq.beq t 15)
    then
      (do
        (PCStoreValue ()))
    else
      (do
        (R_read t)) ) : SailM (BitVec 32) )
  let _ : Unit :=
    bif (Bool.and (Bool.not wback) (bne t 15))
    then (AArch32_SetLSInstructionSyndrome 4 false t false)
    else ()
  (MemU_set address 4 data)
  bif wback
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STR_r_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:15240.29-15240.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "STRT"))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := (BEq.beq P (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (Bool.or (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq W (0b1 : (BitVec 1))))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (Bool.or (BEq.beq n 15) (BEq.beq n t)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STR_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_STR_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) (Rt : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_STR_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

def decode_aarch32_instrs_STR_r_T2enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm2 : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let index : Bool := true
      let add : Bool := true
      let wback : Bool := false
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, (UInt0 imm2)) : (SRType × Int))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      bif (Bool.or (BEq.beq t 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STR_r_Op_A_txt add index m n shift_n shift_t t wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, m : Int, n : Nat, k_postindex : Bool, k_register_form : Bool, shift_n
  : Int, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STRT_Op_A_txt (add : Bool) (imm32 : (BitVec 32)) (m : Int) (n : Nat) (postindex : Bool) (register_form : Bool) (shift_n : Int) (shift_t : SRType) (t : Nat) : SailM Unit := do
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let offset ← (( do
    bif register_form
    then (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
    else (pure imm32) ) : SailM (BitVec 32) )
  let offset_addr ← (( do
    bif add
    then (pure ((← (R_read n)) + offset))
    else (pure ((← (R_read n)) - offset)) ) : SailM (BitVec 32) )
  let address ← (( do
    bif postindex
    then (R_read n)
    else (pure offset_addr) ) : SailM (BitVec 32) )
  let data ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let data ← (( do
    bif (BEq.beq t 15)
    then
      (do
        (PCStoreValue ()))
    else
      (do
        (R_read t)) ) : SailM (BitVec 32) )
  bif (Bool.and (Bool.and (Bool.not postindex) (bne t 15))
       (BEq.beq (← readReg PSTATE).T (0b1 : (BitVec 1))))
  then (pure (AArch32_SetLSInstructionSyndrome 4 false t false))
  else (pure ())
  (MemU_unpriv_set address 4 data)
  bif postindex
  then (R_set n offset_addr)
  else (pure ())

def decode_aarch32_instrs_STRT_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:15375.29-15375.30"
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm12 32)
      bif (Bool.or (BEq.beq n 15) (BEq.beq n t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      (execute_aarch32_instrs_STRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

def decode_aarch32_instrs_STRT_A2enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:15410.29-15410.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let postindex : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let register_form : Bool := true
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (BEq.beq n 15) (BEq.beq n t)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_STRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

def decode_aarch32_instrs_STRT_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      let m := m
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      let postindex : Bool := false
      let add : Bool := true
      let register_form : Bool := false
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STRT_Op_A_txt add imm32 m n postindex register_form shift_n shift_t t))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SUB_i_Op_A_txt (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (setflags : Bool) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read n)) (Complement.complement imm32) (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_SUB_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:15507.29-15507.30"
      bif (Bool.and (BEq.beq Rn (0xF : (BitVec 4))) (BEq.beq S (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "ADR"))
      else (pure ())
      bif (BEq.beq Rn (0xD : (BitVec 4)))
      then sailThrow ((Error_See "SUB (SP minus immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      (execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_SUB_i_T1enc_A_txt (imm3 : (BitVec 3)) (Rn : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let imm32 : (BitVec 32) := (zero_extend imm3 32)
      (execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_SUB_i_T2enc_A_txt (Rdn : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rdn)
      let n := (UInt0 Rdn)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      (execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_SUB_i_T3enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "CMP (immediate)"))
      else (pure ())
      bif (BEq.beq Rn (0xD : (BitVec 4)))
      then sailThrow ((Error_See "SUB (SP minus immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (T32ExpandImm ((i ++ imm3) ++ imm8)) ) : SailM (BitVec 32) )
      bif (Bool.or (Bool.and (BEq.beq d 15) (Bool.not setflags)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_SUB_i_T4enc_A_txt (i : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "ADR"))
      else (pure ())
      bif (BEq.beq Rn (0xD : (BitVec 4)))
      then sailThrow ((Error_See "SUB (SP minus immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let setflags : Bool := false
      let imm32 : (BitVec 32) := (zero_extend ((i ++ imm3) ++ imm8) 32)
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags))
  else (pure ())

def decode_aarch32_instrs_SUB_i_T5enc_A_txt (Rn : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Rn (0xE : (BitVec 4))) (IsZero imm8))
      then sailThrow ((Error_See "ERET"))
      else (pure ())
      let d := 15
      let n := (UInt0 Rn)
      let setflags : Bool := true
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      bif (bne n 14)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SUB_i_Op_A_txt d imm32 n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SUB_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read n)) (Complement.complement shifted) (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_SUB_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:15700.29-15700.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (BEq.beq Rn (0xD : (BitVec 4)))
      then sailThrow ((Error_See "SUB (SP minus register)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_SUB_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_SUB_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags ← (( do (pure (Bool.not (← (InITBlock ())))) ) : SailM Bool )
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_SUB_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_SUB_r_T2enc_A_txt (S : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "CMP (register)"))
      else (pure ())
      bif (BEq.beq Rn (0xD : (BitVec 4)))
      then sailThrow ((Error_See "SUB (SP minus register)"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.or (Bool.and (BEq.beq d 15) (Bool.not setflags)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SUB_r_Op_A_txt d m n setflags shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, s : Nat, k_setflags : Bool, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SUB_rr_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (s : Nat) (setflags : Bool) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read n)) (Complement.complement shifted) (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  (R_set d result)
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
      writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
      writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
  else (pure ())

def decode_aarch32_instrs_SUB_rr_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:15817.29-15817.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SUB_rr_Op_A_txt d m n s setflags shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, k_setflags : Bool, 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SUB_SP_i_Op_A_txt (d : Nat) (imm32 : (BitVec 32)) (setflags : Bool) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read 13)) (Complement.complement imm32) (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_SUB_SP_i_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:15870.29-15870.30"
      let d := (UInt0 Rd)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      (execute_aarch32_instrs_SUB_SP_i_Op_A_txt d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_SUB_SP_i_T1enc_A_txt (imm7 : (BitVec 7)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := 13
      let setflags : Bool := false
      let imm32 : (BitVec 32) := (zero_extend (imm7 ++ (0b00 : (BitVec 2))) 32)
      (execute_aarch32_instrs_SUB_SP_i_Op_A_txt d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_SUB_SP_i_T2enc_A_txt (i : (BitVec 1)) (S : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "CMP (immediate)"))
      else (pure ())
      let d := (UInt0 Rd)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let imm32 ← (( do (T32ExpandImm ((i ++ imm3) ++ imm8)) ) : SailM (BitVec 32) )
      bif (Bool.and (BEq.beq d 15) (Bool.not setflags))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SUB_SP_i_Op_A_txt d imm32 setflags))
  else (pure ())

def decode_aarch32_instrs_SUB_SP_i_T3enc_A_txt (i : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let setflags : Bool := false
      let imm32 : (BitVec 32) := (zero_extend ((i ++ imm3) ++ imm8) 32)
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SUB_SP_i_Op_A_txt d imm32 setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, k_setflags : Bool, shift_n : Int, 0 ≤ m ∧
  m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SUB_SP_r_Op_A_txt (d : Nat) (m : Nat) (setflags : Bool) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shifted ← (( do (Shift (← (R_read m)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do
    (pure (AddWithCarry (← (R_read 13)) (Complement.complement shifted) (0b1 : (BitVec 1))))
  let result : (BitVec 32) := tup__0
  let nzcv : (BitVec 4) := tup__1
  (pure ())
  bif (BEq.beq d 15)
  then
    (do
      bif setflags
      then (ALUExceptionReturn result)
      else (ALUWritePC result))
  else
    (do
      (R_set d result)
      bif setflags
      then
        (do
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb nzcv 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb nzcv 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb nzcv 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb nzcv 0 0) })
      else (pure ()))

def decode_aarch32_instrs_SUB_SP_r_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:15986.29-15986.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_SUB_SP_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_SUB_SP_r_T1enc_A_txt (S : (BitVec 1)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq Rd (0xF : (BitVec 4))) (BEq.beq S (0b1 : (BitVec 1))))
      then sailThrow ((Error_See "CMP (register)"))
      else (pure ())
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (Bool.and (BEq.beq d 15) (Bool.not setflags)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SUB_SP_r_Op_A_txt d m setflags shift_n shift_t))
  else (pure ())

def execute_aarch32_instrs_SVC_Op_A_txt (imm32 : (BitVec 32)) : SailM Unit := do
  (AArch32_CheckForSVCTrap (Sail.BitVec.extractLsb imm32 15 0))
  (AArch32_CallSupervisor (Sail.BitVec.extractLsb imm32 15 0))

def decode_aarch32_instrs_SVC_A1enc_A_txt (cond : (BitVec 4)) (imm24 : (BitVec 24)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16058.29-16058.30"
      let imm32 : (BitVec 32) := (zero_extend imm24 32)
      (execute_aarch32_instrs_SVC_Op_A_txt imm32))
  else (pure ())

def decode_aarch32_instrs_SVC_T1enc_A_txt (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      (execute_aarch32_instrs_SVC_Op_A_txt imm32))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SXTAB16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 15 0
      ((Sail.BitVec.extractLsb (← (R_read n)) 15 0) + (sign_extend
          (Sail.BitVec.extractLsb rotated 7 0) 16))))
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 31 16
      ((Sail.BitVec.extractLsb (← (R_read n)) 31 16) + (sign_extend
          (Sail.BitVec.extractLsb rotated 23 16) 16))))

def decode_aarch32_instrs_SXTAB16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16102.29-16102.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SXTB16"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTAB16_Op_A_txt d m n rotation))
  else (pure ())

def decode_aarch32_instrs_SXTAB16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SXTB16"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTAB16_Op_A_txt d m n rotation))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SXTAB_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d ((← (R_read n)) + (sign_extend (Sail.BitVec.extractLsb rotated 7 0) 32)))

def decode_aarch32_instrs_SXTAB_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16177.29-16177.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SXTB"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTAB_Op_A_txt d m n rotation))
  else (pure ())

def decode_aarch32_instrs_SXTAB_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SXTB"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTAB_Op_A_txt d m n rotation))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SXTAH_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d ((← (R_read n)) + (sign_extend (Sail.BitVec.extractLsb rotated 15 0) 32)))

def decode_aarch32_instrs_SXTAH_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16252.29-16252.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SXTH"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTAH_Op_A_txt d m n rotation))
  else (pure ())

def decode_aarch32_instrs_SXTAH_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "SXTH"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTAH_Op_A_txt d m n rotation))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SXTB16_Op_A_txt (d : Nat) (m : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 15 0
      (sign_extend (Sail.BitVec.extractLsb rotated 7 0) 16)))
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 31 16
      (sign_extend (Sail.BitVec.extractLsb rotated 23 16) 16)))

def decode_aarch32_instrs_SXTB16_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16328.29-16328.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTB16_Op_A_txt d m rotation))
  else (pure ())

def decode_aarch32_instrs_SXTB16_T1enc_A_txt (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTB16_Op_A_txt d m rotation))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SXTB_Op_A_txt (d : Nat) (m : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d (sign_extend (Sail.BitVec.extractLsb rotated 7 0) 32))

def decode_aarch32_instrs_SXTB_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16393.29-16393.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTB_Op_A_txt d m rotation))
  else (pure ())

def decode_aarch32_instrs_SXTB_T1enc_A_txt (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := 0
      (execute_aarch32_instrs_SXTB_Op_A_txt d m rotation))
  else (pure ())

def decode_aarch32_instrs_SXTB_T2enc_A_txt (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTB_Op_A_txt d m rotation))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_SXTH_Op_A_txt (d : Nat) (m : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d (sign_extend (Sail.BitVec.extractLsb rotated 15 0) 32))

def decode_aarch32_instrs_SXTH_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16477.29-16477.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTH_Op_A_txt d m rotation))
  else (pure ())

def decode_aarch32_instrs_SXTH_T1enc_A_txt (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := 0
      (execute_aarch32_instrs_SXTH_Op_A_txt d m rotation))
  else (pure ())

def decode_aarch32_instrs_SXTH_T2enc_A_txt (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SXTH_Op_A_txt d m rotation))
  else (pure ())

/-- Type quantifiers: k_is_tbh : Bool, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_TBB_Op_A_txt (is_tbh : Bool) (m : Nat) (n : Nat) : SailM Unit := do
  let halfwords ← (( do (undefined_range 0 65535) ) : SailM Nat )
  let halfwords ← (( do
    bif is_tbh
    then
      (do
        (pure (UInt0 (← (MemU_read ((← (R_read n)) + ((← (R_read m)) <<< 1)) 2)))))
    else
      (do
        (pure (UInt0 (← (MemU_read ((← (R_read n)) + (← (R_read m))) 1))))) ) : SailM Nat )
  let halfwords := halfwords
  (BranchWritePC (BitVec.addInt (← (PC_read__1 ())) (2 *i halfwords)) BranchType_INDIR)

def decode_aarch32_instrs_TBB_T1enc_A_txt (Rn : (BitVec 4)) (H : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let is_tbh : Bool := (BEq.beq H (0b1 : (BitVec 1)))
      bif (BEq.beq m 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_TBB_Op_A_txt is_tbh m n))
  else (pure ())

/-- Type quantifiers: n : Nat, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_TEQ_i_Op_A_txt (carry : (BitVec 1)) (imm32 : (BitVec 32)) (n : Nat) : SailM Unit := do
  let result ← (( do (pure ((← (R_read n)) ^^^ imm32)) ) : SailM (BitVec 32) )
  writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
  writeReg PSTATE { (← readReg PSTATE) with C := carry }

def decode_aarch32_instrs_TEQ_i_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16607.29-16607.30"
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let n := (UInt0 Rn)
      let (tup__0, tup__1) ← do (A32ExpandImm_C imm12 (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      (execute_aarch32_instrs_TEQ_i_Op_A_txt carry imm32 n))
  else (pure ())

def decode_aarch32_instrs_TEQ_i_T1enc_A_txt (i : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let n := (UInt0 Rn)
      let (tup__0, tup__1) ← do (T32ExpandImm_C ((i ++ imm3) ++ imm8) (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      let carry := carry
      (execute_aarch32_instrs_TEQ_i_Op_A_txt carry imm32 n))
  else (pure ())

/-- Type quantifiers: m : Nat, n : Nat, shift_n : Int, 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_TEQ_r_Op_A_txt (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) ^^^ shifted)) ) : SailM (BitVec 32) )
  writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
  writeReg PSTATE { (← readReg PSTATE) with C := carry }

def decode_aarch32_instrs_TEQ_r_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16674.29-16674.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_TEQ_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_TEQ_r_T1enc_A_txt (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq n 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_TEQ_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

/-- Type quantifiers: m : Nat, n : Nat, s : Nat, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_TEQ_rr_Op_A_txt (m : Nat) (n : Nat) (s : Nat) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) ^^^ shifted)) ) : SailM (BitVec 32) )
  writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
  writeReg PSTATE { (← readReg PSTATE) with C := carry }

def decode_aarch32_instrs_TEQ_rr_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16753.29-16753.30"
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (BEq.beq n 15) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_TEQ_rr_Op_A_txt m n s shift_t))
  else (pure ())

/-- Type quantifiers: n : Nat, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_TST_i_Op_A_txt (carry : (BitVec 1)) (imm32 : (BitVec 32)) (n : Nat) : SailM Unit := do
  let result ← (( do (pure ((← (R_read n)) &&& imm32)) ) : SailM (BitVec 32) )
  writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
  writeReg PSTATE { (← readReg PSTATE) with C := carry }

def decode_aarch32_instrs_TST_i_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16794.29-16794.30"
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let n := (UInt0 Rn)
      let (tup__0, tup__1) ← do (A32ExpandImm_C imm12 (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      (execute_aarch32_instrs_TST_i_Op_A_txt carry imm32 n))
  else (pure ())

def decode_aarch32_instrs_TST_i_T1enc_A_txt (i : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let n := (UInt0 Rn)
      let (tup__0, tup__1) ← do (T32ExpandImm_C ((i ++ imm3) ++ imm8) (← readReg PSTATE).C)
      let imm32 : (BitVec 32) := tup__0
      let carry : (BitVec 1) := tup__1
      (pure ())
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let imm32 := imm32
      let carry := carry
      (execute_aarch32_instrs_TST_i_Op_A_txt carry imm32 n))
  else (pure ())

/-- Type quantifiers: m : Nat, n : Nat, shift_n : Int, 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_TST_r_Op_A_txt (m : Nat) (n : Nat) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) &&& shifted)) ) : SailM (BitVec 32) )
  writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
  writeReg PSTATE { (← readReg PSTATE) with C := carry }

def decode_aarch32_instrs_TST_r_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (imm5 : (BitVec 5)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16861.29-16861.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let (tup__0, tup__1) ← do (DecodeImmShift stype imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      (execute_aarch32_instrs_TST_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_TST_r_T1enc_A_txt (Rm : (BitVec 3)) (Rn : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let _ : Unit :=
        let (tup__0, tup__1) := ((SRType_LSL, 0) : (SRType × Nat))
        let shift_t : SRType := tup__0
        let shift_n : Int := tup__1
        ()
      let shift_n := shift_n
      (execute_aarch32_instrs_TST_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_TST_r_T2enc_A_txt (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (imm2 : (BitVec 2)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let (tup__0, tup__1) ← do (DecodeImmShift stype (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq n 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_TST_r_Op_A_txt m n shift_n shift_t))
  else (pure ())

/-- Type quantifiers: m : Nat, n : Nat, s : Nat, 0 ≤ s ∧
  s ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 -/
def execute_aarch32_instrs_TST_rr_Op_A_txt (m : Nat) (n : Nat) (s : Nat) (shift_t : SRType) : SailM Unit := do
  let carry ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let shifted ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let shift_n ← do (pure (UInt0 (Sail.BitVec.extractLsb (← (R_read s)) 7 0)))
  let (tup__0, tup__1) ← do (Shift_C (← (R_read m)) shift_t shift_n (← readReg PSTATE).C)
  let shifted : (BitVec 32) := tup__0
  let carry : (BitVec 1) := tup__1
  (pure ())
  let result ← (( do (pure ((← (R_read n)) &&& shifted)) ) : SailM (BitVec 32) )
  writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(BitVec.access result 31)]) }
  writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit result) }
  writeReg PSTATE { (← readReg PSTATE) with C := carry }

def decode_aarch32_instrs_TST_rr_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rs : (BitVec 4)) (stype : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:16962.29-16962.30"
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let s := (UInt0 Rs)
      let shift_t ← (( do (DecodeRegShift stype) ) : SailM SRType )
      bif (Bool.or (Bool.or (BEq.beq n 15) (BEq.beq m 15)) (BEq.beq s 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_TST_rr_Op_A_txt m n s shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UADD16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let sum2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange sum1 15 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange sum2 15 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 1 0
    (bif (sum1 ≥b (UInt0 (0x10000 : (BitVec 20))))
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 3 2
    (bif (sum2 ≥b (UInt0 (0x10000 : (BitVec 20))))
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }

def decode_aarch32_instrs_UADD16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17006.29-17006.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UADD16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UADD16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UADD16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UADD8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let sum2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let sum3 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let sum4 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (integer_subrange sum1 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (integer_subrange sum2 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (integer_subrange sum3 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (integer_subrange sum4 7 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 0
    (Bit
      (bif (sum1 ≥b (UInt0 (0x100 : (BitVec 12))))
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 1
    (Bit
      (bif (sum2 ≥b (UInt0 (0x100 : (BitVec 12))))
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 2
    (Bit
      (bif (sum3 ≥b (UInt0 (0x100 : (BitVec 12))))
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 3
    (Bit
      (bif (sum4 ≥b (UInt0 (0x100 : (BitVec 12))))
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }

def decode_aarch32_instrs_UADD8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17077.29-17077.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UADD8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UADD8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UADD8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UASX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let sum ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange diff 15 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange sum 15 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 1 0
    (bif (diff ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 3 2
    (bif (sum ≥b (UInt0 (0x10000 : (BitVec 20))))
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }

def decode_aarch32_instrs_UASX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17142.29-17142.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UASX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UASX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UASX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, lsbit : Nat, msbit : Int, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ lsbit ∧ lsbit ≤ 31 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UBFX_Op_A_txt (d : Nat) (lsbit : Nat) (msbit : Int) (n : Nat) : SailM Unit := do
  assert (Bool.and (lsbit ≤b msbit) (msbit <b 32)) "src/instrs32.sail:17195.55-17195.56"
  (R_set d (zero_extend (Sail.BitVec.extractLsb (← (R_read n)) msbit lsbit) 32))

def decode_aarch32_instrs_UBFX_A1enc_A_txt (cond : (BitVec 4)) (widthm1 : (BitVec 5)) (Rd : (BitVec 4)) (lsb : (BitVec 5)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17203.29-17203.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let lsbit := (UInt0 lsb)
      let widthminus1 := (UInt0 widthm1)
      let msbit := (lsbit +i widthminus1)
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (msbit >b 31)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UBFX_Op_A_txt d lsbit msbit n))
  else (pure ())

def decode_aarch32_instrs_UBFX_T1enc_A_txt (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (widthm1 : (BitVec 5)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let lsbit := (UInt0 (imm3 ++ imm2))
      let widthminus1 := (UInt0 widthm1)
      let msbit := (lsbit +i widthminus1)
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (msbit >b 31)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UBFX_Op_A_txt d lsbit msbit n))
  else (pure ())

def execute_aarch32_instrs_UDF_Op_A_txt (_ : Unit) : SailM Unit := do
  sailThrow ((Error_Undefined ()))

def decode_aarch32_instrs_UDF_A1enc_A_txt (imm12 : (BitVec 12)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 : (BitVec 32) := (zero_extend (imm12 ++ imm4) 32)
      (execute_aarch32_instrs_UDF_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_UDF_T1enc_A_txt (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 : (BitVec 32) := (zero_extend imm8 32)
      (execute_aarch32_instrs_UDF_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_UDF_T2enc_A_txt (imm4 : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 : (BitVec 32) := (zero_extend (imm4 ++ imm12) 32)
      (execute_aarch32_instrs_UDF_Op_A_txt ()))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UDIV_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let result ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do
    bif (BEq.beq (UInt0 (← (R_read m))) 0)
    then (pure 0)
    else
      (do
        (pure (RoundTowardsZero
            (div_real (to_real (UInt0 (← (R_read n)))) (to_real (UInt0 (← (R_read m)))))))) ) :
    SailM Int )
  let result := result
  (R_set d (integer_subrange result 31 0))

def decode_aarch32_instrs_UDIV_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17339.29-17339.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (bne a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UDIV_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UDIV_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15)) (bne a 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UDIV_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UHADD16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let sum2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange sum1 16 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange sum2 16 1)))

def decode_aarch32_instrs_UHADD16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17402.29-17402.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHADD16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UHADD16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHADD16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UHADD8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let sum2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let sum3 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let sum4 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (integer_subrange sum1 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (integer_subrange sum2 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (integer_subrange sum3 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (integer_subrange sum4 8 1)))

def decode_aarch32_instrs_UHADD8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17469.29-17469.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHADD8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UHADD8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHADD8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UHASX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let sum ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange diff 16 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange sum 16 1)))

def decode_aarch32_instrs_UHASX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17532.29-17532.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHASX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UHASX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHASX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UHSAX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let diff ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange sum 16 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange diff 16 1)))

def decode_aarch32_instrs_UHSAX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17595.29-17595.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHSAX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UHSAX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHSAX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UHSUB16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let diff2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange diff1 16 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange diff2 16 1)))

def decode_aarch32_instrs_UHSUB16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17658.29-17658.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHSUB16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UHSUB16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHSUB16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UHSUB8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let diff2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let diff3 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let diff4 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (integer_subrange diff1 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (integer_subrange diff2 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (integer_subrange diff3 8 1)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (integer_subrange diff4 8 1)))

def decode_aarch32_instrs_UHSUB8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17725.29-17725.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHSUB8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UHSUB8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UHSUB8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: dHi : Nat, dLo : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ dLo ∧ dLo ≤ 15 ∧ 0 ≤ dHi ∧ dHi ≤ 15 -/
def execute_aarch32_instrs_UMAAL_Op_A_txt (dHi : Nat) (dLo : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let result ← do
    (pure ((((UInt0 (← (R_read n))) *i (UInt0 (← (R_read m)))) +i (UInt0 (← (R_read dHi)))) +i (UInt0
          (← (R_read dLo)))))
  (R_set dHi (integer_subrange result 63 32))
  (R_set dLo (integer_subrange result 31 0))

def decode_aarch32_instrs_UMAAL_A1enc_A_txt (cond : (BitVec 4)) (RdHi : (BitVec 4)) (RdLo : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17787.29-17787.30"
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UMAAL_Op_A_txt dHi dLo m n))
  else (pure ())

def decode_aarch32_instrs_UMAAL_T1enc_A_txt (Rn : (BitVec 4)) (RdLo : (BitVec 4)) (RdHi : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UMAAL_Op_A_txt dHi dLo m n))
  else (pure ())

/-- Type quantifiers: dHi : Nat, dLo : Nat, m : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ dLo ∧ dLo ≤ 15 ∧ 0 ≤ dHi ∧ dHi ≤ 15 -/
def execute_aarch32_instrs_UMLAL_Op_A_txt (dHi : Nat) (dLo : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let result ← do
    (pure (((UInt0 (← (R_read n))) *i (UInt0 (← (R_read m)))) +i (UInt0
          ((← (R_read dHi)) ++ (← (R_read dLo))))))
  (R_set dHi (integer_subrange result 63 32))
  (R_set dLo (integer_subrange result 31 0))
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(integer_access result 63)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit (integer_subrange result 63 0)) })
  else (pure ())

def decode_aarch32_instrs_UMLAL_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (RdHi : (BitVec 4)) (RdLo : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17860.29-17860.30"
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UMLAL_Op_A_txt dHi dLo m n setflags))
  else (pure ())

def decode_aarch32_instrs_UMLAL_T1enc_A_txt (Rn : (BitVec 4)) (RdLo : (BitVec 4)) (RdHi : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := false
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UMLAL_Op_A_txt dHi dLo m n setflags))
  else (pure ())

/-- Type quantifiers: dHi : Nat, dLo : Nat, m : Nat, n : Nat, k_setflags : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ dLo ∧ dLo ≤ 15 ∧ 0 ≤ dHi ∧ dHi ≤ 15 -/
def execute_aarch32_instrs_UMULL_Op_A_txt (dHi : Nat) (dLo : Nat) (m : Nat) (n : Nat) (setflags : Bool) : SailM Unit := do
  let result ← do (pure ((UInt0 (← (R_read n))) *i (UInt0 (← (R_read m)))))
  (R_set dHi (integer_subrange result 63 32))
  (R_set dLo (integer_subrange result 31 0))
  bif setflags
  then
    (do
      writeReg PSTATE { (← readReg PSTATE) with N := (BitVec.join1 [(integer_access result 63)]) }
      writeReg PSTATE { (← readReg PSTATE) with Z := (IsZeroBit (integer_subrange result 63 0)) })
  else (pure ())

def decode_aarch32_instrs_UMULL_A1enc_A_txt (cond : (BitVec 4)) (S : (BitVec 1)) (RdHi : (BitVec 4)) (RdLo : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:17936.29-17936.30"
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := (BEq.beq S (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UMULL_Op_A_txt dHi dLo m n setflags))
  else (pure ())

def decode_aarch32_instrs_UMULL_T1enc_A_txt (Rn : (BitVec 4)) (RdLo : (BitVec 4)) (RdHi : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let dLo := (UInt0 RdLo)
      let dHi := (UInt0 RdHi)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let setflags : Bool := false
      bif (Bool.or (Bool.or (Bool.or (BEq.beq dLo 15) (BEq.beq dHi 15)) (BEq.beq n 15))
           (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq dHi dLo)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UMULL_Op_A_txt dHi dLo m n setflags))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UQADD16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let sum2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (← (UnsignedSat sum1 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (← (UnsignedSat sum2 16))))

def decode_aarch32_instrs_UQADD16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18008.29-18008.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQADD16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UQADD16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQADD16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UQADD8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let sum2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let sum3 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let sum4 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (← (UnsignedSat sum1 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (← (UnsignedSat sum2 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (← (UnsignedSat sum3 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (← (UnsignedSat sum4 8))))

def decode_aarch32_instrs_UQADD8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18075.29-18075.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQADD8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UQADD8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQADD8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UQASX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let sum ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (← (UnsignedSat diff 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (← (UnsignedSat sum 16))))

def decode_aarch32_instrs_UQASX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18138.29-18138.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQASX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UQASX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQASX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UQSAX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let diff ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (← (UnsignedSat sum 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (← (UnsignedSat diff 16))))

def decode_aarch32_instrs_UQSAX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18201.29-18201.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQSAX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UQSAX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQSAX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UQSUB16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let diff2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (← (UnsignedSat diff1 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (← (UnsignedSat diff2 16))))

def decode_aarch32_instrs_UQSUB16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18264.29-18264.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQSUB16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UQSUB16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQSUB16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UQSUB8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let diff2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let diff3 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let diff4 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (← (UnsignedSat diff1 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (← (UnsignedSat diff2 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (← (UnsignedSat diff3 8))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (← (UnsignedSat diff4 8))))

def decode_aarch32_instrs_UQSUB8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18331.29-18331.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQSUB8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_UQSUB8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UQSUB8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_USAD8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let absdiff1 ← do
    (pure (Int.natAbs
        ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) -i (UInt0
            (Sail.BitVec.extractLsb (← (R_read m)) 7 0)))))
  let absdiff2 ← do
    (pure (Int.natAbs
        ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) -i (UInt0
            (Sail.BitVec.extractLsb (← (R_read m)) 15 8)))))
  let absdiff3 ← do
    (pure (Int.natAbs
        ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) -i (UInt0
            (Sail.BitVec.extractLsb (← (R_read m)) 23 16)))))
  let absdiff4 ← do
    (pure (Int.natAbs
        ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) -i (UInt0
            (Sail.BitVec.extractLsb (← (R_read m)) 31 24)))))
  let result := (((absdiff1 +i absdiff2) +i absdiff3) +i absdiff4)
  (R_set d (integer_subrange result 31 0))

def decode_aarch32_instrs_USAD8_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18396.29-18396.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USAD8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_USAD8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USAD8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: a : Nat, d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 ∧ 0 ≤ a ∧ a ≤ 15 -/
def execute_aarch32_instrs_USADA8_Op_A_txt (a : Nat) (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let absdiff1 ← do
    (pure (Int.natAbs
        ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) -i (UInt0
            (Sail.BitVec.extractLsb (← (R_read m)) 7 0)))))
  let absdiff2 ← do
    (pure (Int.natAbs
        ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) -i (UInt0
            (Sail.BitVec.extractLsb (← (R_read m)) 15 8)))))
  let absdiff3 ← do
    (pure (Int.natAbs
        ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) -i (UInt0
            (Sail.BitVec.extractLsb (← (R_read m)) 23 16)))))
  let absdiff4 ← do
    (pure (Int.natAbs
        ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) -i (UInt0
            (Sail.BitVec.extractLsb (← (R_read m)) 31 24)))))
  let result ← do
    (pure (((((UInt0 (← (R_read a))) +i absdiff1) +i absdiff2) +i absdiff3) +i absdiff4))
  (R_set d (integer_subrange result 31 0))

def decode_aarch32_instrs_USADA8_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (Ra : (BitVec 4)) (Rm : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18457.29-18457.30"
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "USAD8"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USADA8_Op_A_txt a d m n))
  else (pure ())

def decode_aarch32_instrs_USADA8_T1enc_A_txt (Rn : (BitVec 4)) (Ra : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Ra (0xF : (BitVec 4)))
      then sailThrow ((Error_See "USAD8"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let a := (UInt0 Ra)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USADA8_Op_A_txt a d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, saturate_to : Nat, 0 ≤ saturate_to ∧
  saturate_to ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_USAT16_Op_A_txt (d : Nat) (n : Nat) (saturate_to : Nat) : SailM Unit := do
  let result1 ← (( do (undefined_bitvector 16) ) : SailM (BitVec 16) )
  let result2 ← (( do (undefined_bitvector 16) ) : SailM (BitVec 16) )
  let sat1 ← (( do (undefined_bool ()) ) : SailM Bool )
  let sat2 ← (( do (undefined_bool ()) ) : SailM Bool )
  let (tup__0, tup__1) ← do
    (ZeroUnsignedSatQ (sint (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) saturate_to 16)
  let result1 : (BitVec 16) := tup__0
  let sat1 : Bool := tup__1
  (pure ())
  let (tup__0, tup__1) ← do
    (ZeroUnsignedSatQ (sint (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) saturate_to 16)
  let result2 : (BitVec 16) := tup__0
  let sat2 : Bool := tup__1
  (pure ())
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 result1))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 result2))
  bif (Bool.or sat1 sat2)
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_USAT16_A1enc_A_txt (cond : (BitVec 4)) (sat_imm : (BitVec 4)) (Rd : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18534.29-18534.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let saturate_to := (UInt0 sat_imm)
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USAT16_Op_A_txt d n saturate_to))
  else (pure ())

def decode_aarch32_instrs_USAT16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (sat_imm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let saturate_to := (UInt0 sat_imm)
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USAT16_Op_A_txt d n saturate_to))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, saturate_to : Nat, shift_n : Int, 0 ≤ saturate_to ∧
  saturate_to ≤ 31 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_USAT_Op_A_txt (d : Nat) (n : Nat) (saturate_to : Nat) (shift_n : Int) (shift_t : SRType) : SailM Unit := do
  let result ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let operand ← (( do (Shift (← (R_read n)) shift_t shift_n (← readReg PSTATE).C) ) : SailM
    (BitVec 32) )
  let (tup__0, tup__1) ← do (ZeroUnsignedSatQ (sint operand) saturate_to 32)
  let result : (BitVec 32) := tup__0
  let sat : Bool := tup__1
  (pure ())
  (R_set d result)
  bif sat
  then writeReg PSTATE { (← readReg PSTATE) with Q := (0b1 : (BitVec 1)) }
  else (pure ())

def decode_aarch32_instrs_USAT_A1enc_A_txt (cond : (BitVec 4)) (sat_imm : (BitVec 5)) (Rd : (BitVec 4)) (imm5 : (BitVec 5)) (sh : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18606.29-18606.30"
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let saturate_to := (UInt0 sat_imm)
      let (tup__0, tup__1) ← do (DecodeImmShift (sh ++ (0b0 : (BitVec 1))) imm5)
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let shift_t := shift_t
      let shift_n := shift_n
      (execute_aarch32_instrs_USAT_Op_A_txt d n saturate_to shift_n shift_t))
  else (pure ())

def decode_aarch32_instrs_USAT_T1enc_A_txt (sh : (BitVec 1)) (Rn : (BitVec 4)) (imm3 : (BitVec 3)) (Rd : (BitVec 4)) (imm2 : (BitVec 2)) (sat_imm : (BitVec 5)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let shift_n ← (( do (undefined_int ()) ) : SailM Int )
      let shift_t ← (( do (undefined_SRType ()) ) : SailM SRType )
      bif (Bool.and (BEq.beq sh (0b1 : (BitVec 1))) (BEq.beq (imm3 ++ imm2) (0b00000 : (BitVec 5))))
      then sailThrow ((Error_See "USAT16"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let saturate_to := (UInt0 sat_imm)
      let (tup__0, tup__1) ← do (DecodeImmShift (sh ++ (0b0 : (BitVec 1))) (imm3 ++ imm2))
      let shift_t : SRType := tup__0
      let shift_n : Int := tup__1
      (pure ())
      let shift_n := shift_n
      bif (Bool.or (BEq.beq d 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USAT_Op_A_txt d n saturate_to shift_n shift_t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_USAX_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let sum ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) +i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  let diff ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange sum 15 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange diff 15 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 1 0
    (bif (sum ≥b (UInt0 (0x10000 : (BitVec 20))))
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 3 2
    (bif (diff ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }

def decode_aarch32_instrs_USAX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18689.29-18689.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USAX_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_USAX_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USAX_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_USUB16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 0)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 0))))
  let diff2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 16)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 16))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 0 (integer_subrange diff1 15 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 16 (integer_subrange diff2 15 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 1 0
    (bif (diff1 ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (Sail.BitVec.updateSubrange
    (← readReg PSTATE).GE 3 2
    (bif (diff2 ≥b 0)
    then (0b11 : (BitVec 2))
    else (0b00 : (BitVec 2)))) }

def decode_aarch32_instrs_USUB16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18754.29-18754.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USUB16_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_USUB16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USUB16_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_USUB8_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let diff1 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 7 0)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 7 0))))
  let diff2 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 15 8)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 15 8))))
  let diff3 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 23 16)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 23 16))))
  let diff4 ← do
    (pure ((UInt0 (Sail.BitVec.extractLsb (← (R_read n)) 31 24)) -i (UInt0
          (Sail.BitVec.extractLsb (← (R_read m)) 31 24))))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 7 0 (integer_subrange diff1 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 15 8 (integer_subrange diff2 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 23 16 (integer_subrange diff3 7 0)))
  (R_set d (Sail.BitVec.updateSubrange (← (R_read d)) 31 24 (integer_subrange diff4 7 0)))
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 0
    (Bit
      (bif (diff1 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 1
    (Bit
      (bif (diff2 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 2
    (Bit
      (bif (diff3 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }
  writeReg PSTATE { (← readReg PSTATE) with GE := (BitVec.update (← readReg PSTATE).GE 3
    (Bit
      (bif (diff4 ≥b 0)
      then (0b1 : (BitVec 1))
      else (0b0 : (BitVec 1))))) }

def decode_aarch32_instrs_USUB8_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18825.29-18825.30"
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USUB8_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_USUB8_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_USUB8_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UXTAB16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 15 0
      ((Sail.BitVec.extractLsb (← (R_read n)) 15 0) + (zero_extend
          (Sail.BitVec.extractLsb rotated 7 0) 16))))
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 31 16
      ((Sail.BitVec.extractLsb (← (R_read n)) 31 16) + (zero_extend
          (Sail.BitVec.extractLsb rotated 23 16) 16))))

def decode_aarch32_instrs_UXTAB16_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18887.29-18887.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "UXTB16"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTAB16_Op_A_txt d m n rotation))
  else (pure ())

def decode_aarch32_instrs_UXTAB16_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "UXTB16"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTAB16_Op_A_txt d m n rotation))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UXTAB_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d ((← (R_read n)) + (zero_extend (Sail.BitVec.extractLsb rotated 7 0) 32)))

def decode_aarch32_instrs_UXTAB_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:18962.29-18962.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "UXTB"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTAB_Op_A_txt d m n rotation))
  else (pure ())

def decode_aarch32_instrs_UXTAB_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "UXTB"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTAB_Op_A_txt d m n rotation))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UXTAH_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d ((← (R_read n)) + (zero_extend (Sail.BitVec.extractLsb rotated 15 0) 32)))

def decode_aarch32_instrs_UXTAH_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:19037.29-19037.30"
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "UXTH"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTAH_Op_A_txt d m n rotation))
  else (pure ())

def decode_aarch32_instrs_UXTAH_T1enc_A_txt (Rn : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Rn (0xF : (BitVec 4)))
      then sailThrow ((Error_See "UXTH"))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTAH_Op_A_txt d m n rotation))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UXTB16_Op_A_txt (d : Nat) (m : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 15 0
      (zero_extend (Sail.BitVec.extractLsb rotated 7 0) 16)))
  (R_set d
    (Sail.BitVec.updateSubrange (← (R_read d)) 31 16
      (zero_extend (Sail.BitVec.extractLsb rotated 23 16) 16)))

def decode_aarch32_instrs_UXTB16_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:19113.29-19113.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTB16_Op_A_txt d m rotation))
  else (pure ())

def decode_aarch32_instrs_UXTB16_T1enc_A_txt (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTB16_Op_A_txt d m rotation))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UXTB_Op_A_txt (d : Nat) (m : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d (zero_extend (Sail.BitVec.extractLsb rotated 7 0) 32))

def decode_aarch32_instrs_UXTB_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:19178.29-19178.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTB_Op_A_txt d m rotation))
  else (pure ())

def decode_aarch32_instrs_UXTB_T1enc_A_txt (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := 0
      (execute_aarch32_instrs_UXTB_Op_A_txt d m rotation))
  else (pure ())

def decode_aarch32_instrs_UXTB_T2enc_A_txt (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTB_Op_A_txt d m rotation))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, rotation : Nat, 0 ≤ rotation ∧
  rotation ≤ 31 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_UXTH_Op_A_txt (d : Nat) (m : Nat) (rotation : Nat) : SailM Unit := do
  let rotated ← (( do (pure (ROR (← (R_read m)) rotation)) ) : SailM (BitVec 32) )
  (R_set d (zero_extend (Sail.BitVec.extractLsb rotated 15 0) 32))

def decode_aarch32_instrs_UXTH_A1enc_A_txt (cond : (BitVec 4)) (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:19262.29-19262.30"
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTH_Op_A_txt d m rotation))
  else (pure ())

def decode_aarch32_instrs_UXTH_T1enc_A_txt (Rm : (BitVec 3)) (Rd : (BitVec 3)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := 0
      (execute_aarch32_instrs_UXTH_Op_A_txt d m rotation))
  else (pure ())

def decode_aarch32_instrs_UXTH_T2enc_A_txt (Rd : (BitVec 4)) (rotate : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let m := (UInt0 Rm)
      let rotation := (UInt0 (rotate ++ (0b000 : (BitVec 3))))
      bif (Bool.or (BEq.beq d 15) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_UXTH_Op_A_txt d m rotation))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, k_long_destination
  : Bool, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VABA_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (long_destination : Bool) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let absdiff ← (( do (undefined_int ()) ) : SailM Int )
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (absdiff, op1, op2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (absdiff, op1, op2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (absdiff, op1, op2) := loop_vars
      loop_vars ← do
        let (absdiff, op1, op2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (absdiff, op1, op2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (absdiff, op1, op2) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (Din_read (n +i r))) e esize)
              let op2 ← (Elem_read (← (Din_read (m +i r))) e esize)
              let absdiff ←
                (pure (Int.natAbs
                    ((← (asl_Int op1 is_unsigned)) -i (← (asl_Int op2 is_unsigned)))))
              bif long_destination
              then
                (Q_set (Int.shiftr d 1)
                  (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize)
                      (BitVec.addInt
                        (← (Elem_read (← (Qin_read (Int.shiftr d 1))) e (2 *i esize))) absdiff))))
              else
                (D_set (d +i r)
                  (← (Elem_set (← (D_read (d +i r))) e esize
                      (BitVec.addInt (← (Elem_read (← (Din_read (d +i r))) e esize)) absdiff))))
              (pure (absdiff, op1, op2))
          (pure loop_vars_1) ) : SailM (Int × (BitVec esize) × (BitVec esize)) )
        (pure (absdiff, op1, op2))
    (pure loop_vars) ) : SailM (Int × (BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VABA_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let long_destination : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VABA_Op_A_txt d elements esize long_destination m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VABA_A2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let long_destination : Bool := true
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs := 1
      (execute_aarch32_instrs_VABA_Op_A_txt d elements esize long_destination m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VABA_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let long_destination : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VABA_Op_A_txt d elements esize long_destination m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VABA_T2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let long_destination : Bool := true
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs := 1
      (execute_aarch32_instrs_VABA_Op_A_txt d elements esize long_destination m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VABD_f_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (op1, op2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2) := loop_vars
      loop_vars ← do
        let (op1, op2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (n +i r))) e esize)
              let op2 ← (Elem_read (← (D_read (m +i r))) e esize)
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (← (FPAbs (← (FPSub op1 op2 (← (StandardFPSCRValue ())))))))))
              (pure (op1, op2))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, op2))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VABD_f_A1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VABD_f_Op_A_txt d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VABD_f_T1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VABD_f_Op_A_txt d elements esize m n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, k_long_destination
  : Bool, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VABD_i_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (long_destination : Bool) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let absdiff ← (( do (undefined_int ()) ) : SailM Int )
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (absdiff, op1, op2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (absdiff, op1, op2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (absdiff, op1, op2) := loop_vars
      loop_vars ← do
        let (absdiff, op1, op2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (absdiff, op1, op2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (absdiff, op1, op2) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (Din_read (n +i r))) e esize)
              let op2 ← (Elem_read (← (Din_read (m +i r))) e esize)
              let absdiff ←
                (pure (Int.natAbs
                    ((← (asl_Int op1 is_unsigned)) -i (← (asl_Int op2 is_unsigned)))))
              bif long_destination
              then
                (Q_set (Int.shiftr d 1)
                  (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize)
                      (integer_subrange absdiff ((2 *i esize) -i 1) 0))))
              else
                (D_set (d +i r)
                  (← (Elem_set (← (D_read (d +i r))) e esize
                      (integer_subrange absdiff (esize -i 1) 0))))
              (pure (absdiff, op1, op2))
          (pure loop_vars_1) ) : SailM (Int × (BitVec esize) × (BitVec esize)) )
        (pure (absdiff, op1, op2))
    (pure loop_vars) ) : SailM (Int × (BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VABD_i_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let long_destination : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VABD_i_Op_A_txt d elements esize long_destination m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VABD_i_A2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let long_destination : Bool := true
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs := 1
      (execute_aarch32_instrs_VABD_i_Op_A_txt d elements esize long_destination m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VABD_i_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let long_destination : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VABD_i_Op_A_txt d elements esize long_destination m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VABD_i_T2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let long_destination : Bool := true
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs := 1
      (execute_aarch32_instrs_VABD_i_Op_A_txt d elements esize long_destination m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: k_advsimd : Bool, d__arg : Nat, elements : Int, esize : Nat, k_floating_point
  : Bool, m : Nat, regs : Int, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VABS_Op_A_txt (advsimd : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (floating_point : Bool) (m : Nat) (regs : Int) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif advsimd
  then
    (do
      let result ← (( do
        let loop_r_lower := 0
        let loop_r_upper := (regs -i 1)
        let mut loop_vars := result
        for r in [loop_r_lower:loop_r_upper:1]i do
          let result := loop_vars
          loop_vars ← do
            let loop_e_lower := 0
            let loop_e_upper := (elements -i 1)
            let mut loop_vars_1 := result
            for e in [loop_e_lower:loop_e_upper:1]i do
              let result := loop_vars_1
              loop_vars_1 ← do
                bif floating_point
                then
                  (do
                    assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                      (BEq.beq esize 64)) "src/instrs32.sail:19798.61-19798.62"
                    (D_set (d +i r)
                      (← (Elem_set (← (D_read (d +i r))) e esize
                          (← (FPAbs (← (Elem_read (← (D_read (m +i r))) e esize)))))))
                    (pure result))
                else
                  (do
                    let result ←
                      (pure (Int.natAbs (sint (← (Elem_read (← (D_read (m +i r))) e esize)))))
                    (D_set (d +i r)
                      (← (Elem_set (← (D_read (d +i r))) e esize
                          (integer_subrange result (esize -i 1) 0))))
                    (pure result))
            (pure loop_vars_1)
        (pure loop_vars) ) : SailM Int )
      (pure ()))
  else
    (do
      match esize with
      | 16 => (S_set d
          ((Zeros (n := 16)) ++ (← (FPAbs (Sail.BitVec.extractLsb (← (S_read m)) 15 0)))))
      | 32 => (S_set d (← (FPAbs (← (S_read m)))))
      | 64 => (D_set d (← (FPAbs (← (D_read m)))))
      | _ => (pure ()))

def decode_aarch32_instrs_VABS_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let advsimd : Bool := true
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VABS_Op_A_txt advsimd d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VABS_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:19863.29-19863.30"
      let floating_point ← (( do (undefined_bool ()) ) : SailM Bool )
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let floating_point := floating_point
      let advsimd : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VABS_Op_A_txt advsimd d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VABS_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
           (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let advsimd : Bool := true
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VABS_Op_A_txt advsimd d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VABS_T2enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let floating_point ← (( do (undefined_bool ()) ) : SailM Bool )
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let floating_point := floating_point
      let advsimd : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VABS_Op_A_txt advsimd d elements esize floating_point m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, n : Nat, k_or_equal : Bool, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VACGE_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (n : Nat) (or_equal : Bool) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (op1, op2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2) := loop_vars
      loop_vars ← do
        let (op1, op2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (FPAbs (← (Elem_read (← (D_read (n +i r))) e esize)))
              let op2 ← (FPAbs (← (Elem_read (← (D_read (m +i r))) e esize)))
              let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
              let test_passed ← (( do
                bif or_equal
                then
                  (do
                    (FPCompareGE op1 op2 (← (StandardFPSCRValue ()))))
                else
                  (do
                    (FPCompareGT op1 op2 (← (StandardFPSCRValue ())))) ) : SailM Bool )
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (bif test_passed
                    then (Ones (n := esize))
                    else (Zeros (n := esize))))))
              (pure (op1, op2))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, op2))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VACGE_A1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let or_equal : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VACGE_Op_A_txt d elements esize m n or_equal regs))
  else (pure ())

def decode_aarch32_instrs_VACGE_T1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let or_equal : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VACGE_Op_A_txt d elements esize m n or_equal regs))
  else (pure ())

/-- Type quantifiers: k_advsimd : Bool, d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, regs
  : Int, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VADD_f_Op_A_txt (advsimd : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Int) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif advsimd
  then
    (do
      let loop_r_lower := 0
      let loop_r_upper := (regs -i 1)
      let mut loop_vars := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars
        loop_vars ← do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := ()
          for e in [loop_e_lower:loop_e_upper:1]i do
            let () := loop_vars_1
            loop_vars_1 ← do
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (← (FPAdd (← (Elem_read (← (D_read (n +i r))) e esize))
                        (← (Elem_read (← (D_read (m +i r))) e esize))
                        (← (StandardFPSCRValue ())))))))
          (pure loop_vars_1)
      (pure loop_vars))
  else
    (do
      match esize with
      | 16 => (S_set d
          ((Zeros (n := 16)) ++ (← (FPAdd (Sail.BitVec.extractLsb (← (S_read n)) 15 0)
                (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ()))))))
      | 32 => (S_set d (← (FPAdd (← (S_read n)) (← (S_read m)) (← (FPSCR_read ())))))
      | 64 => (D_set d (← (FPAdd (← (D_read n)) (← (D_read m)) (← (FPSCR_read ())))))
      | _ => (pure ()))

def decode_aarch32_instrs_VADD_f_A1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let advsimd : Bool := true
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VADD_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VADD_f_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:20225.29-20225.30"
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let advsimd : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VADD_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VADD_f_T1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let advsimd : Bool := true
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VADD_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VADD_f_T2enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let advsimd : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VADD_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VADDHN_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (pure ((← (Elem_read (← (Qin_read (Int.shiftl n 1))) e (2 *i esize))) + (← (Elem_read
                  (← (Qin_read (Int.shiftl m 1))) e (2 *i esize)))))
        (D_set d
          (← (Elem_set (← (D_read d)) e esize
              (Sail.BitVec.extractLsb result ((2 *i esize) -i 1) esize))))
        (pure result)
    (pure loop_vars) ) : SailM (BitVec (2 * esize)) )
  (pure ())

def decode_aarch32_instrs_VADDHN_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VADDHN_Op_A_txt d elements esize m n))
  else (pure ())

def decode_aarch32_instrs_VADDHN_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VADDHN_Op_A_txt d elements esize m n))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VADD_i_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                ((← (Elem_read (← (D_read (n +i r))) e esize)) + (← (Elem_read
                      (← (D_read (m +i r))) e esize))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VADD_i_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VADD_i_Op_A_txt d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VADD_i_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VADD_i_Op_A_txt d elements esize m n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, k_is_vaddw :
  Bool, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VADDL_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (is_vaddw : Bool) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let op1 ← (( do (undefined_int ()) ) : SailM Int )
        let op1 ← (( do
          bif is_vaddw
          then
            (do
              (asl_Int (← (Elem_read (← (Qin_read (Int.shiftl n 1))) e (2 *i esize)))
                is_unsigned))
          else
            (do
              (asl_Int (← (Elem_read (← (Din_read n)) e esize)) is_unsigned)) ) : SailM Int )
        let op1 := op1
        let result ←
          (pure (op1 +i (← (asl_Int (← (Elem_read (← (Din_read m)) e esize)) is_unsigned))))
        (Q_set (Int.shiftr d 1)
          (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize)
              (integer_subrange result ((2 *i esize) -i 1) 0))))
        (pure result)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VADDL_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (Bool.and (BEq.beq op (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let is_vaddw : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VADDL_Op_A_txt d elements esize is_vaddw m n is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VADDL_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (Bool.and (BEq.beq op (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let is_vaddw : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VADDL_Op_A_txt d elements esize is_vaddw m n is_unsigned))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VAND_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do (D_set (d +i r) ((← (D_read (n +i r))) &&& (← (D_read (m +i r)))))
  (pure loop_vars)

def decode_aarch32_instrs_VAND_r_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VAND_r_Op_A_txt d m n regs))
  else (pure ())

def decode_aarch32_instrs_VAND_r_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VAND_r_Op_A_txt d m n regs))
  else (pure ())

/-- Type quantifiers: d : Nat, regs : Nat, regs ∈ {1, 2} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VBIC_i_Op_A_txt (d : Nat) (imm64 : (BitVec 64)) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do (D_set (d +i r) ((← (D_read (d +i r))) &&& (Complement.complement imm64)))
  (pure loop_vars)

def decode_aarch32_instrs_VBIC_i_A1enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b0 : (BitVec 1)))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b1 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VBIC_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VBIC_i_A2enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b0 : (BitVec 1)))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b1 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VBIC_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VBIC_i_T1enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b0 : (BitVec 1)))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b1 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VBIC_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VBIC_i_T2enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b0 : (BitVec 1)))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b1 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VBIC_i_Op_A_txt d imm64 regs))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VBIC_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      (D_set (d +i r) ((← (D_read (n +i r))) &&& (Complement.complement (← (D_read (m +i r))))))
  (pure loop_vars)

def decode_aarch32_instrs_VBIC_r_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VBIC_r_Op_A_txt d m n regs))
  else (pure ())

def decode_aarch32_instrs_VBIC_r_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VBIC_r_Op_A_txt d m n regs))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VBIF_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (operation : VBitOps) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      match operation with
      | VBitOps_VBIF => (D_set (d +i r)
          (((← (D_read (d +i r))) &&& (← (D_read (m +i r)))) ||| ((← (D_read (n +i r))) &&& (Complement.complement
                (← (D_read (m +i r)))))))
      | VBitOps_VBIT => (D_set (d +i r)
          (((← (D_read (n +i r))) &&& (← (D_read (m +i r)))) ||| ((← (D_read (d +i r))) &&& (Complement.complement
                (← (D_read (m +i r)))))))
      | VBitOps_VBSL => (D_set (d +i r)
          (((← (D_read (n +i r))) &&& (← (D_read (d +i r)))) ||| ((← (D_read (m +i r))) &&& (Complement.complement
                (← (D_read (d +i r)))))))
  (pure loop_vars)

def decode_aarch32_instrs_VBIF_A1enc_A_txt (D : (BitVec 1)) (op : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let operation : VBitOps := VBitOps_VBIF
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq op (0b00 : (BitVec 2)))
      then sailThrow ((Error_See "VEOR"))
      else (pure ())
      let operation : VBitOps :=
        bif (BEq.beq op (0b01 : (BitVec 2)))
        then VBitOps_VBSL
        else operation
      let operation : VBitOps :=
        bif (BEq.beq op (0b10 : (BitVec 2)))
        then VBitOps_VBIT
        else operation
      let operation : VBitOps :=
        bif (BEq.beq op (0b11 : (BitVec 2)))
        then VBitOps_VBIF
        else operation
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VBIF_Op_A_txt d m n operation regs))
  else (pure ())

def decode_aarch32_instrs_VBIF_T1enc_A_txt (D : (BitVec 1)) (op : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let operation : VBitOps := VBitOps_VBIF
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq op (0b00 : (BitVec 2)))
      then sailThrow ((Error_See "VEOR"))
      else (pure ())
      let operation : VBitOps :=
        bif (BEq.beq op (0b01 : (BitVec 2)))
        then VBitOps_VBSL
        else operation
      let operation : VBitOps :=
        bif (BEq.beq op (0b10 : (BitVec 2)))
        then VBitOps_VBIT
        else operation
      let operation : VBitOps :=
        bif (BEq.beq op (0b11 : (BitVec 2)))
        then VBitOps_VBIF
        else operation
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VBIF_Op_A_txt d m n operation regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_floating_point : Bool, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCEQ_i_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (floating_point : Bool) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
          let test_passed ← (( do
            bif floating_point
            then
              (do
                assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs32.sail:21029.57-21029.58"
                let zero ← (( do (FPZero (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
                (FPCompareEQ (← (Elem_read (← (D_read (m +i r))) e esize)) zero
                  (← (StandardFPSCRValue ()))))
            else
              (do
                (pure (BEq.beq (← (Elem_read (← (D_read (m +i r))) e esize))
                    (Zeros (n := esize))))) ) : SailM Bool )
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (bif test_passed
                then (Ones (n := esize))
                else (Zeros (n := esize))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VCEQ_i_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCEQ_i_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VCEQ_i_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
           (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCEQ_i_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_int_operation : Bool, m : Nat, n
  : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCEQ_r_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (int_operation : Bool) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (op1, op2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2) := loop_vars
      loop_vars ← do
        let (op1, op2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (n +i r))) e esize)
              let op2 ← (Elem_read (← (D_read (m +i r))) e esize)
              let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
              let test_passed ← (( do
                bif int_operation
                then (pure (BEq.beq op1 op2))
                else
                  (do
                    assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                      (BEq.beq esize 64)) "src/instrs32.sail:21135.57-21135.58"
                    (FPCompareEQ op1 op2 (← (StandardFPSCRValue ())))) ) : SailM Bool )
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (bif test_passed
                    then (Ones (n := esize))
                    else (Zeros (n := esize))))))
              (pure (op1, op2))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, op2))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VCEQ_r_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let int_operation : Bool := true
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCEQ_r_Op_A_txt d elements esize int_operation m n regs))
  else (pure ())

def decode_aarch32_instrs_VCEQ_r_A2enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let int_operation : Bool := false
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCEQ_r_Op_A_txt d elements esize int_operation m n regs))
  else (pure ())

def decode_aarch32_instrs_VCEQ_r_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let int_operation : Bool := true
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCEQ_r_Op_A_txt d elements esize int_operation m n regs))
  else (pure ())

def decode_aarch32_instrs_VCEQ_r_T2enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let int_operation : Bool := false
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCEQ_r_Op_A_txt d elements esize int_operation m n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_floating_point : Bool, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCGE_i_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (floating_point : Bool) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
          let test_passed ← (( do
            bif floating_point
            then
              (do
                assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs32.sail:21324.57-21324.58"
                let zero ← (( do (FPZero (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
                (FPCompareGE (← (Elem_read (← (D_read (m +i r))) e esize)) zero
                  (← (StandardFPSCRValue ()))))
            else
              (do
                (pure ((sint (← (Elem_read (← (D_read (m +i r))) e esize))) ≥b 0))) ) : SailM
            Bool )
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (bif test_passed
                then (Ones (n := esize))
                else (Zeros (n := esize))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VCGE_i_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGE_i_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VCGE_i_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
           (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGE_i_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCGE_r_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (vtype : VCGEType) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (op1, op2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2) := loop_vars
      loop_vars ← do
        let (op1, op2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (n +i r))) e esize)
              let op2 ← (Elem_read (← (D_read (m +i r))) e esize)
              let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
              let test_passed ← (( do
                match vtype with
                | VCGEType_signed => (pure ((sint op1) ≥b (sint op2)))
                | VCGEType_unsigned => (pure ((UInt0 op1) ≥b (UInt0 op2)))
                | VCGEType_fp => (do
                    assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                      (BEq.beq esize 64)) "src/instrs32.sail:21435.59-21435.60"
                    (FPCompareGE op1 op2 (← (StandardFPSCRValue ())))) ) : SailM Bool )
              let test_passed := test_passed
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (bif test_passed
                    then (Ones (n := esize))
                    else (Zeros (n := esize))))))
              (pure (op1, op2))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, op2))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VCGE_r_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let vtype : VCGEType :=
        bif (BEq.beq U (0b1 : (BitVec 1)))
        then VCGEType_unsigned
        else VCGEType_signed
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGE_r_Op_A_txt d elements esize m n regs vtype))
  else (pure ())

def decode_aarch32_instrs_VCGE_r_A2enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let vtype : VCGEType := VCGEType_fp
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGE_r_Op_A_txt d elements esize m n regs vtype))
  else (pure ())

def decode_aarch32_instrs_VCGE_r_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let vtype : VCGEType :=
        bif (BEq.beq U (0b1 : (BitVec 1)))
        then VCGEType_unsigned
        else VCGEType_signed
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGE_r_Op_A_txt d elements esize m n regs vtype))
  else (pure ())

def decode_aarch32_instrs_VCGE_r_T2enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let vtype : VCGEType := VCGEType_fp
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGE_r_Op_A_txt d elements esize m n regs vtype))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_floating_point : Bool, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCGT_i_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (floating_point : Bool) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
          let test_passed ← (( do
            bif floating_point
            then
              (do
                assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs32.sail:21630.57-21630.58"
                let zero ← (( do (FPZero (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
                (FPCompareGT (← (Elem_read (← (D_read (m +i r))) e esize)) zero
                  (← (StandardFPSCRValue ()))))
            else
              (do
                (pure ((sint (← (Elem_read (← (D_read (m +i r))) e esize))) >b 0))) ) : SailM
            Bool )
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (bif test_passed
                then (Ones (n := esize))
                else (Zeros (n := esize))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VCGT_i_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGT_i_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VCGT_i_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
           (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGT_i_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCGT_r_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (vtype : VCGTtype) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (op1, op2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2) := loop_vars
      loop_vars ← do
        let (op1, op2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (n +i r))) e esize)
              let op2 ← (Elem_read (← (D_read (m +i r))) e esize)
              let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
              let test_passed ← (( do
                match vtype with
                | VCGTtype_signed => (pure ((sint op1) >b (sint op2)))
                | VCGTtype_unsigned => (pure ((UInt0 op1) >b (UInt0 op2)))
                | VCGTtype_fp => (do
                    assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                      (BEq.beq esize 64)) "src/instrs32.sail:21741.59-21741.60"
                    (FPCompareGT op1 op2 (← (StandardFPSCRValue ())))) ) : SailM Bool )
              let test_passed := test_passed
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (bif test_passed
                    then (Ones (n := esize))
                    else (Zeros (n := esize))))))
              (pure (op1, op2))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, op2))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VCGT_r_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let vtype : VCGTtype :=
        bif (BEq.beq U (0b1 : (BitVec 1)))
        then VCGTtype_unsigned
        else VCGTtype_signed
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGT_r_Op_A_txt d elements esize m n regs vtype))
  else (pure ())

def decode_aarch32_instrs_VCGT_r_A2enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let vtype : VCGTtype := VCGTtype_fp
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGT_r_Op_A_txt d elements esize m n regs vtype))
  else (pure ())

def decode_aarch32_instrs_VCGT_r_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let vtype : VCGTtype :=
        bif (BEq.beq U (0b1 : (BitVec 1)))
        then VCGTtype_unsigned
        else VCGTtype_signed
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGT_r_Op_A_txt d elements esize m n regs vtype))
  else (pure ())

def decode_aarch32_instrs_VCGT_r_T2enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let vtype : VCGTtype := VCGTtype_fp
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCGT_r_Op_A_txt d elements esize m n regs vtype))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_floating_point : Bool, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCLE_i_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (floating_point : Bool) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
          let test_passed ← (( do
            bif floating_point
            then
              (do
                assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs32.sail:21936.57-21936.58"
                let zero ← (( do (FPZero (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
                (FPCompareGE zero (← (Elem_read (← (D_read (m +i r))) e esize))
                  (← (StandardFPSCRValue ()))))
            else
              (do
                (pure ((sint (← (Elem_read (← (D_read (m +i r))) e esize))) ≤b 0))) ) : SailM
            Bool )
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (bif test_passed
                then (Ones (n := esize))
                else (Zeros (n := esize))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VCLE_i_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCLE_i_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VCLE_i_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
           (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCLE_i_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, regs : Nat, regs ∈
  {1, 2} ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCLS_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (integer_subrange
                  (CountLeadingSignBits (← (Elem_read (← (D_read (m +i r))) e esize)))
                  (esize -i 1) 0))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VCLS_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCLS_Op_A_txt d elements esize m regs))
  else (pure ())

def decode_aarch32_instrs_VCLS_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCLS_Op_A_txt d elements esize m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_floating_point : Bool, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCLT_i_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (floating_point : Bool) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          let test_passed ← (( do (undefined_bool ()) ) : SailM Bool )
          let test_passed ← (( do
            bif floating_point
            then
              (do
                assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) (BEq.beq esize 64)) "src/instrs32.sail:22112.57-22112.58"
                let zero ← (( do (FPZero (0b0 : (BitVec 1)) esize) ) : SailM (BitVec esize) )
                (FPCompareGT zero (← (Elem_read (← (D_read (m +i r))) e esize))
                  (← (StandardFPSCRValue ()))))
            else
              (do
                (pure ((sint (← (Elem_read (← (D_read (m +i r))) e esize))) <b 0))) ) : SailM
            Bool )
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (bif test_passed
                then (Ones (n := esize))
                else (Zeros (n := esize))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VCLT_i_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCLT_i_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VCLT_i_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
           (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCLT_i_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, regs : Nat, regs ∈
  {1, 2} ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCLZ_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (integer_subrange
                  (CountLeadingZeroBits (← (Elem_read (← (D_read (m +i r))) e esize)))
                  (esize -i 1) 0))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VCLZ_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCLZ_Op_A_txt d elements esize m regs))
  else (pure ())

def decode_aarch32_instrs_VCLZ_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCLZ_Op_A_txt d elements esize m regs))
  else (pure ())

/-- Type quantifiers: d : Nat, esize : Nat, m : Int, k_quiet_nan_exc : Bool, k_with_zero : Bool, esize
  ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VCMP_Op_A_txt (d : Nat) (esize : Nat) (m : Int) (quiet_nan_exc : Bool) (with_zero : Bool) : SailM Unit := do
  (CheckVFPEnabled true)
  let nzcv ← (( do (undefined_bitvector 4) ) : SailM (BitVec 4) )
  let nzcv ← (( do
    match esize with
    | 16 => (do
        let op16 ← (( do
          bif with_zero
          then (FPZero (0b0 : (BitVec 1)) 16)
          else (pure (Sail.BitVec.extractLsb (← (S_read m)) 15 0)) ) : SailM (BitVec 16) )
        (FPCompare (Sail.BitVec.extractLsb (← (S_read d)) 15 0) op16 quiet_nan_exc
          (← (FPSCR_read ()))))
    | 32 => (do
        let op32 ← (( do
          bif with_zero
          then (FPZero (0b0 : (BitVec 1)) 32)
          else (S_read m) ) : SailM (BitVec 32) )
        (FPCompare (← (S_read d)) op32 quiet_nan_exc (← (FPSCR_read ()))))
    | 64 => (do
        let op64 ← (( do
          bif with_zero
          then (FPZero (0b0 : (BitVec 1)) 64)
          else (D_read m) ) : SailM (BitVec 64) )
        (FPCompare (← (D_read d)) op64 quiet_nan_exc (← (FPSCR_read ()))))
    | _ => (pure nzcv) ) : SailM (BitVec 4) )
  (FPSCR_write (Mk_FPSCR_Type (Sail.BitVec.updateSubrange (← (FPSCR_read__1 ())) 31 28 nzcv)))

def decode_aarch32_instrs_VCMP_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (E : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:22307.29-22307.30"
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let quiet_nan_exc : Bool := (BEq.beq E (0b1 : (BitVec 1)))
      let with_zero : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VCMP_Op_A_txt d esize m quiet_nan_exc with_zero))
  else (pure ())

def decode_aarch32_instrs_VCMP_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (E : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:22361.29-22361.30"
      let m ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let m := m
      let quiet_nan_exc : Bool := (BEq.beq E (0b1 : (BitVec 1)))
      let with_zero : Bool := true
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              ())
            else ()))
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VCMP_Op_A_txt d esize m quiet_nan_exc with_zero))
  else (pure ())

def decode_aarch32_instrs_VCMP_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (E : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let quiet_nan_exc : Bool := (BEq.beq E (0b1 : (BitVec 1)))
      let with_zero : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VCMP_Op_A_txt d esize m quiet_nan_exc with_zero))
  else (pure ())

def decode_aarch32_instrs_VCMP_T2enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (E : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let m ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let m := m
      let quiet_nan_exc : Bool := (BEq.beq E (0b1 : (BitVec 1)))
      let with_zero : Bool := true
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              ())
            else ()))
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VCMP_Op_A_txt d esize m quiet_nan_exc with_zero))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, regs : Nat, regs ∈
  {1, 2} ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 8 ∧ elements = 8 ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCNT_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (integer_subrange (BitCount (← (Elem_read (← (D_read (m +i r))) e esize)))
                  (esize -i 1) 0))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VCNT_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := 8
      let elements := 8
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCNT_Op_A_txt d elements esize m regs))
  else (pure ())

def decode_aarch32_instrs_VCNT_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := 8
      let elements := 8
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCNT_Op_A_txt d elements esize m regs))
  else (pure ())

/-- Type quantifiers: k_convert_from_half : Bool, d : Nat, lowbit : Nat, m : Nat, k_uses_double :
  Bool, 0 ≤ m ∧ m ≤ 31 ∧ lowbit ∈ {0, 16} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VCVTB_Op_A_txt (convert_from_half : Bool) (d : Nat) (lowbit : Nat) (m : Nat) (uses_double : Bool) : SailM Unit := do
  (CheckVFPEnabled true)
  let hp ← (( do (undefined_bitvector 16) ) : SailM (BitVec 16) )
  bif convert_from_half
  then
    (do
      let hp ← (( do (pure (Sail.BitVec.extractLsb (← (S_read m)) (lowbit +i 15) lowbit)) ) :
        SailM (BitVec 16) )
      bif uses_double
      then (D_set d (← (FPConvert__1 hp (← (FPSCR_read ())) 64)))
      else (S_set d (← (FPConvert__1 hp (← (FPSCR_read ())) 32))))
  else
    (do
      let hp ← (( do
        bif uses_double
        then
          (do
            (FPConvert__1 (← (D_read m)) (← (FPSCR_read ())) 16))
        else
          (do
            (FPConvert__1 (← (S_read m)) (← (FPSCR_read ())) 16)) ) : SailM (BitVec 16) )
      (S_set d (Sail.BitVec.updateSubrange (← (S_read d)) (lowbit +i 15) lowbit hp)))

def decode_aarch32_instrs_VCVTB_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (op : (BitVec 1)) (Vd : (BitVec 4)) (sz : (BitVec 1)) (T : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:22617.29-22617.30"
      let uses_double : Bool := (BEq.beq sz (0b1 : (BitVec 1)))
      let convert_from_half : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let lowbit :=
        bif (BEq.beq T (0b1 : (BitVec 1)))
        then 16
        else 0
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let (d, m) : (Nat × Nat) :=
        bif uses_double
        then
          (let (d, m) : (Nat × Nat) :=
            bif convert_from_half
            then
              (let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (Vm ++ M))
              (d, m))
            else
              (let d : Nat := (UInt0 (Vd ++ D))
              let m : Nat := (UInt0 (M ++ Vm))
              (d, m))
          (d, m))
        else
          (let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          (d, m))
      let m := m
      let d := d
      (execute_aarch32_instrs_VCVTB_Op_A_txt convert_from_half d lowbit m uses_double))
  else (pure ())

def decode_aarch32_instrs_VCVTB_T1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (Vd : (BitVec 4)) (sz : (BitVec 1)) (T : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let uses_double : Bool := (BEq.beq sz (0b1 : (BitVec 1)))
      let convert_from_half : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let lowbit :=
        bif (BEq.beq T (0b1 : (BitVec 1)))
        then 16
        else 0
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let (d, m) : (Nat × Nat) :=
        bif uses_double
        then
          (let (d, m) : (Nat × Nat) :=
            bif convert_from_half
            then
              (let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (Vm ++ M))
              (d, m))
            else
              (let d : Nat := (UInt0 (Vd ++ D))
              let m : Nat := (UInt0 (M ++ Vm))
              (d, m))
          (d, m))
        else
          (let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          (d, m))
      let m := m
      let d := d
      (execute_aarch32_instrs_VCVTB_Op_A_txt convert_from_half d lowbit m uses_double))
  else (pure ())

/-- Type quantifiers: d : Nat, k_double_to_single : Bool, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VCVT_ds_Op_A_txt (d : Nat) (double_to_single : Bool) (m : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  bif double_to_single
  then (S_set d (← (FPConvert__1 (← (D_read m)) (← (FPSCR_read ())) 32)))
  else (D_set d (← (FPConvert__1 (← (S_read m)) (← (FPSCR_read ())) 64)))

def decode_aarch32_instrs_VCVT_ds_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:22712.29-22712.30"
      let double_to_single : Bool := (BEq.beq size (0b11 : (BitVec 2)))
      let d :=
        bif double_to_single
        then (UInt0 (Vd ++ D))
        else (UInt0 (D ++ Vd))
      let m :=
        bif double_to_single
        then (UInt0 (M ++ Vm))
        else (UInt0 (Vm ++ M))
      assert (Bool.and (0 ≤b m) (Bool.and (m ≤b 31) (Bool.and (0 ≤b d) (d ≤b 31)))) "src/instrs32.sail:22716.68-22716.69"
      (execute_aarch32_instrs_VCVT_ds_Op_A_txt d double_to_single m))
  else (pure ())

def decode_aarch32_instrs_VCVT_ds_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let double_to_single : Bool := (BEq.beq size (0b11 : (BitVec 2)))
      let d :=
        bif double_to_single
        then (UInt0 (Vd ++ D))
        else (UInt0 (D ++ Vd))
      let m :=
        bif double_to_single
        then (UInt0 (M ++ Vm))
        else (UInt0 (Vm ++ M))
      assert (Bool.and (0 ≤b m) (Bool.and (m ≤b 31) (Bool.and (0 ≤b d) (d ≤b 31)))) "src/instrs32.sail:22740.68-22740.69"
      (execute_aarch32_instrs_VCVT_ds_Op_A_txt d double_to_single m))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, k_half_to_single : Bool, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ elements = 4 ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCVT_hs_Op_A_txt (d__arg : Nat) (elements : Nat) (half_to_single : Bool) (m : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif half_to_single
      then
        (Q_set (Int.shiftr d 1)
          (← (Elem_set (← (Q_read (Int.shiftr d 1))) e 32
              (← (FPConvert__1 (← (Elem_read (← (Din_read m)) e 16))
                  (← (StandardFPSCRValue ())) 32)))))
      else
        (D_set d
          (← (Elem_set (← (D_read d)) e 16
              (← (FPConvert__1 (← (Elem_read (← (Qin_read (Int.shiftl m 1))) e 32))
                  (← (StandardFPSCRValue ())) 16)))))
  (pure loop_vars)

def decode_aarch32_instrs_VCVT_hs_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (bne size (0b01 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let half_to_single : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      bif (Bool.and half_to_single
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (Bool.not half_to_single)
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := 16
      let elements := 4
      let m := (UInt0 (M ++ Vm))
      let d := (UInt0 (D ++ Vd))
      (execute_aarch32_instrs_VCVT_hs_Op_A_txt d elements half_to_single m))
  else (pure ())

def decode_aarch32_instrs_VCVT_hs_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (bne size (0b01 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let half_to_single : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      bif (Bool.and half_to_single
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (Bool.not half_to_single)
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := 16
      let elements := 4
      let m := (UInt0 (M ++ Vm))
      let d := (UInt0 (D ++ Vd))
      (execute_aarch32_instrs_VCVT_hs_Op_A_txt d elements half_to_single m))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, regs
  : Nat, k_to_integer : Bool, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCVT_is_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) (to_integer : Bool) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (op1, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, result) := loop_vars
      loop_vars ← do
        let (op1, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, result) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (m +i r))) e esize)
              let result ← (( do
                bif to_integer
                then
                  (do
                    (FPToFixed op1 0 is_unsigned (← (StandardFPSCRValue ())) FPRounding_ZERO esize))
                else
                  (do
                    (FixedToFP op1 0 is_unsigned (← (StandardFPSCRValue ())) FPRounding_TIEEVEN
                      esize)) ) : SailM (BitVec esize) )
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              (pure (op1, result))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VCVT_is_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 2)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
           (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let to_integer : Bool := (BEq.beq (BitVec.join1 [(BitVec.access op 1)]) (0b1 : (BitVec 1)))
      let is_unsigned : Bool := (BEq.beq (BitVec.join1 [(BitVec.access op 0)]) (0b1 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let elements : Int := 2
            ())
          else ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCVT_is_Op_A_txt d elements esize m regs to_integer is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VCVT_is_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 2)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
           (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let to_integer : Bool := (BEq.beq (BitVec.join1 [(BitVec.access op 1)]) (0b1 : (BitVec 1)))
      let is_unsigned : Bool := (BEq.beq (BitVec.join1 [(BitVec.access op 0)]) (0b1 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let elements : Int := 2
            ())
          else ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCVT_is_Op_A_txt d elements esize m regs to_integer is_unsigned))
  else (pure ())

/-- Type quantifiers: d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, k_to_integer : Bool, 0
  ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VCVT_iv_Op_A_txt (d : Nat) (esize : Nat) (m : Nat) (rounding : FPRounding) (to_integer : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckVFPEnabled true)
  bif to_integer
  then
    (do
      match esize with
      | 16 => (S_set d
          (← (FPToFixed (Sail.BitVec.extractLsb (← (S_read m)) 15 0) 0 is_unsigned
              (← (FPSCR_read ())) rounding 32)))
      | 32 => (S_set d
          (← (FPToFixed (← (S_read m)) 0 is_unsigned (← (FPSCR_read ())) rounding 32)))
      | 64 => (S_set d
          (← (FPToFixed (← (D_read m)) 0 is_unsigned (← (FPSCR_read ())) rounding 32)))
      | _ => (pure ()))
  else
    (do
      match esize with
      | 16 => (do
          let fp16 ← (( do
            (FixedToFP (← (S_read m)) 0 is_unsigned (← (FPSCR_read ())) rounding 16) ) : SailM
            (BitVec 16) )
          (S_set d ((Zeros (n := 16)) ++ fp16)))
      | 32 => (S_set d
          (← (FixedToFP (← (S_read m)) 0 is_unsigned (← (FPSCR_read ())) rounding 32)))
      | 64 => (D_set d
          (← (FixedToFP (← (S_read m)) 0 is_unsigned (← (FPSCR_read ())) rounding 64)))
      | _ => (pure ()))

def decode_aarch32_instrs_VCVT_iv_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (opc2 : (BitVec 3)) (Vd : (BitVec 4)) (size : (BitVec 2)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:22999.29-22999.30"
      bif (Bool.and (bne opc2 (0b000 : (BitVec 3)))
           (Bool.not
             (let b__0 := opc2
             bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b10 : (BitVec 2)))
             then true
             else false : Bool)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let esize : Int := 16
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
      let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
      let to_integer : Bool := (BEq.beq (BitVec.join1 [(BitVec.access opc2 2)]) (0b1 : (BitVec 1)))
      let (d, esize, is_unsigned, m, rounding) ← (( do
        bif to_integer
        then
          (do
            let is_unsigned : Bool :=
              (BEq.beq (BitVec.join1 [(BitVec.access opc2 0)]) (0b0 : (BitVec 1)))
            let rounding ←
              bif (BEq.beq op (0b1 : (BitVec 1)))
              then (pure FPRounding_ZERO)
              else (FPRoundingMode (← (FPSCR_read ())))
            let d : Nat := (UInt0 (Vd ++ D))
            let b__4 := size
            let (esize, m) : (Int × Nat) :=
              bif (BEq.beq b__4 (0b01 : (BitVec 2)))
              then
                (let esize : Int := 16
                let m : Nat := (UInt0 (Vm ++ M))
                (esize, m))
              else
                (let (esize, m) : (Int × Nat) :=
                  bif (BEq.beq b__4 (0b10 : (BitVec 2)))
                  then
                    (let esize : Int := 32
                    let m : Nat := (UInt0 (Vm ++ M))
                    (esize, m))
                  else
                    (let (esize, m) : (Int × Nat) :=
                      bif (BEq.beq b__4 (0b11 : (BitVec 2)))
                      then
                        (let esize : Int := 64
                        let m : Nat := (UInt0 (M ++ Vm))
                        (esize, m))
                      else (esize, m)
                    (esize, m))
                (esize, m))
            (pure (d, esize, is_unsigned, m, rounding)))
        else
          (do
            let is_unsigned : Bool := (BEq.beq op (0b0 : (BitVec 1)))
            let rounding ← (FPRoundingMode (← (FPSCR_read ())))
            let m : Nat := (UInt0 (Vm ++ M))
            let b__1 := size
            let (d, esize) : (Nat × Int) :=
              bif (BEq.beq b__1 (0b01 : (BitVec 2)))
              then
                (let esize : Int := 16
                let d : Nat := (UInt0 (Vd ++ D))
                (d, esize))
              else
                (let (d, esize) : (Nat × Int) :=
                  bif (BEq.beq b__1 (0b10 : (BitVec 2)))
                  then
                    (let esize : Int := 32
                    let d : Nat := (UInt0 (Vd ++ D))
                    (d, esize))
                  else
                    (let (d, esize) : (Nat × Int) :=
                      bif (BEq.beq b__1 (0b11 : (BitVec 2)))
                      then
                        (let esize : Int := 64
                        let d : Nat := (UInt0 (D ++ Vd))
                        (d, esize))
                      else (d, esize)
                    (d, esize))
                (d, esize))
            (pure (d, esize, is_unsigned, m, rounding))) ) : SailM
        (Nat × Int × Bool × Nat × FPRounding) )
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VCVT_iv_Op_A_txt d esize m rounding to_integer is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VCVT_iv_T1enc_A_txt (D : (BitVec 1)) (opc2 : (BitVec 3)) (Vd : (BitVec 4)) (size : (BitVec 2)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (bne opc2 (0b000 : (BitVec 3)))
           (Bool.not
             (let b__0 := opc2
             bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 1) (0b10 : (BitVec 2)))
             then true
             else false : Bool)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let esize : Int := 16
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let is_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
      let rounding ← (( do (undefined_FPRounding ()) ) : SailM FPRounding )
      let to_integer : Bool := (BEq.beq (BitVec.join1 [(BitVec.access opc2 2)]) (0b1 : (BitVec 1)))
      let (d, esize, is_unsigned, m, rounding) ← (( do
        bif to_integer
        then
          (do
            let is_unsigned : Bool :=
              (BEq.beq (BitVec.join1 [(BitVec.access opc2 0)]) (0b0 : (BitVec 1)))
            let rounding ←
              bif (BEq.beq op (0b1 : (BitVec 1)))
              then (pure FPRounding_ZERO)
              else (FPRoundingMode (← (FPSCR_read ())))
            let d : Nat := (UInt0 (Vd ++ D))
            let b__4 := size
            let (esize, m) : (Int × Nat) :=
              bif (BEq.beq b__4 (0b01 : (BitVec 2)))
              then
                (let esize : Int := 16
                let m : Nat := (UInt0 (Vm ++ M))
                (esize, m))
              else
                (let (esize, m) : (Int × Nat) :=
                  bif (BEq.beq b__4 (0b10 : (BitVec 2)))
                  then
                    (let esize : Int := 32
                    let m : Nat := (UInt0 (Vm ++ M))
                    (esize, m))
                  else
                    (let (esize, m) : (Int × Nat) :=
                      bif (BEq.beq b__4 (0b11 : (BitVec 2)))
                      then
                        (let esize : Int := 64
                        let m : Nat := (UInt0 (M ++ Vm))
                        (esize, m))
                      else (esize, m)
                    (esize, m))
                (esize, m))
            (pure (d, esize, is_unsigned, m, rounding)))
        else
          (do
            let is_unsigned : Bool := (BEq.beq op (0b0 : (BitVec 1)))
            let rounding ← (FPRoundingMode (← (FPSCR_read ())))
            let m : Nat := (UInt0 (Vm ++ M))
            let b__1 := size
            let (d, esize) : (Nat × Int) :=
              bif (BEq.beq b__1 (0b01 : (BitVec 2)))
              then
                (let esize : Int := 16
                let d : Nat := (UInt0 (Vd ++ D))
                (d, esize))
              else
                (let (d, esize) : (Nat × Int) :=
                  bif (BEq.beq b__1 (0b10 : (BitVec 2)))
                  then
                    (let esize : Int := 32
                    let d : Nat := (UInt0 (Vd ++ D))
                    (d, esize))
                  else
                    (let (d, esize) : (Nat × Int) :=
                      bif (BEq.beq b__1 (0b11 : (BitVec 2)))
                      then
                        (let esize : Int := 64
                        let d : Nat := (UInt0 (D ++ Vd))
                        (d, esize))
                      else (d, esize)
                    (d, esize))
                (d, esize))
            (pure (d, esize, is_unsigned, m, rounding))) ) : SailM
        (Nat × Int × Bool × Nat × FPRounding) )
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VCVT_iv_Op_A_txt d esize m rounding to_integer is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, frac_bits : Nat, k_is_unsigned :
  Bool, m : Nat, regs : Nat, k_to_fixed : Bool, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  1 ≤ frac_bits ∧
  frac_bits ≤ 64 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCVT_xs_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (frac_bits : Nat) (m : Nat) (regs : Nat) (to_fixed : Bool) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let (op1, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, result) := loop_vars
      loop_vars ← do
        let (op1, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, result) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (m +i r))) e esize)
              let result ← (( do
                bif to_fixed
                then
                  (do
                    (FPToFixed op1 frac_bits is_unsigned (← (StandardFPSCRValue ()))
                      FPRounding_ZERO esize))
                else
                  (do
                    (FixedToFP op1 frac_bits is_unsigned (← (StandardFPSCRValue ()))
                      FPRounding_TIEEVEN esize)) ) : SailM (BitVec esize) )
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              (pure (op1, result))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VCVT_xs_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (op : (BitVec 2)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access op 1)]) (0b0 : (BitVec 1)))
           (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access op 1)]) (0b0 : (BitVec 1)))
           (let b__1 := imm6
           bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b10 : (BitVec 2)))
           then true
           else false : Bool))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (let b__2 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__2 5 5) (0b0 : (BitVec 1)))
         then true
         else false : Bool)
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let to_fixed : Bool := (BEq.beq (BitVec.join1 [(BitVec.access op 0)]) (0b1 : (BitVec 1)))
      let frac_bits := (64 -i (UInt0 imm6))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__3 := (BitVec.join1 [(BitVec.access op 1)])
        bif (BEq.beq b__3 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          ())
        else
          (let esize : Int := 32
          let elements : Int := 2
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCVT_xs_Op_A_txt d elements esize frac_bits m regs to_fixed
        is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VCVT_xs_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (op : (BitVec 2)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access op 1)]) (0b0 : (BitVec 1)))
           (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access op 1)]) (0b0 : (BitVec 1)))
           (let b__1 := imm6
           bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b10 : (BitVec 2)))
           then true
           else false : Bool))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (let b__2 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__2 5 5) (0b0 : (BitVec 1)))
         then true
         else false : Bool)
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let to_fixed : Bool := (BEq.beq (BitVec.join1 [(BitVec.access op 0)]) (0b1 : (BitVec 1)))
      let frac_bits := (64 -i (UInt0 imm6))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__3 := (BitVec.join1 [(BitVec.access op 1)])
        bif (BEq.beq b__3 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          ())
        else
          (let esize : Int := 32
          let elements : Int := 2
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VCVT_xs_Op_A_txt d elements esize frac_bits m regs to_fixed
        is_unsigned))
  else (pure ())

/-- Type quantifiers: d : Nat, fp_size : Nat, frac_bits : Int, k_is_unsigned : Bool, size : Nat, k_to_fixed
  : Bool, size ∈ {16, 32} ∧ fp_size ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VCVT_xv_Op_A_txt (d : Nat) (fp_size : Nat) (frac_bits : Int) (size : Nat) (to_fixed : Bool) (is_unsigned : Bool) : SailM Unit := do
  (CheckVFPEnabled true)
  bif to_fixed
  then
    (do
      let result ← (( do (undefined_bitvector size) ) : SailM (BitVec size) )
      match fp_size with
      | 16 => (do
          let result ← (( do
            (FPToFixed (Sail.BitVec.extractLsb (← (S_read d)) 15 0) frac_bits is_unsigned
              (← (FPSCR_read ())) FPRounding_ZERO size) ) : SailM (BitVec size) )
          (S_set d (← (Extend result 32 is_unsigned))))
      | 32 => (do
          let result ← (( do
            (FPToFixed (← (S_read d)) frac_bits is_unsigned (← (FPSCR_read ())) FPRounding_ZERO
              size) ) : SailM (BitVec size) )
          (S_set d (← (Extend result 32 is_unsigned))))
      | 64 => (do
          let result ← (( do
            (FPToFixed (← (D_read d)) frac_bits is_unsigned (← (FPSCR_read ())) FPRounding_ZERO
              size) ) : SailM (BitVec size) )
          (D_set d (← (Extend result 64 is_unsigned))))
      | _ => (pure ()))
  else
    (do
      match fp_size with
      | 16 => (do
          let fp16 ← (( do
            (FixedToFP (Sail.BitVec.extractLsb (← (S_read d)) (size -i 1) 0) frac_bits is_unsigned
              (← (FPSCR_read ())) FPRounding_TIEEVEN 16) ) : SailM (BitVec 16) )
          (S_set d ((Zeros (n := 16)) ++ fp16)))
      | 32 => (S_set d
          (← (FixedToFP (Sail.BitVec.extractLsb (← (S_read d)) (size -i 1) 0) frac_bits
              is_unsigned (← (FPSCR_read ())) FPRounding_TIEEVEN 32)))
      | 64 => (D_set d
          (← (FixedToFP (Sail.BitVec.extractLsb (← (D_read d)) (size -i 1) 0) frac_bits
              is_unsigned (← (FPSCR_read ())) FPRounding_TIEEVEN 64)))
      | _ => (pure ()))

def decode_aarch32_instrs_VCVT_xv_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (op : (BitVec 1)) (U : (BitVec 1)) (Vd : (BitVec 4)) (sf : (BitVec 2)) (sx : (BitVec 1)) (i : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:23359.29-23359.30"
      bif (Bool.or (BEq.beq sf (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq sf (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sf (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let to_fixed : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let size :=
        bif (BEq.beq sx (0b0 : (BitVec 1)))
        then 16
        else 32
      let frac_bits := (size -i (UInt0 (imm4 ++ i)))
      let fp_size : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := sf
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let fp_size : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let fp_size : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let fp_size : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              ())
            else ()))
      let fp_size := fp_size
      let d := d
      bif (frac_bits <b 0)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let d := d
      (execute_aarch32_instrs_VCVT_xv_Op_A_txt d fp_size frac_bits size to_fixed is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VCVT_xv_T1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (U : (BitVec 1)) (Vd : (BitVec 4)) (sf : (BitVec 2)) (sx : (BitVec 1)) (i : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq sf (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq sf (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sf (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let to_fixed : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let size :=
        bif (BEq.beq sx (0b0 : (BitVec 1)))
        then 16
        else 32
      let frac_bits := (size -i (UInt0 (imm4 ++ i)))
      let fp_size : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := sf
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let fp_size : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let fp_size : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let fp_size : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              ())
            else ()))
      let fp_size := fp_size
      let d := d
      bif (frac_bits <b 0)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let d := d
      (execute_aarch32_instrs_VCVT_xv_Op_A_txt d fp_size frac_bits size to_fixed is_unsigned))
  else (pure ())

/-- Type quantifiers: d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VDIV_Op_A_txt (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  match esize with
  | 16 => (S_set d
      ((Zeros (n := 16)) ++ (← (FPDiv (Sail.BitVec.extractLsb (← (S_read n)) 15 0)
            (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ()))))))
  | 32 => (S_set d (← (FPDiv (← (S_read n)) (← (S_read m)) (← (FPSCR_read ())))))
  | 64 => (D_set d (← (FPDiv (← (D_read n)) (← (D_read m)) (← (FPSCR_read ())))))
  | _ => (pure ())

def decode_aarch32_instrs_VDIV_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:23491.29-23491.30"
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VDIV_Op_A_txt d esize m n))
  else (pure ())

def decode_aarch32_instrs_VDIV_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VDIV_Op_A_txt d esize m n))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, regs : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧
  regs ∈ {1, 2} ∧
  esize ∈ {8, 16, 32} ∧ elements ∈ {2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VDUP_r_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (regs : Nat) (t : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let scalar ← (( do (pure (Sail.BitVec.extractLsb (← (R_read t)) (esize -i 1) 0)) ) : SailM
    (BitVec (0 + (esize - 1 - 0 + 1))) )
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize scalar)))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VDUP_r_A1enc_A_txt (cond : (BitVec 4)) (B : (BitVec 1)) (Q : (BitVec 1)) (Vd : (BitVec 4)) (Rt : (BitVec 4)) (D : (BitVec 1)) (E : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:23626.29-23626.30"
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let t := (UInt0 Rt)
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      let esize : Int := 8
      let elements : Int := 2
      let b__0 := (B ++ E)
      bif (BEq.beq b__0 (0b00 : (BitVec 2)))
      then
        (let esize : Int := 32
        let elements : Int := 2
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            (pure ()))
          else
            (do
              bif (BEq.beq b__0 (0b10 : (BitVec 2)))
              then
                (let esize : Int := 8
                let elements : Int := 8
                (pure ()))
              else sailThrow ((Error_Undefined ()))))
      let esize := esize
      let elements := elements
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VDUP_r_Op_A_txt d elements esize regs t))
  else (pure ())

def decode_aarch32_instrs_VDUP_r_T1enc_A_txt (B : (BitVec 1)) (Q : (BitVec 1)) (Vd : (BitVec 4)) (Rt : (BitVec 4)) (D : (BitVec 1)) (E : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let t := (UInt0 Rt)
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      let esize : Int := 8
      let elements : Int := 2
      let b__0 := (B ++ E)
      bif (BEq.beq b__0 (0b00 : (BitVec 2)))
      then
        (let esize : Int := 32
        let elements : Int := 2
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            (pure ()))
          else
            (do
              bif (BEq.beq b__0 (0b10 : (BitVec 2)))
              then
                (let esize : Int := 8
                let elements : Int := 8
                (pure ()))
              else sailThrow ((Error_Undefined ()))))
      let esize := esize
      let elements := elements
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VDUP_r_Op_A_txt d elements esize regs t))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, index : Nat, m : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  esize ∈ {8, 16, 32} ∧ elements ∈ {2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VDUP_s_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (index : Nat) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let scalar ← (( do (Elem_read (← (D_read m)) index esize) ) : SailM (BitVec esize) )
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize scalar)))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VDUP_s_A1enc_A_txt (D : (BitVec 1)) (imm4 : (BitVec 4)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm4
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 0) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let index ← (( do (undefined_range 0 7) ) : SailM Nat )
      let _ : Unit :=
        let b__1 := imm4
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 0 0) (0b1 : (BitVec 1)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let index : Nat := (UInt0 (Sail.BitVec.extractLsb imm4 3 1))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 1 0) (0b10 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let index : Nat := (UInt0 (Sail.BitVec.extractLsb imm4 3 2))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 2 0) (0b100 : (BitVec 3)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let index : Nat := (UInt0 (BitVec.join1 [(BitVec.access imm4 3)]))
              ())
            else ()))
      let index := index
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VDUP_s_Op_A_txt d elements esize index m regs))
  else (pure ())

def decode_aarch32_instrs_VDUP_s_T1enc_A_txt (D : (BitVec 1)) (imm4 : (BitVec 4)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm4
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 2 0) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let index ← (( do (undefined_range 0 7) ) : SailM Nat )
      let _ : Unit :=
        let b__1 := imm4
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 0 0) (0b1 : (BitVec 1)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let index : Nat := (UInt0 (Sail.BitVec.extractLsb imm4 3 1))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 1 0) (0b10 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let index : Nat := (UInt0 (Sail.BitVec.extractLsb imm4 3 2))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 2 0) (0b100 : (BitVec 3)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let index : Nat := (UInt0 (BitVec.join1 [(BitVec.access imm4 3)]))
              ())
            else ()))
      let index := index
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VDUP_s_Op_A_txt d elements esize index m regs))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VEOR_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do (D_set (d +i r) ((← (D_read (n +i r))) ^^^ (← (D_read (m +i r)))))
  (pure loop_vars)

def decode_aarch32_instrs_VEOR_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VEOR_Op_A_txt d m n regs))
  else (pure ())

def decode_aarch32_instrs_VEOR_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VEOR_Op_A_txt d m n regs))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, position : Nat, k_quadword_operation : Bool, 0 ≤
  position ∧
  position ≤ 120 ∧ 0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VEXT_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (position : Nat) (quadword_operation : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  bif quadword_operation
  then
    (Q_set (Int.shiftl d 1)
      (Sail.BitVec.extractLsb ((← (Q_read (Int.shiftl m 1))) ++ (← (Q_read (Int.shiftl n 1))))
        (position +i 127) position))
  else
    (do
      assert (Bool.and (0 ≤b position)
        (Bool.and (position ≤b (position +i 63)) ((position +i 63) <b 128))) "src/instrs32.sail:23935.96-23935.97"
      (D_set d
        (Sail.BitVec.extractLsb ((← (D_read m)) ++ (← (D_read n))) (position +i 63) position)))

def decode_aarch32_instrs_VEXT_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (imm4 : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b0 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access imm4 3)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let quadword_operation : Bool := (BEq.beq Q (0b1 : (BitVec 1)))
      let position := (8 *i (UInt0 imm4))
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VEXT_Op_A_txt d m n position quadword_operation))
  else (pure ())

def decode_aarch32_instrs_VEXT_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (imm4 : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b0 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access imm4 3)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let quadword_operation : Bool := (BEq.beq Q (0b1 : (BitVec 1)))
      let position := (8 *i (UInt0 imm4))
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VEXT_Op_A_txt d m n position quadword_operation))
  else (pure ())

/-- Type quantifiers: k_advsimd : Bool, d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, k_op1_neg
  : Bool, regs : Int, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VFMA_Op_A_txt (advsimd : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) (regs : Int) : SailM Unit := do
  let d : Int := d__arg
  let op16 ← (( do (undefined_bitvector 16) ) : SailM (BitVec 16) )
  let op32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let op64 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif advsimd
  then
    (do
      let loop_r_lower := 0
      let loop_r_upper := (regs -i 1)
      let mut loop_vars := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars
        loop_vars ← do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := ()
          for e in [loop_e_lower:loop_e_upper:1]i do
            let () := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (( do (Elem_read (← (D_read (n +i r))) e esize) ) : SailM (BitVec esize)
                )
              let op1 ← (( do
                bif op1_neg
                then
                  (do
                    (FPNeg op1))
                else (pure op1) ) : SailM (BitVec esize) )
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (← (FPMulAdd (← (Elem_read (← (D_read (d +i r))) e esize)) op1
                        (← (Elem_read (← (D_read (m +i r))) e esize))
                        (← (StandardFPSCRValue ())))))))
          (pure loop_vars_1)
      (pure loop_vars))
  else
    (do
      match esize with
      | 16 => (do
          let op16 ← (( do
            bif op1_neg
            then (FPNeg (Sail.BitVec.extractLsb (← (S_read n)) 15 0))
            else (pure (Sail.BitVec.extractLsb (← (S_read n)) 15 0)) ) : SailM (BitVec 16) )
          (S_set d
            ((Zeros (n := 16)) ++ (← (FPMulAdd (Sail.BitVec.extractLsb (← (S_read d)) 15 0) op16
                  (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ())))))))
      | 32 => (do
          let op32 ← (( do
            bif op1_neg
            then (FPNeg (← (S_read n)))
            else (S_read n) ) : SailM (BitVec 32) )
          (S_set d (← (FPMulAdd (← (S_read d)) op32 (← (S_read m)) (← (FPSCR_read ()))))))
      | 64 => (do
          let op64 ← (( do
            bif op1_neg
            then (FPNeg (← (D_read n)))
            else (D_read n) ) : SailM (BitVec 64) )
          (D_set d (← (FPMulAdd (← (D_read d)) op64 (← (D_read m)) (← (FPSCR_read ()))))))
      | _ => (pure ()))

def decode_aarch32_instrs_VFMA_A1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let advsimd : Bool := true
      let op1_neg : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VFMA_Op_A_txt advsimd d elements esize m n op1_neg regs))
  else (pure ())

def decode_aarch32_instrs_VFMA_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:24102.29-24102.30"
      let floating_point ← (( do (undefined_bool ()) ) : SailM Bool )
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let floating_point := floating_point
      let advsimd : Bool := false
      let op1_neg : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VFMA_Op_A_txt advsimd d elements esize m n op1_neg regs))
  else (pure ())

def decode_aarch32_instrs_VFMA_T1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let advsimd : Bool := true
      let op1_neg : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VFMA_Op_A_txt advsimd d elements esize m n op1_neg regs))
  else (pure ())

def decode_aarch32_instrs_VFMA_T2enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let floating_point ← (( do (undefined_bool ()) ) : SailM Bool )
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let floating_point := floating_point
      let advsimd : Bool := false
      let op1_neg : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VFMA_Op_A_txt advsimd d elements esize m n op1_neg regs))
  else (pure ())

/-- Type quantifiers: d : Nat, esize : Nat, m : Nat, n : Nat, k_op1_neg : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VFNMA_Op_A_txt (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (op1_neg : Bool) : SailM Unit := do
  let op16 ← (( do (undefined_bitvector 16) ) : SailM (BitVec 16) )
  let op32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let op64 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  (CheckVFPEnabled true)
  match esize with
  | 16 => (do
      let op16 ← (( do
        bif op1_neg
        then (FPNeg (Sail.BitVec.extractLsb (← (S_read n)) 15 0))
        else (pure (Sail.BitVec.extractLsb (← (S_read n)) 15 0)) ) : SailM (BitVec 16) )
      (S_set d
        ((Zeros (n := 16)) ++ (← (FPMulAdd
              (← (FPNeg (Sail.BitVec.extractLsb (← (S_read d)) 15 0))) op16
              (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ())))))))
  | 32 => (do
      let op32 ← (( do
        bif op1_neg
        then (FPNeg (← (S_read n)))
        else (S_read n) ) : SailM (BitVec 32) )
      (S_set d
        (← (FPMulAdd (← (FPNeg (← (S_read d)))) op32 (← (S_read m)) (← (FPSCR_read ()))))))
  | 64 => (do
      let op64 ← (( do
        bif op1_neg
        then (FPNeg (← (D_read n)))
        else (D_read n) ) : SailM (BitVec 64) )
      (D_set d
        (← (FPMulAdd (← (FPNeg (← (D_read d)))) op64 (← (D_read m)) (← (FPSCR_read ()))))))
  | _ => (pure ())

def decode_aarch32_instrs_VFNMA_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:24319.29-24319.30"
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let op1_neg : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VFNMA_Op_A_txt d esize m n op1_neg))
  else (pure ())

def decode_aarch32_instrs_VFNMA_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let op1_neg : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VFNMA_Op_A_txt d esize m n op1_neg))
  else (pure ())

/-- Type quantifiers: k_add : Bool, d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m
  : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VHADD_Op_A_txt (add : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let (op1, op2, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2, result) := loop_vars
      loop_vars ← do
        let (op1, op2, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2, result) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (asl_Int (← (Elem_read (← (D_read (n +i r))) e esize)) is_unsigned)
              let op2 ← (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned)
              let result : Int :=
                bif add
                then (Int.shiftr (op1 +i op2) 1)
                else (Int.shiftr (op1 -i op2) 1)
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (integer_subrange result (esize -i 1) 0))))
              (pure (op1, op2, result))
          (pure loop_vars_1) ) : SailM (Int × Int × Int) )
        (pure (op1, op2, result))
    (pure loop_vars) ) : SailM (Int × Int × Int) )
  (pure ())

def decode_aarch32_instrs_VHADD_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VHADD_Op_A_txt add d elements esize m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VHADD_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VHADD_Op_A_txt add d elements esize m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d__arg : Nat, ebytes : Nat, index : Nat, m : Nat, n : Nat, k_register_index
  : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  ebytes ∈ {1, 2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ alignment ∈ {1, 2, 4} -/
def execute_aarch32_instrs_VLD1_1_Op_A_txt (alignment : Nat) (d__arg : Nat) (ebytes : Nat) (index : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  (D_set d (← (Elem_set (← (D_read d)) index (8 *i ebytes) (← (MemU_read address ebytes)))))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) ebytes)))
  else (pure ())

def decode_aarch32_instrs_VLD1_1_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD1 (single element to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let alignment := 1
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_1_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD1 (single element to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_1_A3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD1 (single element to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (bne (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
           (bne (Sail.BitVec.extractLsb index_align 1 0) (0b11 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let alignment :=
        bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_1_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD1 (single element to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let alignment := 1
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_1_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD1 (single element to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_1_T3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD1 (single element to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (bne (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
           (bne (Sail.BitVec.extractLsb index_align 1 0) (0b11 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let alignment :=
        bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d : Nat, ebytes : Nat, m : Nat, n : Nat, k_register_index :
  Bool, regs : Nat, k_wback : Bool, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d ∧ d ≤ 31 ∧ alignment ∈ {1, 2, 4, 8} -/
def execute_aarch32_instrs_VLD1_a_Op_A_txt (alignment : Nat) (d : Nat) (ebytes : Nat) (m : Nat) (n : Nat) (register_index : Bool) (regs : Nat) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let esize := (8 *i ebytes)
  let element ← (( do (MemU_read address ebytes) ) : SailM (BitVec esize) )
  let replicated_element : (BitVec 64) := (BitVec.replicateBits element (ediv_nat 64 esize))
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do (D_set (d +i r) replicated_element)
  (pure loop_vars)
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) ebytes)))
  else (pure ())

def decode_aarch32_instrs_VLD1_a_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (T : (BitVec 1)) (a : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq a (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let regs :=
        bif (BEq.beq T (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq a (0b0 : (BitVec 1)))
        then 1
        else ebytes
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD1_a_Op_A_txt alignment d ebytes m n register_index regs wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_a_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (T : (BitVec 1)) (a : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq a (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let regs :=
        bif (BEq.beq T (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq a (0b0 : (BitVec 1)))
        then 1
        else ebytes
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD1_a_Op_A_txt alignment d ebytes m n register_index regs wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d__arg : Nat, ebytes : Nat, elements : Int, m : Nat, n : Nat, k_register_index
  : Bool, regs : Nat, k_wback : Bool, regs ∈ {1, 2, 3, 4} ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ alignment ∈ {1, 4, 8, 16, 32} -/
def execute_aarch32_instrs_VLD1_m_Op_A_txt (alignment : Nat) (d__arg : Nat) (ebytes : Nat) (elements : Int) (m : Nat) (n : Nat) (register_index : Bool) (regs : Nat) (wback : Bool) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let address ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := address
    for r in [loop_r_lower:loop_r_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := address
        for e in [loop_e_lower:loop_e_upper:1]i do
          let address := loop_vars_1
          loop_vars_1 ← do
            let data ← (( do (undefined_bitvector (ebytes *i 8)) ) : SailM (BitVec (ebytes * 8)) )
            let data ← (( do
              bif (bne ebytes 8)
              then
                (do
                  (MemU_read address ebytes))
              else
                (do
                  bif (Bool.and (Bool.not (IsAligned__1 address ebytes))
                       (← (AlignmentEnforced ())))
                  then (AArch32_Abort address (← (AlignmentFault accdesc)))
                  else (pure ())
                  bif (← (BigEndian AccessType_ASIMD))
                  then
                    (do
                      let data ←
                        (pure (Sail.BitVec.updateSubrange data 31 0
                            (← (MemU_read (BitVec.addInt address 4) 4))))
                      (pure (Sail.BitVec.updateSubrange data 63 32 (← (MemU_read address 4)))))
                  else
                    (do
                      let data ←
                        (pure (Sail.BitVec.updateSubrange data 31 0 (← (MemU_read address 4))))
                      (pure (Sail.BitVec.updateSubrange data 63 32
                          (← (MemU_read (BitVec.addInt address 4) 4)))))) ) : SailM
              (BitVec (ebytes * 8)) )
            (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e (8 *i ebytes) data)))
            (pure (BitVec.addInt address ebytes))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (8 *i regs))))
  else (pure ())

def decode_aarch32_instrs_VLD1_m_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 1
      bif (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:24951.173-24951.174"
      (execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_m_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 2
      bif (BEq.beq align (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:24988.173-24988.174"
      (execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_m_A3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 3
      bif (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:25025.173-25025.174"
      (execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_m_A4enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 4
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:25059.173-25059.174"
      (execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_m_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 1
      bif (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:25096.173-25096.174"
      (execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_m_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 2
      bif (BEq.beq align (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:25133.173-25133.174"
      (execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_m_T3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 3
      bif (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:25170.173-25170.174"
      (execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD1_m_T4enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 4
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:25204.173-25204.174"
      (execute_aarch32_instrs_VLD1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d__arg : Nat, d2__arg : Int, ebytes : Nat, index : Nat, m :
  Nat, n : Nat, k_register_index : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  ebytes ∈ {1, 2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ alignment ∈ {1, 2, 4, 8} -/
def execute_aarch32_instrs_VLD2_1_Op_A_txt (alignment : Nat) (d__arg : Nat) (d2__arg : Int) (ebytes : Nat) (index : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  let d : Int := d__arg
  let d2 : Int := d2__arg
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  (D_set d (← (Elem_set (← (D_read d)) index (8 *i ebytes) (← (MemU_read address ebytes)))))
  (D_set d2
    (← (Elem_set (← (D_read d2)) index (8 *i ebytes)
        (← (MemU_read (BitVec.addInt address ebytes) ebytes)))))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (2 *i ebytes))))
  else (pure ())

def decode_aarch32_instrs_VLD2_1_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD2 (single 2-element structure to all lanes)"))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD2_1_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD2 (single 2-element structure to all lanes)"))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD2_1_A3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD2 (single 2-element structure to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD2_1_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD2 (single 2-element structure to all lanes)"))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD2_1_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD2 (single 2-element structure to all lanes)"))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD2_1_T3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD2 (single 2-element structure to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d : Nat, d2 : Int, ebytes : Nat, m : Nat, n : Nat, k_register_index
  : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d ∧ d ≤ 31 ∧ alignment ∈ {1, 2, 4, 8, 16} -/
def execute_aarch32_instrs_VLD2_a_Op_A_txt (alignment : Nat) (d : Nat) (d2 : Int) (ebytes : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let esize := (8 *i ebytes)
  let element1 ← (( do (MemU_read address ebytes) ) : SailM (BitVec esize) )
  let element2 ← (( do (MemU_read (BitVec.addInt address ebytes) ebytes) ) : SailM (BitVec esize)
    )
  (D_set d (BitVec.replicateBits element1 (ediv_nat 64 esize)))
  (D_set d2 (BitVec.replicateBits element2 (ediv_nat 64 esize)))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (2 *i ebytes))))
  else (pure ())

def decode_aarch32_instrs_VLD2_a_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (T : (BitVec 1)) (a : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let alignment :=
        bif (BEq.beq a (0b0 : (BitVec 1)))
        then 1
        else (2 *i ebytes)
      let inc_name :=
        bif (BEq.beq T (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD2_a_Op_A_txt alignment d d2 ebytes m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD2_a_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (T : (BitVec 1)) (a : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let alignment :=
        bif (BEq.beq a (0b0 : (BitVec 1)))
        then 1
        else (2 *i ebytes)
      let inc_name :=
        bif (BEq.beq T (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD2_a_Op_A_txt alignment d d2 ebytes m n register_index wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d__arg : Nat, d2__arg : Int, ebytes : Nat, elements : Int, m
  : Nat, n : Nat, pairs : Nat, k_register_index : Bool, k_wback : Bool, pairs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ alignment ∈ {1, 4, 8, 16, 32} -/
def execute_aarch32_instrs_VLD2_m_Op_A_txt (alignment : Nat) (d__arg : Nat) (d2__arg : Int) (ebytes : Nat) (elements : Int) (m : Nat) (n : Nat) (pairs : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  let d : Int := d__arg
  let d2 : Int := d2__arg
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let address ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (pairs -i 1)
    let mut loop_vars := address
    for r in [loop_r_lower:loop_r_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := address
        for e in [loop_e_lower:loop_e_upper:1]i do
          let address := loop_vars_1
          loop_vars_1 ← do
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e (8 *i ebytes)
                  (← (MemU_read address ebytes)))))
            (D_set (d2 +i r)
              (← (Elem_set (← (D_read (d2 +i r))) e (8 *i ebytes)
                  (← (MemU_read (BitVec.addInt address ebytes) ebytes)))))
            (pure (BitVec.addInt address (2 *i ebytes)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (16 *i pairs))))
  else (pure ())

def decode_aarch32_instrs_VLD2_m_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let pairs := 1
      bif (BEq.beq align (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let inc_name :=
        bif (BEq.beq itype (0x9 : (BitVec 4)))
        then 2
        else 1
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d2 +i pairs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (Bool.or (BEq.beq pairs 1) (BEq.beq pairs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:25627.168-25627.169"
      (execute_aarch32_instrs_VLD2_m_Op_A_txt alignment d d2 ebytes elements m n pairs
        register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD2_m_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let pairs := 2
      let inc_name := 2
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d2 +i pairs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (Bool.or (BEq.beq pairs 1) (BEq.beq pairs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:25666.168-25666.169"
      (execute_aarch32_instrs_VLD2_m_Op_A_txt alignment d d2 ebytes elements m n pairs
        register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD2_m_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let pairs := 1
      bif (BEq.beq align (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let inc_name :=
        bif (BEq.beq itype (0x9 : (BitVec 4)))
        then 2
        else 1
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d2 +i pairs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (Bool.or (BEq.beq pairs 1) (BEq.beq pairs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:25708.168-25708.169"
      (execute_aarch32_instrs_VLD2_m_Op_A_txt alignment d d2 ebytes elements m n pairs
        register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD2_m_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let pairs := 2
      let inc_name := 2
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d2 +i pairs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (Bool.or (BEq.beq pairs 1) (BEq.beq pairs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:25747.168-25747.169"
      (execute_aarch32_instrs_VLD2_m_Op_A_txt alignment d d2 ebytes elements m n pairs
        register_index wback))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, d2__arg : Int, d3__arg : Int, ebytes : Nat, index : Nat, m : Nat, n
  : Nat, k_register_index : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ ebytes ∈ {1, 2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VLD3_1_Op_A_txt (d__arg : Nat) (d2__arg : Int) (d3__arg : Int) (ebytes : Nat) (index : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  let d : Int := d__arg
  let d2 : Int := d2__arg
  let d3 : Int := d3__arg
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  (D_set d (← (Elem_set (← (D_read d)) index (8 *i ebytes) (← (MemU_read address ebytes)))))
  (D_set d2
    (← (Elem_set (← (D_read d2)) index (8 *i ebytes)
        (← (MemU_read (BitVec.addInt address ebytes) ebytes)))))
  (D_set d3
    (← (Elem_set (← (D_read d3)) index (8 *i ebytes)
        (← (MemU_read (BitVec.addInt address (2 *i ebytes)) ebytes)))))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (3 *i ebytes))))
  else (pure ())

def decode_aarch32_instrs_VLD3_1_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD3 (single 3-element structure to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD3_1_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD3 (single 3-element structure to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD3_1_A3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD3 (single 3-element structure to all lanes)"))
      else (pure ())
      bif (bne (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD3_1_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD3 (single 3-element structure to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD3_1_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD3 (single 3-element structure to all lanes)"))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD3_1_T3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD3 (single 3-element structure to all lanes)"))
      else (pure ())
      bif (bne (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

/-- Type quantifiers: d : Nat, d2 : Int, d3 : Int, ebytes : Nat, m : Nat, n : Nat, k_register_index
  : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VLD3_a_Op_A_txt (d : Nat) (d2 : Int) (d3 : Int) (ebytes : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let esize := (ebytes *i 8)
  let element1 ← (( do (MemU_read address ebytes) ) : SailM (BitVec esize) )
  let element2 ← (( do (MemU_read (BitVec.addInt address ebytes) ebytes) ) : SailM (BitVec esize)
    )
  let element3 ← (( do (MemU_read (BitVec.addInt address (2 *i ebytes)) ebytes) ) : SailM
    (BitVec esize) )
  (D_set d (BitVec.replicateBits element1 (ediv_nat 64 esize)))
  (D_set d2 (BitVec.replicateBits element2 (ediv_nat 64 esize)))
  (D_set d3 (BitVec.replicateBits element3 (ediv_nat 64 esize)))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (3 *i ebytes))))
  else (pure ())

def decode_aarch32_instrs_VLD3_a_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (T : (BitVec 1)) (a : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2))) (BEq.beq a (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let inc_name :=
        bif (BEq.beq T (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD3_a_Op_A_txt d d2 d3 ebytes m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD3_a_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (T : (BitVec 1)) (a : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2))) (BEq.beq a (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let inc_name :=
        bif (BEq.beq T (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD3_a_Op_A_txt d d2 d3 ebytes m n register_index wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d__arg : Nat, d2__arg : Int, d3__arg : Int, ebytes : Nat, elements
  : Int, m : Nat, n : Nat, k_register_index : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ alignment ∈ {1, 8} -/
def execute_aarch32_instrs_VLD3_m_Op_A_txt (alignment : Nat) (d__arg : Nat) (d2__arg : Int) (d3__arg : Int) (ebytes : Nat) (elements : Int) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  let d : Int := d__arg
  let d2 : Int := d2__arg
  let d3 : Int := d3__arg
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let address ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := address
    for e in [loop_e_lower:loop_e_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        (D_set d (← (Elem_set (← (D_read d)) e (8 *i ebytes) (← (MemU_read address ebytes)))))
        (D_set d2
          (← (Elem_set (← (D_read d2)) e (8 *i ebytes)
              (← (MemU_read (BitVec.addInt address ebytes) ebytes)))))
        (D_set d3
          (← (Elem_set (← (D_read d3)) e (8 *i ebytes)
              (← (MemU_read (BitVec.addInt address (2 *i ebytes)) ebytes)))))
        (pure (BitVec.addInt address (3 *i ebytes)))
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) 24)))
  else (pure ())

def decode_aarch32_instrs_VLD3_m_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let inc_name : Int := 1
      let b__0 := itype
      bif (BEq.beq b__0 (0x4 : (BitVec 4)))
      then
        (let inc_name : Int := 1
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0x5 : (BitVec 4)))
          then
            (let inc_name : Int := 2
            (pure ()))
          else sailThrow ((Error_See "Related encodings")))
      let inc_name := inc_name
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD3_m_Op_A_txt alignment d d2 d3 ebytes elements m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD3_m_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let inc_name : Int := 1
      let b__0 := itype
      bif (BEq.beq b__0 (0x4 : (BitVec 4)))
      then
        (let inc_name : Int := 1
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0x5 : (BitVec 4)))
          then
            (let inc_name : Int := 2
            (pure ()))
          else sailThrow ((Error_See "Related encodings")))
      let inc_name := inc_name
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD3_m_Op_A_txt alignment d d2 d3 ebytes elements m n register_index
        wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d__arg : Nat, d2__arg : Int, d3__arg : Int, d4__arg : Int, ebytes
  : Nat, index : Nat, m : Nat, n : Nat, k_register_index : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  ebytes ∈ {1, 2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ alignment ∈ {1, 4, 8, 16, 32} -/
def execute_aarch32_instrs_VLD4_1_Op_A_txt (alignment : Nat) (d__arg : Nat) (d2__arg : Int) (d3__arg : Int) (d4__arg : Int) (ebytes : Nat) (index : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  let d : Int := d__arg
  let d2 : Int := d2__arg
  let d3 : Int := d3__arg
  let d4 : Int := d4__arg
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  (D_set d (← (Elem_set (← (D_read d)) index (8 *i ebytes) (← (MemU_read address ebytes)))))
  (D_set d2
    (← (Elem_set (← (D_read d2)) index (8 *i ebytes)
        (← (MemU_read (BitVec.addInt address ebytes) ebytes)))))
  (D_set d3
    (← (Elem_set (← (D_read d3)) index (8 *i ebytes)
        (← (MemU_read (BitVec.addInt address (2 *i ebytes)) ebytes)))))
  (D_set d4
    (← (Elem_set (← (D_read d4)) index (8 *i ebytes)
        (← (MemU_read (BitVec.addInt address (3 *i ebytes)) ebytes)))))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (4 *i ebytes))))
  else (pure ())

def decode_aarch32_instrs_VLD4_1_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD4 (single 4-element structure to all lanes)"))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD4_1_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD4 (single 4-element structure to all lanes)"))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD4_1_A3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD4 (single 4-element structure to all lanes)"))
      else (pure ())
      bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 (Sail.BitVec.extractLsb index_align 1 0)))
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 15)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 15)
              (Bool.and
                (Bool.or
                  (Bool.or
                    (Bool.or
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                          (BEq.beq index 3)) (BEq.beq index 4)) (BEq.beq index 5)) (BEq.beq index 6))
                  (BEq.beq index 7))
                (Bool.and
                  (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:26383.183-26383.184"
      (execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD4_1_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD4 (single 4-element structure to all lanes)"))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD4_1_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD4 (single 4-element structure to all lanes)"))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VLD4_1_T3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "VLD4 (single 4-element structure to all lanes)"))
      else (pure ())
      bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 (Sail.BitVec.extractLsb index_align 1 0)))
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 15)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 15)
              (Bool.and
                (Bool.or
                  (Bool.or
                    (Bool.or
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                          (BEq.beq index 3)) (BEq.beq index 4)) (BEq.beq index 5)) (BEq.beq index 6))
                  (BEq.beq index 7))
                (Bool.and
                  (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:26502.183-26502.184"
      (execute_aarch32_instrs_VLD4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d : Nat, d2 : Int, d3 : Int, d4 : Int, ebytes : Nat, m : Nat, n
  : Nat, k_register_index : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d ∧ d ≤ 31 ∧ alignment ∈ {1, 4, 8, 16, 32} -/
def execute_aarch32_instrs_VLD4_a_Op_A_txt (alignment : Nat) (d : Nat) (d2 : Int) (d3 : Int) (d4 : Int) (ebytes : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let esize := (ebytes *i 8)
  let element1 ← (( do (MemU_read address ebytes) ) : SailM (BitVec esize) )
  let element2 ← (( do (MemU_read (BitVec.addInt address ebytes) ebytes) ) : SailM (BitVec esize)
    )
  let element3 ← (( do (MemU_read (BitVec.addInt address (2 *i ebytes)) ebytes) ) : SailM
    (BitVec esize) )
  let element4 ← (( do (MemU_read (BitVec.addInt address (3 *i ebytes)) ebytes) ) : SailM
    (BitVec esize) )
  (D_set d (BitVec.replicateBits element1 (ediv_nat 64 esize)))
  (D_set d2 (BitVec.replicateBits element2 (ediv_nat 64 esize)))
  (D_set d3 (BitVec.replicateBits element3 (ediv_nat 64 esize)))
  (D_set d4 (BitVec.replicateBits element4 (ediv_nat 64 esize)))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (4 *i ebytes))))
  else (pure ())

def decode_aarch32_instrs_VLD4_a_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (T : (BitVec 1)) (a : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq size (0b11 : (BitVec 2))) (BEq.beq a (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes : Int := 1
      let alignment ← (( do (undefined_int ()) ) : SailM Int )
      let (alignment, ebytes) : (Int × Int) :=
        bif (BEq.beq size (0b11 : (BitVec 2)))
        then
          (let ebytes : Int := 4
          let alignment : Int := 16
          (alignment, ebytes))
        else
          (let ebytes : Int := (Int.shiftl 1 (UInt0 size))
          let alignment : Int :=
            bif (BEq.beq size (0b10 : (BitVec 2)))
            then
              (bif (BEq.beq a (0b0 : (BitVec 1)))
              then 1
              else 8)
            else
              (bif (BEq.beq a (0b0 : (BitVec 1)))
              then 1
              else (4 *i ebytes))
          (alignment, ebytes))
      let ebytes := ebytes
      let alignment := alignment
      let inc_name :=
        bif (BEq.beq T (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let alignment := alignment
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 15)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 15)
              (Bool.and
                (Bool.or
                  (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                  (BEq.beq ebytes 8))
                (Bool.and (0 ≤b d)
                  (Bool.and (d ≤b 31)
                    (Bool.or
                      (Bool.or
                        (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                          (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32))))))))) "src/instrs32.sail:26586.149-26586.150"
      (execute_aarch32_instrs_VLD4_a_Op_A_txt alignment d d2 d3 d4 ebytes m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD4_a_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (T : (BitVec 1)) (a : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq size (0b11 : (BitVec 2))) (BEq.beq a (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes : Int := 1
      let alignment ← (( do (undefined_int ()) ) : SailM Int )
      let (alignment, ebytes) : (Int × Int) :=
        bif (BEq.beq size (0b11 : (BitVec 2)))
        then
          (let ebytes : Int := 4
          let alignment : Int := 16
          (alignment, ebytes))
        else
          (let ebytes : Int := (Int.shiftl 1 (UInt0 size))
          let alignment : Int :=
            bif (BEq.beq size (0b10 : (BitVec 2)))
            then
              (bif (BEq.beq a (0b0 : (BitVec 1)))
              then 1
              else 8)
            else
              (bif (BEq.beq a (0b0 : (BitVec 1)))
              then 1
              else (4 *i ebytes))
          (alignment, ebytes))
      let ebytes := ebytes
      let alignment := alignment
      let inc_name :=
        bif (BEq.beq T (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let alignment := alignment
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 15)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 15)
              (Bool.and
                (Bool.or
                  (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                  (BEq.beq ebytes 8))
                (Bool.and (0 ≤b d)
                  (Bool.and (d ≤b 31)
                    (Bool.or
                      (Bool.or
                        (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                          (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32))))))))) "src/instrs32.sail:26639.149-26639.150"
      (execute_aarch32_instrs_VLD4_a_Op_A_txt alignment d d2 d3 d4 ebytes m n register_index wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d__arg : Nat, d2__arg : Int, d3__arg : Int, d4__arg : Int, ebytes
  : Nat, elements : Int, m : Nat, n : Nat, k_register_index : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 ∧ alignment ∈ {1, 4, 8, 16, 32} -/
def execute_aarch32_instrs_VLD4_m_Op_A_txt (alignment : Nat) (d__arg : Nat) (d2__arg : Int) (d3__arg : Int) (d4__arg : Int) (ebytes : Nat) (elements : Int) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  let d : Int := d__arg
  let d2 : Int := d2__arg
  let d3 : Int := d3__arg
  let d4 : Int := d4__arg
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_LOAD nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let address ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := address
    for e in [loop_e_lower:loop_e_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        (D_set d (← (Elem_set (← (D_read d)) e (8 *i ebytes) (← (MemU_read address ebytes)))))
        (D_set d2
          (← (Elem_set (← (D_read d2)) e (8 *i ebytes)
              (← (MemU_read (BitVec.addInt address ebytes) ebytes)))))
        (D_set d3
          (← (Elem_set (← (D_read d3)) e (8 *i ebytes)
              (← (MemU_read (BitVec.addInt address (2 *i ebytes)) ebytes)))))
        (D_set d4
          (← (Elem_set (← (D_read d4)) e (8 *i ebytes)
              (← (MemU_read (BitVec.addInt address (3 *i ebytes)) ebytes)))))
        (pure (BitVec.addInt address (4 *i ebytes)))
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) 32)))
  else (pure ())

def decode_aarch32_instrs_VLD4_m_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let inc_name : Int := 1
      let b__0 := itype
      bif (BEq.beq b__0 (0x0 : (BitVec 4)))
      then
        (let inc_name : Int := 1
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0x1 : (BitVec 4)))
          then
            (let inc_name : Int := 2
            (pure ()))
          else sailThrow ((Error_See "Related encodings")))
      let inc_name := inc_name
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 15)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 15)
              (Bool.and
                (Bool.or
                  (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                  (BEq.beq ebytes 8))
                (Bool.and (0 ≤b d)
                  (Bool.and (d ≤b 31)
                    (Bool.or
                      (Bool.or
                        (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                          (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32))))))))) "src/instrs32.sail:26725.149-26725.150"
      (execute_aarch32_instrs_VLD4_m_Op_A_txt alignment d d2 d3 d4 ebytes elements m n
        register_index wback))
  else (pure ())

def decode_aarch32_instrs_VLD4_m_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let inc_name : Int := 1
      let b__0 := itype
      bif (BEq.beq b__0 (0x0 : (BitVec 4)))
      then
        (let inc_name : Int := 1
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0x1 : (BitVec 4)))
          then
            (let inc_name : Int := 2
            (pure ()))
          else sailThrow ((Error_See "Related encodings")))
      let inc_name := inc_name
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 15)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 15)
              (Bool.and
                (Bool.or
                  (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                  (BEq.beq ebytes 8))
                (Bool.and (0 ≤b d)
                  (Bool.and (d ≤b 31)
                    (Bool.or
                      (Bool.or
                        (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                          (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32))))))))) "src/instrs32.sail:26777.149-26777.150"
      (execute_aarch32_instrs_VLD4_m_Op_A_txt alignment d d2 d3 d4 ebytes elements m n
        register_index wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, d : Nat, n : Nat, regs : Int, k_single_regs : Bool, k_wback :
  Bool, 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VLDM_Op_A_txt (add : Bool) (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (regs : Int) (single_regs : Bool) (wback : Bool) : SailM Unit := do
  let word1 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let word2 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  (CheckVFPEnabled true)
  let address ← (( do
    bif add
    then (R_read n)
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let (address, word1, word2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (address, word1, word2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (address, word1, word2) := loop_vars
      loop_vars ← do
        let (address, word1, word2) ← (( do
          bif single_regs
          then
            (do
              (S_set (d +i r) (← (MemA_read address 4)))
              let address : (BitVec 32) := (BitVec.addInt address 4)
              (pure (address, word1, word2)))
          else
            (do
              let word1 ← (MemA_read address 4)
              let word2 ← (MemA_read (BitVec.addInt address 4) 4)
              let address : (BitVec 32) := (BitVec.addInt address 8)
              (D_set (d +i r)
                (← do
                  bif (← (BigEndian AccessType_ASIMD))
                  then (pure (word1 ++ word2))
                  else (pure (word2 ++ word1))))
              (pure (address, word1, word2))) ) : SailM ((BitVec 32) × (BitVec 32) × (BitVec 32))
          )
        (pure (address, word1, word2))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 32) × (BitVec 32)) )
  bif wback
  then
    (R_set n
      (← do
        bif add
        then (pure ((← (R_read n)) + imm32))
        else (pure ((← (R_read n)) - imm32))))
  else (pure ())

def decode_aarch32_instrs_VLDM_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (D : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:26827.29-26827.30"
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VLDR"))
      else (pure ())
      bif (Bool.and (BEq.beq P U) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let single_regs : Bool := false
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let regs := (ediv_nat (UInt0 imm8) 2)
      bif (Bool.and (BEq.beq n 15) (Bool.or wback (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (BEq.beq regs 0) (regs >b 16)) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access imm8 0)]) (0b1 : (BitVec 1)))
           ((d +i regs) >b 16))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLDM_Op_A_txt add d imm32 n regs single_regs wback))
  else (pure ())

def decode_aarch32_instrs_VLDM_A2enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (D : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:26875.29-26875.30"
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VLDR"))
      else (pure ())
      bif (Bool.and (BEq.beq P U) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let single_regs : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let d := (UInt0 (Vd ++ D))
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let regs := (UInt0 imm8)
      bif (Bool.and (BEq.beq n 15) (Bool.or wback (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq regs 0) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLDM_Op_A_txt add d imm32 n regs single_regs wback))
  else (pure ())

def decode_aarch32_instrs_VLDM_T1enc_A_txt (P : (BitVec 1)) (U : (BitVec 1)) (D : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VLDR"))
      else (pure ())
      bif (Bool.and (BEq.beq P U) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let single_regs : Bool := false
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let regs := (ediv_nat (UInt0 imm8) 2)
      bif (Bool.and (BEq.beq n 15) (Bool.or wback (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (BEq.beq regs 0) (regs >b 16)) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access imm8 0)]) (0b1 : (BitVec 1)))
           ((d +i regs) >b 16))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLDM_Op_A_txt add d imm32 n regs single_regs wback))
  else (pure ())

def decode_aarch32_instrs_VLDM_T2enc_A_txt (P : (BitVec 1)) (U : (BitVec 1)) (D : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VLDR"))
      else (pure ())
      bif (Bool.and (BEq.beq P U) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let single_regs : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let d := (UInt0 (Vd ++ D))
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let regs := (UInt0 imm8)
      bif (Bool.and (BEq.beq n 15) (Bool.or wback (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq regs 0) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VLDM_Op_A_txt add d imm32 n regs single_regs wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VLDR_Op_A_txt (add : Bool) (d : Nat) (esize : Nat) (imm32 : (BitVec 32)) (n : Nat) : SailM Unit := do
  let word1 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let word2 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  (CheckVFPEnabled true)
  let base ← (( do
    bif (BEq.beq n 15)
    then (pure (Align_bits (← (PC_read__1 ())) 4))
    else (R_read n) ) : SailM (BitVec 32) )
  let address : (BitVec 32) :=
    bif add
    then (base + imm32)
    else (base - imm32)
  match esize with
  | 16 => (S_set d ((Zeros (n := 16)) ++ (← (MemA_read address 2))))
  | 32 => (S_set d (← (MemA_read address 4)))
  | 64 => (do
      let word1 ← (( do (MemA_read address 4) ) : SailM (BitVec 32) )
      let word2 ← (( do (MemA_read (BitVec.addInt address 4) 4) ) : SailM (BitVec 32) )
      (D_set d
        (← do
          bif (← (BigEndian AccessType_ASIMD))
          then (pure (word1 ++ word2))
          else (pure (word2 ++ word1)))))
  | _ => (pure ())

def decode_aarch32_instrs_VLDR_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:27036.29-27036.30"
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let imm32 : (BitVec 32) :=
        bif (BEq.beq esize 16)
        then (zero_extend (imm8 ++ (0b0 : (BitVec 1))) 32)
        else (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let d : Nat := (UInt0 (Vd ++ D))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let d : Nat := (UInt0 (Vd ++ D))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let d : Nat := (UInt0 (D ++ Vd))
              ())
            else ()))
      let d := d
      let n := (UInt0 Rn)
      (execute_aarch32_instrs_VLDR_Op_A_txt add d esize imm32 n))
  else (pure ())

def decode_aarch32_instrs_VLDR_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let imm32 : (BitVec 32) :=
        bif (BEq.beq esize 16)
        then (zero_extend (imm8 ++ (0b0 : (BitVec 1))) 32)
        else (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let d : Nat := (UInt0 (Vd ++ D))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let d : Nat := (UInt0 (Vd ++ D))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let d : Nat := (UInt0 (D ++ Vd))
              ())
            else ()))
      let d := d
      let n := (UInt0 Rn)
      (execute_aarch32_instrs_VLDR_Op_A_txt add d esize imm32 n))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, k_maximum : Bool, n : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMAX_f_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (maximum : Bool) (n : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (op1, op2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2) := loop_vars
      loop_vars ← do
        let (op1, op2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (n +i r))) e esize)
              let op2 ← (Elem_read (← (D_read (m +i r))) e esize)
              bif maximum
              then
                (D_set (d +i r)
                  (← (Elem_set (← (D_read (d +i r))) e esize
                      (← (FPMax op1 op2 (← (StandardFPSCRValue ())))))))
              else
                (D_set (d +i r)
                  (← (Elem_set (← (D_read (d +i r))) e esize
                      (← (FPMin op1 op2 (← (StandardFPSCRValue ())))))))
              (pure (op1, op2))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, op2))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VMAX_f_A1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMAX_f_Op_A_txt d elements esize m maximum n regs))
  else (pure ())

def decode_aarch32_instrs_VMAX_f_T1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMAX_f_Op_A_txt d elements esize m maximum n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, k_maximum
  : Bool, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMAX_i_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (maximum : Bool) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let (op1, op2, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2, result) := loop_vars
      loop_vars ← do
        let (op1, op2, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2, result) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (asl_Int (← (Elem_read (← (D_read (n +i r))) e esize)) is_unsigned)
              let op2 ← (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned)
              let result : Int :=
                bif maximum
                then (Max.max op1 op2)
                else (Min.min op1 op2)
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (integer_subrange result (esize -i 1) 0))))
              (pure (op1, op2, result))
          (pure loop_vars_1) ) : SailM (Int × Int × Int) )
        (pure (op1, op2, result))
    (pure loop_vars) ) : SailM (Int × Int × Int) )
  (pure ())

def decode_aarch32_instrs_VMAX_i_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (op : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMAX_i_Op_A_txt d elements esize m maximum n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMAX_i_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (op : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMAX_i_Op_A_txt d elements esize m maximum n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: k_add : Bool, k_advsimd : Bool, d__arg : Nat, elements : Int, esize : Nat, m :
  Nat, n : Nat, regs : Int, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMLA_f_Op_A_txt (add : Bool) (advsimd : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Int) : SailM Unit := do
  let d : Int := d__arg
  let addend ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let addend16 ← (( do (undefined_bitvector 16) ) : SailM (BitVec 16) )
  let addend32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let addend64 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let product ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif advsimd
  then
    (do
      let (addend, product) ← (( do
        let loop_r_lower := 0
        let loop_r_upper := (regs -i 1)
        let mut loop_vars := (addend, product)
        for r in [loop_r_lower:loop_r_upper:1]i do
          let (addend, product) := loop_vars
          loop_vars ← do
            let (addend, product) ← (( do
              let loop_e_lower := 0
              let loop_e_upper := (elements -i 1)
              let mut loop_vars_1 := (addend, product)
              for e in [loop_e_lower:loop_e_upper:1]i do
                let (addend, product) := loop_vars_1
                loop_vars_1 ← do
                  let product ←
                    (FPMul (← (Elem_read (← (D_read (n +i r))) e esize))
                      (← (Elem_read (← (D_read (m +i r))) e esize))
                      (← (StandardFPSCRValue ())))
                  let addend ←
                    bif add
                    then (pure product)
                    else (FPNeg product)
                  (D_set (d +i r)
                    (← (Elem_set (← (D_read (d +i r))) e esize
                        (← (FPAdd (← (Elem_read (← (D_read (d +i r))) e esize)) addend
                            (← (StandardFPSCRValue ())))))))
                  (pure (addend, product))
              (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
            (pure (addend, product))
        (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
      (pure ()))
  else
    (do
      match esize with
      | 16 => (do
          let addend16 ← (( do
            bif add
            then
              (FPMul (Sail.BitVec.extractLsb (← (S_read n)) 15 0)
                (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ())))
            else
              (FPNeg
                (← (FPMul (Sail.BitVec.extractLsb (← (S_read n)) 15 0)
                    (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ()))))) ) :
            SailM (BitVec 16) )
          (S_set d
            ((Zeros (n := 16)) ++ (← (FPAdd (Sail.BitVec.extractLsb (← (S_read d)) 15 0)
                  addend16 (← (FPSCR_read ())))))))
      | 32 => (do
          let addend32 ← (( do
            bif add
            then (FPMul (← (S_read n)) (← (S_read m)) (← (FPSCR_read ())))
            else (FPNeg (← (FPMul (← (S_read n)) (← (S_read m)) (← (FPSCR_read ()))))) ) :
            SailM (BitVec 32) )
          (S_set d (← (FPAdd (← (S_read d)) addend32 (← (FPSCR_read ()))))))
      | 64 => (do
          let addend64 ← (( do
            bif add
            then (FPMul (← (D_read n)) (← (D_read m)) (← (FPSCR_read ())))
            else (FPNeg (← (FPMul (← (D_read n)) (← (D_read m)) (← (FPSCR_read ()))))) ) :
            SailM (BitVec 64) )
          (D_set d (← (FPAdd (← (D_read d)) addend64 (← (FPSCR_read ()))))))
      | _ => (pure ()))

def decode_aarch32_instrs_VMLA_f_A1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let advsimd : Bool := true
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMLA_f_Op_A_txt add advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VMLA_f_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:27444.29-27444.30"
      let floating_point ← (( do (undefined_bool ()) ) : SailM Bool )
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let floating_point := floating_point
      let advsimd : Bool := false
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VMLA_f_Op_A_txt add advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VMLA_f_T1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let advsimd : Bool := true
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMLA_f_Op_A_txt add advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VMLA_f_T2enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let floating_point ← (( do (undefined_bool ()) ) : SailM Bool )
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let floating_point := floating_point
      let advsimd : Bool := false
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VMLA_f_Op_A_txt add advsimd d elements esize m n regs))
  else (pure ())

/-- Type quantifiers: k_add : Bool, d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, k_long_destination
  : Bool, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMLA_i_Op_A_txt (add : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (long_destination : Bool) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let addend ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let (addend, product) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (addend, product)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (addend, product) := loop_vars
      loop_vars ← do
        let (addend, product) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (addend, product)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (addend, product) := loop_vars_1
            loop_vars_1 ← do
              let product ←
                (pure ((← (asl_Int (← (Elem_read (← (Din_read (n +i r))) e esize)) is_unsigned)) *i (← (asl_Int
                        (← (Elem_read (← (Din_read (m +i r))) e esize)) is_unsigned))))
              let addend : Int :=
                bif add
                then product
                else (Neg.neg product)
              bif long_destination
              then
                (Q_set (Int.shiftr d 1)
                  (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize)
                      (BitVec.addInt
                        (← (Elem_read (← (Qin_read (Int.shiftr d 1))) e (2 *i esize))) addend))))
              else
                (D_set (d +i r)
                  (← (Elem_set (← (D_read (d +i r))) e esize
                      (BitVec.addInt (← (Elem_read (← (Din_read (d +i r))) e esize)) addend))))
              (pure (addend, product))
          (pure loop_vars_1) ) : SailM (Int × Int) )
        (pure (addend, product))
    (pure loop_vars) ) : SailM (Int × Int) )
  (pure ())

def decode_aarch32_instrs_VMLA_i_A1enc_A_txt (op : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let long_destination : Bool := false
      let is_unsigned : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMLA_i_Op_A_txt add d elements esize long_destination m n regs
        is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMLA_i_A2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let long_destination : Bool := true
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs := 1
      (execute_aarch32_instrs_VMLA_i_Op_A_txt add d elements esize long_destination m n regs
        is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMLA_i_T1enc_A_txt (op : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let long_destination : Bool := false
      let is_unsigned : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMLA_i_Op_A_txt add d elements esize long_destination m n regs
        is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMLA_i_T2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let long_destination : Bool := true
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs := 1
      (execute_aarch32_instrs_VMLA_i_Op_A_txt add d elements esize long_destination m n regs
        is_unsigned))
  else (pure ())

/-- Type quantifiers: k_add : Bool, d__arg : Nat, elements : Nat, esize : Nat, k_floating_point :
  Bool, index : Nat, k_is_unsigned : Bool, k_long_destination : Bool, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  index ∈ {0, 1, 2, 3} ∧
  esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMLA_s_Op_A_txt (add : Bool) (d__arg : Nat) (elements : Nat) (esize : Nat) (floating_point : Bool) (index : Nat) (long_destination : Bool) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let addend ← (( do (undefined_int ()) ) : SailM Int )
  let fp_addend ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op1val ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let op2 ← (( do (Elem_read (← (Din_read m)) index esize) ) : SailM (BitVec esize) )
  let op2val ← do (asl_Int op2 is_unsigned)
  let (addend, fp_addend, op1, op1val) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (addend, fp_addend, op1, op1val)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (addend, fp_addend, op1, op1val) := loop_vars
      loop_vars ← do
        let (addend, fp_addend, op1, op1val) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (addend, fp_addend, op1, op1val)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (addend, fp_addend, op1, op1val) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (Din_read (n +i r))) e esize)
              let op1val ← (asl_Int op1 is_unsigned)
              let (addend, fp_addend) ← (( do
                bif floating_point
                then
                  (do
                    let fp_addend ←
                      bif add
                      then (FPMul op1 op2 (← (StandardFPSCRValue ())))
                      else (FPNeg (← (FPMul op1 op2 (← (StandardFPSCRValue ())))))
                    (D_set (d +i r)
                      (← (Elem_set (← (D_read (d +i r))) e esize
                          (← (FPAdd (← (Elem_read (← (Din_read (d +i r))) e esize)) fp_addend
                              (← (StandardFPSCRValue ())))))))
                    (pure (addend, fp_addend)))
                else
                  (do
                    let addend : Int :=
                      bif add
                      then (op1val *i op2val)
                      else ((Neg.neg op1val) *i op2val)
                    bif long_destination
                    then
                      (Q_set (Int.shiftr d 1)
                        (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize)
                            (BitVec.addInt
                              (← (Elem_read (← (Qin_read (Int.shiftr d 1))) e (2 *i esize)))
                              addend))))
                    else
                      (D_set (d +i r)
                        (← (Elem_set (← (D_read (d +i r))) e esize
                            (BitVec.addInt (← (Elem_read (← (Din_read (d +i r))) e esize))
                              addend))))
                    (pure (addend, fp_addend))) ) : SailM (Int × (BitVec esize)) )
              (pure (addend, fp_addend, op1, op1val))
          (pure loop_vars_1) ) : SailM (Int × (BitVec esize) × (BitVec esize) × Int) )
        (pure (addend, fp_addend, op1, op1val))
    (pure loop_vars) ) : SailM (Int × (BitVec esize) × (BitVec esize) × Int) )
  (pure ())

def decode_aarch32_instrs_VMLA_s_A1enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (F : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
             (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := false
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let long_destination : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      let esize : Int := 16
      let elements : Int := 2
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                    (BEq.beq index 3))
                  (Bool.and (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                    (Bool.and (Bool.or (BEq.beq elements 2) (BEq.beq elements 4))
                      (Bool.and (0 ≤b d) (d ≤b 31)))))))))) "src/instrs32.sail:27879.175-27879.176"
      (execute_aarch32_instrs_VMLA_s_Op_A_txt add d elements esize floating_point index
        long_destination m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMLA_s_A2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let floating_point : Bool := false
      let long_destination : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs := 1
      let esize : Int := 16
      let elements : Int := 2
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                    (BEq.beq index 3))
                  (Bool.and (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                    (Bool.and (Bool.or (BEq.beq elements 2) (BEq.beq elements 4))
                      (Bool.and (0 ≤b d) (d ≤b 31)))))))))) "src/instrs32.sail:27937.175-27937.176"
      (execute_aarch32_instrs_VMLA_s_Op_A_txt add d elements esize floating_point index
        long_destination m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMLA_s_T1enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (F : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
             (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
           (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := false
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let long_destination : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      let esize : Int := 16
      let elements : Int := 2
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                    (BEq.beq index 3))
                  (Bool.and (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                    (Bool.and (Bool.or (BEq.beq elements 2) (BEq.beq elements 4))
                      (Bool.and (0 ≤b d) (d ≤b 31)))))))))) "src/instrs32.sail:28000.175-28000.176"
      (execute_aarch32_instrs_VMLA_s_Op_A_txt add d elements esize floating_point index
        long_destination m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMLA_s_T2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let floating_point : Bool := false
      let long_destination : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs := 1
      let esize : Int := 16
      let elements : Int := 2
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                    (BEq.beq index 3))
                  (Bool.and (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                    (Bool.and (Bool.or (BEq.beq elements 2) (BEq.beq elements 4))
                      (Bool.and (0 ≤b d) (d ≤b 31)))))))))) "src/instrs32.sail:28058.175-28058.176"
      (execute_aarch32_instrs_VMLA_s_Op_A_txt add d elements esize floating_point index
        long_destination m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VMOVX_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  (S_set d ((Zeros (n := 16)) ++ (Sail.BitVec.extractLsb (← (S_read m)) 31 16)))

def decode_aarch32_instrs_VMOVX_A1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (HaveFP16Ext ()))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (Vd ++ D))
      let m := (UInt0 (Vm ++ M))
      (execute_aarch32_instrs_VMOVX_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_VMOVX_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (HaveFP16Ext ()))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (Vd ++ D))
      let m := (UInt0 (Vm ++ M))
      (execute_aarch32_instrs_VMOVX_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VINS_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  (S_set d
    ((Sail.BitVec.extractLsb (← (S_read m)) 15 0) ++ (Sail.BitVec.extractLsb (← (S_read d)) 15 0)))

def decode_aarch32_instrs_VINS_A1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (HaveFP16Ext ()))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (Vd ++ D))
      let m := (UInt0 (Vm ++ M))
      (execute_aarch32_instrs_VINS_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_VINS_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (HaveFP16Ext ()))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (Vd ++ D))
      let m := (UInt0 (Vm ++ M))
      (execute_aarch32_instrs_VINS_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: m : Nat, t : Nat, t2 : Nat, k_to_arm_registers : Bool, 0 ≤ t2 ∧
  t2 ≤ 15 ∧ 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ m ∧ m ≤ 31 -/
def execute_aarch32_instrs_VMOV_d_Op_A_txt (m : Nat) (t : Nat) (t2 : Nat) (to_arm_registers : Bool) : SailM Unit := do
  (CheckVFPEnabled true)
  bif to_arm_registers
  then
    (do
      (R_set t (Sail.BitVec.extractLsb (← (D_read m)) 31 0))
      (R_set t2 (Sail.BitVec.extractLsb (← (D_read m)) 63 32)))
  else
    (do
      (D_set m (Sail.BitVec.updateSubrange (← (D_read m)) 31 0 (← (R_read t))))
      (D_set m (Sail.BitVec.updateSubrange (← (D_read m)) 63 32 (← (R_read t2)))))

def decode_aarch32_instrs_VMOV_d_A1enc_A_txt (cond : (BitVec 4)) (op : (BitVec 1)) (Rt2 : (BitVec 4)) (Rt : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:28225.29-28225.30"
      let to_arm_registers : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let m := (UInt0 (M ++ Vm))
      bif (Bool.or (BEq.beq t 15) (BEq.beq t2 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and to_arm_registers (BEq.beq t t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMOV_d_Op_A_txt m t t2 to_arm_registers))
  else (pure ())

def decode_aarch32_instrs_VMOV_d_T1enc_A_txt (op : (BitVec 1)) (Rt2 : (BitVec 4)) (Rt : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let to_arm_registers : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let m := (UInt0 (M ++ Vm))
      bif (Bool.or (BEq.beq t 15) (BEq.beq t2 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and to_arm_registers (BEq.beq t t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMOV_d_Op_A_txt m t t2 to_arm_registers))
  else (pure ())

/-- Type quantifiers: k_advsimd : Bool, d : Nat, regs : Nat, k_single_register : Bool, regs ∈
  {1, 2} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VMOV_i_Op_A_txt (advsimd : Bool) (d : Nat) (imm32 : (BitVec 32)) (imm64 : (BitVec 64)) (regs : Nat) (single_register : Bool) : SailM Unit := do
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif single_register
  then (S_set d imm32)
  else
    (do
      let loop_r_lower := 0
      let loop_r_upper := (regs -i 1)
      let mut loop_vars := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars
        loop_vars ← do (D_set (d +i r) imm64)
      (pure loop_vars))

def decode_aarch32_instrs_VMOV_i_A1enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (op : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (Bool.and
           (Bool.and (BEq.beq op (0b0 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1))))
           (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VORR (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq op (0b1 : (BitVec 1))) (bne cmode (0xE : (BitVec 4))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm32 := imm32
      let single_register : Bool := false
      let advsimd : Bool := true
      let imm64 ← (( do (AdvSIMDExpandImm op cmode ((i ++ imm3) ++ imm4)) ) : SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_i_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (imm4H : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:28338.29-28338.30"
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let single_register : Bool := (bne size (0b11 : (BitVec 2)))
      let advsimd : Bool := false
      let imm16 ← (( do (undefined_bitvector 16) ) : SailM (BitVec 16) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let imm64 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let regs : Int := 1
      let b__0 := size
      bif (BEq.beq b__0 (0b01 : (BitVec 2)))
      then
        (do
          let d : Nat := (UInt0 (Vd ++ D))
          let imm16 ← (( do (VFPExpandImm (imm4H ++ imm4L) 16) ) : SailM (BitVec 16) )
          let imm32 : (BitVec 32) := ((Zeros (n := 16)) ++ imm16)
          (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (do
              let d : Nat := (UInt0 (Vd ++ D))
              let imm32 ← (VFPExpandImm (imm4H ++ imm4L) 32)
              (pure ()))
          else
            (do
              bif (BEq.beq b__0 (0b11 : (BitVec 2)))
              then
                (do
                  let d : Nat := (UInt0 (D ++ Vd))
                  let imm64 ← (VFPExpandImm (imm4H ++ imm4L) 64)
                  let regs : Int := 1
                  (pure ()))
              else (pure ())))
      let regs := regs
      let d := d
      (execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_i_A3enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (op : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (Bool.and
           (Bool.and (BEq.beq op (0b0 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1))))
           (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VORR (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq op (0b1 : (BitVec 1))) (bne cmode (0xE : (BitVec 4))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm32 := imm32
      let single_register : Bool := false
      let advsimd : Bool := true
      let imm64 ← (( do (AdvSIMDExpandImm op cmode ((i ++ imm3) ++ imm4)) ) : SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_i_A4enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (op : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (Bool.and
           (Bool.and (BEq.beq op (0b0 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1))))
           (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VORR (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq op (0b1 : (BitVec 1))) (bne cmode (0xE : (BitVec 4))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm32 := imm32
      let single_register : Bool := false
      let advsimd : Bool := true
      let imm64 ← (( do (AdvSIMDExpandImm op cmode ((i ++ imm3) ++ imm4)) ) : SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_i_A5enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (op : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (Bool.and
           (Bool.and (BEq.beq op (0b0 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1))))
           (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VORR (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq op (0b1 : (BitVec 1))) (bne cmode (0xE : (BitVec 4))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm32 := imm32
      let single_register : Bool := false
      let advsimd : Bool := true
      let imm64 ← (( do (AdvSIMDExpandImm op cmode ((i ++ imm3) ++ imm4)) ) : SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_i_T1enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (op : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (Bool.and
           (Bool.and (BEq.beq op (0b0 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1))))
           (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VORR (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq op (0b1 : (BitVec 1))) (bne cmode (0xE : (BitVec 4))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm32 := imm32
      let single_register : Bool := false
      let advsimd : Bool := true
      let imm64 ← (( do (AdvSIMDExpandImm op cmode ((i ++ imm3) ++ imm4)) ) : SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_i_T2enc_A_txt (D : (BitVec 1)) (imm4H : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (imm4L : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let single_register : Bool := (bne size (0b11 : (BitVec 2)))
      let advsimd : Bool := false
      let imm16 ← (( do (undefined_bitvector 16) ) : SailM (BitVec 16) )
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      let imm64 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let regs : Int := 1
      let b__0 := size
      bif (BEq.beq b__0 (0b01 : (BitVec 2)))
      then
        (do
          let d : Nat := (UInt0 (Vd ++ D))
          let imm16 ← (( do (VFPExpandImm (imm4H ++ imm4L) 16) ) : SailM (BitVec 16) )
          let imm32 : (BitVec 32) := ((Zeros (n := 16)) ++ imm16)
          (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (do
              let d : Nat := (UInt0 (Vd ++ D))
              let imm32 ← (VFPExpandImm (imm4H ++ imm4L) 32)
              (pure ()))
          else
            (do
              bif (BEq.beq b__0 (0b11 : (BitVec 2)))
              then
                (do
                  let d : Nat := (UInt0 (D ++ Vd))
                  let imm64 ← (VFPExpandImm (imm4H ++ imm4L) 64)
                  let regs : Int := 1
                  (pure ()))
              else (pure ())))
      let regs := regs
      let d := d
      (execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_i_T3enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (op : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (Bool.and
           (Bool.and (BEq.beq op (0b0 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1))))
           (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VORR (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq op (0b1 : (BitVec 1))) (bne cmode (0xE : (BitVec 4))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm32 := imm32
      let single_register : Bool := false
      let advsimd : Bool := true
      let imm64 ← (( do (AdvSIMDExpandImm op cmode ((i ++ imm3) ++ imm4)) ) : SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_i_T4enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (op : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (Bool.and
           (Bool.and (BEq.beq op (0b0 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1))))
           (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VORR (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq op (0b1 : (BitVec 1))) (bne cmode (0xE : (BitVec 4))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm32 := imm32
      let single_register : Bool := false
      let advsimd : Bool := true
      let imm64 ← (( do (AdvSIMDExpandImm op cmode ((i ++ imm3) ++ imm4)) ) : SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_i_T5enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (op : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let imm32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
      bif (Bool.and
           (Bool.and (BEq.beq op (0b0 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1))))
           (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VORR (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq op (0b1 : (BitVec 1))) (bne cmode (0xE : (BitVec 4))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm32 := imm32
      let single_register : Bool := false
      let advsimd : Bool := true
      let imm64 ← (( do (AdvSIMDExpandImm op cmode ((i ++ imm3) ++ imm4)) ) : SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMOV_i_Op_A_txt advsimd d imm32 imm64 regs single_register))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, 0
  ≤ m ∧ m ≤ 31 ∧ esize ∈ {0, 8, 16, 24, 32, 40, 48, 56} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMOVL_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        assert (Bool.or ((e *i esize) ≤b (((e *i esize) +i esize) -i 1))
          (Bool.not (Bool.and (e ≥b 0) (((e +i 1) *i esize) ≤b 64)))) "src/instrs32.sail:28727.131-28727.132"
        let result ← (asl_Int (← (Elem_read (← (Din_read m)) e esize)) is_unsigned)
        (Q_set (Int.shiftr d 1)
          (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize)
              (integer_subrange result ((2 *i esize) -i 1) 0))))
        (pure result)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VMOVL_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm3H : (BitVec 3)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq imm3H (0b000 : (BitVec 3)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (Bool.and (bne imm3H (0b001 : (BitVec 3))) (bne imm3H (0b010 : (BitVec 3))))
           (bne imm3H (0b100 : (BitVec 3))))
      then sailThrow ((Error_See "VSHLL"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (8 *i (UInt0 imm3H))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let elements := (fdiv_int 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VMOVL_Op_A_txt d elements esize m is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMOVL_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm3H : (BitVec 3)) (Vd : (BitVec 4)) (L : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq imm3H (0b000 : (BitVec 3)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (Bool.and (bne imm3H (0b001 : (BitVec 3))) (bne imm3H (0b010 : (BitVec 3))))
           (bne imm3H (0b100 : (BitVec 3))))
      then sailThrow ((Error_See "VSHLL"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (8 *i (UInt0 imm3H))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let elements := (fdiv_int 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VMOVL_Op_A_txt d elements esize m is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMOVN_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_e_lower := 0
  let loop_e_upper := (elements -i 1)
  let mut loop_vars := ()
  for e in [loop_e_lower:loop_e_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      (D_set d
        (← (Elem_set (← (D_read d)) e esize
            (Sail.BitVec.extractLsb
              (← (Elem_read (← (Qin_read (Int.shiftl m 1))) e (2 *i esize))) (esize -i 1) 0))))
  (pure loop_vars)

def decode_aarch32_instrs_VMOVN_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VMOVN_Op_A_txt d elements esize m))
  else (pure ())

def decode_aarch32_instrs_VMOVN_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VMOVN_Op_A_txt d elements esize m))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, k_to_arm_register : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch32_instrs_VMOV_h_Op_A_txt (n : Nat) (t : Nat) (to_arm_register : Bool) : SailM Unit := do
  (CheckVFPEnabled true)
  bif to_arm_register
  then (R_set t ((Zeros (n := 16)) ++ (Sail.BitVec.extractLsb (← (S_read n)) 15 0)))
  else (S_set n ((Zeros (n := 16)) ++ (Sail.BitVec.extractLsb (← (R_read t)) 15 0)))

def decode_aarch32_instrs_VMOV_h_A1enc_A_txt (cond : (BitVec 4)) (op : (BitVec 1)) (Vn : (BitVec 4)) (Rt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:28889.29-28889.30"
      bif (Bool.not (HaveFP16Ext ()))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne cond (0xE : (BitVec 4)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let to_arm_register : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let t := (UInt0 Rt)
      let n := (UInt0 (Vn ++ N))
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMOV_h_Op_A_txt n t to_arm_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_h_T1enc_A_txt (op : (BitVec 1)) (Vn : (BitVec 4)) (Rt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (HaveFP16Ext ()))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let to_arm_register : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let t := (UInt0 Rt)
      let n := (UInt0 (Vn ++ N))
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMOV_h_Op_A_txt n t to_arm_register))
  else (pure ())

/-- Type quantifiers: k_advsimd : Bool, d : Nat, m : Nat, regs : Nat, k_single_register : Bool, regs
  = 1 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VMOV_r_Op_A_txt (advsimd : Bool) (d : Nat) (m : Nat) (regs : Nat) (single_register : Bool) : SailM Unit := do
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif single_register
  then (S_set d (← (S_read m)))
  else
    (do
      let loop_r_lower := 0
      let loop_r_upper := (regs -i 1)
      let mut loop_vars := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars
        loop_vars ← do (D_set (d +i r) (← (D_read (m +i r))))
      (pure loop_vars))

def decode_aarch32_instrs_VMOV_r_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:28974.29-28974.30"
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let single_register : Bool := (BEq.beq size (0b10 : (BitVec 2)))
      let advsimd : Bool := false
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let regs : Int := 1
      let (d, m, regs) : (Nat × Nat × Int) :=
        bif single_register
        then
          (let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          (d, m, regs))
        else
          (let d : Nat := (UInt0 (D ++ Vd))
          let m : Nat := (UInt0 (M ++ Vm))
          let regs : Int := 1
          (d, m, regs))
      let regs := regs
      let m := m
      let d := d
      (execute_aarch32_instrs_VMOV_r_Op_A_txt advsimd d m regs single_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_r_T2enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let single_register : Bool := (BEq.beq size (0b10 : (BitVec 2)))
      let advsimd : Bool := false
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let regs : Int := 1
      let (d, m, regs) : (Nat × Nat × Int) :=
        bif single_register
        then
          (let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          (d, m, regs))
        else
          (let d : Nat := (UInt0 (D ++ Vd))
          let m : Nat := (UInt0 (M ++ Vm))
          let regs : Int := 1
          (d, m, regs))
      let regs := regs
      let m := m
      let d := d
      (execute_aarch32_instrs_VMOV_r_Op_A_txt advsimd d m regs single_register))
  else (pure ())

/-- Type quantifiers: k_advsimd : Bool, d__arg : Nat, esize : Nat, index : Int, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧ esize ∈ {8, 16, 32} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMOV_rs_Op_A_txt (advsimd : Bool) (d__arg : Nat) (esize : Nat) (index : Int) (t : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  (D_set d
    (← (Elem_set (← (D_read d)) index esize
        (Sail.BitVec.extractLsb (← (R_read t)) (esize -i 1) 0))))

def decode_aarch32_instrs_VMOV_rs_A1enc_A_txt (cond : (BitVec 4)) (opc1 : (BitVec 2)) (Vd : (BitVec 4)) (Rt : (BitVec 4)) (D : (BitVec 1)) (opc2 : (BitVec 2)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:29062.29-29062.30"
      let advsimd ← (( do (undefined_bool ()) ) : SailM Bool )
      let esize : Int := 8
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let b__0 := (opc1 ++ opc2)
      bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 3) (0b1 : (BitVec 1)))
      then
        (let advsimd : Bool := true
        let esize : Int := 8
        let index : Int := (UInt0 ((BitVec.join1 [(BitVec.access opc1 0)]) ++ opc2))
        (pure ()))
      else
        (do
          bif (Bool.and (BEq.beq (Sail.BitVec.extractLsb b__0 3 3) (0b0 : (BitVec 1)))
               (BEq.beq (Sail.BitVec.extractLsb b__0 0 0) (0b1 : (BitVec 1))))
          then
            (let advsimd : Bool := true
            let esize : Int := 16
            let index : Int :=
              (UInt0
                ((BitVec.join1 [(BitVec.access opc1 0)]) ++ (BitVec.join1 [(BitVec.access opc2 1)])))
            (pure ()))
          else
            (do
              bif (Bool.and (BEq.beq (Sail.BitVec.extractLsb b__0 3 3) (0b0 : (BitVec 1)))
                   (BEq.beq (Sail.BitVec.extractLsb b__0 1 0) (0b00 : (BitVec 2))))
              then
                (let advsimd : Bool := false
                let esize : Int := 32
                let index : Int := (UInt0 (BitVec.join1 [(BitVec.access opc1 0)]))
                (pure ()))
              else sailThrow ((Error_Undefined ()))))
      let advsimd := advsimd
      let index := index
      let esize := esize
      let d := (UInt0 (D ++ Vd))
      let t := (UInt0 Rt)
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      match esize with
      | 8 => (execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d 8 index t)
      | 16 => (execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d 16 index t)
      | 32 => (execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d 32 index t)
      | _ => assert false "src/instrs32.sail:29105.26-29105.27")
  else (pure ())

def decode_aarch32_instrs_VMOV_rs_T1enc_A_txt (opc1 : (BitVec 2)) (Vd : (BitVec 4)) (Rt : (BitVec 4)) (D : (BitVec 1)) (opc2 : (BitVec 2)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let advsimd ← (( do (undefined_bool ()) ) : SailM Bool )
      let esize : Int := 8
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let b__0 := (opc1 ++ opc2)
      bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 3) (0b1 : (BitVec 1)))
      then
        (let advsimd : Bool := true
        let esize : Int := 8
        let index : Int := (UInt0 ((BitVec.join1 [(BitVec.access opc1 0)]) ++ opc2))
        (pure ()))
      else
        (do
          bif (Bool.and (BEq.beq (Sail.BitVec.extractLsb b__0 3 3) (0b0 : (BitVec 1)))
               (BEq.beq (Sail.BitVec.extractLsb b__0 0 0) (0b1 : (BitVec 1))))
          then
            (let advsimd : Bool := true
            let esize : Int := 16
            let index : Int :=
              (UInt0
                ((BitVec.join1 [(BitVec.access opc1 0)]) ++ (BitVec.join1 [(BitVec.access opc2 1)])))
            (pure ()))
          else
            (do
              bif (Bool.and (BEq.beq (Sail.BitVec.extractLsb b__0 3 3) (0b0 : (BitVec 1)))
                   (BEq.beq (Sail.BitVec.extractLsb b__0 1 0) (0b00 : (BitVec 2))))
              then
                (let advsimd : Bool := false
                let esize : Int := 32
                let index : Int := (UInt0 (BitVec.join1 [(BitVec.access opc1 0)]))
                (pure ()))
              else sailThrow ((Error_Undefined ()))))
      let advsimd := advsimd
      let index := index
      let esize := esize
      let d := (UInt0 (D ++ Vd))
      let t := (UInt0 Rt)
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      match esize with
      | 8 => (execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d 8 index t)
      | 16 => (execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d 16 index t)
      | 32 => (execute_aarch32_instrs_VMOV_rs_Op_A_txt advsimd d 32 index t)
      | _ => assert false "src/instrs32.sail:29173.26-29173.27")
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, k_to_arm_register : Bool, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 31 -/
def execute_aarch32_instrs_VMOV_s_Op_A_txt (n : Nat) (t : Nat) (to_arm_register : Bool) : SailM Unit := do
  (CheckVFPEnabled true)
  bif to_arm_register
  then (R_set t (← (S_read n)))
  else (S_set n (← (R_read t)))

def decode_aarch32_instrs_VMOV_s_A1enc_A_txt (cond : (BitVec 4)) (op : (BitVec 1)) (Vn : (BitVec 4)) (Rt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:29211.29-29211.30"
      let to_arm_register : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let t := (UInt0 Rt)
      let n := (UInt0 (Vn ++ N))
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMOV_s_Op_A_txt n t to_arm_register))
  else (pure ())

def decode_aarch32_instrs_VMOV_s_T1enc_A_txt (op : (BitVec 1)) (Vn : (BitVec 4)) (Rt : (BitVec 4)) (N : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let to_arm_register : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let t := (UInt0 Rt)
      let n := (UInt0 (Vn ++ N))
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMOV_s_Op_A_txt n t to_arm_register))
  else (pure ())

/-- Type quantifiers: k_advsimd : Bool, esize : Nat, index : Int, k_is_unsigned : Bool, n : Nat, t :
  Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 31 ∧ esize ∈ {8, 16, 32} -/
def execute_aarch32_instrs_VMOV_sr_Op_A_txt (advsimd : Bool) (esize : Nat) (index : Int) (n : Nat) (t : Nat) (is_unsigned : Bool) : SailM Unit := do
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif is_unsigned
  then (R_set t (zero_extend (← (Elem_read (← (D_read n)) index esize)) 32))
  else (R_set t (sign_extend (← (Elem_read (← (D_read n)) index esize)) 32))

def decode_aarch32_instrs_VMOV_sr_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (opc1 : (BitVec 2)) (Vn : (BitVec 4)) (Rt : (BitVec 4)) (N : (BitVec 1)) (opc2 : (BitVec 2)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:29282.29-29282.30"
      let advsimd ← (( do (undefined_bool ()) ) : SailM Bool )
      let esize : Int := 8
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let b__0 := ((U ++ opc1) ++ opc2)
      bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 3) (0b1 : (BitVec 1)))
      then
        (let advsimd : Bool := true
        let esize : Int := 8
        let index : Int := (UInt0 ((BitVec.join1 [(BitVec.access opc1 0)]) ++ opc2))
        (pure ()))
      else
        (do
          bif (Bool.and (BEq.beq (Sail.BitVec.extractLsb b__0 3 3) (0b0 : (BitVec 1)))
               (BEq.beq (Sail.BitVec.extractLsb b__0 0 0) (0b1 : (BitVec 1))))
          then
            (let advsimd : Bool := true
            let esize : Int := 16
            let index : Int :=
              (UInt0
                ((BitVec.join1 [(BitVec.access opc1 0)]) ++ (BitVec.join1 [(BitVec.access opc2 1)])))
            (pure ()))
          else
            (do
              bif (Bool.and (BEq.beq (Sail.BitVec.extractLsb b__0 4 3) (0b00 : (BitVec 2)))
                   (BEq.beq (Sail.BitVec.extractLsb b__0 1 0) (0b00 : (BitVec 2))))
              then
                (let advsimd : Bool := false
                let esize : Int := 32
                let index : Int := (UInt0 (BitVec.join1 [(BitVec.access opc1 0)]))
                (pure ()))
              else
                (do
                  bif (Bool.and (BEq.beq (Sail.BitVec.extractLsb b__0 4 3) (0b10 : (BitVec 2)))
                       (BEq.beq (Sail.BitVec.extractLsb b__0 1 0) (0b00 : (BitVec 2))))
                  then sailThrow ((Error_Undefined ()))
                  else sailThrow ((Error_Undefined ())))))
      let advsimd := advsimd
      let index := index
      let esize := esize
      let t := (UInt0 Rt)
      let n := (UInt0 (N ++ Vn))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      match esize with
      | 8 => (execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd 8 index n t is_unsigned)
      | 16 => (execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd 16 index n t is_unsigned)
      | 32 => (execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd 32 index n t is_unsigned)
      | _ => assert false "src/instrs32.sail:29329.26-29329.27")
  else (pure ())

def decode_aarch32_instrs_VMOV_sr_T1enc_A_txt (U : (BitVec 1)) (opc1 : (BitVec 2)) (Vn : (BitVec 4)) (Rt : (BitVec 4)) (N : (BitVec 1)) (opc2 : (BitVec 2)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let advsimd ← (( do (undefined_bool ()) ) : SailM Bool )
      let esize : Int := 8
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let b__0 := ((U ++ opc1) ++ opc2)
      bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 3) (0b1 : (BitVec 1)))
      then
        (let advsimd : Bool := true
        let esize : Int := 8
        let index : Int := (UInt0 ((BitVec.join1 [(BitVec.access opc1 0)]) ++ opc2))
        (pure ()))
      else
        (do
          bif (Bool.and (BEq.beq (Sail.BitVec.extractLsb b__0 3 3) (0b0 : (BitVec 1)))
               (BEq.beq (Sail.BitVec.extractLsb b__0 0 0) (0b1 : (BitVec 1))))
          then
            (let advsimd : Bool := true
            let esize : Int := 16
            let index : Int :=
              (UInt0
                ((BitVec.join1 [(BitVec.access opc1 0)]) ++ (BitVec.join1 [(BitVec.access opc2 1)])))
            (pure ()))
          else
            (do
              bif (Bool.and (BEq.beq (Sail.BitVec.extractLsb b__0 4 3) (0b00 : (BitVec 2)))
                   (BEq.beq (Sail.BitVec.extractLsb b__0 1 0) (0b00 : (BitVec 2))))
              then
                (let advsimd : Bool := false
                let esize : Int := 32
                let index : Int := (UInt0 (BitVec.join1 [(BitVec.access opc1 0)]))
                (pure ()))
              else
                (do
                  bif (Bool.and (BEq.beq (Sail.BitVec.extractLsb b__0 4 3) (0b10 : (BitVec 2)))
                       (BEq.beq (Sail.BitVec.extractLsb b__0 1 0) (0b00 : (BitVec 2))))
                  then sailThrow ((Error_Undefined ()))
                  else sailThrow ((Error_Undefined ())))))
      let advsimd := advsimd
      let index := index
      let esize := esize
      let t := (UInt0 Rt)
      let n := (UInt0 (N ++ Vn))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      match esize with
      | 8 => (execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd 8 index n t is_unsigned)
      | 16 => (execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd 16 index n t is_unsigned)
      | 32 => (execute_aarch32_instrs_VMOV_sr_Op_A_txt advsimd 32 index n t is_unsigned)
      | _ => assert false "src/instrs32.sail:29402.26-29402.27")
  else (pure ())

/-- Type quantifiers: m : Nat, t : Nat, t2 : Nat, k_to_arm_registers : Bool, 0 ≤ t2 ∧
  t2 ≤ 15 ∧ 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ m ∧ m ≤ 31 -/
def execute_aarch32_instrs_VMOV_ss_Op_A_txt (m : Nat) (t : Nat) (t2 : Nat) (to_arm_registers : Bool) : SailM Unit := do
  (CheckVFPEnabled true)
  bif to_arm_registers
  then
    (do
      (R_set t (← (S_read m)))
      (R_set t2 (← (S_read (m +i 1)))))
  else
    (do
      (S_set m (← (R_read t)))
      (S_set (m +i 1) (← (R_read t2))))

def decode_aarch32_instrs_VMOV_ss_A1enc_A_txt (cond : (BitVec 4)) (op : (BitVec 1)) (Rt2 : (BitVec 4)) (Rt : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:29443.29-29443.30"
      let to_arm_registers : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let m := (UInt0 (Vm ++ M))
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq t2 15)) (BEq.beq m 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and to_arm_registers (BEq.beq t t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMOV_ss_Op_A_txt m t t2 to_arm_registers))
  else (pure ())

def decode_aarch32_instrs_VMOV_ss_T1enc_A_txt (op : (BitVec 1)) (Rt2 : (BitVec 4)) (Rt : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let to_arm_registers : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let m := (UInt0 (Vm ++ M))
      bif (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq t2 15)) (BEq.beq m 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and to_arm_registers (BEq.beq t t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMOV_ss_Op_A_txt m t t2 to_arm_registers))
  else (pure ())

/-- Type quantifiers: k_advsimd : Bool, d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, regs
  : Int, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMUL_f_Op_A_txt (advsimd : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Int) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif advsimd
  then
    (do
      let loop_r_lower := 0
      let loop_r_upper := (regs -i 1)
      let mut loop_vars := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars
        loop_vars ← do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := ()
          for e in [loop_e_lower:loop_e_upper:1]i do
            let () := loop_vars_1
            loop_vars_1 ← do
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (← (FPMul (← (Elem_read (← (D_read (n +i r))) e esize))
                        (← (Elem_read (← (D_read (m +i r))) e esize))
                        (← (StandardFPSCRValue ())))))))
          (pure loop_vars_1)
      (pure loop_vars))
  else
    (do
      match esize with
      | 16 => (S_set d
          ((Zeros (n := 16)) ++ (← (FPMul (Sail.BitVec.extractLsb (← (S_read n)) 15 0)
                (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ()))))))
      | 32 => (S_set d (← (FPMul (← (S_read n)) (← (S_read m)) (← (FPSCR_read ())))))
      | 64 => (D_set d (← (FPMul (← (D_read n)) (← (D_read m)) (← (FPSCR_read ())))))
      | _ => (pure ()))

def decode_aarch32_instrs_VMUL_f_A1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let advsimd : Bool := true
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMUL_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VMUL_f_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:29579.29-29579.30"
      let floating_point ← (( do (undefined_bool ()) ) : SailM Bool )
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let floating_point := floating_point
      let advsimd : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VMUL_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VMUL_f_T1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let advsimd : Bool := true
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMUL_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VMUL_f_T2enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let floating_point ← (( do (undefined_bool ()) ) : SailM Bool )
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let floating_point := floating_point
      let advsimd : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VMUL_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, k_long_destination
  : Bool, m : Nat, n : Nat, k_polynomial : Bool, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMUL_i_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (long_destination : Bool) (m : Nat) (n : Nat) (polynomial : Bool) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op1val ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2val ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let (op1, op1val, op2, op2val) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op1val, op2, op2val)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op1val, op2, op2val) := loop_vars
      loop_vars ← do
        let (op1, op1val, op2, op2val) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op1val, op2, op2val)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op1val, op2, op2val) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (Din_read (n +i r))) e esize)
              let op1val ← (asl_Int op1 is_unsigned)
              let op2 ← (Elem_read (← (Din_read (m +i r))) e esize)
              let op2val ← (asl_Int op2 is_unsigned)
              let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM
                (BitVec (2 * esize)) )
              let product : (BitVec (2 * esize)) :=
                bif polynomial
                then (PolynomialMult op1 op2)
                else (integer_subrange (op1val *i op2val) ((2 *i esize) -i 1) 0)
              bif long_destination
              then
                (Q_set (Int.shiftr d 1)
                  (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize) product)))
              else
                (D_set (d +i r)
                  (← (Elem_set (← (D_read (d +i r))) e esize
                      (Sail.BitVec.extractLsb product (esize -i 1) 0))))
              (pure (op1, op1val, op2, op2val))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × Int × (BitVec esize) × Int) )
        (pure (op1, op1val, op2, op2val))
    (pure loop_vars) ) : SailM ((BitVec esize) × Int × (BitVec esize) × Int) )
  (pure ())

def decode_aarch32_instrs_VMUL_i_A1enc_A_txt (op : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (Bool.and (BEq.beq op (0b1 : (BitVec 1))) (bne size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := false
      let polynomial : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let long_destination : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMUL_i_Op_A_txt d elements esize long_destination m n polynomial regs
        is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMUL_i_A2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let polynomial : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let long_destination : Bool := true
      let esize : Int := (Int.shiftl 8 (UInt0 size))
      let elements : Int := (ediv_nat 64 esize)
      let (elements, esize) ← (( do
        bif polynomial
        then
          (do
            bif (Bool.or (BEq.beq U (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
            then sailThrow ((Error_Undefined ()))
            else (pure ())
            let (elements, esize) ← (( do
              bif (BEq.beq size (0b10 : (BitVec 2)))
              then
                (do
                  bif (Bool.not (← (HaveBit128PMULLExt ())))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let esize : Int := 64
                  let elements : Int := 1
                  (pure (elements, esize)))
              else (pure (elements, esize)) ) : SailM (Int × Int) )
            (pure (elements, esize)))
        else (pure (elements, esize)) ) : SailM (Int × Int) )
      let esize := esize
      let elements := elements
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs := 1
      (execute_aarch32_instrs_VMUL_i_Op_A_txt d elements esize long_destination m n polynomial regs
        is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMUL_i_T1enc_A_txt (op : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (Bool.and (BEq.beq op (0b1 : (BitVec 1))) (bne size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := false
      let polynomial : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let long_destination : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMUL_i_Op_A_txt d elements esize long_destination m n polynomial regs
        is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMUL_i_T2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let polynomial : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let long_destination : Bool := true
      let esize : Int := (Int.shiftl 8 (UInt0 size))
      let elements : Int := (ediv_nat 64 esize)
      let (elements, esize) ← (( do
        bif polynomial
        then
          (do
            bif (Bool.or (BEq.beq U (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
            then sailThrow ((Error_Undefined ()))
            else (pure ())
            let (elements, esize) ← (( do
              bif (BEq.beq size (0b10 : (BitVec 2)))
              then
                (do
                  bif (← (InITBlock ()))
                  then sailThrow ((Error_Unpredictable ()))
                  else (pure ())
                  bif (Bool.not (← (HaveBit128PMULLExt ())))
                  then sailThrow ((Error_Undefined ()))
                  else (pure ())
                  let esize : Int := 64
                  let elements : Int := 1
                  (pure (elements, esize)))
              else (pure (elements, esize)) ) : SailM (Int × Int) )
            (pure (elements, esize)))
        else (pure (elements, esize)) ) : SailM (Int × Int) )
      let esize := esize
      let elements := elements
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs := 1
      (execute_aarch32_instrs_VMUL_i_Op_A_txt d elements esize long_destination m n polynomial regs
        is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_floating_point : Bool, index :
  Nat, k_is_unsigned : Bool, k_long_destination : Bool, m : Nat, n : Nat, regs : Nat, regs ∈
  {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  index ∈ {0, 1, 2, 3} ∧
  esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMUL_s_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (floating_point : Bool) (index : Nat) (long_destination : Bool) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op1val ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let op2 ← (( do (Elem_read (← (Din_read m)) index esize) ) : SailM (BitVec esize) )
  let op2val ← do (asl_Int op2 is_unsigned)
  let (op1, op1val) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op1val)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op1val) := loop_vars
      loop_vars ← do
        let (op1, op1val) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op1val)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op1val) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (Din_read (n +i r))) e esize)
              let op1val ← (asl_Int op1 is_unsigned)
              bif floating_point
              then
                (D_set (d +i r)
                  (← (Elem_set (← (D_read (d +i r))) e esize
                      (← (FPMul op1 op2 (← (StandardFPSCRValue ())))))))
              else
                (do
                  bif long_destination
                  then
                    (Q_set (Int.shiftr d 1)
                      (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize)
                          (integer_subrange (op1val *i op2val) ((2 *i esize) -i 1) 0))))
                  else
                    (D_set (d +i r)
                      (← (Elem_set (← (D_read (d +i r))) e esize
                          (integer_subrange (op1val *i op2val) (esize -i 1) 0)))))
              (pure (op1, op1val))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × Int) )
        (pure (op1, op1val))
    (pure loop_vars) ) : SailM ((BitVec esize) × Int) )
  (pure ())

def decode_aarch32_instrs_VMUL_s_A1enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (F : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
             (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := false
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let long_destination : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      let esize : Int := 16
      let elements : Int := 2
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                    (BEq.beq index 3))
                  (Bool.and (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                    (Bool.and (Bool.or (BEq.beq elements 2) (BEq.beq elements 4))
                      (Bool.and (0 ≤b d) (d ≤b 31)))))))))) "src/instrs32.sail:30043.175-30043.176"
      (execute_aarch32_instrs_VMUL_s_Op_A_txt d elements esize floating_point index long_destination
        m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMUL_s_A2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let long_destination : Bool := true
      let floating_point : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs := 1
      let esize : Int := 16
      let elements : Int := 2
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                    (BEq.beq index 3))
                  (Bool.and (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                    (Bool.and (Bool.or (BEq.beq elements 2) (BEq.beq elements 4))
                      (Bool.and (0 ≤b d) (d ≤b 31)))))))))) "src/instrs32.sail:30099.175-30099.176"
      (execute_aarch32_instrs_VMUL_s_Op_A_txt d elements esize floating_point index long_destination
        m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMUL_s_T1enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (F : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
           (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
             (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := false
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let long_destination : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      let esize : Int := 16
      let elements : Int := 2
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                    (BEq.beq index 3))
                  (Bool.and (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                    (Bool.and (Bool.or (BEq.beq elements 2) (BEq.beq elements 4))
                      (Bool.and (0 ≤b d) (d ≤b 31)))))))))) "src/instrs32.sail:30160.175-30160.176"
      (execute_aarch32_instrs_VMUL_s_Op_A_txt d elements esize floating_point index long_destination
        m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VMUL_s_T2enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let long_destination : Bool := true
      let floating_point : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs := 1
      let esize : Int := 16
      let elements : Int := 2
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                    (BEq.beq index 3))
                  (Bool.and (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                    (Bool.and (Bool.or (BEq.beq elements 2) (BEq.beq elements 4))
                      (Bool.and (0 ≤b d) (d ≤b 31)))))))))) "src/instrs32.sail:30216.175-30216.176"
      (execute_aarch32_instrs_VMUL_s_Op_A_txt d elements esize floating_point index long_destination
        m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d : Nat, regs : Nat, regs ∈ {1, 2} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VMVN_i_Op_A_txt (d : Nat) (imm64 : (BitVec 64)) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do (D_set (d +i r) (Complement.complement imm64))
  (pure loop_vars)

def decode_aarch32_instrs_VMVN_i_A1enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or
           (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1)))
             (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 1) (0b111 : (BitVec 3))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b1 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VMVN_i_A2enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or
           (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1)))
             (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 1) (0b111 : (BitVec 3))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b1 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VMVN_i_A3enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or
           (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1)))
             (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 1) (0b111 : (BitVec 3))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b1 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VMVN_i_T1enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or
           (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1)))
             (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 1) (0b111 : (BitVec 3))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b1 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VMVN_i_T2enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or
           (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1)))
             (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 1) (0b111 : (BitVec 3))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b1 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VMVN_i_T3enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or
           (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b1 : (BitVec 1)))
             (bne (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 1) (0b111 : (BitVec 3))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b1 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMVN_i_Op_A_txt d imm64 regs))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VMVN_r_Op_A_txt (d : Nat) (m : Nat) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do (D_set (d +i r) (Complement.complement (← (D_read (m +i r)))))
  (pure loop_vars)

def decode_aarch32_instrs_VMVN_r_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMVN_r_Op_A_txt d m regs))
  else (pure ())

def decode_aarch32_instrs_VMVN_r_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VMVN_r_Op_A_txt d m regs))
  else (pure ())

/-- Type quantifiers: k_advsimd : Bool, d__arg : Nat, elements : Int, esize : Nat, k_floating_point
  : Bool, m : Nat, regs : Int, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VNEG_Op_A_txt (advsimd : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (floating_point : Bool) (m : Nat) (regs : Int) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif advsimd
  then
    (do
      let result ← (( do
        let loop_r_lower := 0
        let loop_r_upper := (regs -i 1)
        let mut loop_vars := result
        for r in [loop_r_lower:loop_r_upper:1]i do
          let result := loop_vars
          loop_vars ← do
            let loop_e_lower := 0
            let loop_e_upper := (elements -i 1)
            let mut loop_vars_1 := result
            for e in [loop_e_lower:loop_e_upper:1]i do
              let result := loop_vars_1
              loop_vars_1 ← do
                bif floating_point
                then
                  (do
                    assert (Bool.or (Bool.or (BEq.beq esize 16) (BEq.beq esize 32))
                      (BEq.beq esize 64)) "src/instrs32.sail:30507.61-30507.62"
                    (D_set (d +i r)
                      (← (Elem_set (← (D_read (d +i r))) e esize
                          (← (FPNeg (← (Elem_read (← (D_read (m +i r))) e esize)))))))
                    (pure result))
                else
                  (do
                    let result ←
                      (pure (Neg.neg (sint (← (Elem_read (← (D_read (m +i r))) e esize)))))
                    (D_set (d +i r)
                      (← (Elem_set (← (D_read (d +i r))) e esize
                          (integer_subrange result (esize -i 1) 0))))
                    (pure result))
            (pure loop_vars_1)
        (pure loop_vars) ) : SailM Int )
      (pure ()))
  else
    (do
      match esize with
      | 16 => (S_set d
          ((Zeros (n := 16)) ++ (← (FPNeg (Sail.BitVec.extractLsb (← (S_read m)) 15 0)))))
      | 32 => (S_set d (← (FPNeg (← (S_read m)))))
      | 64 => (D_set d (← (FPNeg (← (D_read m)))))
      | _ => (pure ()))

def decode_aarch32_instrs_VNEG_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let advsimd : Bool := true
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VNEG_Op_A_txt advsimd d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VNEG_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:30572.29-30572.30"
      let floating_point ← (( do (undefined_bool ()) ) : SailM Bool )
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let floating_point := floating_point
      let advsimd : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VNEG_Op_A_txt advsimd d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VNEG_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq F (0b1 : (BitVec 1)))
           (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
             (BEq.beq size (0b00 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (Bool.and (BEq.beq F (0b1 : (BitVec 1))) (BEq.beq size (0b01 : (BitVec 2))))
           (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let advsimd : Bool := true
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VNEG_Op_A_txt advsimd d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VNEG_T2enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let floating_point ← (( do (undefined_bool ()) ) : SailM Bool )
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let floating_point := floating_point
      let advsimd : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VNEG_Op_A_txt advsimd d elements esize floating_point m regs))
  else (pure ())

/-- Type quantifiers: d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VNMLA_Op_A_txt (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (vtype : VFPNegMul) : SailM Unit := do
  let product16 ← (( do (undefined_bitvector 16) ) : SailM (BitVec 16) )
  let product32 ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let product64 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  (CheckVFPEnabled true)
  match esize with
  | 16 => (do
      let product16 ← (( do
        (FPMul (Sail.BitVec.extractLsb (← (S_read n)) 15 0)
          (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ()))) ) : SailM
        (BitVec 16) )
      match vtype with
      | VFPNegMul_VNMLA => (S_set d
          ((Zeros (n := 16)) ++ (← (FPAdd
                (← (FPNeg (Sail.BitVec.extractLsb (← (S_read d)) 15 0))) (← (FPNeg product16))
                (← (FPSCR_read ()))))))
      | VFPNegMul_VNMLS => (S_set d
          ((Zeros (n := 16)) ++ (← (FPAdd
                (← (FPNeg (Sail.BitVec.extractLsb (← (S_read d)) 15 0))) product16
                (← (FPSCR_read ()))))))
      | VFPNegMul_VNMUL => (S_set d ((Zeros (n := 16)) ++ (← (FPNeg product16)))))
  | 32 => (do
      let product32 ← (( do (FPMul (← (S_read n)) (← (S_read m)) (← (FPSCR_read ()))) ) :
        SailM (BitVec 32) )
      match vtype with
      | VFPNegMul_VNMLA => (S_set d
          (← (FPAdd (← (FPNeg (← (S_read d)))) (← (FPNeg product32)) (← (FPSCR_read ())))))
      | VFPNegMul_VNMLS => (S_set d
          (← (FPAdd (← (FPNeg (← (S_read d)))) product32 (← (FPSCR_read ())))))
      | VFPNegMul_VNMUL => (S_set d (← (FPNeg product32))))
  | 64 => (do
      let product64 ← (( do (FPMul (← (D_read n)) (← (D_read m)) (← (FPSCR_read ()))) ) :
        SailM (BitVec 64) )
      match vtype with
      | VFPNegMul_VNMLA => (D_set d
          (← (FPAdd (← (FPNeg (← (D_read d)))) (← (FPNeg product64)) (← (FPSCR_read ())))))
      | VFPNegMul_VNMLS => (D_set d
          (← (FPAdd (← (FPNeg (← (D_read d)))) product64 (← (FPSCR_read ())))))
      | VFPNegMul_VNMUL => (D_set d (← (FPNeg product64))))
  | _ => (pure ())

def decode_aarch32_instrs_VNMLA_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:30788.29-30788.30"
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let vtype : VFPNegMul :=
        bif (BEq.beq op (0b1 : (BitVec 1)))
        then VFPNegMul_VNMLA
        else VFPNegMul_VNMLS
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VNMLA_Op_A_txt d esize m n vtype))
  else (pure ())

def decode_aarch32_instrs_VNMLA_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:30852.29-30852.30"
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let vtype : VFPNegMul := VFPNegMul_VNMUL
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VNMLA_Op_A_txt d esize m n vtype))
  else (pure ())

def decode_aarch32_instrs_VNMLA_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let vtype : VFPNegMul :=
        bif (BEq.beq op (0b1 : (BitVec 1)))
        then VFPNegMul_VNMLA
        else VFPNegMul_VNMLS
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VNMLA_Op_A_txt d esize m n vtype))
  else (pure ())

def decode_aarch32_instrs_VNMLA_T2enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let vtype : VFPNegMul := VFPNegMul_VNMUL
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VNMLA_Op_A_txt d esize m n vtype))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VORN_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      (D_set (d +i r) ((← (D_read (n +i r))) ||| (Complement.complement (← (D_read (m +i r))))))
  (pure loop_vars)

def decode_aarch32_instrs_VORN_r_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VORN_r_Op_A_txt d m n regs))
  else (pure ())

def decode_aarch32_instrs_VORN_r_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VORN_r_Op_A_txt d m n regs))
  else (pure ())

/-- Type quantifiers: d : Nat, regs : Nat, regs ∈ {1, 2} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VORR_i_Op_A_txt (d : Nat) (imm64 : (BitVec 64)) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do (D_set (d +i r) ((← (D_read (d +i r))) ||| imm64))
  (pure loop_vars)

def decode_aarch32_instrs_VORR_i_A1enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b0 : (BitVec 1)))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VMOV (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b0 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VORR_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VORR_i_A2enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b0 : (BitVec 1)))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VMOV (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b0 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VORR_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VORR_i_T1enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b0 : (BitVec 1)))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VMOV (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b0 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VORR_i_Op_A_txt d imm64 regs))
  else (pure ())

def decode_aarch32_instrs_VORR_i_T2enc_A_txt (i : (BitVec 1)) (D : (BitVec 1)) (imm3 : (BitVec 3)) (Vd : (BitVec 4)) (cmode : (BitVec 4)) (Q : (BitVec 1)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access cmode 0)]) (0b0 : (BitVec 1)))
           (BEq.beq (Sail.BitVec.extractLsb cmode 3 2) (0b11 : (BitVec 2))))
      then sailThrow ((Error_See "VMOV (immediate)"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let imm64 ← (( do (AdvSIMDExpandImm (0b0 : (BitVec 1)) cmode ((i ++ imm3) ++ imm4)) ) :
        SailM (BitVec 64) )
      let d := (UInt0 (D ++ Vd))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VORR_i_Op_A_txt d imm64 regs))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VORR_r_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do (D_set (d +i r) ((← (D_read (n +i r))) ||| (← (D_read (m +i r)))))
  (pure loop_vars)

def decode_aarch32_instrs_VORR_r_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VORR_r_Op_A_txt d m n regs))
  else (pure ())

def decode_aarch32_instrs_VORR_r_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VORR_r_Op_A_txt d m n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VPADAL_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let h := (fdiv_int elements 2)
  let (op1, op2, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2, result) := loop_vars
      loop_vars ← do
        let (op1, op2, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (h -i 1)
          let mut loop_vars_1 := (op1, op2, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2, result) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (m +i r))) (2 *i e) esize)
              let op2 ← (Elem_read (← (D_read (m +i r))) ((2 *i e) +i 1) esize)
              let result ←
                (pure ((← (asl_Int op1 is_unsigned)) +i (← (asl_Int op2 is_unsigned))))
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e (2 *i esize)
                    (BitVec.addInt (← (Elem_read (← (D_read (d +i r))) e (2 *i esize))) result))))
              (pure (op1, op2, result))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize) × Int) )
        (pure (op1, op2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × Int) )
  (pure ())

def decode_aarch32_instrs_VPADAL_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VPADAL_Op_A_txt d elements esize m regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VPADAL_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VPADAL_Op_A_txt d elements esize m regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d : Nat, elements : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VPADD_f_Op_A_txt (d : Nat) (elements : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let dest ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let h := (ediv_nat elements 2)
  let dest ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (h -i 1)
    let mut loop_vars := dest
    for e in [loop_e_lower:loop_e_upper:1]i do
      let dest := loop_vars
      loop_vars ← do
        let dest ←
          (Elem_set dest e esize
            (← (FPAdd (← (Elem_read (← (D_read n)) (2 *i e) esize))
                (← (Elem_read (← (D_read n)) ((2 *i e) +i 1) esize))
                (← (StandardFPSCRValue ())))))
        (Elem_set dest (e +i h) esize
          (← (FPAdd (← (Elem_read (← (D_read m)) (2 *i e) esize))
              (← (Elem_read (← (D_read m)) ((2 *i e) +i 1) esize)) (← (StandardFPSCRValue ())))))
    (pure loop_vars) ) : SailM (BitVec 64) )
  (D_set d dest)

def decode_aarch32_instrs_VPADD_f_A1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VPADD_f_Op_A_txt d elements esize m n))
  else (pure ())

def decode_aarch32_instrs_VPADD_f_T1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VPADD_f_Op_A_txt d elements esize m n))
  else (pure ())

/-- Type quantifiers: d : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VPADD_i_Op_A_txt (d : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let dest ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let h := (fdiv_int elements 2)
  let dest ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (h -i 1)
    let mut loop_vars := dest
    for e in [loop_e_lower:loop_e_upper:1]i do
      let dest := loop_vars
      loop_vars ← do
        let dest ←
          (Elem_set dest e esize
            ((← (Elem_read (← (D_read n)) (2 *i e) esize)) + (← (Elem_read (← (D_read n))
                  ((2 *i e) +i 1) esize))))
        (Elem_set dest (e +i h) esize
          ((← (Elem_read (← (D_read m)) (2 *i e) esize)) + (← (Elem_read (← (D_read m))
                ((2 *i e) +i 1) esize))))
    (pure loop_vars) ) : SailM (BitVec 64) )
  (D_set d dest)

def decode_aarch32_instrs_VPADD_i_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2))) (BEq.beq Q (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VPADD_i_Op_A_txt d elements esize m n))
  else (pure ())

def decode_aarch32_instrs_VPADD_i_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2))) (BEq.beq Q (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VPADD_i_Op_A_txt d elements esize m n))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VPADDL_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let h := (fdiv_int elements 2)
  let (op1, op2, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2, result) := loop_vars
      loop_vars ← do
        let (op1, op2, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (h -i 1)
          let mut loop_vars_1 := (op1, op2, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2, result) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (m +i r))) (2 *i e) esize)
              let op2 ← (Elem_read (← (D_read (m +i r))) ((2 *i e) +i 1) esize)
              let result ←
                (pure ((← (asl_Int op1 is_unsigned)) +i (← (asl_Int op2 is_unsigned))))
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e (2 *i esize)
                    (integer_subrange result ((2 *i esize) -i 1) 0))))
              (pure (op1, op2, result))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize) × Int) )
        (pure (op1, op2, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize) × Int) )
  (pure ())

def decode_aarch32_instrs_VPADDL_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VPADDL_Op_A_txt d elements esize m regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VPADDL_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VPADDL_Op_A_txt d elements esize m regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d : Nat, elements : Nat, esize : Nat, m : Nat, k_maximum : Bool, n : Nat, 0
  ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VPMAX_f_Op_A_txt (d : Nat) (elements : Nat) (esize : Nat) (m : Nat) (maximum : Bool) (n : Nat) : SailM Unit := do
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let dest ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let h := (ediv_nat elements 2)
  let (dest, op1, op2) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (h -i 1)
    let mut loop_vars := (dest, op1, op2)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (dest, op1, op2) := loop_vars
      loop_vars ← do
        let op1 ← (Elem_read (← (D_read n)) (2 *i e) esize)
        let op2 ← (Elem_read (← (D_read n)) ((2 *i e) +i 1) esize)
        let dest ←
          (Elem_set dest e esize
            (← do
              bif maximum
              then (FPMax op1 op2 (← (StandardFPSCRValue ())))
              else (FPMin op1 op2 (← (StandardFPSCRValue ())))))
        let op1 ← (Elem_read (← (D_read m)) (2 *i e) esize)
        let op2 ← (Elem_read (← (D_read m)) ((2 *i e) +i 1) esize)
        let dest ←
          (Elem_set dest (e +i h) esize
            (← do
              bif maximum
              then (FPMax op1 op2 (← (StandardFPSCRValue ())))
              else (FPMin op1 op2 (← (StandardFPSCRValue ())))))
        (pure (dest, op1, op2))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec esize) × (BitVec esize)) )
  (D_set d dest)

def decode_aarch32_instrs_VPMAX_f_A1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VPMAX_f_Op_A_txt d elements esize m maximum n))
  else (pure ())

def decode_aarch32_instrs_VPMAX_f_T1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VPMAX_f_Op_A_txt d elements esize m maximum n))
  else (pure ())

/-- Type quantifiers: d : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, k_maximum
  : Bool, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VPMAX_i_Op_A_txt (d : Nat) (elements : Int) (esize : Nat) (m : Nat) (maximum : Bool) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let dest ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let h := (fdiv_int elements 2)
  let (dest, op1, op2, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (h -i 1)
    let mut loop_vars := (dest, op1, op2, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (dest, op1, op2, result) := loop_vars
      loop_vars ← do
        let op1 ← (asl_Int (← (Elem_read (← (D_read n)) (2 *i e) esize)) is_unsigned)
        let op2 ← (asl_Int (← (Elem_read (← (D_read n)) ((2 *i e) +i 1) esize)) is_unsigned)
        let result : Int :=
          bif maximum
          then (Max.max op1 op2)
          else (Min.min op1 op2)
        let dest ← (Elem_set dest e esize (integer_subrange result (esize -i 1) 0))
        let op1 ← (asl_Int (← (Elem_read (← (D_read m)) (2 *i e) esize)) is_unsigned)
        let op2 ← (asl_Int (← (Elem_read (← (D_read m)) ((2 *i e) +i 1) esize)) is_unsigned)
        let result : Int :=
          bif maximum
          then (Max.max op1 op2)
          else (Min.min op1 op2)
        let dest ← (Elem_set dest (e +i h) esize (integer_subrange result (esize -i 1) 0))
        (pure (dest, op1, op2, result))
    (pure loop_vars) ) : SailM ((BitVec 64) × Int × Int × Int) )
  (D_set d dest)

def decode_aarch32_instrs_VPMAX_i_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (op : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VPMAX_i_Op_A_txt d elements esize m maximum n is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VPMAX_i_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (op : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VPMAX_i_Op_A_txt d elements esize m maximum n is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, regs : Nat, regs ∈
  {1, 2} ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQABS_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let result ←
              (pure (Int.natAbs (sint (← (Elem_read (← (D_read (m +i r))) e esize)))))
            let sat ← (( do (undefined_bool ()) ) : SailM Bool )
            let (__tup_0, __tup_1) ← do (SignedSatQ result esize)
            (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize __tup_0)))
            let sat : Bool := __tup_1
            (pure ())
            bif sat
            then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
            else (pure ())
            (pure result)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VQABS_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQABS_Op_A_txt d elements esize m regs))
  else (pure ())

def decode_aarch32_instrs_VQABS_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQABS_Op_A_txt d elements esize m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQADD_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let sum ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let sum ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := sum
    for r in [loop_r_lower:loop_r_upper:1]i do
      let sum := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := sum
        for e in [loop_e_lower:loop_e_upper:1]i do
          let sum := loop_vars_1
          loop_vars_1 ← do
            let sum ←
              (pure ((← (asl_Int (← (Elem_read (← (D_read (n +i r))) e esize)) is_unsigned)) +i (← (asl_Int
                      (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned))))
            let sat ← (( do (undefined_bool ()) ) : SailM Bool )
            let (__tup_0, __tup_1) ← do (SatQ sum esize is_unsigned)
            (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize __tup_0)))
            let sat : Bool := __tup_1
            (pure ())
            bif sat
            then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
            else (pure ())
            (pure sum)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VQADD_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQADD_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VQADD_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQADD_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: k_add : Bool, d__arg : Nat, elements : Int, esize : Nat, index : Int, m : Nat, n
  : Nat, k_scalar_form : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQDMLAL_Op_A_txt (add : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (index : Int) (m : Nat) (n : Nat) (scalar_form : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let sat1 ← (( do (undefined_bool ()) ) : SailM Bool )
  (CheckAdvSIMDEnabled ())
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do
    bif scalar_form
    then
      (do
        (pure (sint (← (Elem_read (← (Din_read m)) index esize)))))
    else (pure op2) ) : SailM Int )
  let (op1, op2, product, sat1) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (op1, op2, product, sat1)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (op1, op2, product, sat1) := loop_vars
      loop_vars ← do
        let op2 ← (( do
          bif (Bool.not scalar_form)
          then
            (do
              (pure (sint (← (Elem_read (← (Din_read m)) e esize)))))
          else (pure op2) ) : SailM Int )
        let op1 ← (pure (sint (← (Elem_read (← (Din_read n)) e esize))))
        let (tup__0, tup__1) ← do (SignedSatQ ((2 *i op1) *i op2) (2 *i esize))
        let product : (BitVec (2 * esize)) := tup__0
        let sat1 : Bool := tup__1
        (pure ())
        let result ← (( do (undefined_int ()) ) : SailM Int )
        let result ← (( do
          bif add
          then
            (do
              (pure ((sint (← (Elem_read (← (Qin_read (Int.shiftr d 1))) e (2 *i esize)))) +i (sint
                    product))))
          else
            (do
              (pure ((sint (← (Elem_read (← (Qin_read (Int.shiftr d 1))) e (2 *i esize)))) -i (sint
                    product)))) ) : SailM Int )
        let result := result
        let sat2 ← (( do (undefined_bool ()) ) : SailM Bool )
        let (__tup_0, __tup_1) ← do (SignedSatQ result (2 *i esize))
        (Q_set (Int.shiftr d 1)
          (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize) __tup_0)))
        let sat2 : Bool := __tup_1
        (pure ())
        bif (Bool.or sat1 sat2)
        then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
        else (pure ())
        (pure (op1, op2, product, sat1))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec (2 * esize)) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQDMLAL_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let index ← (( do (undefined_int ()) ) : SailM Int )
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index := index
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let scalar_form : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      (execute_aarch32_instrs_VQDMLAL_Op_A_txt add d elements esize index m n scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMLAL_A2enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let scalar_form : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let esize : Int := 8
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 31)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 31)
              (Bool.and
                (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                  (BEq.beq esize 64)) (Bool.and (0 ≤b d) (d ≤b 31))))))) "src/instrs32.sail:32155.117-32155.118"
      (execute_aarch32_instrs_VQDMLAL_Op_A_txt add d elements esize index m n scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMLAL_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let index ← (( do (undefined_int ()) ) : SailM Int )
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index := index
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let scalar_form : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      (execute_aarch32_instrs_VQDMLAL_Op_A_txt add d elements esize index m n scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMLAL_T2enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let scalar_form : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let esize : Int := 8
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 31)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 31)
              (Bool.and
                (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                  (BEq.beq esize 64)) (Bool.and (0 ≤b d) (d ≤b 31))))))) "src/instrs32.sail:32245.117-32245.118"
      (execute_aarch32_instrs_VQDMLAL_Op_A_txt add d elements esize index m n scalar_form))
  else (pure ())

/-- Type quantifiers: k_add : Bool, d__arg : Nat, elements : Int, esize : Nat, index : Int, m : Nat, n
  : Nat, k_scalar_form : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQDMLSL_Op_A_txt (add : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (index : Int) (m : Nat) (n : Nat) (scalar_form : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let sat1 ← (( do (undefined_bool ()) ) : SailM Bool )
  (CheckAdvSIMDEnabled ())
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do
    bif scalar_form
    then
      (do
        (pure (sint (← (Elem_read (← (Din_read m)) index esize)))))
    else (pure op2) ) : SailM Int )
  let (op1, op2, product, sat1) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (op1, op2, product, sat1)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (op1, op2, product, sat1) := loop_vars
      loop_vars ← do
        let op2 ← (( do
          bif (Bool.not scalar_form)
          then
            (do
              (pure (sint (← (Elem_read (← (Din_read m)) e esize)))))
          else (pure op2) ) : SailM Int )
        let op1 ← (pure (sint (← (Elem_read (← (Din_read n)) e esize))))
        let (tup__0, tup__1) ← do (SignedSatQ ((2 *i op1) *i op2) (2 *i esize))
        let product : (BitVec (2 * esize)) := tup__0
        let sat1 : Bool := tup__1
        (pure ())
        let result ← (( do (undefined_int ()) ) : SailM Int )
        let result ← (( do
          bif add
          then
            (do
              (pure ((sint (← (Elem_read (← (Qin_read (Int.shiftr d 1))) e (2 *i esize)))) +i (sint
                    product))))
          else
            (do
              (pure ((sint (← (Elem_read (← (Qin_read (Int.shiftr d 1))) e (2 *i esize)))) -i (sint
                    product)))) ) : SailM Int )
        let result := result
        let sat2 ← (( do (undefined_bool ()) ) : SailM Bool )
        let (__tup_0, __tup_1) ← do (SignedSatQ result (2 *i esize))
        (Q_set (Int.shiftr d 1)
          (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize) __tup_0)))
        let sat2 : Bool := __tup_1
        (pure ())
        bif (Bool.or sat1 sat2)
        then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
        else (pure ())
        (pure (op1, op2, product, sat1))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec (2 * esize)) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQDMLSL_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let index ← (( do (undefined_int ()) ) : SailM Int )
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index := index
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let scalar_form : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      (execute_aarch32_instrs_VQDMLSL_Op_A_txt add d elements esize index m n scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMLSL_A2enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let scalar_form : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let esize : Int := 8
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 31)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 31)
              (Bool.and
                (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                  (BEq.beq esize 64)) (Bool.and (0 ≤b d) (d ≤b 31))))))) "src/instrs32.sail:32377.117-32377.118"
      (execute_aarch32_instrs_VQDMLSL_Op_A_txt add d elements esize index m n scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMLSL_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let index ← (( do (undefined_int ()) ) : SailM Int )
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index := index
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let scalar_form : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      (execute_aarch32_instrs_VQDMLSL_Op_A_txt add d elements esize index m n scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMLSL_T2enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let add : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let scalar_form : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let esize : Int := 8
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 31)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 31)
              (Bool.and
                (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                  (BEq.beq esize 64)) (Bool.and (0 ≤b d) (d ≤b 31))))))) "src/instrs32.sail:32467.117-32467.118"
      (execute_aarch32_instrs_VQDMLSL_Op_A_txt add d elements esize index m n scalar_form))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, index : Int, m : Nat, n : Nat, regs
  : Nat, k_scalar_form : Bool, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQDMULH_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (index : Int) (m : Nat) (n : Nat) (regs : Nat) (scalar_form : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  (CheckAdvSIMDEnabled ())
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do
    bif scalar_form
    then
      (do
        (pure (sint (← (Elem_read (← (D_read m)) index esize)))))
    else (pure op2) ) : SailM Int )
  let (op1, op2, result, sat) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2, result, sat)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2, result, sat) := loop_vars
      loop_vars ← do
        let (op1, op2, result, sat) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2, result, sat)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2, result, sat) := loop_vars_1
            loop_vars_1 ← do
              let op2 ← (( do
                bif (Bool.not scalar_form)
                then
                  (do
                    (pure (sint (← (Elem_read (← (D_read (m +i r))) e esize)))))
                else (pure op2) ) : SailM Int )
              let op1 ← (pure (sint (← (Elem_read (← (D_read (n +i r))) e esize))))
              let (tup__0, tup__1) ← do (SignedSatQ (Int.shiftr ((2 *i op1) *i op2) esize) esize)
              let result : (BitVec esize) := tup__0
              let sat : Bool := tup__1
              (pure ())
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              bif sat
              then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
              else (pure ())
              (pure (op1, op2, result, sat))
          (pure loop_vars_1) ) : SailM (Int × Int × (BitVec esize) × Bool) )
        (pure (op1, op2, result, sat))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec esize) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQDMULH_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let index ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index := index
      let scalar_form : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQDMULH_Op_A_txt d elements esize index m n regs scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMULH_A2enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let scalar_form : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      let esize : Int := 8
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64)) (Bool.and (0 ≤b d) (d ≤b 31)))))))) "src/instrs32.sail:32590.135-32590.136"
      (execute_aarch32_instrs_VQDMULH_Op_A_txt d elements esize index m n regs scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMULH_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let index ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index := index
      let scalar_form : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQDMULH_Op_A_txt d elements esize index m n regs scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMULH_T2enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let scalar_form : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      let esize : Int := 8
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64)) (Bool.and (0 ≤b d) (d ≤b 31)))))))) "src/instrs32.sail:32683.135-32683.136"
      (execute_aarch32_instrs_VQDMULH_Op_A_txt d elements esize index m n regs scalar_form))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, index : Int, m : Nat, n : Nat, k_scalar_form
  : Bool, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQDMULL_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (index : Int) (m : Nat) (n : Nat) (scalar_form : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let product ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  (CheckAdvSIMDEnabled ())
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do
    bif scalar_form
    then
      (do
        (pure (sint (← (Elem_read (← (Din_read m)) index esize)))))
    else (pure op2) ) : SailM Int )
  let (op1, op2, product, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (op1, op2, product, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (op1, op2, product, sat) := loop_vars
      loop_vars ← do
        let op2 ← (( do
          bif (Bool.not scalar_form)
          then
            (do
              (pure (sint (← (Elem_read (← (Din_read m)) e esize)))))
          else (pure op2) ) : SailM Int )
        let op1 ← (pure (sint (← (Elem_read (← (Din_read n)) e esize))))
        let (tup__0, tup__1) ← do (SignedSatQ ((2 *i op1) *i op2) (2 *i esize))
        let product : (BitVec (2 * esize)) := tup__0
        let sat : Bool := tup__1
        (pure ())
        (Q_set (Int.shiftr d 1)
          (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize) product)))
        bif sat
        then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
        else (pure ())
        (pure (op1, op2, product, sat))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec (2 * esize)) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQDMULL_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let index ← (( do (undefined_int ()) ) : SailM Int )
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index := index
      let scalar_form : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      (execute_aarch32_instrs_VQDMULL_Op_A_txt d elements esize index m n scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMULL_A2enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let scalar_form : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let esize : Int := 8
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 31)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 31)
              (Bool.and
                (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                  (BEq.beq esize 64)) (Bool.and (0 ≤b d) (d ≤b 31))))))) "src/instrs32.sail:32798.117-32798.118"
      (execute_aarch32_instrs_VQDMULL_Op_A_txt d elements esize index m n scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMULL_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let index ← (( do (undefined_int ()) ) : SailM Int )
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index := index
      let scalar_form : Bool := false
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      (execute_aarch32_instrs_VQDMULL_Op_A_txt d elements esize index m n scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQDMULL_T2enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let scalar_form : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let esize : Int := 8
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 31)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 31)
              (Bool.and
                (Bool.or (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                  (BEq.beq esize 64)) (Bool.and (0 ≤b d) (d ≤b 31))))))) "src/instrs32.sail:32884.117-32884.118"
      (execute_aarch32_instrs_VQDMULL_Op_A_txt d elements esize index m n scalar_form))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, k_dest_unsigned : Bool, elements : Int, esize : Nat, m : Nat, k_src_unsigned
  : Bool, 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQMOVN_Op_A_txt (d__arg : Nat) (dest_unsigned : Bool) (elements : Int) (esize : Nat) (m : Nat) (src_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let operand ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let operand ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := operand
    for e in [loop_e_lower:loop_e_upper:1]i do
      let operand := loop_vars
      loop_vars ← do
        let operand ←
          (asl_Int (← (Elem_read (← (Qin_read (Int.shiftl m 1))) e (2 *i esize))) src_unsigned)
        let sat ← (( do (undefined_bool ()) ) : SailM Bool )
        let (__tup_0, __tup_1) ← do (SatQ operand esize dest_unsigned)
        (D_set d (← (Elem_set (← (D_read d)) e esize __tup_0)))
        let sat : Bool := __tup_1
        (pure ())
        bif sat
        then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
        else (pure ())
        (pure operand)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VQMOVN_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq op (0b00 : (BitVec 2)))
      then sailThrow ((Error_See "VMOVN"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let src_unsigned : Bool := (BEq.beq op (0b11 : (BitVec 2)))
      let dest_unsigned : Bool := (BEq.beq (BitVec.join1 [(BitVec.access op 0)]) (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VQMOVN_Op_A_txt d dest_unsigned elements esize m src_unsigned))
  else (pure ())

def decode_aarch32_instrs_VQMOVN_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq op (0b00 : (BitVec 2)))
      then sailThrow ((Error_See "VMOVN"))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let src_unsigned : Bool := (BEq.beq op (0b11 : (BitVec 2)))
      let dest_unsigned : Bool := (BEq.beq (BitVec.join1 [(BitVec.access op 0)]) (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VQMOVN_Op_A_txt d dest_unsigned elements esize m src_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, regs : Nat, regs ∈
  {1, 2} ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQNEG_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let result ← (pure (Neg.neg (sint (← (Elem_read (← (D_read (m +i r))) e esize)))))
            let sat ← (( do (undefined_bool ()) ) : SailM Bool )
            let (__tup_0, __tup_1) ← do (SignedSatQ result esize)
            (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize __tup_0)))
            let sat : Bool := __tup_1
            (pure ())
            bif sat
            then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
            else (pure ())
            (pure result)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VQNEG_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQNEG_Op_A_txt d elements esize m regs))
  else (pure ())

def decode_aarch32_instrs_VQNEG_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQNEG_Op_A_txt d elements esize m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, index : Int, m : Nat, n : Nat, regs
  : Nat, k_scalar_form : Bool, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQRDMULH_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (index : Int) (m : Nat) (n : Nat) (regs : Nat) (scalar_form : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  (CheckAdvSIMDEnabled ())
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let round : Bool := true
  let op2 ← (( do
    bif scalar_form
    then
      (do
        (pure (sint (← (Elem_read (← (D_read m)) index esize)))))
    else (pure op2) ) : SailM Int )
  let (op1, op2, result, sat) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2, result, sat)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2, result, sat) := loop_vars
      loop_vars ← do
        let (op1, op2, result, sat) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2, result, sat)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2, result, sat) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (pure (sint (← (Elem_read (← (D_read (n +i r))) e esize))))
              let op2 ← (( do
                bif (Bool.not scalar_form)
                then
                  (do
                    (pure (sint (← (Elem_read (← (D_read (m +i r))) e esize)))))
                else (pure op2) ) : SailM Int )
              let rdmulh ← do (RShr ((2 *i op1) *i op2) esize round)
              let (tup__0, tup__1) ← do (SignedSatQ rdmulh esize)
              let result : (BitVec esize) := tup__0
              let sat : Bool := tup__1
              (pure ())
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              bif sat
              then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
              else (pure ())
              (pure (op1, op2, result, sat))
          (pure loop_vars_1) ) : SailM (Int × Int × (BitVec esize) × Bool) )
        (pure (op1, op2, result, sat))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec esize) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQRDMULH_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let index ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index := index
      let scalar_form : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQRDMULH_Op_A_txt d elements esize index m n regs scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQRDMULH_A2enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let scalar_form : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      let esize : Int := 8
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64)) (Bool.and (0 ≤b d) (d ≤b 31)))))))) "src/instrs32.sail:33186.135-33186.136"
      (execute_aarch32_instrs_VQRDMULH_Op_A_txt d elements esize index m n regs scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQRDMULH_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let index ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let index := index
      let scalar_form : Bool := false
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQRDMULH_Op_A_txt d elements esize index m n regs scalar_form))
  else (pure ())

def decode_aarch32_instrs_VQRDMULH_T2enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let scalar_form : Bool := true
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      let esize : Int := 8
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let m ← (( do (undefined_int ()) ) : SailM Int )
      let index ← (( do (undefined_int ()) ) : SailM Int )
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
          let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let (elements, esize, index, m) : (Int × Int × Int × Int) :=
        bif (BEq.beq size (0b10 : (BitVec 2)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          let m : Int := (UInt0 Vm)
          let index : Int := (UInt0 M)
          (elements, esize, index, m))
        else (elements, esize, index, m)
      let m := m
      let index := index
      let esize := esize
      let elements := elements
      assert (Bool.and (Bool.or (BEq.beq regs 1) (BEq.beq regs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 31)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 31)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq esize 8) (BEq.beq esize 16)) (BEq.beq esize 32))
                    (BEq.beq esize 64)) (Bool.and (0 ≤b d) (d ≤b 31)))))))) "src/instrs32.sail:33279.135-33279.136"
      (execute_aarch32_instrs_VQRDMULH_Op_A_txt d elements esize index m n regs scalar_form))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, index : Int, m : Nat, n : Nat, regs
  : Nat, k_scalar_form : Bool, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQRDMLAH_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (index : Int) (m : Nat) (n : Nat) (regs : Nat) (scalar_form : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let op3 ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  (CheckAdvSIMDEnabled ())
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let round : Bool := true
  let op2 ← (( do
    bif scalar_form
    then
      (do
        (pure (sint (← (Elem_read (← (D_read m)) index esize)))))
    else (pure op2) ) : SailM Int )
  let (op1, op2, op3, result, sat) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2, op3, result, sat)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2, op3, result, sat) := loop_vars
      loop_vars ← do
        let (op1, op2, op3, result, sat) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2, op3, result, sat)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2, op3, result, sat) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (pure (sint (← (Elem_read (← (D_read (n +i r))) e esize))))
              let op3 ←
                (pure (Int.shiftl (sint (← (Elem_read (← (D_read (d +i r))) e esize))) esize))
              let op2 ← (( do
                bif (Bool.not scalar_form)
                then
                  (do
                    (pure (sint (← (Elem_read (← (D_read (m +i r))) e esize)))))
                else (pure op2) ) : SailM Int )
              let rdmlah ← do (RShr (op3 +i (2 *i (op1 *i op2))) esize round)
              let (tup__0, tup__1) ← do (SignedSatQ rdmlah esize)
              let result : (BitVec esize) := tup__0
              let sat : Bool := tup__1
              (pure ())
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              bif sat
              then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
              else (pure ())
              (pure (op1, op2, op3, result, sat))
          (pure loop_vars_1) ) : SailM (Int × Int × Int × (BitVec esize) × Bool) )
        (pure (op1, op2, op3, result, sat))
    (pure loop_vars) ) : SailM (Int × Int × Int × (BitVec esize) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQRDMLAH_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  let index ← (( do (undefined_int ()) ) : SailM Int )
  bif (Bool.not (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := index
  let add : Bool := true
  let scalar_form : Bool := false
  let esize := (Int.shiftl 8 (UInt0 size))
  let elements := (ediv_nat 64 esize)
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VQRDMLAH_Op_A_txt d elements esize index m n regs scalar_form)

def decode_aarch32_instrs_VQRDMLAH_A2enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_See "Related encodings"))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let add : Bool := true
  let scalar_form : Bool := true
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  let esize : Int := 8
  let elements ← (( do (undefined_int ()) ) : SailM Int )
  let m ← (( do (undefined_int ()) ) : SailM Int )
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (elements, esize, index, m) : (Int × Int × Int × Int) :=
    bif (BEq.beq size (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
      let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
      (elements, esize, index, m))
    else (elements, esize, index, m)
  let (elements, esize, index, m) : (Int × Int × Int × Int) :=
    bif (BEq.beq size (0b10 : (BitVec 2)))
    then
      (let esize : Int := 32
      let elements : Int := 2
      let m : Int := (UInt0 Vm)
      let index : Int := (UInt0 M)
      (elements, esize, index, m))
    else (elements, esize, index, m)
  let m := m
  let index := index
  let esize := esize
  let elements := elements
  assert (Bool.and (0 ≤b m) (m ≤b 31)) "src/instrs32.sail:33410.43-33410.44"
  (execute_aarch32_instrs_VQRDMLAH_Op_A_txt d elements esize index m n regs scalar_form)

def decode_aarch32_instrs_VQRDMLAH_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  let index ← (( do (undefined_int ()) ) : SailM Int )
  bif (Bool.not (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := index
  let add : Bool := true
  let scalar_form : Bool := false
  let esize := (Int.shiftl 8 (UInt0 size))
  let elements := (ediv_nat 64 esize)
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VQRDMLAH_Op_A_txt d elements esize index m n regs scalar_form)

def decode_aarch32_instrs_VQRDMLAH_T2enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_See "Related encodings"))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let add : Bool := true
  let scalar_form : Bool := true
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  let esize : Int := 8
  let elements ← (( do (undefined_int ()) ) : SailM Int )
  let m ← (( do (undefined_int ()) ) : SailM Int )
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (elements, esize, index, m) : (Int × Int × Int × Int) :=
    bif (BEq.beq size (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
      let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
      (elements, esize, index, m))
    else (elements, esize, index, m)
  let (elements, esize, index, m) : (Int × Int × Int × Int) :=
    bif (BEq.beq size (0b10 : (BitVec 2)))
    then
      (let esize : Int := 32
      let elements : Int := 2
      let m : Int := (UInt0 Vm)
      let index : Int := (UInt0 M)
      (elements, esize, index, m))
    else (elements, esize, index, m)
  let m := m
  let index := index
  let esize := esize
  let elements := elements
  assert (Bool.and (0 ≤b m) (m ≤b 31)) "src/instrs32.sail:33511.43-33511.44"
  (execute_aarch32_instrs_VQRDMLAH_Op_A_txt d elements esize index m n regs scalar_form)

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, index : Int, m : Nat, n : Nat, regs
  : Nat, k_scalar_form : Bool, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQRDMLSH_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (index : Int) (m : Nat) (n : Nat) (regs : Nat) (scalar_form : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let op3 ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  (CheckAdvSIMDEnabled ())
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let round : Bool := true
  let op2 ← (( do
    bif scalar_form
    then
      (do
        (pure (sint (← (Elem_read (← (D_read m)) index esize)))))
    else (pure op2) ) : SailM Int )
  let (op1, op2, op3, result, sat) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2, op3, result, sat)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2, op3, result, sat) := loop_vars
      loop_vars ← do
        let (op1, op2, op3, result, sat) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2, op3, result, sat)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2, op3, result, sat) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (pure (sint (← (Elem_read (← (D_read (n +i r))) e esize))))
              let op3 ←
                (pure (Int.shiftl (sint (← (Elem_read (← (D_read (d +i r))) e esize))) esize))
              let op2 ← (( do
                bif (Bool.not scalar_form)
                then
                  (do
                    (pure (sint (← (Elem_read (← (D_read (m +i r))) e esize)))))
                else (pure op2) ) : SailM Int )
              let rdmlsh ← do (RShr (op3 -i (2 *i (op1 *i op2))) esize round)
              let (tup__0, tup__1) ← do (SignedSatQ rdmlsh esize)
              let result : (BitVec esize) := tup__0
              let sat : Bool := tup__1
              (pure ())
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              bif sat
              then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
              else (pure ())
              (pure (op1, op2, op3, result, sat))
          (pure loop_vars_1) ) : SailM (Int × Int × Int × (BitVec esize) × Bool) )
        (pure (op1, op2, op3, result, sat))
    (pure loop_vars) ) : SailM (Int × Int × Int × (BitVec esize) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQRDMLSH_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  let index ← (( do (undefined_int ()) ) : SailM Int )
  bif (Bool.not (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := index
  let add : Bool := false
  let scalar_form : Bool := false
  let esize := (Int.shiftl 8 (UInt0 size))
  let elements := (ediv_nat 64 esize)
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VQRDMLSH_Op_A_txt d elements esize index m n regs scalar_form)

def decode_aarch32_instrs_VQRDMLSH_A2enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_See "Related encodings"))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let add : Bool := false
  let scalar_form : Bool := true
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  let esize : Int := 8
  let elements ← (( do (undefined_int ()) ) : SailM Int )
  let m ← (( do (undefined_int ()) ) : SailM Int )
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let (elements, esize, index, m) : (Int × Int × Int × Int) :=
    bif (BEq.beq size (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
      let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
      (elements, esize, index, m))
    else (elements, esize, index, m)
  let (elements, esize, index, m) : (Int × Int × Int × Int) :=
    bif (BEq.beq size (0b10 : (BitVec 2)))
    then
      (let esize : Int := 32
      let elements : Int := 2
      let m : Int := (UInt0 Vm)
      let index : Int := (UInt0 M)
      (elements, esize, index, m))
    else (elements, esize, index, m)
  let m := m
  let index := index
  let esize := esize
  let elements := elements
  assert (Bool.and (0 ≤b m) (m ≤b 31)) "src/instrs32.sail:33640.43-33640.44"
  (execute_aarch32_instrs_VQRDMLSH_Op_A_txt d elements esize index m n regs scalar_form)

def decode_aarch32_instrs_VQRDMLSH_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  let index ← (( do (undefined_int ()) ) : SailM Int )
  bif (Bool.not (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let index := index
  let add : Bool := false
  let scalar_form : Bool := false
  let esize := (Int.shiftl 8 (UInt0 size))
  let elements := (ediv_nat 64 esize)
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VQRDMLSH_Op_A_txt d elements esize index m n regs scalar_form)

def decode_aarch32_instrs_VQRDMLSH_T2enc_A_txt (Q : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveQRDMLAHExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (BEq.beq size (0b11 : (BitVec 2)))
  then sailThrow ((Error_See "Related encodings"))
  else (pure ())
  bif (BEq.beq size (0b00 : (BitVec 2)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let add : Bool := false
  let scalar_form : Bool := true
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  let esize : Int := 8
  let m ← (( do (undefined_int ()) ) : SailM Int )
  let index ← (( do (undefined_int ()) ) : SailM Int )
  let elements ← (( do (undefined_int ()) ) : SailM Int )
  let (elements, esize, index, m) : (Int × Int × Int × Int) :=
    bif (BEq.beq size (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      let m : Int := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
      let index : Int := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
      (elements, esize, index, m))
    else (elements, esize, index, m)
  let (elements, esize, index, m) : (Int × Int × Int × Int) :=
    bif (BEq.beq size (0b10 : (BitVec 2)))
    then
      (let esize : Int := 32
      let elements : Int := 2
      let m : Int := (UInt0 Vm)
      let index : Int := (UInt0 M)
      (elements, esize, index, m))
    else (elements, esize, index, m)
  let m := m
  let index := index
  let esize := esize
  let elements := elements
  assert (Bool.and (0 ≤b m) (m ≤b 31)) "src/instrs32.sail:33741.43-33741.44"
  (execute_aarch32_instrs_VQRDMLSH_Op_A_txt d elements esize index m n regs scalar_form)

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQRSHL_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  let (result, sat) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (result, sat)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (result, sat) := loop_vars
      loop_vars ← do
        let (result, sat) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (result, sat)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (result, sat) := loop_vars_1
            loop_vars_1 ← do
              let element ← (( do
                (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned) ) : SailM
                Int )
              let shift ← (( do
                (pure (sint
                    (Sail.BitVec.extractLsb (← (Elem_read (← (D_read (n +i r))) e esize)) 7 0)))
                ) : SailM Int )
              let element : Int :=
                bif (shift ≥b 0)
                then (_shl_int_general element shift)
                else
                  (let shift := (Neg.neg shift)
                  (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
              let element := element
              let (tup__0, tup__1) ← do (SatQ element esize is_unsigned)
              let result : (BitVec esize) := tup__0
              let sat : Bool := tup__1
              (pure ())
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              bif sat
              then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
              else (pure ())
              (pure (result, sat))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × Bool) )
        (pure (result, sat))
    (pure loop_vars) ) : SailM ((BitVec esize) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQRSHL_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQRSHL_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VQRSHL_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQRSHL_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, k_dest_unsigned : Bool, elements : Nat, esize : Nat, m : Nat, shift_amount
  : Int, k_src_unsigned : Bool, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ elements ∈ {2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQRSHRN_Op_A_txt (d__arg : Nat) (dest_unsigned : Bool) (elements : Nat) (esize : Nat) (m : Nat) (shift_amount : Int) (src_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let operand ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  (CheckAdvSIMDEnabled ())
  let round : Bool := true
  let (operand, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (operand, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (operand, result, sat) := loop_vars
      loop_vars ← do
        let operand ←
          (asl_Int (← (Elem_read (← (Qin_read (Int.shiftl m 1))) e (2 *i esize))) src_unsigned)
        let rshrn ← do (RShr operand shift_amount round)
        let (tup__0, tup__1) ← do (SatQ rshrn esize dest_unsigned)
        let result : (BitVec esize) := tup__0
        let sat : Bool := tup__1
        (pure ())
        (D_set d (← (Elem_set (← (D_read d)) e esize result)))
        bif sat
        then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
        else (pure ())
        (pure (operand, result, sat))
    (pure loop_vars) ) : SailM (Int × (BitVec esize) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQRSHRN_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq U (0b0 : (BitVec 1))) (BEq.beq op (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VRSHRN"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := imm6
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 3) (0b001 : (BitVec 3)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 5) (0b1 : (BitVec 1)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else ()))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let src_unsigned : Bool :=
        (Bool.and (BEq.beq U (0b1 : (BitVec 1))) (BEq.beq op (0b1 : (BitVec 1))))
      let dest_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VQRSHRN_Op_A_txt d dest_unsigned elements esize m shift_amount
        src_unsigned))
  else (pure ())

def decode_aarch32_instrs_VQRSHRN_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq U (0b0 : (BitVec 1))) (BEq.beq op (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VRSHRN"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := imm6
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 3) (0b001 : (BitVec 3)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 5) (0b1 : (BitVec 1)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else ()))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let src_unsigned : Bool :=
        (Bool.and (BEq.beq U (0b1 : (BitVec 1))) (BEq.beq op (0b1 : (BitVec 1))))
      let dest_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VQRSHRN_Op_A_txt d dest_unsigned elements esize m shift_amount
        src_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, k_dest_unsigned : Bool, elements : Nat, esize : Nat, m : Nat, regs
  : Nat, shift_amount : Int, k_src_unsigned : Bool, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ elements ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQSHL_i_Op_A_txt (d__arg : Nat) (dest_unsigned : Bool) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) (shift_amount : Int) (src_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let operand ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  (CheckAdvSIMDEnabled ())
  let (operand, result, sat) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (operand, result, sat)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (operand, result, sat) := loop_vars
      loop_vars ← do
        let (operand, result, sat) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (operand, result, sat)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (operand, result, sat) := loop_vars_1
            loop_vars_1 ← do
              let operand ←
                (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) src_unsigned)
              let (tup__0, tup__1) ← do
                (SatQ (_shl_int_general operand shift_amount) esize dest_unsigned)
              let result : (BitVec esize) := tup__0
              let sat : Bool := tup__1
              (pure ())
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              bif sat
              then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
              else (pure ())
              (pure (operand, result, sat))
          (pure loop_vars_1) ) : SailM (Int × (BitVec esize) × Bool) )
        (pure (operand, result, sat))
    (pure loop_vars) ) : SailM (Int × (BitVec esize) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQSHL_i_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (op : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq U (0b0 : (BitVec 1))) (BEq.beq op (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := ((UInt0 imm6) -i 8)
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := ((UInt0 imm6) -i 16)
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := ((UInt0 imm6) -i 32)
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (UInt0 imm6)
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let src_unsigned : Bool :=
        (Bool.and (BEq.beq U (0b1 : (BitVec 1))) (BEq.beq op (0b1 : (BitVec 1))))
      let dest_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements 8 m regs shift_amount
          src_unsigned)
      | 16 => (execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements 16 m regs
          shift_amount src_unsigned)
      | 32 => (execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements 32 m regs
          shift_amount src_unsigned)
      | 64 => (execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements 64 m regs
          shift_amount src_unsigned)
      | _ => assert false "src/instrs32.sail:34086.26-34086.27")
  else (pure ())

def decode_aarch32_instrs_VQSHL_i_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (op : (BitVec 1)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq U (0b0 : (BitVec 1))) (BEq.beq op (0b0 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := ((UInt0 imm6) -i 8)
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := ((UInt0 imm6) -i 16)
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := ((UInt0 imm6) -i 32)
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (UInt0 imm6)
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let src_unsigned : Bool :=
        (Bool.and (BEq.beq U (0b1 : (BitVec 1))) (BEq.beq op (0b1 : (BitVec 1))))
      let dest_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements 8 m regs shift_amount
          src_unsigned)
      | 16 => (execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements 16 m regs
          shift_amount src_unsigned)
      | 32 => (execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements 32 m regs
          shift_amount src_unsigned)
      | 64 => (execute_aarch32_instrs_VQSHL_i_Op_A_txt d dest_unsigned elements 64 m regs
          shift_amount src_unsigned)
      | _ => assert false "src/instrs32.sail:34171.26-34171.27")
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQSHL_r_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let operand ← (( do (undefined_int ()) ) : SailM Int )
  let shift ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let (operand, shift) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (operand, shift)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (operand, shift) := loop_vars
      loop_vars ← do
        let (operand, shift) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (operand, shift)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (operand, shift) := loop_vars_1
            loop_vars_1 ← do
              let shift ←
                (pure (sint
                    (Sail.BitVec.extractLsb (← (Elem_read (← (D_read (n +i r))) e esize)) 7 0)))
              let operand ←
                (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned)
              let sat ← (( do (undefined_bool ()) ) : SailM Bool )
              let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let (result, sat) ← (( do
                bif (shift ≥b 0)
                then
                  (do
                    let (tup__0, tup__1) ← do
                      (SatQ (_shl_int_general operand shift) esize is_unsigned)
                    let result : (BitVec esize) := tup__0
                    let sat : Bool := tup__1
                    (pure (result, sat)))
                else
                  (do
                    let (tup__0, tup__1) ← do
                      (SatQ (_shr_int_general operand (Neg.neg shift)) esize is_unsigned)
                    let result : (BitVec esize) := tup__0
                    let sat : Bool := tup__1
                    (pure (result, sat))) ) : SailM ((BitVec esize) × Bool) )
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              bif sat
              then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
              else (pure ())
              (pure (operand, shift))
          (pure loop_vars_1) ) : SailM (Int × Int) )
        (pure (operand, shift))
    (pure loop_vars) ) : SailM (Int × Int) )
  (pure ())

def decode_aarch32_instrs_VQSHL_r_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQSHL_r_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VQSHL_r_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQSHL_r_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, k_dest_unsigned : Bool, elements : Nat, esize : Nat, m : Nat, shift_amount
  : Int, k_src_unsigned : Bool, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ elements ∈ {2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQSHRN_Op_A_txt (d__arg : Nat) (dest_unsigned : Bool) (elements : Nat) (esize : Nat) (m : Nat) (shift_amount : Int) (src_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let operand ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let sat ← (( do (undefined_bool ()) ) : SailM Bool )
  (CheckAdvSIMDEnabled ())
  let (operand, result, sat) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := (operand, result, sat)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (operand, result, sat) := loop_vars
      loop_vars ← do
        let operand ←
          (asl_Int (← (Elem_read (← (Qin_read (Int.shiftl m 1))) e (2 *i esize))) src_unsigned)
        let (tup__0, tup__1) ← do
          (SatQ (_shr_int_general operand shift_amount) esize dest_unsigned)
        let result : (BitVec esize) := tup__0
        let sat : Bool := tup__1
        (pure ())
        (D_set d (← (Elem_set (← (D_read d)) e esize result)))
        bif sat
        then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
        else (pure ())
        (pure (operand, result, sat))
    (pure loop_vars) ) : SailM (Int × (BitVec esize) × Bool) )
  (pure ())

def decode_aarch32_instrs_VQSHRN_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq U (0b0 : (BitVec 1))) (BEq.beq op (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VSHRN"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := imm6
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 3) (0b001 : (BitVec 3)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 5) (0b1 : (BitVec 1)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else ()))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let src_unsigned : Bool :=
        (Bool.and (BEq.beq U (0b1 : (BitVec 1))) (BEq.beq op (0b1 : (BitVec 1))))
      let dest_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VQSHRN_Op_A_txt d dest_unsigned elements esize m shift_amount
        src_unsigned))
  else (pure ())

def decode_aarch32_instrs_VQSHRN_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq U (0b0 : (BitVec 1))) (BEq.beq op (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VSHRN"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := imm6
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 3) (0b001 : (BitVec 3)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 5) (0b1 : (BitVec 1)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else ()))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let src_unsigned : Bool :=
        (Bool.and (BEq.beq U (0b1 : (BitVec 1))) (BEq.beq op (0b1 : (BitVec 1))))
      let dest_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VQSHRN_Op_A_txt d dest_unsigned elements esize m shift_amount
        src_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VQSUB_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let diff ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let diff ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := diff
    for r in [loop_r_lower:loop_r_upper:1]i do
      let diff := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := diff
        for e in [loop_e_lower:loop_e_upper:1]i do
          let diff := loop_vars_1
          loop_vars_1 ← do
            let diff ←
              (pure ((← (asl_Int (← (Elem_read (← (D_read (n +i r))) e esize)) is_unsigned)) -i (← (asl_Int
                      (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned))))
            let sat ← (( do (undefined_bool ()) ) : SailM Bool )
            let (__tup_0, __tup_1) ← do (SatQ diff esize is_unsigned)
            (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize __tup_0)))
            let sat : Bool := __tup_1
            (pure ())
            bif sat
            then (FPSCR_write (_update_FPSCR_Type_QC (← (FPSCR_read__1 ())) (0b1 : (BitVec 1))))
            else (pure ())
            (pure diff)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VQSUB_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQSUB_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VQSUB_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VQSUB_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRADDHN_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let round : Bool := true
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (RShr
            (UInt0
              ((← (Elem_read (← (Qin_read (Int.shiftl n 1))) e (2 *i esize))) + (← (Elem_read
                    (← (Qin_read (Int.shiftl m 1))) e (2 *i esize))))) esize round)
        (D_set d (← (Elem_set (← (D_read d)) e esize (integer_subrange result (esize -i 1) 0))))
        (pure result)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VRADDHN_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VRADDHN_Op_A_txt d elements esize m n))
  else (pure ())

def decode_aarch32_instrs_VRADDHN_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VRADDHN_Op_A_txt d elements esize m n))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_floating_point : Bool, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRECPE_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (floating_point : Bool) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          bif floating_point
          then
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e esize
                  (← (FPRecipEstimate (← (Elem_read (← (D_read (m +i r))) e esize))
                      (← (StandardFPSCRValue ())))))))
          else
            (do
              assert (BEq.beq esize 32) "src/instrs32.sail:34614.47-34614.48"
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (← (UnsignedRecipEstimate (← (Elem_read (← (D_read (m +i r))) e esize))))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VRECPE_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.and (BEq.beq size (0b01 : (BitVec 2)))
             (Bool.or (Bool.not (HaveFP16Ext ())) (BEq.beq F (0b0 : (BitVec 1)))))
           (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let elements : Int := 2
            ())
          else ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRECPE_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VRECPE_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.and (BEq.beq size (0b01 : (BitVec 2)))
             (Bool.or (Bool.not (HaveFP16Ext ())) (BEq.beq F (0b0 : (BitVec 1)))))
           (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let elements : Int := 2
            ())
          else ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRECPE_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRECPS_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (← (FPRecipStep (← (Elem_read (← (D_read (n +i r))) e esize))
                    (← (Elem_read (← (D_read (m +i r))) e esize)))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VRECPS_A1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRECPS_Op_A_txt d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VRECPS_T1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRECPS_Op_A_txt d elements esize m n regs))
  else (pure ())

/-- Type quantifiers: containers : Int, d : Nat, elements_per_container : Int, esize : Nat, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VREV16_Op_A_txt (containers : Int) (d : Nat) (elements_per_container : Int) (esize : Nat) (m : Nat) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let element ← (( do (undefined_int ()) ) : SailM Int )
  let rev_element ← (( do (undefined_int ()) ) : SailM Int )
  let (element, result, rev_element) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (element, result, rev_element)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (element, result, rev_element) := loop_vars
      loop_vars ← do
        let element : Int := 0
        let (element, result, rev_element) ← (( do
          let loop_c_lower := 0
          let loop_c_upper := (containers -i 1)
          let mut loop_vars_1 := (element, result, rev_element)
          for c in [loop_c_lower:loop_c_upper:1]i do
            let (element, result, rev_element) := loop_vars_1
            loop_vars_1 ← do
              let rev_element : Int := ((element +i elements_per_container) -i 1)
              let (element, result, rev_element) ← (( do
                let loop_e_lower := 0
                let loop_e_upper := (elements_per_container -i 1)
                let mut loop_vars_2 := (element, result, rev_element)
                for e in [loop_e_lower:loop_e_upper:1]i do
                  let (element, result, rev_element) := loop_vars_2
                  loop_vars_2 ← do
                    let rev_element := rev_element
                    let element := element
                    let result ←
                      (Elem_set result rev_element esize
                        (← (Elem_read (← (D_read (m +i r))) element esize)))
                    (pure ())
                    let element : Int := (element +i 1)
                    let rev_element : Int := (rev_element -i 1)
                    (pure (element, result, rev_element))
                (pure loop_vars_2) ) : SailM (Int × (BitVec 64) × Int) )
              (pure (element, result, rev_element))
          (pure loop_vars_1) ) : SailM (Int × (BitVec 64) × Int) )
        (D_set (d +i r) result)
        (pure (element, result, rev_element))
    (pure loop_vars) ) : SailM (Int × (BitVec 64) × Int) )
  (pure ())

def decode_aarch32_instrs_VREV16_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 2)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (((UInt0 op) +i (UInt0 size)) ≥b 3)
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let container_size : Int := 16
      let _ : Unit :=
        let b__0 := op
        bif (BEq.beq b__0 (0b10 : (BitVec 2)))
        then
          (let container_size : Int := 16
          ())
        else
          (bif (BEq.beq b__0 (0b01 : (BitVec 2)))
          then
            (let container_size : Int := 32
            ())
          else
            (bif (BEq.beq b__0 (0b00 : (BitVec 2)))
            then
              (let container_size : Int := 64
              ())
            else ()))
      let container_size := container_size
      let containers := (ediv_nat 64 container_size)
      let elements_per_container := (ediv_nat container_size esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container esize m regs))
  else (pure ())

def decode_aarch32_instrs_VREV16_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 2)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (((UInt0 op) +i (UInt0 size)) ≥b 3)
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let container_size : Int := 16
      let _ : Unit :=
        let b__0 := op
        bif (BEq.beq b__0 (0b10 : (BitVec 2)))
        then
          (let container_size : Int := 16
          ())
        else
          (bif (BEq.beq b__0 (0b01 : (BitVec 2)))
          then
            (let container_size : Int := 32
            ())
          else
            (bif (BEq.beq b__0 (0b00 : (BitVec 2)))
            then
              (let container_size : Int := 64
              ())
            else ()))
      let container_size := container_size
      let containers := (ediv_nat 64 container_size)
      let elements_per_container := (ediv_nat container_size esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VREV16_Op_A_txt containers d elements_per_container esize m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRHADD_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_int ()) ) : SailM Int )
  let op2 ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let (op1, op2, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, op2, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, op2, result) := loop_vars
      loop_vars ← do
        let (op1, op2, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, op2, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, op2, result) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (asl_Int (← (Elem_read (← (D_read (n +i r))) e esize)) is_unsigned)
              let op2 ← (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned)
              let result : Int := (Int.shiftr ((op1 +i op2) +i 1) 1)
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (integer_subrange result (esize -i 1) 0))))
              (pure (op1, op2, result))
          (pure loop_vars_1) ) : SailM (Int × Int × Int) )
        (pure (op1, op2, result))
    (pure loop_vars) ) : SailM (Int × Int × Int) )
  (pure ())

def decode_aarch32_instrs_VRHADD_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRHADD_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VRHADD_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRHADD_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRSHL_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let result ← (( do (undefined_int ()) ) : SailM Int )
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let element ← do
              (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned)
            let shift ← (( do
              (pure (sint
                  (Sail.BitVec.extractLsb (← (Elem_read (← (D_read (n +i r))) e esize)) 7 0))) )
              : SailM Int )
            let result : Int :=
              bif (shift ≥b 0)
              then (_shl_int_general element shift)
              else
                (let shift := (Neg.neg shift)
                (_shr_int_general (element +i (_shl_int_general 1 (shift -i 1))) shift))
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e esize
                  (integer_subrange result (esize -i 1) 0))))
            (pure result)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VRSHL_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRSHL_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VRSHL_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRSHL_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, regs
  : Nat, shift_amount : Int, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ elements ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRSHR_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) (shift_amount : Int) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let round : Bool := true
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let result ←
              (RShr (← (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned))
                shift_amount round)
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e esize
                  (integer_subrange result (esize -i 1) 0))))
            (pure result)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VRSHR_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (64 -i (UInt0 imm6))
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VRSHR_Op_A_txt d elements 8 m regs shift_amount is_unsigned)
      | 16 => (execute_aarch32_instrs_VRSHR_Op_A_txt d elements 16 m regs shift_amount is_unsigned)
      | 32 => (execute_aarch32_instrs_VRSHR_Op_A_txt d elements 32 m regs shift_amount is_unsigned)
      | 64 => (execute_aarch32_instrs_VRSHR_Op_A_txt d elements 64 m regs shift_amount is_unsigned)
      | _ => assert false "src/instrs32.sail:35204.26-35204.27")
  else (pure ())

def decode_aarch32_instrs_VRSHR_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (64 -i (UInt0 imm6))
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VRSHR_Op_A_txt d elements 8 m regs shift_amount is_unsigned)
      | 16 => (execute_aarch32_instrs_VRSHR_Op_A_txt d elements 16 m regs shift_amount is_unsigned)
      | 32 => (execute_aarch32_instrs_VRSHR_Op_A_txt d elements 32 m regs shift_amount is_unsigned)
      | 64 => (execute_aarch32_instrs_VRSHR_Op_A_txt d elements 64 m regs shift_amount is_unsigned)
      | _ => assert false "src/instrs32.sail:35284.26-35284.27")
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, shift_amount : Int, 0 ≤
  m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ elements ∈ {2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRSHRN_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (shift_amount : Int) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let round : Bool := true
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (RShr (UInt0 (← (Elem_read (← (Qin_read (Int.shiftl m 1))) e (2 *i esize))))
            shift_amount round)
        (D_set d (← (Elem_set (← (D_read d)) e esize (integer_subrange result (esize -i 1) 0))))
        (pure result)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VRSHRN_A1enc_A_txt (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := imm6
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 3) (0b001 : (BitVec 3)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 5) (0b1 : (BitVec 1)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else ()))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VRSHRN_Op_A_txt d elements esize m shift_amount))
  else (pure ())

def decode_aarch32_instrs_VRSHRN_T1enc_A_txt (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := imm6
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 3) (0b001 : (BitVec 3)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 5) (0b1 : (BitVec 1)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else ()))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VRSHRN_Op_A_txt d elements esize m shift_amount))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_floating_point : Bool, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRSQRTE_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (floating_point : Bool) (m : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          bif floating_point
          then
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e esize
                  (← (FPRSqrtEstimate (← (Elem_read (← (D_read (m +i r))) e esize))
                      (← (StandardFPSCRValue ())))))))
          else
            (do
              assert (BEq.beq esize 32) "src/instrs32.sail:35439.47-35439.48"
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (← (UnsignedRSqrtEstimate (← (Elem_read (← (D_read (m +i r))) e esize))))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VRSQRTE_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.and (BEq.beq size (0b01 : (BitVec 2)))
             (Bool.or (Bool.not (HaveFP16Ext ())) (BEq.beq F (0b0 : (BitVec 1)))))
           (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let elements : Int := 2
            ())
          else ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRSQRTE_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

def decode_aarch32_instrs_VRSQRTE_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (F : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.and (BEq.beq size (0b01 : (BitVec 2)))
             (Bool.or (Bool.not (HaveFP16Ext ())) (BEq.beq F (0b0 : (BitVec 1)))))
           (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let floating_point : Bool := (BEq.beq F (0b1 : (BitVec 1)))
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let elements : Int := 4
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let elements : Int := 2
            ())
          else ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRSQRTE_Op_A_txt d elements esize floating_point m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRSQRTS_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (← (FPRSqrtStep (← (Elem_read (← (D_read (n +i r))) e esize))
                    (← (Elem_read (← (D_read (m +i r))) e esize)))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VRSQRTS_A1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRSQRTS_Op_A_txt d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VRSQRTS_T1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VRSQRTS_Op_A_txt d elements esize m n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, regs
  : Nat, shift_amount : Int, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ elements ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRSRA_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) (shift_amount : Int) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let round : Bool := true
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let result ←
              (RShr (← (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned))
                shift_amount round)
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e esize
                  (BitVec.addInt (← (Elem_read (← (D_read (d +i r))) e esize)) result))))
            (pure result)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VRSRA_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (64 -i (UInt0 imm6))
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VRSRA_Op_A_txt d elements 8 m regs shift_amount is_unsigned)
      | 16 => (execute_aarch32_instrs_VRSRA_Op_A_txt d elements 16 m regs shift_amount is_unsigned)
      | 32 => (execute_aarch32_instrs_VRSRA_Op_A_txt d elements 32 m regs shift_amount is_unsigned)
      | 64 => (execute_aarch32_instrs_VRSRA_Op_A_txt d elements 64 m regs shift_amount is_unsigned)
      | _ => assert false "src/instrs32.sail:35727.26-35727.27")
  else (pure ())

def decode_aarch32_instrs_VRSRA_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (64 -i (UInt0 imm6))
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VRSRA_Op_A_txt d elements 8 m regs shift_amount is_unsigned)
      | 16 => (execute_aarch32_instrs_VRSRA_Op_A_txt d elements 16 m regs shift_amount is_unsigned)
      | 32 => (execute_aarch32_instrs_VRSRA_Op_A_txt d elements 32 m regs shift_amount is_unsigned)
      | 64 => (execute_aarch32_instrs_VRSRA_Op_A_txt d elements 64 m regs shift_amount is_unsigned)
      | _ => assert false "src/instrs32.sail:35807.26-35807.27")
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRSUBHN_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let round : Bool := true
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (RShr
            (UInt0
              ((← (Elem_read (← (Qin_read (Int.shiftl n 1))) e (2 *i esize))) - (← (Elem_read
                    (← (Qin_read (Int.shiftl m 1))) e (2 *i esize))))) esize round)
        (D_set d (← (Elem_set (← (D_read d)) e esize (integer_subrange result (esize -i 1) 0))))
        (pure result)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VRSUBHN_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VRSUBHN_Op_A_txt d elements esize m n))
  else (pure ())

def decode_aarch32_instrs_VRSUBHN_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VRSUBHN_Op_A_txt d elements esize m n))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, regs : Nat, shift_amount :
  Int, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ elements ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSHL_i_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) (shift_amount : Int) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                ((← (Elem_read (← (D_read (m +i r))) e esize)) <<< shift_amount))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VSHL_i_A1enc_A_txt (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := ((UInt0 imm6) -i 8)
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := ((UInt0 imm6) -i 16)
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := ((UInt0 imm6) -i 32)
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (UInt0 imm6)
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VSHL_i_Op_A_txt d elements 8 m regs shift_amount)
      | 16 => (execute_aarch32_instrs_VSHL_i_Op_A_txt d elements 16 m regs shift_amount)
      | 32 => (execute_aarch32_instrs_VSHL_i_Op_A_txt d elements 32 m regs shift_amount)
      | 64 => (execute_aarch32_instrs_VSHL_i_Op_A_txt d elements 64 m regs shift_amount)
      | _ => assert false "src/instrs32.sail:35979.26-35979.27")
  else (pure ())

def decode_aarch32_instrs_VSHL_i_T1enc_A_txt (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := ((UInt0 imm6) -i 8)
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := ((UInt0 imm6) -i 16)
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := ((UInt0 imm6) -i 32)
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (UInt0 imm6)
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VSHL_i_Op_A_txt d elements 8 m regs shift_amount)
      | 16 => (execute_aarch32_instrs_VSHL_i_Op_A_txt d elements 16 m regs shift_amount)
      | 32 => (execute_aarch32_instrs_VSHL_i_Op_A_txt d elements 32 m regs shift_amount)
      | 64 => (execute_aarch32_instrs_VSHL_i_Op_A_txt d elements 64 m regs shift_amount)
      | _ => assert false "src/instrs32.sail:36057.26-36057.27")
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, shift_amount
  : Int, 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSHLL_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (shift_amount : Int) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (pure (_shl_int_general
              (← (asl_Int (← (Elem_read (← (Din_read m)) e esize)) is_unsigned)) shift_amount))
        (Q_set (Int.shiftr d 1)
          (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize)
              (integer_subrange result ((2 *i esize) -i 1) 0))))
        (pure result)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VSHLL_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := imm6
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 3) (0b001 : (BitVec 3)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := ((UInt0 imm6) -i 8)
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := ((UInt0 imm6) -i 16)
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 5) (0b1 : (BitVec 1)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := ((UInt0 imm6) -i 32)
              ())
            else ()))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      bif (BEq.beq shift_amount 0)
      then sailThrow ((Error_See "VMOVL"))
      else (pure ())
      let shift_amount := shift_amount
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VSHLL_Op_A_txt d elements esize m shift_amount is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VSHLL_A2enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let shift_amount := esize
      let is_unsigned : Bool := false
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VSHLL_Op_A_txt d elements esize m shift_amount is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VSHLL_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := imm6
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 3) (0b001 : (BitVec 3)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := ((UInt0 imm6) -i 8)
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := ((UInt0 imm6) -i 16)
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 5) (0b1 : (BitVec 1)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := ((UInt0 imm6) -i 32)
              ())
            else ()))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      bif (BEq.beq shift_amount 0)
      then sailThrow ((Error_See "VMOVL"))
      else (pure ())
      let shift_amount := shift_amount
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VSHLL_Op_A_txt d elements esize m shift_amount is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VSHLL_T2enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let shift_amount := esize
      let is_unsigned : Bool := false
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VSHLL_Op_A_txt d elements esize m shift_amount is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, m : Nat, n :
  Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSHL_r_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let shift ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let shift ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := shift
    for r in [loop_r_lower:loop_r_upper:1]i do
      let shift := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := shift
        for e in [loop_e_lower:loop_e_upper:1]i do
          let shift := loop_vars_1
          loop_vars_1 ← do
            let shift ←
              (pure (sint
                  (Sail.BitVec.extractLsb (← (Elem_read (← (D_read (n +i r))) e esize)) 7 0)))
            let result ← (( do (undefined_int ()) ) : SailM Int )
            let result ← (( do
              bif (shift ≥b 0)
              then
                (do
                  (pure (_shl_int_general
                      (← (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned))
                      shift)))
              else
                (do
                  (pure (_shr_int_general
                      (← (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned))
                      (Neg.neg shift)))) ) : SailM Int )
            let result := result
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e esize
                  (integer_subrange result (esize -i 1) 0))))
            (pure shift)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VSHL_r_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VSHL_r_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VSHL_r_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let n := (UInt0 (N ++ Vn))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VSHL_r_Op_A_txt d elements esize m n regs is_unsigned))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, regs
  : Nat, shift_amount : Int, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ elements ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSHR_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) (shift_amount : Int) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let result ←
              (pure (_shr_int_general
                  (← (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned))
                  shift_amount))
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e esize
                  (integer_subrange result (esize -i 1) 0))))
            (pure result)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VSHR_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (64 -i (UInt0 imm6))
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VSHR_Op_A_txt d elements 8 m regs shift_amount is_unsigned)
      | 16 => (execute_aarch32_instrs_VSHR_Op_A_txt d elements 16 m regs shift_amount is_unsigned)
      | 32 => (execute_aarch32_instrs_VSHR_Op_A_txt d elements 32 m regs shift_amount is_unsigned)
      | 64 => (execute_aarch32_instrs_VSHR_Op_A_txt d elements 64 m regs shift_amount is_unsigned)
      | _ => assert false "src/instrs32.sail:36431.26-36431.27")
  else (pure ())

def decode_aarch32_instrs_VSHR_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (64 -i (UInt0 imm6))
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VSHR_Op_A_txt d elements 8 m regs shift_amount is_unsigned)
      | 16 => (execute_aarch32_instrs_VSHR_Op_A_txt d elements 16 m regs shift_amount is_unsigned)
      | 32 => (execute_aarch32_instrs_VSHR_Op_A_txt d elements 32 m regs shift_amount is_unsigned)
      | 64 => (execute_aarch32_instrs_VSHR_Op_A_txt d elements 64 m regs shift_amount is_unsigned)
      | _ => assert false "src/instrs32.sail:36511.26-36511.27")
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, shift_amount : Int, 0 ≤
  m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32} ∧ elements ∈ {2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSHRN_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (shift_amount : Int) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (pure ((← (Elem_read (← (Qin_read (Int.shiftl m 1))) e (2 *i esize))) >>> shift_amount))
        (D_set d
          (← (Elem_set (← (D_read d)) e esize (Sail.BitVec.extractLsb result (esize -i 1) 0))))
        (pure result)
    (pure loop_vars) ) : SailM (BitVec (2 * esize)) )
  (pure ())

def decode_aarch32_instrs_VSHRN_A1enc_A_txt (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := imm6
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 3) (0b001 : (BitVec 3)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 5) (0b1 : (BitVec 1)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else ()))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VSHRN_Op_A_txt d elements esize m shift_amount))
  else (pure ())

def decode_aarch32_instrs_VSHRN_T1enc_A_txt (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := imm6
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 5 3) (0b000 : (BitVec 3)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 2
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := imm6
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 3) (0b001 : (BitVec 3)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 4) (0b01 : (BitVec 2)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 5 5) (0b1 : (BitVec 1)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else ()))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VSHRN_Op_A_txt d elements esize m shift_amount))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, regs : Nat, shift_amount :
  Int, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ elements ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSLI_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) (shift_amount : Int) : SailM Unit := do
  let d : Int := d__arg
  let shifted_op ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let mask : (BitVec esize) := ((Ones (n := esize)) <<< shift_amount)
  let shifted_op ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := shifted_op
    for r in [loop_r_lower:loop_r_upper:1]i do
      let shifted_op := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := shifted_op
        for e in [loop_e_lower:loop_e_upper:1]i do
          let shifted_op := loop_vars_1
          loop_vars_1 ← do
            let shifted_op ←
              (pure ((← (Elem_read (← (D_read (m +i r))) e esize)) <<< shift_amount))
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e esize
                  (((← (Elem_read (← (D_read (d +i r))) e esize)) &&& (Complement.complement
                        mask)) ||| shifted_op))))
            (pure shifted_op)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec esize) )
  (pure ())

def decode_aarch32_instrs_VSLI_A1enc_A_txt (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := ((UInt0 imm6) -i 8)
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := ((UInt0 imm6) -i 16)
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := ((UInt0 imm6) -i 32)
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (UInt0 imm6)
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VSLI_Op_A_txt d elements 8 m regs shift_amount)
      | 16 => (execute_aarch32_instrs_VSLI_Op_A_txt d elements 16 m regs shift_amount)
      | 32 => (execute_aarch32_instrs_VSLI_Op_A_txt d elements 32 m regs shift_amount)
      | 64 => (execute_aarch32_instrs_VSLI_Op_A_txt d elements 64 m regs shift_amount)
      | _ => assert false "src/instrs32.sail:36729.26-36729.27")
  else (pure ())

def decode_aarch32_instrs_VSLI_T1enc_A_txt (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := ((UInt0 imm6) -i 8)
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := ((UInt0 imm6) -i 16)
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := ((UInt0 imm6) -i 32)
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (UInt0 imm6)
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VSLI_Op_A_txt d elements 8 m regs shift_amount)
      | 16 => (execute_aarch32_instrs_VSLI_Op_A_txt d elements 16 m regs shift_amount)
      | 32 => (execute_aarch32_instrs_VSLI_Op_A_txt d elements 32 m regs shift_amount)
      | 64 => (execute_aarch32_instrs_VSLI_Op_A_txt d elements 64 m regs shift_amount)
      | _ => assert false "src/instrs32.sail:36807.26-36807.27")
  else (pure ())

/-- Type quantifiers: d : Nat, esize : Nat, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VSQRT_Op_A_txt (d : Nat) (esize : Nat) (m : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  match esize with
  | 16 => (S_set d
      ((Zeros (n := 16)) ++ (← (FPSqrt (Sail.BitVec.extractLsb (← (S_read m)) 15 0)
            (← (FPSCR_read ()))))))
  | 32 => (S_set d (← (FPSqrt (← (S_read m)) (← (FPSCR_read ())))))
  | 64 => (D_set d (← (FPSqrt (← (D_read m)) (← (FPSCR_read ())))))
  | _ => (pure ())

def decode_aarch32_instrs_VSQRT_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:36850.29-36850.30"
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VSQRT_Op_A_txt d esize m))
  else (pure ())

def decode_aarch32_instrs_VSQRT_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VSQRT_Op_A_txt d esize m))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, regs
  : Nat, shift_amount : Int, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ elements ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSRA_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) (shift_amount : Int) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := result
    for r in [loop_r_lower:loop_r_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars_1
          loop_vars_1 ← do
            let result ←
              (pure (_shr_int_general
                  (← (asl_Int (← (Elem_read (← (D_read (m +i r))) e esize)) is_unsigned))
                  shift_amount))
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e esize
                  (BitVec.addInt (← (Elem_read (← (D_read (d +i r))) e esize)) result))))
            (pure result)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VSRA_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (64 -i (UInt0 imm6))
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VSRA_Op_A_txt d elements 8 m regs shift_amount is_unsigned)
      | 16 => (execute_aarch32_instrs_VSRA_Op_A_txt d elements 16 m regs shift_amount is_unsigned)
      | 32 => (execute_aarch32_instrs_VSRA_Op_A_txt d elements 32 m regs shift_amount is_unsigned)
      | 64 => (execute_aarch32_instrs_VSRA_Op_A_txt d elements 64 m regs shift_amount is_unsigned)
      | _ => assert false "src/instrs32.sail:37028.26-37028.27")
  else (pure ())

def decode_aarch32_instrs_VSRA_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (64 -i (UInt0 imm6))
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VSRA_Op_A_txt d elements 8 m regs shift_amount is_unsigned)
      | 16 => (execute_aarch32_instrs_VSRA_Op_A_txt d elements 16 m regs shift_amount is_unsigned)
      | 32 => (execute_aarch32_instrs_VSRA_Op_A_txt d elements 32 m regs shift_amount is_unsigned)
      | 64 => (execute_aarch32_instrs_VSRA_Op_A_txt d elements 64 m regs shift_amount is_unsigned)
      | _ => assert false "src/instrs32.sail:37108.26-37108.27")
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, m : Nat, regs : Nat, shift_amount :
  Int, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧
  esize ∈ {8, 16, 32, 64} ∧ elements ∈ {1, 2, 4, 8} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSRI_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) (shift_amount : Int) : SailM Unit := do
  let d : Int := d__arg
  let shifted_op ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let mask : (BitVec esize) := ((Ones (n := esize)) >>> shift_amount)
  let shifted_op ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := shifted_op
    for r in [loop_r_lower:loop_r_upper:1]i do
      let shifted_op := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := shifted_op
        for e in [loop_e_lower:loop_e_upper:1]i do
          let shifted_op := loop_vars_1
          loop_vars_1 ← do
            let shifted_op ←
              (pure ((← (Elem_read (← (D_read (m +i r))) e esize)) >>> shift_amount))
            (D_set (d +i r)
              (← (Elem_set (← (D_read (d +i r))) e esize
                  (((← (Elem_read (← (D_read (d +i r))) e esize)) &&& (Complement.complement
                        mask)) ||| shifted_op))))
            (pure shifted_op)
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec esize) )
  (pure ())

def decode_aarch32_instrs_VSRI_A1enc_A_txt (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (64 -i (UInt0 imm6))
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VSRI_Op_A_txt d elements 8 m regs shift_amount)
      | 16 => (execute_aarch32_instrs_VSRI_Op_A_txt d elements 16 m regs shift_amount)
      | 32 => (execute_aarch32_instrs_VSRI_Op_A_txt d elements 32 m regs shift_amount)
      | 64 => (execute_aarch32_instrs_VSRI_Op_A_txt d elements 64 m regs shift_amount)
      | _ => assert false "src/instrs32.sail:37204.26-37204.27")
  else (pure ())

def decode_aarch32_instrs_VSRI_T1enc_A_txt (D : (BitVec 1)) (imm6 : (BitVec 6)) (Vd : (BitVec 4)) (L : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (let b__0 := (L ++ imm6)
         bif (BEq.beq (Sail.BitVec.extractLsb b__0 6 3) (0x0 : (BitVec 4)))
         then true
         else false : Bool)
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize : Int := 8
      let elements : Int := 1
      let shift_amount ← (( do (undefined_int ()) ) : SailM Int )
      let _ : Unit :=
        let b__1 := (L ++ imm6)
        bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 3) (0x1 : (BitVec 4)))
        then
          (let esize : Int := 8
          let elements : Int := 8
          let shift_amount : Int := (16 -i (UInt0 imm6))
          ())
        else
          (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 4) (0b001 : (BitVec 3)))
          then
            (let esize : Int := 16
            let elements : Int := 4
            let shift_amount : Int := (32 -i (UInt0 imm6))
            ())
          else
            (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 5) (0b01 : (BitVec 2)))
            then
              (let esize : Int := 32
              let elements : Int := 2
              let shift_amount : Int := (64 -i (UInt0 imm6))
              ())
            else
              (bif (BEq.beq (Sail.BitVec.extractLsb b__1 6 6) (0b1 : (BitVec 1)))
              then
                (let esize : Int := 64
                let elements : Int := 1
                let shift_amount : Int := (64 -i (UInt0 imm6))
                ())
              else ())))
      let shift_amount := shift_amount
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      match esize with
      | 8 => (execute_aarch32_instrs_VSRI_Op_A_txt d elements 8 m regs shift_amount)
      | 16 => (execute_aarch32_instrs_VSRI_Op_A_txt d elements 16 m regs shift_amount)
      | 32 => (execute_aarch32_instrs_VSRI_Op_A_txt d elements 32 m regs shift_amount)
      | 64 => (execute_aarch32_instrs_VSRI_Op_A_txt d elements 64 m regs shift_amount)
      | _ => assert false "src/instrs32.sail:37282.26-37282.27")
  else (pure ())

/-- Type quantifiers: alignment : Nat, d : Nat, ebytes : Nat, index : Nat, m : Nat, n : Nat, k_register_index
  : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  ebytes ∈ {1, 2, 4} ∧ 0 ≤ d ∧ d ≤ 31 ∧ alignment ∈ {1, 2, 4} -/
def execute_aarch32_instrs_VST1_1_Op_A_txt (alignment : Nat) (d : Nat) (ebytes : Nat) (index : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_STORE nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  (MemU_set address ebytes (← (Elem_read (← (D_read d)) index (8 *i ebytes))))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) ebytes)))
  else (pure ())

def decode_aarch32_instrs_VST1_1_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let alignment := 1
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST1_1_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST1_1_A3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (bne (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
           (bne (Sail.BitVec.extractLsb index_align 1 0) (0b11 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let alignment :=
        bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST1_1_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let alignment := 1
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST1_1_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST1_1_T3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (bne (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
           (bne (Sail.BitVec.extractLsb index_align 1 0) (0b11 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let alignment :=
        bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST1_1_Op_A_txt alignment d ebytes index m n register_index wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d : Nat, ebytes : Nat, elements : Int, m : Nat, n : Nat, k_register_index
  : Bool, regs : Nat, k_wback : Bool, regs ∈ {1, 2, 3, 4} ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d ∧ d ≤ 31 ∧ alignment ∈ {1, 4, 8, 16, 32} -/
def execute_aarch32_instrs_VST1_m_Op_A_txt (alignment : Nat) (d : Nat) (ebytes : Nat) (elements : Int) (m : Nat) (n : Nat) (register_index : Bool) (regs : Nat) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_STORE nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let address ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := address
    for r in [loop_r_lower:loop_r_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := address
        for e in [loop_e_lower:loop_e_upper:1]i do
          let address := loop_vars_1
          loop_vars_1 ← do
            bif (bne ebytes 8)
            then (MemU_set address ebytes (← (Elem_read (← (D_read (d +i r))) e (8 *i ebytes))))
            else
              (do
                bif (Bool.and (Bool.not (IsAligned__1 address ebytes)) (← (AlignmentEnforced ())))
                then (AArch32_Abort address (← (AlignmentFault accdesc)))
                else (pure ())
                let data ← (( do (Elem_read (← (D_read (d +i r))) e 64) ) : SailM (BitVec 64) )
                bif (← (BigEndian AccessType_ASIMD))
                then
                  (do
                    (MemU_set address 4 (Sail.BitVec.extractLsb data 63 32))
                    (MemU_set (BitVec.addInt address 4) 4 (Sail.BitVec.extractLsb data 31 0)))
                else
                  (do
                    (MemU_set address 4 (Sail.BitVec.extractLsb data 31 0))
                    (MemU_set (BitVec.addInt address 4) 4 (Sail.BitVec.extractLsb data 63 32))))
            (pure (BitVec.addInt address ebytes))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (8 *i regs))))
  else (pure ())

def decode_aarch32_instrs_VST1_m_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 1
      bif (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:37615.173-37615.174"
      (execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VST1_m_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 2
      bif (BEq.beq align (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:37652.173-37652.174"
      (execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VST1_m_A3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 3
      bif (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:37689.173-37689.174"
      (execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VST1_m_A4enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 4
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:37723.173-37723.174"
      (execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VST1_m_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 1
      bif (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:37760.173-37760.174"
      (execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VST1_m_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 2
      bif (BEq.beq align (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:37797.173-37797.174"
      (execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VST1_m_T3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 3
      bif (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:37834.173-37834.174"
      (execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

def decode_aarch32_instrs_VST1_m_T4enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let regs := 4
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and
        (Bool.or (Bool.or (Bool.or (BEq.beq regs 1) (BEq.beq regs 2)) (BEq.beq regs 3))
          (BEq.beq regs 4))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:37868.173-37868.174"
      (execute_aarch32_instrs_VST1_m_Op_A_txt alignment d ebytes elements m n register_index regs
        wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d : Nat, d2 : Int, ebytes : Nat, index : Nat, m : Nat, n :
  Nat, k_register_index : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  ebytes ∈ {1, 2, 4} ∧ 0 ≤ d ∧ d ≤ 31 ∧ alignment ∈ {1, 2, 4, 8} -/
def execute_aarch32_instrs_VST2_1_Op_A_txt (alignment : Nat) (d : Nat) (d2 : Int) (ebytes : Nat) (index : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_STORE nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  (MemU_set address ebytes (← (Elem_read (← (D_read d)) index (8 *i ebytes))))
  (MemU_set (BitVec.addInt address ebytes) ebytes
    (← (Elem_read (← (D_read d2)) index (8 *i ebytes))))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (2 *i ebytes))))
  else (pure ())

def decode_aarch32_instrs_VST2_1_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST2_1_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST2_1_A3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST2_1_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST2_1_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST2_1_T3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d2 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST2_1_Op_A_txt alignment d d2 ebytes index m n register_index wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d : Nat, d2 : Int, ebytes : Nat, elements : Int, m : Nat, n :
  Nat, pairs : Nat, k_register_index : Bool, k_wback : Bool, pairs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d ∧ d ≤ 31 ∧ alignment ∈ {1, 4, 8, 16, 32} -/
def execute_aarch32_instrs_VST2_m_Op_A_txt (alignment : Nat) (d : Nat) (d2 : Int) (ebytes : Nat) (elements : Int) (m : Nat) (n : Nat) (pairs : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_STORE nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let address ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (pairs -i 1)
    let mut loop_vars := address
    for r in [loop_r_lower:loop_r_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        let loop_e_lower := 0
        let loop_e_upper := (elements -i 1)
        let mut loop_vars_1 := address
        for e in [loop_e_lower:loop_e_upper:1]i do
          let address := loop_vars_1
          loop_vars_1 ← do
            (MemU_set address ebytes (← (Elem_read (← (D_read (d +i r))) e (8 *i ebytes))))
            (MemU_set (BitVec.addInt address ebytes) ebytes
              (← (Elem_read (← (D_read (d2 +i r))) e (8 *i ebytes))))
            (pure (BitVec.addInt address (2 *i ebytes)))
        (pure loop_vars_1)
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (16 *i pairs))))
  else (pure ())

def decode_aarch32_instrs_VST2_m_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let pairs := 1
      bif (BEq.beq align (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let inc_name :=
        bif (BEq.beq itype (0x9 : (BitVec 4)))
        then 2
        else 1
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d2 +i pairs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (Bool.or (BEq.beq pairs 1) (BEq.beq pairs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:38187.168-38187.169"
      (execute_aarch32_instrs_VST2_m_Op_A_txt alignment d d2 ebytes elements m n pairs
        register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST2_m_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let pairs := 2
      let inc_name := 2
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d2 +i pairs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (Bool.or (BEq.beq pairs 1) (BEq.beq pairs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:38226.168-38226.169"
      (execute_aarch32_instrs_VST2_m_Op_A_txt alignment d d2 ebytes elements m n pairs
        register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST2_m_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let pairs := 1
      bif (BEq.beq align (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let inc_name :=
        bif (BEq.beq itype (0x9 : (BitVec 4)))
        then 2
        else 1
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d2 +i pairs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (Bool.or (BEq.beq pairs 1) (BEq.beq pairs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:38268.168-38268.169"
      (execute_aarch32_instrs_VST2_m_Op_A_txt alignment d d2 ebytes elements m n pairs
        register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST2_m_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let pairs := 2
      let inc_name := 2
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) ((d2 +i pairs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (Bool.or (BEq.beq pairs 1) (BEq.beq pairs 2))
        (Bool.and (0 ≤b n)
          (Bool.and (n ≤b 15)
            (Bool.and (0 ≤b m)
              (Bool.and (m ≤b 15)
                (Bool.and
                  (Bool.or
                    (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                    (BEq.beq ebytes 8))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:38307.168-38307.169"
      (execute_aarch32_instrs_VST2_m_Op_A_txt alignment d d2 ebytes elements m n pairs
        register_index wback))
  else (pure ())

/-- Type quantifiers: d : Nat, d2 : Int, d3 : Int, ebytes : Nat, index : Nat, m : Nat, n : Nat, k_register_index
  : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ ebytes ∈ {1, 2, 4} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VST3_1_Op_A_txt (d : Nat) (d2 : Int) (d3 : Int) (ebytes : Nat) (index : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  (MemU_set address ebytes (← (Elem_read (← (D_read d)) index (8 *i ebytes))))
  (MemU_set (BitVec.addInt address ebytes) ebytes
    (← (Elem_read (← (D_read d2)) index (8 *i ebytes))))
  (MemU_set (BitVec.addInt address (2 *i ebytes)) ebytes
    (← (Elem_read (← (D_read d3)) index (8 *i ebytes))))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (3 *i ebytes))))
  else (pure ())

def decode_aarch32_instrs_VST3_1_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST3_1_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST3_1_A3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST3_1_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST3_1_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST3_1_T3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST3_1_Op_A_txt d d2 d3 ebytes index m n register_index wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d : Nat, d2 : Int, d3 : Int, ebytes : Nat, elements : Int, m
  : Nat, n : Nat, k_register_index : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧ m ≤ 15 ∧ ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d ∧ d ≤ 31 ∧ alignment ∈ {1, 8} -/
def execute_aarch32_instrs_VST3_m_Op_A_txt (alignment : Nat) (d : Nat) (d2 : Int) (d3 : Int) (ebytes : Nat) (elements : Int) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_STORE nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let address ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := address
    for e in [loop_e_lower:loop_e_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        (MemU_set address ebytes (← (Elem_read (← (D_read d)) e (8 *i ebytes))))
        (MemU_set (BitVec.addInt address ebytes) ebytes
          (← (Elem_read (← (D_read d2)) e (8 *i ebytes))))
        (MemU_set (BitVec.addInt address (2 *i ebytes)) ebytes
          (← (Elem_read (← (D_read d3)) e (8 *i ebytes))))
        (pure (BitVec.addInt address (3 *i ebytes)))
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) 24)))
  else (pure ())

def decode_aarch32_instrs_VST3_m_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let inc_name : Int := 1
      let b__0 := itype
      bif (BEq.beq b__0 (0x4 : (BitVec 4)))
      then
        (let inc_name : Int := 1
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0x5 : (BitVec 4)))
          then
            (let inc_name : Int := 2
            (pure ()))
          else sailThrow ((Error_See "Related encodings")))
      let inc_name := inc_name
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST3_m_Op_A_txt alignment d d2 d3 ebytes elements m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VST3_m_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (BEq.beq (BitVec.join1 [(BitVec.access align 1)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let inc_name : Int := 1
      let b__0 := itype
      bif (BEq.beq b__0 (0x4 : (BitVec 4)))
      then
        (let inc_name : Int := 1
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0x5 : (BitVec 4)))
          then
            (let inc_name : Int := 2
            (pure ()))
          else sailThrow ((Error_See "Related encodings")))
      let inc_name := inc_name
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d3 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST3_m_Op_A_txt alignment d d2 d3 ebytes elements m n register_index
        wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d : Nat, d2 : Int, d3 : Int, d4 : Int, ebytes : Nat, index :
  Nat, m : Nat, n : Nat, k_register_index : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  index ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧
  ebytes ∈ {1, 2, 4} ∧ 0 ≤ d ∧ d ≤ 31 ∧ alignment ∈ {1, 4, 8, 16, 32} -/
def execute_aarch32_instrs_VST4_1_Op_A_txt (alignment : Nat) (d : Nat) (d2 : Int) (d3 : Int) (d4 : Int) (ebytes : Nat) (index : Nat) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_STORE nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  (MemU_set address ebytes (← (Elem_read (← (D_read d)) index (8 *i ebytes))))
  (MemU_set (BitVec.addInt address ebytes) ebytes
    (← (Elem_read (← (D_read d2)) index (8 *i ebytes))))
  (MemU_set (BitVec.addInt address (2 *i ebytes)) ebytes
    (← (Elem_read (← (D_read d3)) index (8 *i ebytes))))
  (MemU_set (BitVec.addInt address (3 *i ebytes)) ebytes
    (← (Elem_read (← (D_read d4)) index (8 *i ebytes))))
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) (4 *i ebytes))))
  else (pure ())

def decode_aarch32_instrs_VST4_1_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VST4_1_A2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b01 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VST4_1_A3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b10 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 (Sail.BitVec.extractLsb index_align 1 0)))
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 15)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 15)
              (Bool.and
                (Bool.or
                  (Bool.or
                    (Bool.or
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                          (BEq.beq index 3)) (BEq.beq index 4)) (BEq.beq index 5)) (BEq.beq index 6))
                  (BEq.beq index 7))
                (Bool.and
                  (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:38846.183-38846.184"
      (execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VST4_1_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let ebytes := 1
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 1))
      let inc_name := 1
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 4
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VST4_1_T2enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b01 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let ebytes := 2
      let index := (UInt0 (Sail.BitVec.extractLsb index_align 3 2))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 1)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 0)]) (0b0 : (BitVec 1)))
        then 1
        else 8
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

def decode_aarch32_instrs_VST4_1_T3enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (index_align : (BitVec 4)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b10 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let ebytes := 4
      let index := (UInt0 (BitVec.join1 [(BitVec.access index_align 3)]))
      let inc_name :=
        bif (BEq.beq (BitVec.join1 [(BitVec.access index_align 2)]) (0b0 : (BitVec 1)))
        then 1
        else 2
      let alignment :=
        bif (BEq.beq (Sail.BitVec.extractLsb index_align 1 0) (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 (Sail.BitVec.extractLsb index_align 1 0)))
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 15)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 15)
              (Bool.and
                (Bool.or
                  (Bool.or
                    (Bool.or
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
                          (BEq.beq index 3)) (BEq.beq index 4)) (BEq.beq index 5)) (BEq.beq index 6))
                  (BEq.beq index 7))
                (Bool.and
                  (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                  (Bool.and (0 ≤b d)
                    (Bool.and (d ≤b 31)
                      (Bool.or
                        (Bool.or
                          (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                            (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32)))))))))) "src/instrs32.sail:38974.183-38974.184"
      (execute_aarch32_instrs_VST4_1_Op_A_txt alignment d d2 d3 d4 ebytes index m n register_index
        wback))
  else (pure ())

/-- Type quantifiers: alignment : Nat, d : Nat, d2 : Int, d3 : Int, d4 : Int, ebytes : Nat, elements
  : Int, m : Nat, n : Nat, k_register_index : Bool, k_wback : Bool, 0 ≤ n ∧
  n ≤ 15 ∧
  0 ≤ m ∧
  m ≤ 15 ∧ ebytes ∈ {1, 2, 4, 8} ∧ 0 ≤ d ∧ d ≤ 31 ∧ alignment ∈ {1, 4, 8, 16, 32} -/
def execute_aarch32_instrs_VST4_m_Op_A_txt (alignment : Nat) (d : Nat) (d2 : Int) (d3 : Int) (d4 : Int) (ebytes : Nat) (elements : Int) (m : Nat) (n : Nat) (register_index : Bool) (wback : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let nontemporal : Bool := false
  let tagchecked : Bool := false
  let accdesc ← (( do (CreateAccDescASIMD MemOp_STORE nontemporal tagchecked) ) : SailM
    AccessDescriptor )
  bif (Bool.not (IsAligned__1 address alignment))
  then (AArch32_Abort address (← (AlignmentFault accdesc)))
  else (pure ())
  let address ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := address
    for e in [loop_e_lower:loop_e_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        (MemU_set address ebytes (← (Elem_read (← (D_read d)) e (8 *i ebytes))))
        (MemU_set (BitVec.addInt address ebytes) ebytes
          (← (Elem_read (← (D_read d2)) e (8 *i ebytes))))
        (MemU_set (BitVec.addInt address (2 *i ebytes)) ebytes
          (← (Elem_read (← (D_read d3)) e (8 *i ebytes))))
        (MemU_set (BitVec.addInt address (3 *i ebytes)) ebytes
          (← (Elem_read (← (D_read d4)) e (8 *i ebytes))))
        (pure (BitVec.addInt address (4 *i ebytes)))
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif wback
  then
    (do
      bif register_index
      then (R_set n ((← (R_read n)) + (← (R_read m))))
      else (R_set n (BitVec.addInt (← (R_read n)) 32)))
  else (pure ())

def decode_aarch32_instrs_VST4_m_A1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let inc_name : Int := 1
      let b__0 := itype
      bif (BEq.beq b__0 (0x0 : (BitVec 4)))
      then
        (let inc_name : Int := 1
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0x1 : (BitVec 4)))
          then
            (let inc_name : Int := 2
            (pure ()))
          else sailThrow ((Error_See "Related encodings")))
      let inc_name := inc_name
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 15)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 15)
              (Bool.and
                (Bool.or
                  (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                  (BEq.beq ebytes 8))
                (Bool.and (0 ≤b d)
                  (Bool.and (d ≤b 31)
                    (Bool.or
                      (Bool.or
                        (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                          (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32))))))))) "src/instrs32.sail:39055.149-39055.150"
      (execute_aarch32_instrs_VST4_m_Op_A_txt alignment d d2 d3 d4 ebytes elements m n
        register_index wback))
  else (pure ())

def decode_aarch32_instrs_VST4_m_T1enc_A_txt (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (itype : (BitVec 4)) (size : (BitVec 2)) (align : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let inc_name : Int := 1
      let b__0 := itype
      bif (BEq.beq b__0 (0x0 : (BitVec 4)))
      then
        (let inc_name : Int := 1
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0x1 : (BitVec 4)))
          then
            (let inc_name : Int := 2
            (pure ()))
          else sailThrow ((Error_See "Related encodings")))
      let inc_name := inc_name
      let alignment :=
        bif (BEq.beq align (0b00 : (BitVec 2)))
        then 1
        else (Int.shiftl 4 (UInt0 align))
      let ebytes := (Int.shiftl 1 (UInt0 size))
      let elements := (ediv_nat 8 ebytes)
      let d := (UInt0 (D ++ Vd))
      let d2 := (d +i inc_name)
      let d3 := (d2 +i inc_name)
      let d4 := (d3 +i inc_name)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let wback : Bool := (bne m 15)
      let register_index : Bool := (Bool.and (bne m 15) (bne m 13))
      bif (Bool.or (BEq.beq n 15) (d4 >b 31))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      assert (Bool.and (0 ≤b n)
        (Bool.and (n ≤b 15)
          (Bool.and (0 ≤b m)
            (Bool.and (m ≤b 15)
              (Bool.and
                (Bool.or
                  (Bool.or (Bool.or (BEq.beq ebytes 1) (BEq.beq ebytes 2)) (BEq.beq ebytes 4))
                  (BEq.beq ebytes 8))
                (Bool.and (0 ≤b d)
                  (Bool.and (d ≤b 31)
                    (Bool.or
                      (Bool.or
                        (Bool.or (Bool.or (BEq.beq alignment 1) (BEq.beq alignment 4))
                          (BEq.beq alignment 8)) (BEq.beq alignment 16)) (BEq.beq alignment 32))))))))) "src/instrs32.sail:39107.149-39107.150"
      (execute_aarch32_instrs_VST4_m_Op_A_txt alignment d d2 d3 d4 ebytes elements m n
        register_index wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, d : Nat, n : Nat, regs : Int, k_single_regs : Bool, k_wback :
  Bool, 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VSTM_Op_A_txt (add : Bool) (d : Nat) (imm32 : (BitVec 32)) (n : Nat) (regs : Int) (single_regs : Bool) (wback : Bool) : SailM Unit := do
  (CheckVFPEnabled true)
  let address ← (( do
    bif add
    then (R_read n)
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  let address ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := address
    for r in [loop_r_lower:loop_r_upper:1]i do
      let address := loop_vars
      loop_vars ← do
        bif single_regs
        then
          (do
            (MemA_set address 4 (← (S_read (d +i r))))
            (pure (BitVec.addInt address 4)))
        else
          (do
            bif (← (BigEndian AccessType_ASIMD))
            then
              (do
                (MemA_set address 4 (Sail.BitVec.extractLsb (← (D_read (d +i r))) 63 32))
                (MemA_set (BitVec.addInt address 4) 4
                  (Sail.BitVec.extractLsb (← (D_read (d +i r))) 31 0)))
            else
              (do
                (MemA_set address 4 (Sail.BitVec.extractLsb (← (D_read (d +i r))) 31 0))
                (MemA_set (BitVec.addInt address 4) 4
                  (Sail.BitVec.extractLsb (← (D_read (d +i r))) 63 32)))
            (pure (BitVec.addInt address 8)))
    (pure loop_vars) ) : SailM (BitVec 32) )
  bif wback
  then
    (R_set n
      (← do
        bif add
        then (pure ((← (R_read n)) + imm32))
        else (pure ((← (R_read n)) - imm32))))
  else (pure ())

def decode_aarch32_instrs_VSTM_A1enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (D : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:39157.29-39157.30"
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VSTR"))
      else (pure ())
      bif (Bool.and (BEq.beq P U) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let single_regs : Bool := false
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let regs := (ediv_nat (UInt0 imm8) 2)
      bif (Bool.and (BEq.beq n 15) (Bool.or wback (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (BEq.beq regs 0) (regs >b 16)) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access imm8 0)]) (0b1 : (BitVec 1)))
           ((d +i regs) >b 16))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VSTM_Op_A_txt add d imm32 n regs single_regs wback))
  else (pure ())

def decode_aarch32_instrs_VSTM_A2enc_A_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (D : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:39205.29-39205.30"
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VSTR"))
      else (pure ())
      bif (Bool.and (BEq.beq P U) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let single_regs : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let d := (UInt0 (Vd ++ D))
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let regs := (UInt0 imm8)
      bif (Bool.and (BEq.beq n 15) (Bool.or wback (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq regs 0) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VSTM_Op_A_txt add d imm32 n regs single_regs wback))
  else (pure ())

def decode_aarch32_instrs_VSTM_T1enc_A_txt (P : (BitVec 1)) (U : (BitVec 1)) (D : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VSTR"))
      else (pure ())
      bif (Bool.and (BEq.beq P U) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let single_regs : Bool := false
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let regs := (ediv_nat (UInt0 imm8) 2)
      bif (Bool.and (BEq.beq n 15) (Bool.or wback (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (BEq.beq regs 0) (regs >b 16)) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access imm8 0)]) (0b1 : (BitVec 1)))
           ((d +i regs) >b 16))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VSTM_Op_A_txt add d imm32 n regs single_regs wback))
  else (pure ())

def decode_aarch32_instrs_VSTM_T2enc_A_txt (P : (BitVec 1)) (U : (BitVec 1)) (D : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (Bool.and (BEq.beq P (0b0 : (BitVec 1))) (BEq.beq U (0b0 : (BitVec 1))))
           (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.and (BEq.beq P (0b1 : (BitVec 1))) (BEq.beq W (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "VSTR"))
      else (pure ())
      bif (Bool.and (BEq.beq P U) (BEq.beq W (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let single_regs : Bool := true
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let d := (UInt0 (Vd ++ D))
      let n := (UInt0 Rn)
      let imm32 : (BitVec 32) := (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let regs := (UInt0 imm8)
      bif (Bool.and (BEq.beq n 15) (Bool.or wback (neq_any (← (CurrentInstrSet ())) InstrSet_A32)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq regs 0) ((d +i regs) >b 32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VSTM_Op_A_txt add d imm32 n regs single_regs wback))
  else (pure ())

/-- Type quantifiers: k_add : Bool, d : Nat, esize : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 15 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VSTR_Op_A_txt (add : Bool) (d : Nat) (esize : Nat) (imm32 : (BitVec 32)) (n : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  let address ← (( do
    bif add
    then (pure ((← (R_read n)) + imm32))
    else (pure ((← (R_read n)) - imm32)) ) : SailM (BitVec 32) )
  match esize with
  | 16 => (MemA_set address 2 (Sail.BitVec.extractLsb (← (S_read d)) 15 0))
  | 32 => (MemA_set address 4 (← (S_read d)))
  | 64 => (do
      bif (← (BigEndian AccessType_ASIMD))
      then
        (do
          (MemA_set address 4 (Sail.BitVec.extractLsb (← (D_read d)) 63 32))
          (MemA_set (BitVec.addInt address 4) 4 (Sail.BitVec.extractLsb (← (D_read d)) 31 0)))
      else
        (do
          (MemA_set address 4 (Sail.BitVec.extractLsb (← (D_read d)) 31 0))
          (MemA_set (BitVec.addInt address 4) 4 (Sail.BitVec.extractLsb (← (D_read d)) 63 32))))
  | _ => (pure ())

def decode_aarch32_instrs_VSTR_A1enc_A_txt (cond : (BitVec 4)) (U : (BitVec 1)) (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:39367.29-39367.30"
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let imm32 : (BitVec 32) :=
        bif (BEq.beq esize 16)
        then (zero_extend (imm8 ++ (0b0 : (BitVec 1))) 32)
        else (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let d : Nat := (UInt0 (Vd ++ D))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let d : Nat := (UInt0 (Vd ++ D))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let d : Nat := (UInt0 (D ++ Vd))
              ())
            else ()))
      let d := d
      let n := (UInt0 Rn)
      bif (Bool.and (BEq.beq n 15) (neq_any (← (CurrentInstrSet ())) InstrSet_A32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let d := d
      (execute_aarch32_instrs_VSTR_Op_A_txt add d esize imm32 n))
  else (pure ())

def decode_aarch32_instrs_VSTR_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (Rn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (imm8 : (BitVec 8)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let add : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let imm32 : (BitVec 32) :=
        bif (BEq.beq esize 16)
        then (zero_extend (imm8 ++ (0b0 : (BitVec 1))) 32)
        else (zero_extend (imm8 ++ (0b00 : (BitVec 2))) 32)
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let d : Nat := (UInt0 (Vd ++ D))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let d : Nat := (UInt0 (Vd ++ D))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let d : Nat := (UInt0 (D ++ Vd))
              ())
            else ()))
      let d := d
      let n := (UInt0 Rn)
      bif (Bool.and (BEq.beq n 15) (neq_any (← (CurrentInstrSet ())) InstrSet_A32))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let d := d
      (execute_aarch32_instrs_VSTR_Op_A_txt add d esize imm32 n))
  else (pure ())

/-- Type quantifiers: k_advsimd : Bool, d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, regs
  : Int, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSUB_f_Op_A_txt (advsimd : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Int) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif advsimd
  then
    (do
      let loop_r_lower := 0
      let loop_r_upper := (regs -i 1)
      let mut loop_vars := ()
      for r in [loop_r_lower:loop_r_upper:1]i do
        let () := loop_vars
        loop_vars ← do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := ()
          for e in [loop_e_lower:loop_e_upper:1]i do
            let () := loop_vars_1
            loop_vars_1 ← do
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) e esize
                    (← (FPSub (← (Elem_read (← (D_read (n +i r))) e esize))
                        (← (Elem_read (← (D_read (m +i r))) e esize))
                        (← (StandardFPSCRValue ())))))))
          (pure loop_vars_1)
      (pure loop_vars))
  else
    (do
      match esize with
      | 16 => (S_set d
          ((Zeros (n := 16)) ++ (← (FPSub (Sail.BitVec.extractLsb (← (S_read n)) 15 0)
                (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ()))))))
      | 32 => (S_set d (← (FPSub (← (S_read n)) (← (S_read m)) (← (FPSCR_read ())))))
      | 64 => (D_set d (← (FPSub (← (D_read n)) (← (D_read m)) (← (FPSCR_read ())))))
      | _ => (pure ()))

def decode_aarch32_instrs_VSUB_f_A1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let advsimd : Bool := true
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VSUB_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VSUB_f_A2enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:39545.29-39545.30"
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let advsimd : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VSUB_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VSUB_f_T1enc_A_txt (D : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let advsimd : Bool := true
      let esize : Int := 16
      let elements : Int := 2
      let _ : Unit :=
        let b__0 := sz
        bif (BEq.beq b__0 (0b0 : (BitVec 1)))
        then
          (let esize : Int := 32
          let elements : Int := 2
          ())
        else
          (let esize : Int := 16
          let elements : Int := 4
          ())
      let esize := esize
      let elements := elements
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VSUB_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VSUB_f_T2enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let elements ← (( do (undefined_int ()) ) : SailM Int )
      let regs ← (( do (undefined_int ()) ) : SailM Int )
      bif (Bool.or (bne (_get_FPSCR_Type_length (← (FPSCR_read__1 ()))) (0b000 : (BitVec 3)))
           (bne (_get_FPSCR_Type_Stride (← (FPSCR_read__1 ()))) (0b00 : (BitVec 2))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let regs := regs
      let elements := elements
      let advsimd : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let n ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let n : Nat := (UInt0 (Vn ++ N))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let n : Nat := (UInt0 (Vn ++ N))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let n : Nat := (UInt0 (N ++ Vn))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let n := n
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VSUB_f_Op_A_txt advsimd d elements esize m n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSUBHN_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_bitvector (2 *i esize)) ) : SailM (BitVec (2 * esize)) )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let result ←
          (pure ((← (Elem_read (← (Qin_read (Int.shiftl n 1))) e (2 *i esize))) - (← (Elem_read
                  (← (Qin_read (Int.shiftl m 1))) e (2 *i esize)))))
        (D_set d
          (← (Elem_set (← (D_read d)) e esize
              (Sail.BitVec.extractLsb result ((2 *i esize) -i 1) esize))))
        (pure result)
    (pure loop_vars) ) : SailM (BitVec (2 * esize)) )
  (pure ())

def decode_aarch32_instrs_VSUBHN_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VSUBHN_Op_A_txt d elements esize m n))
  else (pure ())

def decode_aarch32_instrs_VSUBHN_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VSUBHN_Op_A_txt d elements esize m n))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSUB_i_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                ((← (Elem_read (← (D_read (n +i r))) e esize)) - (← (Elem_read
                      (← (D_read (m +i r))) e esize))))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VSUB_i_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VSUB_i_Op_A_txt d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VSUB_i_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VSUB_i_Op_A_txt d elements esize m n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, k_is_unsigned : Bool, k_is_vsubw :
  Bool, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VSUBL_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (is_vsubw : Bool) (m : Nat) (n : Nat) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  let result ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let op1 ← (( do (undefined_int ()) ) : SailM Int )
        let op1 ← (( do
          bif is_vsubw
          then
            (do
              (asl_Int (← (Elem_read (← (Qin_read (Int.shiftl n 1))) e (2 *i esize)))
                is_unsigned))
          else
            (do
              (asl_Int (← (Elem_read (← (Din_read n)) e esize)) is_unsigned)) ) : SailM Int )
        let op1 := op1
        let result ←
          (pure (op1 -i (← (asl_Int (← (Elem_read (← (Din_read m)) e esize)) is_unsigned))))
        (Q_set (Int.shiftr d 1)
          (← (Elem_set (← (Q_read (Int.shiftr d 1))) e (2 *i esize)
              (integer_subrange result ((2 *i esize) -i 1) 0))))
        (pure result)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VSUBL_A1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (Bool.and (BEq.beq op (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let is_vsubw : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VSUBL_Op_A_txt d elements esize is_vsubw m n is_unsigned))
  else (pure ())

def decode_aarch32_instrs_VSUBL_T1enc_A_txt (U : (BitVec 1)) (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (op : (BitVec 1)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (Bool.and (BEq.beq op (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let is_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let is_vsubw : Bool := (BEq.beq op (0b1 : (BitVec 1)))
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VSUBL_Op_A_txt d elements esize is_vsubw m n is_unsigned))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VSWP_Op_A_txt (d : Nat) (m : Nat) (regs : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (BEq.beq d m)
      then (D_set (d +i r) (← (__UNKNOWN_bits 64)))
      else
        (do
          (D_set (d +i r) (← (Din_read (m +i r))))
          (D_set (m +i r) (← (Din_read (d +i r)))))
  (pure loop_vars)

def decode_aarch32_instrs_VSWP_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VSWP_Op_A_txt d m regs))
  else (pure ())

def decode_aarch32_instrs_VSWP_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VSWP_Op_A_txt d m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, k_is_vtbl : Bool, length : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ length ∈ {1, 2, 3, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VTBL_Op_A_txt (d__arg : Nat) (is_vtbl : Bool) (length : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let d : Int := d__arg
  let index ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let table3 ← (( do
    bif (BEq.beq length 4)
    then (D_read (n +i 3))
    else (pure (Zeros (n := 64))) ) : SailM (BitVec 64) )
  let table2 ← (( do
    bif (length ≥b 3)
    then (D_read (n +i 2))
    else (pure (Zeros (n := 64))) ) : SailM (BitVec 64) )
  let table1 ← (( do
    bif (length ≥b 2)
    then (D_read (n +i 1))
    else (pure (Zeros (n := 64))) ) : SailM (BitVec 64) )
  let table ← (( do (pure (((table3 ++ table2) ++ table1) ++ (← (D_read n)))) ) : SailM
    (BitVec 256) )
  let index ← (( do
    let loop_i_lower := 0
    let loop_i_upper := 7
    let mut loop_vars := index
    for i in [loop_i_lower:loop_i_upper:1]i do
      let index := loop_vars
      loop_vars ← do
        let index ← (pure (UInt0 (← (Elem_read (← (D_read m)) i 8))))
        let index := index
        bif (index <b (8 *i length))
        then (D_set d (← (Elem_set (← (D_read d)) i 8 (← (Elem_read table index 8)))))
        else
          (do
            bif is_vtbl
            then (D_set d (← (Elem_set (← (D_read d)) i 8 (Zeros (n := 8)))))
            else (pure ()))
        (pure index)
    (pure loop_vars) ) : SailM Int )
  (pure ())

def decode_aarch32_instrs_VTBL_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (len : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let is_vtbl : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let length := ((UInt0 len) +i 1)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      bif ((n +i length) >b 32)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VTBL_Op_A_txt d is_vtbl length m n))
  else (pure ())

def decode_aarch32_instrs_VTBL_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (len : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let is_vtbl : Bool := (BEq.beq op (0b0 : (BitVec 1)))
      let length := ((UInt0 len) +i 1)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      bif ((n +i length) >b 32)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VTBL_Op_A_txt d is_vtbl length m n))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m__arg : Nat, regs : Nat, regs ∈
  {1, 2} ∧
  0 ≤ m__arg ∧ m__arg ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VTRN_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m__arg : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  let m : Int := m__arg
  (CheckAdvSIMDEnabled ())
  let h := (fdiv_int elements 2)
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      bif (BEq.beq d m)
      then (D_set (d +i r) (← (__UNKNOWN_bits 64)))
      else
        (do
          let loop_e_lower := 0
          let loop_e_upper := (h -i 1)
          let mut loop_vars_1 := ()
          for e in [loop_e_lower:loop_e_upper:1]i do
            let () := loop_vars_1
            loop_vars_1 ← do
              (D_set (d +i r)
                (← (Elem_set (← (D_read (d +i r))) ((2 *i e) +i 1) esize
                    (← (Elem_read (← (Din_read (m +i r))) (2 *i e) esize)))))
              (D_set (m +i r)
                (← (Elem_set (← (D_read (m +i r))) (2 *i e) esize
                    (← (Elem_read (← (Din_read (d +i r))) ((2 *i e) +i 1) esize)))))
          (pure loop_vars_1))
  (pure loop_vars)

def decode_aarch32_instrs_VTRN_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VTRN_Op_A_txt d elements esize m regs))
  else (pure ())

def decode_aarch32_instrs_VTRN_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VTRN_Op_A_txt d elements esize m regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VTST_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          bif (Bool.not
               (IsZero
                 ((← (Elem_read (← (D_read (n +i r))) e esize)) &&& (← (Elem_read
                       (← (D_read (m +i r))) e esize)))))
          then (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize (Ones (n := esize)))))
          else
            (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize (Zeros (n := esize)))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VTST_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VTST_Op_A_txt d elements esize m n regs))
  else (pure ())

def decode_aarch32_instrs_VTST_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or
             (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
               (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (BEq.beq size (0b11 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let esize := (Int.shiftl 8 (UInt0 size))
      let elements := (ediv_nat 64 esize)
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      let regs :=
        bif (BEq.beq Q (0b0 : (BitVec 1)))
        then 1
        else 2
      (execute_aarch32_instrs_VTST_Op_A_txt d elements esize m n regs))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, esize : Nat, m__arg : Nat, k_quadword_operation : Bool, 0 ≤
  m__arg ∧ m__arg ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VUZP_Op_A_txt (d__arg : Nat) (esize : Nat) (m__arg : Nat) (quadword_operation : Bool) : SailM Unit := do
  let d : Int := d__arg
  let m : Int := m__arg
  let zipped_d ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let zipped_q ← (( do (undefined_bitvector 256) ) : SailM (BitVec 256) )
  (CheckAdvSIMDEnabled ())
  bif quadword_operation
  then
    (do
      bif (BEq.beq d m)
      then (Q_set (Int.shiftr d 1) (← (__UNKNOWN_bits 128)))
      else
        (do
          let zipped_q ← (( do
            (pure ((← (Q_read (Int.shiftr m 1))) ++ (← (Q_read (Int.shiftr d 1))))) ) : SailM
            (BitVec 256) )
          let loop_e_lower := 0
          let loop_e_upper := ((ediv_nat 128 esize) -i 1)
          let mut loop_vars_1 := ()
          for e in [loop_e_lower:loop_e_upper:1]i do
            let () := loop_vars_1
            loop_vars_1 ← do
              (Q_set (Int.shiftr d 1)
                (← (Elem_set (← (Q_read (Int.shiftr d 1))) e esize
                    (← (Elem_read zipped_q (2 *i e) esize)))))
              (Q_set (Int.shiftr m 1)
                (← (Elem_set (← (Q_read (Int.shiftr m 1))) e esize
                    (← (Elem_read zipped_q ((2 *i e) +i 1) esize)))))
          (pure loop_vars_1)))
  else
    (do
      bif (BEq.beq d m)
      then (D_set d (← (__UNKNOWN_bits 64)))
      else
        (do
          let zipped_d ← (( do (pure ((← (D_read m)) ++ (← (D_read d)))) ) : SailM
            (BitVec 128) )
          let loop_e_lower := 0
          let loop_e_upper := ((ediv_nat 64 esize) -i 1)
          let mut loop_vars := ()
          for e in [loop_e_lower:loop_e_upper:1]i do
            let () := loop_vars
            loop_vars ← do
              (D_set d
                (← (Elem_set (← (D_read d)) e esize (← (Elem_read zipped_d (2 *i e) esize)))))
              (D_set m
                (← (Elem_set (← (D_read m)) e esize
                    (← (Elem_read zipped_d ((2 *i e) +i 1) esize)))))
          (pure loop_vars)))

def decode_aarch32_instrs_VUZP_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (Bool.and (BEq.beq Q (0b0 : (BitVec 1))) (BEq.beq size (0b10 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let quadword_operation : Bool := (BEq.beq Q (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VUZP_Op_A_txt d esize m quadword_operation))
  else (pure ())

def decode_aarch32_instrs_VUZP_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (Bool.and (BEq.beq Q (0b0 : (BitVec 1))) (BEq.beq size (0b10 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let quadword_operation : Bool := (BEq.beq Q (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VUZP_Op_A_txt d esize m quadword_operation))
  else (pure ())

/-- Type quantifiers: d : Nat, esize : Nat, m : Nat, k_quadword_operation : Bool, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {8, 16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VZIP_Op_A_txt (d : Nat) (esize : Nat) (m : Nat) (quadword_operation : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  bif quadword_operation
  then
    (do
      bif (BEq.beq d m)
      then (Q_set (Int.shiftl d 1) (← (__UNKNOWN_bits 128)))
      else
        (do
          let zipped_q ← (( do (undefined_bitvector 256) ) : SailM (BitVec 256) )
          let zipped_q ← (( do
            let loop_e_lower := 0
            let loop_e_upper := ((ediv_nat 128 esize) -i 1)
            let mut loop_vars_1 := zipped_q
            for e in [loop_e_lower:loop_e_upper:1]i do
              let zipped_q := loop_vars_1
              loop_vars_1 ← do
                let zipped_q ←
                  (Elem_set zipped_q (2 *i e) esize
                    (← (Elem_read (← (Q_read (Int.shiftl d 1))) e esize)))
                (Elem_set zipped_q ((2 *i e) +i 1) esize
                  (← (Elem_read (← (Q_read (Int.shiftl m 1))) e esize)))
            (pure loop_vars_1) ) : SailM (BitVec 256) )
          (Q_set (Int.shiftl d 1) (Sail.BitVec.extractLsb zipped_q 127 0))
          (Q_set (Int.shiftl m 1) (Sail.BitVec.extractLsb zipped_q 255 128))))
  else
    (do
      bif (BEq.beq d m)
      then (D_set d (← (__UNKNOWN_bits 64)))
      else
        (do
          let zipped_d ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
          let zipped_d ← (( do
            let loop_e_lower := 0
            let loop_e_upper := ((ediv_nat 64 esize) -i 1)
            let mut loop_vars := zipped_d
            for e in [loop_e_lower:loop_e_upper:1]i do
              let zipped_d := loop_vars
              loop_vars ← do
                let zipped_d ←
                  (Elem_set zipped_d (2 *i e) esize (← (Elem_read (← (D_read d)) e esize)))
                (Elem_set zipped_d ((2 *i e) +i 1) esize (← (Elem_read (← (D_read m)) e esize)))
            (pure loop_vars) ) : SailM (BitVec 128) )
          (D_set d (Sail.BitVec.extractLsb zipped_d 63 0))
          (D_set m (Sail.BitVec.extractLsb zipped_d 127 64))))

def decode_aarch32_instrs_VZIP_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (Bool.and (BEq.beq Q (0b0 : (BitVec 1))) (BEq.beq size (0b10 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let quadword_operation : Bool := (BEq.beq Q (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VZIP_Op_A_txt d esize m quadword_operation))
  else (pure ())

def decode_aarch32_instrs_VZIP_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b11 : (BitVec 2)))
           (Bool.and (BEq.beq Q (0b0 : (BitVec 1))) (BEq.beq size (0b10 : (BitVec 2)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let quadword_operation : Bool := (BEq.beq Q (0b1 : (BitVec 1)))
      let esize := (Int.shiftl 8 (UInt0 size))
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_VZIP_Op_A_txt d esize m quadword_operation))
  else (pure ())

def execute_aarch32_instrs_WFE_Op_A_txt (_ : Unit) : SailM Unit := do
  bif (← (IsEventRegisterSet ()))
  then (ClearEventRegister ())
  else
    (do
      bif (BEq.beq (← readReg PSTATE).EL EL0)
      then (AArch32_CheckForWFxTrap EL1 WFxType_WFE)
      else (pure ())
      bif (Bool.and
           (Bool.and
             (Bool.or (BEq.beq (← readReg PSTATE).EL EL0) (BEq.beq (← readReg PSTATE).EL EL1))
             (← (EL2Enabled ()))) (Bool.not (← (IsInHost ()))))
      then (AArch32_CheckForWFxTrap EL2 WFxType_WFE)
      else (pure ())
      bif (Bool.and (HaveEL EL3) (bne (← readReg PSTATE).M M32_Monitor))
      then (AArch32_CheckForWFxTrap EL3 WFxType_WFE)
      else (pure ())
      let localtimeout := (Int.shiftl 1 64)
      (WaitForEvent localtimeout))

def decode_aarch32_instrs_WFE_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:40507.29-40507.30"
      (execute_aarch32_instrs_WFE_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_WFE_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_WFE_Op_A_txt ())
  else (pure ())

def decode_aarch32_instrs_WFE_T2enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_WFE_Op_A_txt ())
  else (pure ())

def execute_aarch32_instrs_WFI_Op_A_txt (_ : Unit) : SailM Unit := do
  bif (Bool.not (← (InterruptPending ())))
  then
    (do
      bif (BEq.beq (← readReg PSTATE).EL EL0)
      then (AArch32_CheckForWFxTrap EL1 WFxType_WFI)
      else (pure ())
      bif (Bool.and
           (Bool.and
             (Bool.or (BEq.beq (← readReg PSTATE).EL EL0) (BEq.beq (← readReg PSTATE).EL EL1))
             (← (EL2Enabled ()))) (Bool.not (← (IsInHost ()))))
      then (AArch32_CheckForWFxTrap EL2 WFxType_WFI)
      else (pure ())
      bif (Bool.and (HaveEL EL3) (bne (← readReg PSTATE).M M32_Monitor))
      then (AArch32_CheckForWFxTrap EL3 WFxType_WFI)
      else (pure ())
      let localtimeout := (Int.shiftl 1 64)
      (WaitForInterrupt localtimeout))
  else (pure ())

def decode_aarch32_instrs_WFI_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:40578.29-40578.30"
      (execute_aarch32_instrs_WFI_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_WFI_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_WFI_Op_A_txt ())
  else (pure ())

def decode_aarch32_instrs_WFI_T2enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_WFI_Op_A_txt ())
  else (pure ())

def execute_aarch32_instrs_YIELD_Op_A_txt (_ : Unit) : Unit :=
  (Hint_Yield ())

def decode_aarch32_instrs_YIELD_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:40636.29-40636.30"
      (pure (execute_aarch32_instrs_YIELD_Op_A_txt ())))
  else (pure ())

def decode_aarch32_instrs_YIELD_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_YIELD_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_YIELD_T2enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_YIELD_Op_A_txt ()))
  else (pure ())

/-- Type quantifiers: k_affectA : Bool, k_affectF : Bool, k_affectI : Bool, k_changemode : Bool, k_disable
  : Bool, k_enable : Bool -/
def execute_aarch32_instrs_CPS_OpT_AS_txt (affectA : Bool) (affectF : Bool) (affectI : Bool) (changemode : Bool) (disable : Bool) (enable : Bool) (mode : (BitVec 5)) : SailM Unit := do
  bif (bne (← readReg PSTATE).EL EL0)
  then
    (do
      bif enable
      then
        (do
          bif affectA
          then writeReg PSTATE { (← readReg PSTATE) with A := (0b0 : (BitVec 1)) }
          else (pure ())
          bif affectI
          then writeReg PSTATE { (← readReg PSTATE) with I := (0b0 : (BitVec 1)) }
          else (pure ())
          bif affectF
          then writeReg PSTATE { (← readReg PSTATE) with F := (0b0 : (BitVec 1)) }
          else (pure ()))
      else (pure ())
      bif disable
      then
        (do
          bif affectA
          then writeReg PSTATE { (← readReg PSTATE) with A := (0b1 : (BitVec 1)) }
          else (pure ())
          bif affectI
          then writeReg PSTATE { (← readReg PSTATE) with I := (0b1 : (BitVec 1)) }
          else (pure ())
          bif affectF
          then writeReg PSTATE { (← readReg PSTATE) with F := (0b1 : (BitVec 1)) }
          else (pure ()))
      else (pure ())
      bif changemode
      then (AArch32_WriteModeByInstr mode)
      else (pure ()))
  else (pure ())

def decode_aarch32_instrs_CPS_A1enc_AS_txt (imod : (BitVec 2)) (M : (BitVec 1)) (A : (BitVec 1)) (I : (BitVec 1)) (F : (BitVec 1)) (mode : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (bne mode (0b00000 : (BitVec 5))) (BEq.beq M (0b0 : (BitVec 1))))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.or
       (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access imod 1)]) (0b1 : (BitVec 1)))
         (BEq.beq ((A ++ I) ++ F) (0b000 : (BitVec 3))))
       (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access imod 1)]) (0b0 : (BitVec 1)))
         (bne ((A ++ I) ++ F) (0b000 : (BitVec 3)))))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let enable : Bool := (BEq.beq imod (0b10 : (BitVec 2)))
  let disable : Bool := (BEq.beq imod (0b11 : (BitVec 2)))
  let changemode : Bool := (BEq.beq M (0b1 : (BitVec 1)))
  let affectA : Bool := (BEq.beq A (0b1 : (BitVec 1)))
  let affectI : Bool := (BEq.beq I (0b1 : (BitVec 1)))
  let affectF : Bool := (BEq.beq F (0b1 : (BitVec 1)))
  bif (Bool.or (Bool.and (BEq.beq imod (0b00 : (BitVec 2))) (BEq.beq M (0b0 : (BitVec 1))))
       (BEq.beq imod (0b01 : (BitVec 2))))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_CPS_OpT_AS_txt affectA affectF affectI changemode disable enable mode)

def decode_aarch32_instrs_CPS_T1enc_AS_txt (im : (BitVec 1)) (A : (BitVec 1)) (I : (BitVec 1)) (F : (BitVec 1)) : SailM Unit := do
  let mode ← (( do (undefined_bitvector 5) ) : SailM (BitVec 5) )
  bif (BEq.beq ((A ++ I) ++ F) (0b000 : (BitVec 3)))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let mode := mode
  let enable : Bool := (BEq.beq im (0b0 : (BitVec 1)))
  let disable : Bool := (BEq.beq im (0b1 : (BitVec 1)))
  let changemode : Bool := false
  let affectA : Bool := (BEq.beq A (0b1 : (BitVec 1)))
  let affectI : Bool := (BEq.beq I (0b1 : (BitVec 1)))
  let affectF : Bool := (BEq.beq F (0b1 : (BitVec 1)))
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_CPS_OpT_AS_txt affectA affectF affectI changemode disable enable mode)

def decode_aarch32_instrs_CPS_T2enc_AS_txt (imod : (BitVec 2)) (M : (BitVec 1)) (A : (BitVec 1)) (I : (BitVec 1)) (F : (BitVec 1)) (mode : (BitVec 5)) : SailM Unit := do
  bif (Bool.and (BEq.beq imod (0b00 : (BitVec 2))) (BEq.beq M (0b0 : (BitVec 1))))
  then sailThrow ((Error_See "Hint instructions"))
  else (pure ())
  bif (Bool.and (bne mode (0b00000 : (BitVec 5))) (BEq.beq M (0b0 : (BitVec 1))))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.or
       (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access imod 1)]) (0b1 : (BitVec 1)))
         (BEq.beq ((A ++ I) ++ F) (0b000 : (BitVec 3))))
       (Bool.and (BEq.beq (BitVec.join1 [(BitVec.access imod 1)]) (0b0 : (BitVec 1)))
         (bne ((A ++ I) ++ F) (0b000 : (BitVec 3)))))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let enable : Bool := (BEq.beq imod (0b10 : (BitVec 2)))
  let disable : Bool := (BEq.beq imod (0b11 : (BitVec 2)))
  let changemode : Bool := (BEq.beq M (0b1 : (BitVec 1)))
  let affectA : Bool := (BEq.beq A (0b1 : (BitVec 1)))
  let affectI : Bool := (BEq.beq I (0b1 : (BitVec 1)))
  let affectF : Bool := (BEq.beq F (0b1 : (BitVec 1)))
  bif (Bool.or (BEq.beq imod (0b01 : (BitVec 2))) (← (InITBlock ())))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_CPS_OpT_AS_txt affectA affectF affectI changemode disable enable mode)

def execute_aarch32_instrs_ERET_Op_AS_txt (_ : Unit) : SailM Unit := do
  let new_pc_value ← (( do (undefined_bitvector 32) ) : SailM ELR_hyp_Type )
  bif (Bool.not (← (Halted ())))
  then
    (do
      bif (Bool.or (BEq.beq (← readReg PSTATE).M M32_User)
           (BEq.beq (← readReg PSTATE).M M32_System))
      then sailThrow ((Error_Unpredictable ()))
      else
        (do
          let new_pc_value ← (( do
            bif (BEq.beq (← readReg PSTATE).EL EL2)
            then (ELR_hyp_read ())
            else (R_read 14) ) : SailM ELR_hyp_Type )
          (AArch32_ExceptionReturn new_pc_value (← (SPSR_read (N := 32))))))
  else
    (do
      bif (BEq.beq (← readReg PSTATE).M M32_User)
      then sailThrow ((Error_Undefined ()))
      else
        (do
          bif (BEq.beq (← readReg PSTATE).M M32_System)
          then sailThrow ((Error_Unpredictable ()))
          else
            (do
              let _ : Unit := (SynchronizeContext ())
              (DebugRestorePSR ()))))

def decode_aarch32_instrs_ERET_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:40855.29-40855.30"
      (execute_aarch32_instrs_ERET_Op_AS_txt ()))
  else (pure ())

def decode_aarch32_instrs_ERET_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ERET_Op_AS_txt ()))
  else (pure ())

def execute_aarch32_instrs_HVC_Op_AS_txt (imm16 : (BitVec 16)) : SailM Unit := do
  bif (Bool.or (Bool.or (BEq.beq (← readReg PSTATE).EL EL0) (BEq.beq (← readReg PSTATE).EL EL3))
       (Bool.not (← (EL2Enabled ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let hvc_enable ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let hvc_enable ← (( do
    bif (HaveEL EL3)
    then
      (do
        bif (Bool.and
             (Bool.and (← (ELUsingAArch32 EL3))
               (BEq.beq (_get_SCR_Type_HCE (← readReg SCR)) (0b0 : (BitVec 1))))
             (BEq.beq (← readReg PSTATE).EL EL2))
        then sailThrow ((Error_Unpredictable ()))
        else
          (do
            (pure (_get_SCRType_HCE (← (SCR_GEN_read ()))))))
    else
      (do
        bif (← (ELUsingAArch32 EL2))
        then (pure (Complement.complement (_get_HCR_Type_HCD (← (HCR_read ())))))
        else (pure (Complement.complement (_get_HCR_EL2_Type_HCD (← readReg HCR_EL2))))) ) : SailM
    (BitVec 1) )
  bif (BEq.beq hvc_enable (0b0 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (AArch32_CallHypervisor imm16)

def decode_aarch32_instrs_HVC_A1enc_A_txt (cond : (BitVec 4)) (imm12 : (BitVec 12)) (imm4 : (BitVec 4)) : SailM Unit := do
  assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:40919.25-40919.26"
  bif (bne cond (0xE : (BitVec 4)))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let imm16 : (BitVec 16) := (imm12 ++ imm4)
  (execute_aarch32_instrs_HVC_Op_AS_txt imm16)

def decode_aarch32_instrs_HVC_T1enc_A_txt (imm4 : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  let imm16 : (BitVec 16) := (imm4 ++ imm12)
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_HVC_Op_AS_txt imm16)

/-- Type quantifiers: k_increment_name : Bool, n : Nat, k_wback : Bool, k_wordhigher : Bool, 0 ≤ n
  ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDM_e_Op_AS_txt (increment_name : Bool) (n : Nat) (registers : (BitVec 15)) (wback : Bool) (wordhigher : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let length ← (( do (undefined_int ()) ) : SailM Int )
  let new_pc_value ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (Bool.or (BEq.beq (← readReg PSTATE).M M32_User)
           (BEq.beq (← readReg PSTATE).M M32_System))
      then sailThrow ((Error_Unpredictable ()))
      else
        (do
          let length := ((4 *i (BitCount registers)) +i 4)
          let address ← ((
            bif increment_name
            then (R_read n)
            else (pure (sub_vec_int (← (R_read n)) length)) ) : SailM (BitVec 32) )
          let address : (BitVec 32) :=
            bif wordhigher
            then (BitVec.addInt address 4)
            else address
          let address ← (( do
            let loop_i_lower := 0
            let loop_i_upper := 14
            let mut loop_vars := address
            for i in [loop_i_lower:loop_i_upper:1]i do
              let address := loop_vars
              loop_vars ← do
                bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
                then
                  (do
                    (R_set i (← (MemS_read address 4)))
                    (pure (BitVec.addInt address 4)))
                else (pure address)
            (pure loop_vars) ) : SailM (BitVec 32) )
          let new_pc_value ← (( do (MemS_read address 4) ) : SailM (BitVec 32) )
          assert (Bool.and (0 ≤b n) (n <b 15)) "src/instrs32.sail:40979.46-40979.47"
          bif (Bool.and wback
               (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b0 : (BitVec 1))))
          then
            (R_set n
              (← do
                bif increment_name
                then (pure (BitVec.addInt (← (R_read n)) length))
                else (pure (sub_vec_int (← (R_read n)) length))))
          else (pure ())
          bif (Bool.and wback
               (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
          then (R_set n (← (__UNKNOWN_bits 32)))
          else (pure ())
          (AArch32_ExceptionReturn new_pc_value (← (SPSR_read (N := 32))))))

def decode_aarch32_instrs_LDM_e_A1enc_AS_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 15)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:40995.29-40995.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 15) := register_list
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let increment_name : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wordhigher : Bool := (BEq.beq P U)
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and wback (BEq.beq (BitVec.join1 [(BitVec.access registers n)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDM_e_Op_AS_txt increment_name n registers wback wordhigher))
  else (pure ())

/-- Type quantifiers: k_increment_name : Bool, n : Nat, k_wordhigher : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDM_u_Op_AS_txt (increment_name : Bool) (n : Nat) (registers : (BitVec 15)) (wordhigher : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let length ← (( do (undefined_int ()) ) : SailM Int )
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (Bool.or (BEq.beq (← readReg PSTATE).M M32_User)
           (BEq.beq (← readReg PSTATE).M M32_System))
      then sailThrow ((Error_Unpredictable ()))
      else
        (do
          let length := (4 *i (BitCount registers))
          let address ← ((
            bif increment_name
            then (R_read n)
            else (pure (sub_vec_int (← (R_read n)) length)) ) : SailM (BitVec 32) )
          let address : (BitVec 32) :=
            bif wordhigher
            then (BitVec.addInt address 4)
            else address
          let address ← (( do
            let loop_i_lower := 0
            let loop_i_upper := 14
            let mut loop_vars := address
            for i in [loop_i_lower:loop_i_upper:1]i do
              let address := loop_vars
              loop_vars ← do
                bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
                then
                  (do
                    (Rmode_set i M32_User (← (MemS_read address 4)))
                    (pure (BitVec.addInt address 4)))
                else (pure address)
            (pure loop_vars) ) : SailM (BitVec 32) )
          (pure ())))

def decode_aarch32_instrs_LDM_u_A1enc_AS_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 15)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:41055.29-41055.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 15) := register_list
      let increment_name : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wordhigher : Bool := (BEq.beq P U)
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 1))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDM_u_Op_AS_txt increment_name n registers wordhigher))
  else (pure ())

/-- Type quantifiers: d : Nat, k_read_spsr : Bool, 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_MRS_Op_AS_txt (d : Nat) (read_spsr : Bool) : SailM Unit := do
  let psr_val ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  bif read_spsr
  then
    (do
      bif (Bool.or (BEq.beq (← readReg PSTATE).M M32_User)
           (BEq.beq (← readReg PSTATE).M M32_System))
      then sailThrow ((Error_Unpredictable ()))
      else (R_set d (← (SPSR_read (N := 32)))))
  else
    (do
      let mask : (BitVec 32) := (0xF8EF03DF : (BitVec 32))
      let psr_val ← (( (pure ((← (GetPSRFromPSTATE AArch32_NonDebugState 32)) &&& mask)) ) :
        SailM (BitVec 32) )
      let psr_val ← (( do
        bif (BEq.beq (← readReg PSTATE).EL EL0)
        then
          (do
            let psr_val ← (pure (BitVec.update psr_val 22 (Bit (← (__UNKNOWN_bits 1)))))
            let psr_val ← (pure (Sail.BitVec.updateSubrange psr_val 9 6 (← (__UNKNOWN_bits 4))))
            (pure (Sail.BitVec.updateSubrange psr_val 4 0 (← (__UNKNOWN_bits 5)))))
        else (pure psr_val) ) : SailM (BitVec 32) )
      (R_set d psr_val))

def decode_aarch32_instrs_MRS_A1enc_AS_txt (cond : (BitVec 4)) (R : (BitVec 1)) (Rd : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:41109.29-41109.30"
      let d := (UInt0 Rd)
      let read_spsr : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MRS_Op_AS_txt d read_spsr))
  else (pure ())

def decode_aarch32_instrs_MRS_T1enc_AS_txt (R : (BitVec 1)) (Rd : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let read_spsr : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MRS_Op_AS_txt d read_spsr))
  else (pure ())

/-- Type quantifiers: d : Nat, k_read_spsr : Bool, 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_MRS_br_Op_AS_txt (SYSm : (BitVec 5)) (d : Nat) (read_spsr : Bool) : SailM Unit := do
  let mode ← (( do (undefined_bitvector 5) ) : SailM (BitVec 5) )
  bif (BEq.beq (← readReg PSTATE).EL EL0)
  then sailThrow ((Error_Unpredictable ()))
  else
    (do
      let mode ← (( do (pure (← readReg PSTATE).M) ) : SailM (BitVec 5) )
      bif read_spsr
      then
        (do
          (SPSRaccessValid SYSm mode)
          let b__9 := SYSm
          bif (BEq.beq b__9 (0b01110 : (BitVec 5)))
          then (R_set d (Sail.BitVec.extractLsb (← readReg SPSR_fiq) 31 0))
          else
            (do
              bif (BEq.beq b__9 (0b10000 : (BitVec 5)))
              then (R_set d (Sail.BitVec.extractLsb (← readReg SPSR_irq) 31 0))
              else
                (do
                  bif (BEq.beq b__9 (0b10010 : (BitVec 5)))
                  then (R_set d (Sail.BitVec.extractLsb (← (SPSR_svc_read ())) 31 0))
                  else
                    (do
                      bif (BEq.beq b__9 (0b10100 : (BitVec 5)))
                      then (R_set d (Sail.BitVec.extractLsb (← readReg SPSR_abt) 31 0))
                      else
                        (do
                          bif (BEq.beq b__9 (0b10110 : (BitVec 5)))
                          then (R_set d (Sail.BitVec.extractLsb (← readReg SPSR_und) 31 0))
                          else
                            (do
                              bif (BEq.beq b__9 (0b11100 : (BitVec 5)))
                              then
                                (do
                                  bif (Bool.not (← (ELUsingAArch32 EL3)))
                                  then (AArch64_MonitorModeTrap ())
                                  else (pure ())
                                  (R_set d (← readReg SPSR_mon)))
                              else
                                (do
                                  bif (BEq.beq b__9 (0b11110 : (BitVec 5)))
                                  then
                                    (R_set d (Sail.BitVec.extractLsb (← (SPSR_hyp_read ())) 31 0))
                                  else (pure ()))))))))
      else
        (do
          let m ← (( do (undefined_int ()) ) : SailM Int )
          (BankedRegisterAccessValid SYSm mode)
          let b__0 := SYSm
          bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 3) (0b00 : (BitVec 2)))
          then
            (do
              let m := ((UInt0 (Sail.BitVec.extractLsb SYSm 2 0)) +i 8)
              (R_set d (← (Rmode_read m M32_User))))
          else
            (do
              bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 3) (0b01 : (BitVec 2)))
              then
                (do
                  let m := ((UInt0 (Sail.BitVec.extractLsb SYSm 2 0)) +i 8)
                  (R_set d (← (Rmode_read m M32_FIQ))))
              else
                (do
                  bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 1) (0x8 : (BitVec 4)))
                  then
                    (do
                      let m := (14 -i (UInt0 (BitVec.join1 [(BitVec.access SYSm 0)])))
                      (R_set d (← (Rmode_read m M32_IRQ))))
                  else
                    (do
                      bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 1) (0x9 : (BitVec 4)))
                      then
                        (do
                          let m := (14 -i (UInt0 (BitVec.join1 [(BitVec.access SYSm 0)])))
                          (R_set d (← (Rmode_read m M32_Svc))))
                      else
                        (do
                          bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 1) (0xA : (BitVec 4)))
                          then
                            (do
                              let m := (14 -i (UInt0 (BitVec.join1 [(BitVec.access SYSm 0)])))
                              (R_set d (← (Rmode_read m M32_Abort))))
                          else
                            (do
                              bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 1) (0xB : (BitVec 4)))
                              then
                                (do
                                  let m := (14 -i (UInt0 (BitVec.join1 [(BitVec.access SYSm 0)])))
                                  (R_set d (← (Rmode_read m M32_Undef))))
                              else
                                (do
                                  bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 1) (0xE : (BitVec 4)))
                                  then
                                    (do
                                      bif (Bool.not (← (ELUsingAArch32 EL3)))
                                      then (AArch64_MonitorModeTrap ())
                                      else (pure ())
                                      let m :=
                                        (14 -i (UInt0 (BitVec.join1 [(BitVec.access SYSm 0)])))
                                      (R_set d (← (Rmode_read m M32_Monitor))))
                                  else
                                    (do
                                      bif (BEq.beq b__0 (0b11110 : (BitVec 5)))
                                      then (R_set d (← (ELR_hyp_read ())))
                                      else
                                        (do
                                          bif (BEq.beq b__0 (0b11111 : (BitVec 5)))
                                          then (R_set d (← (Rmode_read 13 M32_Hyp)))
                                          else (pure ())))))))))))

def decode_aarch32_instrs_MRS_br_A1enc_AS_txt (cond : (BitVec 4)) (R : (BitVec 1)) (M1 : (BitVec 4)) (Rd : (BitVec 4)) (M : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:41246.29-41246.30"
      let d := (UInt0 Rd)
      let read_spsr : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let SYSm : (BitVec 5) := (M ++ M1)
      (execute_aarch32_instrs_MRS_br_Op_AS_txt SYSm d read_spsr))
  else (pure ())

def decode_aarch32_instrs_MRS_br_T1enc_AS_txt (R : (BitVec 1)) (M1 : (BitVec 4)) (Rd : (BitVec 4)) (M : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let read_spsr : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (BEq.beq d 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let SYSm : (BitVec 5) := (M ++ M1)
      (execute_aarch32_instrs_MRS_br_Op_AS_txt SYSm d read_spsr))
  else (pure ())

/-- Type quantifiers: n : Nat, k_write_spsr : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_MSR_br_Op_AS_txt (SYSm : (BitVec 5)) (n : Nat) (write_spsr : Bool) : SailM Unit := do
  let mode ← (( do (undefined_bitvector 5) ) : SailM (BitVec 5) )
  bif (BEq.beq (← readReg PSTATE).EL EL0)
  then sailThrow ((Error_Unpredictable ()))
  else
    (do
      let mode ← (( do (pure (← readReg PSTATE).M) ) : SailM (BitVec 5) )
      bif write_spsr
      then
        (do
          (SPSRaccessValid SYSm mode)
          let b__9 := SYSm
          bif (BEq.beq b__9 (0b01110 : (BitVec 5)))
          then
            writeReg SPSR_fiq (Sail.BitVec.updateSubrange (← readReg SPSR_fiq) 31 0
              (← (R_read n)))
          else
            (do
              bif (BEq.beq b__9 (0b10000 : (BitVec 5)))
              then
                writeReg SPSR_irq (Sail.BitVec.updateSubrange (← readReg SPSR_irq) 31 0
                  (← (R_read n)))
              else
                (do
                  bif (BEq.beq b__9 (0b10010 : (BitVec 5)))
                  then
                    (SPSR_svc_write
                      (Mk_SPSR_svc_Type
                        (Sail.BitVec.updateSubrange (← (SPSR_svc_read ())) 31 0 (← (R_read n)))))
                  else
                    (do
                      bif (BEq.beq b__9 (0b10100 : (BitVec 5)))
                      then
                        writeReg SPSR_abt (Sail.BitVec.updateSubrange (← readReg SPSR_abt) 31 0
                          (← (R_read n)))
                      else
                        (do
                          bif (BEq.beq b__9 (0b10110 : (BitVec 5)))
                          then
                            writeReg SPSR_und (Sail.BitVec.updateSubrange (← readReg SPSR_und) 31
                              0 (← (R_read n)))
                          else
                            (do
                              bif (BEq.beq b__9 (0b11100 : (BitVec 5)))
                              then
                                (do
                                  bif (Bool.not (← (ELUsingAArch32 EL3)))
                                  then (AArch64_MonitorModeTrap ())
                                  else (pure ())
                                  writeReg SPSR_mon (Sail.BitVec.updateSubrange
                                    (← readReg SPSR_mon) 31 0 (← (R_read n))))
                              else
                                (do
                                  bif (BEq.beq b__9 (0b11110 : (BitVec 5)))
                                  then
                                    (SPSR_hyp_write
                                      (Mk_SPSR_hyp_Type
                                        (Sail.BitVec.updateSubrange (← (SPSR_hyp_read ())) 31 0
                                          (← (R_read n)))))
                                  else (pure ()))))))))
      else
        (do
          let m ← (( do (undefined_int ()) ) : SailM Int )
          (BankedRegisterAccessValid SYSm mode)
          let b__0 := SYSm
          bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 3) (0b00 : (BitVec 2)))
          then
            (do
              let m := ((UInt0 (Sail.BitVec.extractLsb SYSm 2 0)) +i 8)
              (Rmode_set m M32_User (← (R_read n))))
          else
            (do
              bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 3) (0b01 : (BitVec 2)))
              then
                (do
                  let m := ((UInt0 (Sail.BitVec.extractLsb SYSm 2 0)) +i 8)
                  (Rmode_set m M32_FIQ (← (R_read n))))
              else
                (do
                  bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 1) (0x8 : (BitVec 4)))
                  then
                    (do
                      let m := (14 -i (UInt0 (BitVec.join1 [(BitVec.access SYSm 0)])))
                      (Rmode_set m M32_IRQ (← (R_read n))))
                  else
                    (do
                      bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 1) (0x9 : (BitVec 4)))
                      then
                        (do
                          let m := (14 -i (UInt0 (BitVec.join1 [(BitVec.access SYSm 0)])))
                          (Rmode_set m M32_Svc (← (R_read n))))
                      else
                        (do
                          bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 1) (0xA : (BitVec 4)))
                          then
                            (do
                              let m := (14 -i (UInt0 (BitVec.join1 [(BitVec.access SYSm 0)])))
                              (Rmode_set m M32_Abort (← (R_read n))))
                          else
                            (do
                              bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 1) (0xB : (BitVec 4)))
                              then
                                (do
                                  let m := (14 -i (UInt0 (BitVec.join1 [(BitVec.access SYSm 0)])))
                                  (Rmode_set m M32_Undef (← (R_read n))))
                              else
                                (do
                                  bif (BEq.beq (Sail.BitVec.extractLsb b__0 4 1) (0xE : (BitVec 4)))
                                  then
                                    (do
                                      bif (Bool.not (← (ELUsingAArch32 EL3)))
                                      then (AArch64_MonitorModeTrap ())
                                      else (pure ())
                                      let m :=
                                        (14 -i (UInt0 (BitVec.join1 [(BitVec.access SYSm 0)])))
                                      (Rmode_set m M32_Monitor (← (R_read n))))
                                  else
                                    (do
                                      bif (BEq.beq b__0 (0b11110 : (BitVec 5)))
                                      then (ELR_hyp_write (← (R_read n)))
                                      else
                                        (do
                                          bif (BEq.beq b__0 (0b11111 : (BitVec 5)))
                                          then (Rmode_set 13 M32_Hyp (← (R_read n)))
                                          else (pure ())))))))))))

def decode_aarch32_instrs_MSR_br_A1enc_AS_txt (cond : (BitVec 4)) (R : (BitVec 1)) (M1 : (BitVec 4)) (M : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:41390.29-41390.30"
      let n := (UInt0 Rn)
      let write_spsr : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let SYSm : (BitVec 5) := (M ++ M1)
      (execute_aarch32_instrs_MSR_br_Op_AS_txt SYSm n write_spsr))
  else (pure ())

def decode_aarch32_instrs_MSR_br_T1enc_AS_txt (R : (BitVec 1)) (Rn : (BitVec 4)) (M1 : (BitVec 4)) (M : (BitVec 1)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let write_spsr : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let SYSm : (BitVec 5) := (M ++ M1)
      (execute_aarch32_instrs_MSR_br_Op_AS_txt SYSm n write_spsr))
  else (pure ())

/-- Type quantifiers: k_write_spsr : Bool -/
def execute_aarch32_instrs_MSR_i_Op_AS_txt (imm32 : (BitVec 32)) (mask : (BitVec 4)) (write_spsr : Bool) : SailM Unit := do
  bif write_spsr
  then
    (do
      bif (Bool.or (BEq.beq (← readReg PSTATE).M M32_User)
           (BEq.beq (← readReg PSTATE).M M32_System))
      then sailThrow ((Error_Unpredictable ()))
      else (SPSRWriteByInstr imm32 mask))
  else (CPSRWriteByInstr imm32 mask)

def decode_aarch32_instrs_MSR_i_A1enc_AS_txt (cond : (BitVec 4)) (R : (BitVec 1)) (mask : (BitVec 4)) (imm12 : (BitVec 12)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:41463.29-41463.30"
      bif (Bool.and (BEq.beq mask (0x0 : (BitVec 4))) (BEq.beq R (0b0 : (BitVec 1))))
      then sailThrow ((Error_See "Related encodings"))
      else (pure ())
      let imm32 ← (( do (A32ExpandImm imm12) ) : SailM (BitVec 32) )
      let write_spsr : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (BEq.beq mask (0x0 : (BitVec 4)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MSR_i_Op_AS_txt imm32 mask write_spsr))
  else (pure ())

/-- Type quantifiers: n : Nat, k_write_spsr : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_MSR_r_Op_AS_txt (mask : (BitVec 4)) (n : Nat) (write_spsr : Bool) : SailM Unit := do
  bif write_spsr
  then
    (do
      bif (Bool.or (BEq.beq (← readReg PSTATE).M M32_User)
           (BEq.beq (← readReg PSTATE).M M32_System))
      then sailThrow ((Error_Unpredictable ()))
      else (SPSRWriteByInstr (← (R_read n)) mask))
  else (CPSRWriteByInstr (← (R_read n)) mask)

def decode_aarch32_instrs_MSR_r_A1enc_AS_txt (cond : (BitVec 4)) (R : (BitVec 1)) (mask : (BitVec 4)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:41510.29-41510.30"
      let n := (UInt0 Rn)
      let write_spsr : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (BEq.beq mask (0x0 : (BitVec 4)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MSR_r_Op_AS_txt mask n write_spsr))
  else (pure ())

def decode_aarch32_instrs_MSR_r_T1enc_AS_txt (R : (BitVec 1)) (Rn : (BitVec 4)) (mask : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let write_spsr : Bool := (BEq.beq R (0b1 : (BitVec 1)))
      bif (BEq.beq mask (0x0 : (BitVec 4)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_MSR_r_Op_AS_txt mask n write_spsr))
  else (pure ())

/-- Type quantifiers: k_increment_name : Bool, n : Nat, k_wback : Bool, k_wordhigher : Bool, 0 ≤ n
  ∧ n ≤ 15 -/
def execute_aarch32_instrs_RFE_Op_AS_txt (increment_name : Bool) (n : Nat) (wback : Bool) (wordhigher : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let new_pc_value ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let spsr ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (BEq.beq (← readReg PSTATE).EL EL0)
      then sailThrow ((Error_Unpredictable ()))
      else
        (do
          let address ← ((
            bif increment_name
            then (R_read n)
            else (pure (sub_vec_int (← (R_read n)) 8)) ) : SailM (BitVec 32) )
          let address : (BitVec 32) :=
            bif wordhigher
            then (BitVec.addInt address 4)
            else address
          let new_pc_value ← (( do (MemA_read address 4) ) : SailM (BitVec 32) )
          let spsr ← (( do (MemA_read (BitVec.addInt address 4) 4) ) : SailM (BitVec 32) )
          bif wback
          then
            (R_set n
              (← do
                bif increment_name
                then (pure (BitVec.addInt (← (R_read n)) 8))
                else (pure (sub_vec_int (← (R_read n)) 8))))
          else (pure ())
          (AArch32_ExceptionReturn new_pc_value spsr)))

def decode_aarch32_instrs_RFE_A1enc_AS_txt (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let increment_name : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wordhigher : Bool := (BEq.beq P U)
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_RFE_Op_AS_txt increment_name n wback wordhigher))
  else (pure ())

def decode_aarch32_instrs_RFE_T1enc_AS_txt (W : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let increment_name : Bool := false
      let wordhigher : Bool := false
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_RFE_Op_AS_txt increment_name n wback wordhigher))
  else (pure ())

def decode_aarch32_instrs_RFE_T2enc_AS_txt (W : (BitVec 1)) (Rn : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let n := (UInt0 Rn)
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let increment_name : Bool := true
      let wordhigher : Bool := false
      bif (BEq.beq n 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_RFE_Op_AS_txt increment_name n wback wordhigher))
  else (pure ())

def execute_aarch32_instrs_SMC_Op_AS_txt (_ : Unit) : SailM Unit := do
  let c ← (( do (undefined_Constraint ()) ) : SailM Constraint )
  (AArch32_CheckForSMCUndefOrTrap ())
  bif (Bool.not (← (ELUsingAArch32 EL3)))
  then
    (do
      bif (BEq.beq (_get_SCR_EL3_Type_SMD (← readReg SCR_EL3)) (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ()))
  else
    (do
      bif (BEq.beq (_get_SCR_Type_SCD (← readReg SCR)) (0b1 : (BitVec 1)))
      then
        (do
          bif (eq_any (← (CurrentSecurityState ())) SS_Secure)
          then
            (do
              let c ← (( do (ConstrainUnpredictable Unpredictable_SMD) ) : SailM Constraint )
              assert (Bool.or (eq_any c Constraint_NOP) (eq_any c Constraint_UNDEF)) "src/instrs32.sail:41695.66-41695.67"
              bif (eq_any c Constraint_NOP)
              then (EndOfInstruction ())
              else (pure ()))
          else (pure ())
          sailThrow ((Error_Undefined ())))
      else (pure ()))
  bif (Bool.not (← (ELUsingAArch32 EL3)))
  then (AArch64_CallSecureMonitor (Zeros (n := 16)))
  else (AArch32_TakeSMCException ())

def decode_aarch32_instrs_SMC_A1enc_AS_txt (cond : (BitVec 4)) (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:41716.29-41716.30"
      (execute_aarch32_instrs_SMC_Op_AS_txt ()))
  else (pure ())

def decode_aarch32_instrs_SMC_T1enc_AS_txt (imm4 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.and (← (InITBlock ())) (Bool.not (← (LastInITBlock ()))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_SMC_Op_AS_txt ()))
  else (pure ())

/-- Type quantifiers: k_increment_name : Bool, k_wback : Bool, k_wordhigher : Bool -/
def execute_aarch32_instrs_SRS_OpA_AS_txt (increment_name : Bool) (mode : (BitVec 5)) (wback : Bool) (wordhigher : Bool) : SailM Unit := do
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (BEq.beq (← readReg PSTATE).M M32_User) (BEq.beq (← readReg PSTATE).M M32_System))
  then sailThrow ((Error_Unpredictable ()))
  else
    (do
      bif (BEq.beq mode M32_Hyp)
      then sailThrow ((Error_Unpredictable ()))
      else
        (do
          bif (BEq.beq mode M32_Monitor)
          then
            (do
              bif (Bool.or (Bool.not (HaveEL EL3))
                   (neq_any (← (CurrentSecurityState ())) SS_Secure))
              then sailThrow ((Error_Unpredictable ()))
              else
                (do
                  bif (Bool.not (← (ELUsingAArch32 EL3)))
                  then (AArch64_MonitorModeTrap ())
                  else (pure ())))
          else
            (do
              bif (← (BadMode mode))
              then sailThrow ((Error_Unpredictable ()))
              else (pure ()))))
  let base ← (( do (Rmode_read 13 mode) ) : SailM (BitVec 32) )
  let address : (BitVec 32) :=
    bif increment_name
    then base
    else (sub_vec_int base 8)
  let address : (BitVec 32) :=
    bif wordhigher
    then (BitVec.addInt address 4)
    else address
  (MemA_set address 4 (← (LR_read ())))
  (MemA_set (BitVec.addInt address 4) 4 (← (SPSR_read (N := (8 *i 4)))))
  bif wback
  then
    (Rmode_set 13 mode
      (bif increment_name
      then (BitVec.addInt base 8)
      else (sub_vec_int base 8)))
  else (pure ())

def decode_aarch32_instrs_SRS_A1enc_AS_txt (P : (BitVec 1)) (U : (BitVec 1)) (W : (BitVec 1)) (mode : (BitVec 5)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let increment_name : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wordhigher : Bool := (BEq.beq P U)
      (execute_aarch32_instrs_SRS_OpA_AS_txt increment_name mode wback wordhigher))
  else (pure ())

/-- Type quantifiers: k_increment_name : Bool, k_wback : Bool, k_wordhigher : Bool -/
def execute_aarch32_instrs_SRS_OpT_AS_txt (increment_name : Bool) (mode : (BitVec 5)) (wback : Bool) (wordhigher : Bool) : SailM Unit := do
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (BEq.beq (← readReg PSTATE).M M32_User) (BEq.beq (← readReg PSTATE).M M32_System))
  then sailThrow ((Error_Unpredictable ()))
  else
    (do
      bif (BEq.beq mode M32_Hyp)
      then sailThrow ((Error_Unpredictable ()))
      else
        (do
          bif (BEq.beq mode M32_Monitor)
          then
            (do
              bif (Bool.or (Bool.not (HaveEL EL3))
                   (neq_any (← (CurrentSecurityState ())) SS_Secure))
              then sailThrow ((Error_Unpredictable ()))
              else
                (do
                  bif (Bool.not (← (ELUsingAArch32 EL3)))
                  then (AArch64_MonitorModeTrap ())
                  else (pure ())))
          else
            (do
              bif (← (BadMode mode))
              then sailThrow ((Error_Unpredictable ()))
              else (pure ()))))
  let base ← (( do (Rmode_read 13 mode) ) : SailM (BitVec 32) )
  let address : (BitVec 32) :=
    bif increment_name
    then base
    else (sub_vec_int base 8)
  let address : (BitVec 32) :=
    bif wordhigher
    then (BitVec.addInt address 4)
    else address
  (MemA_set address 4 (← (LR_read ())))
  (MemA_set (BitVec.addInt address 4) 4 (← (SPSR_read (N := (8 *i 4)))))
  bif wback
  then
    (Rmode_set 13 mode
      (bif increment_name
      then (BitVec.addInt base 8)
      else (sub_vec_int base 8)))
  else (pure ())

def decode_aarch32_instrs_SRS_T1enc_AS_txt (W : (BitVec 1)) (mode : (BitVec 5)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let increment_name : Bool := false
      let wordhigher : Bool := false
      (execute_aarch32_instrs_SRS_OpT_AS_txt increment_name mode wback wordhigher))
  else (pure ())

def decode_aarch32_instrs_SRS_T2enc_AS_txt (W : (BitVec 1)) (mode : (BitVec 5)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let wback : Bool := (BEq.beq W (0b1 : (BitVec 1)))
      let increment_name : Bool := true
      let wordhigher : Bool := false
      (execute_aarch32_instrs_SRS_OpT_AS_txt increment_name mode wback wordhigher))
  else (pure ())

/-- Type quantifiers: k_increment_name : Bool, n : Nat, k_wordhigher : Bool, 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STM_u_Op_AS_txt (increment_name : Bool) (n : Nat) (registers : (BitVec 16)) (wordhigher : Bool) : SailM Unit := do
  let address ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let length ← (( do (undefined_int ()) ) : SailM Int )
  bif (BEq.beq (← readReg PSTATE).EL EL2)
  then sailThrow ((Error_Undefined ()))
  else
    (do
      bif (Bool.or (BEq.beq (← readReg PSTATE).M M32_User)
           (BEq.beq (← readReg PSTATE).M M32_System))
      then sailThrow ((Error_Unpredictable ()))
      else
        (do
          let length := (4 *i (BitCount registers))
          let address ← ((
            bif increment_name
            then (R_read n)
            else (pure (sub_vec_int (← (R_read n)) length)) ) : SailM (BitVec 32) )
          let address : (BitVec 32) :=
            bif wordhigher
            then (BitVec.addInt address 4)
            else address
          let address ← (( do
            let loop_i_lower := 0
            let loop_i_upper := 14
            let mut loop_vars := address
            for i in [loop_i_lower:loop_i_upper:1]i do
              let address := loop_vars
              loop_vars ← do
                bif (BEq.beq (BitVec.join1 [(BitVec.access registers i)]) (0b1 : (BitVec 1)))
                then
                  (do
                    (MemS_set address 4 (← (Rmode_read i M32_User)))
                    (pure (BitVec.addInt address 4)))
                else (pure address)
            (pure loop_vars) ) : SailM (BitVec 32) )
          bif (BEq.beq (BitVec.join1 [(BitVec.access registers 15)]) (0b1 : (BitVec 1)))
          then (MemS_set address 4 (← (PCStoreValue ())))
          else (pure ())))

def decode_aarch32_instrs_STM_u_A1enc_AS_txt (cond : (BitVec 4)) (P : (BitVec 1)) (U : (BitVec 1)) (Rn : (BitVec 4)) (register_list : (BitVec 16)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:41928.29-41928.30"
      let n := (UInt0 Rn)
      let registers : (BitVec 16) := register_list
      let increment_name : Bool := (BEq.beq U (0b1 : (BitVec 1)))
      let wordhigher : Bool := (BEq.beq P U)
      bif (Bool.or (BEq.beq n 15) ((BitCount registers) <b 1))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STM_u_Op_AS_txt increment_name n registers wordhigher))
  else (pure ())

/-- Type quantifiers: t : Nat, 0 ≤ t ∧ t ≤ 15 -/
def execute_aarch32_instrs_VMRS_Op_AS_txt (reg : (BitVec 4)) (t : Nat) : SailM Unit := do
  bif (BEq.beq reg (0x1 : (BitVec 4)))
  then
    (do
      (CheckVFPEnabled true)
      bif (BEq.beq t 15)
      then
        (do
          let split_vec ← do
            (pure ((_get_FPSR_Type_N (← readReg FPSR)) ++ ((_get_FPSR_Type_Z (← readReg FPSR)) ++ ((_get_FPSR_Type_C
                      (← readReg FPSR)) ++ (_get_FPSR_Type_V (← readReg FPSR))))))
          writeReg PSTATE { (← readReg PSTATE) with N := (Sail.BitVec.extractLsb split_vec 3 3) }
          writeReg PSTATE { (← readReg PSTATE) with Z := (Sail.BitVec.extractLsb split_vec 2 2) }
          writeReg PSTATE { (← readReg PSTATE) with C := (Sail.BitVec.extractLsb split_vec 1 1) }
          writeReg PSTATE { (← readReg PSTATE) with V := (Sail.BitVec.extractLsb split_vec 0 0) })
      else (R_set t (← (FPSCR_read__1 ()))))
  else
    (do
      bif (BEq.beq (← readReg PSTATE).EL EL0)
      then sailThrow ((Error_Undefined ()))
      else
        (do
          (CheckVFPEnabled false)
          (AArch32_CheckAdvSIMDOrFPRegisterTraps reg)
          let b__0 := reg
          bif (BEq.beq b__0 (0x0 : (BitVec 4)))
          then (R_set t (← readReg FPSID))
          else
            (do
              bif (BEq.beq b__0 (0x5 : (BitVec 4)))
              then (R_set t (← (MVFR2_read ())))
              else
                (do
                  bif (BEq.beq b__0 (0x6 : (BitVec 4)))
                  then (R_set t (← (MVFR1_read ())))
                  else
                    (do
                      bif (BEq.beq b__0 (0x7 : (BitVec 4)))
                      then (R_set t (← (MVFR0_read ())))
                      else
                        (do
                          bif (BEq.beq b__0 (0x8 : (BitVec 4)))
                          then (R_set t (← (FPEXC_read ())))
                          else (Unreachable ())))))))

def decode_aarch32_instrs_VMRS_A1enc_AS_txt (cond : (BitVec 4)) (reg : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:41998.29-41998.30"
      let t := (UInt0 Rt)
      bif (Bool.not
           (let b__0 := reg
           bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b000 : (BitVec 3)))
           then true
           else
             (bif (BEq.beq b__0 (0x5 : (BitVec 4)))
             then true
             else
               (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b011 : (BitVec 3)))
               then true
               else
                 (bif (BEq.beq b__0 (0x8 : (BitVec 4)))
                 then true
                 else false))) : Bool))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq t 15) (bne reg (0x1 : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMRS_Op_AS_txt reg t))
  else (pure ())

def decode_aarch32_instrs_VMRS_T1enc_AS_txt (reg : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      bif (Bool.not
           (let b__0 := reg
           bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b000 : (BitVec 3)))
           then true
           else
             (bif (BEq.beq b__0 (0x5 : (BitVec 4)))
             then true
             else
               (bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b011 : (BitVec 3)))
               then true
               else
                 (bif (BEq.beq b__0 (0x8 : (BitVec 4)))
                 then true
                 else false))) : Bool))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.and (BEq.beq t 15) (bne reg (0x1 : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMRS_Op_AS_txt reg t))
  else (pure ())

/-- Type quantifiers: t : Nat, 0 ≤ t ∧ t ≤ 15 -/
def execute_aarch32_instrs_VMSR_Op_AS_txt (reg : (BitVec 4)) (t : Nat) : SailM Unit := do
  bif (BEq.beq reg (0x1 : (BitVec 4)))
  then
    (do
      (CheckVFPEnabled true)
      (FPSCR_write (Mk_FPSCR_Type (← (R_read t)))))
  else
    (do
      bif (BEq.beq (← readReg PSTATE).EL EL0)
      then sailThrow ((Error_Undefined ()))
      else
        (do
          (CheckVFPEnabled false)
          let b__0 := reg
          bif (BEq.beq b__0 (0x0 : (BitVec 4)))
          then (pure ())
          else
            (do
              bif (BEq.beq b__0 (0x8 : (BitVec 4)))
              then (FPEXC_write (Mk_FPEXC_Type (← (R_read t))))
              else (Unreachable ()))))

def decode_aarch32_instrs_VMSR_A1enc_AS_txt (cond : (BitVec 4)) (reg : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:42089.29-42089.30"
      let t := (UInt0 Rt)
      bif (Bool.and
           (Bool.not
             (let b__0 := reg
             bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b000 : (BitVec 3)))
             then true
             else false : Bool)) (bne reg (0x8 : (BitVec 4))))
      then
        (do
          let c ← (( do (ConstrainUnpredictable Unpredictable_VMSR) ) : SailM Constraint )
          assert (Bool.or (eq_any c Constraint_UNDEF) (eq_any c Constraint_NOP)) "src/instrs32.sail:42096.62-42096.63"
          match c with
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP => (EndOfInstruction ())
          | _ => (pure ()))
      else (pure ())
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMSR_Op_AS_txt reg t))
  else (pure ())

def decode_aarch32_instrs_VMSR_T1enc_AS_txt (reg : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      bif (Bool.and
           (Bool.not
             (let b__0 := reg
             bif (BEq.beq (Sail.BitVec.extractLsb b__0 3 1) (0b000 : (BitVec 3)))
             then true
             else false : Bool)) (bne reg (0x8 : (BitVec 4))))
      then
        (do
          let c ← (( do (ConstrainUnpredictable Unpredictable_VMSR) ) : SailM Constraint )
          assert (Bool.or (eq_any c Constraint_UNDEF) (eq_any c Constraint_NOP)) "src/instrs32.sail:42137.62-42137.63"
          match c with
          | Constraint_UNDEF => sailThrow ((Error_Undefined ()))
          | Constraint_NOP => (EndOfInstruction ())
          | _ => (pure ()))
      else (pure ())
      bif (BEq.beq t 15)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_VMSR_Op_AS_txt reg t))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_AESD_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckCryptoEnabled32 ())
  let op1 ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let op2 ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  (Q_set (Int.shiftl d 1) (← (AESInvSubBytes (AESInvShiftRows (op1 ^^^ op2)))))

def decode_aarch32_instrs_AESD_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveAESExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_AESD_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_AESD_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveAESExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_AESD_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_AESE_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckCryptoEnabled32 ())
  let op1 ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let op2 ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  (Q_set (Int.shiftl d 1) (← (AESSubBytes (AESShiftRows (op1 ^^^ op2)))))

def decode_aarch32_instrs_AESE_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveAESExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_AESE_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_AESE_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveAESExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_AESE_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_AESIMC_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckCryptoEnabled32 ())
  (Q_set (Int.shiftl d 1) (← (AESInvMixColumns (← (Q_read (Int.shiftl m 1))))))

def decode_aarch32_instrs_AESIMC_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveAESExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_AESIMC_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_AESIMC_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveAESExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_AESIMC_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_AESMC_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckCryptoEnabled32 ())
  (Q_set (Int.shiftl d 1) (← (AESMixColumns (← (Q_read (Int.shiftl m 1))))))

def decode_aarch32_instrs_AESMC_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveAESExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_AESMC_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_AESMC_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveAESExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b00 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_AESMC_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: k_crc32c : Bool, d : Nat, m : Nat, n : Nat, size : Nat, size ∈
  {8, 16, 32, 64} ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ m ∧ m ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_CRC32_Op_A_txt (crc32c : Bool) (d : Nat) (m : Nat) (n : Nat) (size : Nat) : SailM Unit := do
  let acc ← (( do (R_read n) ) : SailM (BitVec 32) )
  assert ((size -i 1) <b 32) "src/instrs32.sail:42465.37-42465.38"
  let val_name ← (( do (pure (Sail.BitVec.extractLsb (← (R_read m)) (size -i 1) 0)) ) : SailM
    (BitVec (0 + (size - 1 - 0 + 1))) )
  let poly : (BitVec 32) :=
    (integer_subrange
      (bif crc32c
      then (UInt0 (0x1EDC6F41 : (BitVec 32)))
      else (UInt0 (0x04C11DB7 : (BitVec 32)))) 31 0)
  let tempacc ← (( do (pure ((← (BitReverse acc)) ++ (Zeros (n := size)))) ) : SailM
    (BitVec (32 + size)) )
  let tempval ← (( do (pure ((← (BitReverse val_name)) ++ (Zeros (n := 32)))) ) : SailM
    (BitVec (0 + (size - 1 - 0 + 1) + 32)) )
  (R_set d (← (BitReverse (← (Poly32Mod2 (tempacc ^^^ tempval) poly)))))

def decode_aarch32_instrs_CRC32_A1enc_A_txt (cond : (BitVec 4)) (sz : (BitVec 2)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (C : (BitVec 1)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:42477.29-42477.30"
      bif (Bool.not (← (HaveCRCExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let size := (Int.shiftl 8 (UInt0 sz))
      let crc32c : Bool := (BEq.beq C (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq size 64)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (bne cond (0xE : (BitVec 4)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_CRC32_Op_A_txt crc32c d m n size))
  else (pure ())

def decode_aarch32_instrs_CRC32_T1enc_A_txt (C : (BitVec 1)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (sz : (BitVec 2)) (Rm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveCRCExt ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 Rd)
      let n := (UInt0 Rn)
      let m := (UInt0 Rm)
      let size := (Int.shiftl 8 (UInt0 sz))
      let crc32c : Bool := (BEq.beq C (0b1 : (BitVec 1)))
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq n 15)) (BEq.beq m 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (BEq.beq size 64)
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_CRC32_Op_A_txt crc32c d m n size))
  else (pure ())

def execute_aarch32_instrs_DCPS1_Op_A_txt (_ : Unit) : SailM Unit := do
  let LR_svc ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let tge ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  bif (Bool.not (← (Halted ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (← (EL2Enabled ())) (BEq.beq (← readReg PSTATE).EL EL0))
  then
    (do
      let tge ← (( do
        bif (← (ELUsingAArch32 EL2))
        then (pure (_get_HCR_Type_TGE (← (HCR_read ()))))
        else (pure (_get_HCR_EL2_Type_TGE (← readReg HCR_EL2))) ) : SailM (BitVec 1) )
      bif (BEq.beq tge (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ()))
  else (pure ())
  bif (Bool.or (bne (← readReg PSTATE).EL EL0) (← (ELUsingAArch32 EL1)))
  then
    (do
      bif (BEq.beq (← readReg PSTATE).M M32_Monitor)
      then writeReg SCR (Sail.BitVec.updateSubrange (← readReg SCR) 0 0 (0b0 : (BitVec 1)))
      else (pure ())
      bif (bne (← readReg PSTATE).EL EL2)
      then
        (do
          (AArch32_WriteMode M32_Svc)
          writeReg PSTATE { (← readReg PSTATE) with E := (_get_SCTLR_Type_EE
            (← (SCTLR_read__2 ()))) }
          bif (Bool.and (← (HavePANExt ()))
               (BEq.beq (_get_SCTLR_Type_SPAN (← (SCTLR_read__2 ()))) (0b0 : (BitVec 1))))
          then writeReg PSTATE { (← readReg PSTATE) with PAN := (0b1 : (BitVec 1)) }
          else (pure ())
          let LR_svc ← (__UNKNOWN_bits 32)
          (SPSR_svc_write (Mk_SPSR_svc_Type (← (__UNKNOWN_bits 32)))))
      else
        (do
          writeReg PSTATE { (← readReg PSTATE) with E := (_get_HSCTLR_Type_EE
            (← (HSCTLR_read ()))) }
          (ELR_hyp_write (← (__UNKNOWN_bits 32)))
          (HSR_write (Mk_HSR_Type (← (__UNKNOWN_bits 32))))
          (SPSR_hyp_write (Mk_SPSR_hyp_Type (← (__UNKNOWN_bits 32)))))
      (DLR_write (← (__UNKNOWN_bits 32)))
      (DSPSR_write (Mk_DSPSR_Type (← (__UNKNOWN_bits 32)))))
  else
    (do
      (AArch64_MaybeZeroRegisterUppers ())
      (MaybeZeroSVEUppers EL1)
      writeReg PSTATE { (← readReg PSTATE) with nRW := (0b0 : (BitVec 1)) }
      writeReg PSTATE { (← readReg PSTATE) with SP := (0b1 : (BitVec 1)) }
      writeReg PSTATE { (← readReg PSTATE) with EL := EL1 }
      bif (Bool.and (← (HavePANExt ()))
           (BEq.beq (_get_SCTLR_EL1_Type_SPAN (← readReg SCTLR_EL1)) (0b0 : (BitVec 1))))
      then writeReg PSTATE { (← readReg PSTATE) with PAN := (0b1 : (BitVec 1)) }
      else (pure ())
      bif (← (HaveUAOExt ()))
      then writeReg PSTATE { (← readReg PSTATE) with UAO := (0b0 : (BitVec 1)) }
      else (pure ())
      writeReg ELR_EL1 (← (__UNKNOWN_bits 64))
      writeReg ESR_EL1 (Mk_ESR_EL1_Type (← (__UNKNOWN_bits 64)))
      writeReg SPSR_EL1 (Mk_SPSR_EL1_Type (← (__UNKNOWN_bits 64)))
      writeReg DLR_EL0 (← (__UNKNOWN_bits 64))
      writeReg DSPSR_EL0 (Mk_DSPSR_EL0_Type (← (__UNKNOWN_bits 64)))
      bif (Bool.and
           (Bool.and (← (HaveIESB ()))
             (BEq.beq (_get_SCTLR_EL1_Type_IESB (← readReg SCTLR_EL1)) (0b1 : (BitVec 1))))
           (Bool.not (← (ConstrainUnpredictableBool Unpredictable_IESBinDebug))))
      then (pure (SynchronizeErrors ()))
      else (pure ()))
  (UpdateEDSCRFields ())

def decode_aarch32_instrs_DCPS1_T1enc_A_txt (_ : Unit) : SailM Unit := do
  (execute_aarch32_instrs_DCPS1_Op_A_txt ())

def execute_aarch32_instrs_DCPS2_Op_A_txt (_ : Unit) : SailM Unit := do
  bif (Bool.or (Bool.not (← (Halted ()))) (Bool.not (← (EL2Enabled ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (← (ELUsingAArch32 EL2))
  then
    (do
      (AArch32_WriteMode M32_Hyp)
      writeReg PSTATE { (← readReg PSTATE) with E := (_get_HSCTLR_Type_EE (← (HSCTLR_read ()))) }
      (ELR_hyp_write (← (__UNKNOWN_bits 32)))
      (HSR_write (Mk_HSR_Type (← (__UNKNOWN_bits 32))))
      (SPSR_hyp_write (Mk_SPSR_hyp_Type (← (__UNKNOWN_bits 32))))
      (DLR_write (← (__UNKNOWN_bits 32)))
      (DSPSR_write (Mk_DSPSR_Type (← (__UNKNOWN_bits 32)))))
  else
    (do
      (AArch64_MaybeZeroRegisterUppers ())
      (MaybeZeroSVEUppers EL2)
      writeReg PSTATE { (← readReg PSTATE) with nRW := (0b0 : (BitVec 1)) }
      writeReg PSTATE { (← readReg PSTATE) with SP := (0b1 : (BitVec 1)) }
      writeReg PSTATE { (← readReg PSTATE) with EL := EL2 }
      bif (Bool.and
           (Bool.and
             (Bool.and (← (HavePANExt ()))
               (BEq.beq (_get_SCTLR_EL2_Type_SPAN (← readReg SCTLR_EL2)) (0b0 : (BitVec 1))))
             (BEq.beq (_get_HCR_EL2_Type_E2H (← readReg HCR_EL2)) (0b1 : (BitVec 1))))
           (BEq.beq (_get_HCR_EL2_Type_TGE (← readReg HCR_EL2)) (0b1 : (BitVec 1))))
      then writeReg PSTATE { (← readReg PSTATE) with PAN := (0b1 : (BitVec 1)) }
      else (pure ())
      bif (← (HaveUAOExt ()))
      then writeReg PSTATE { (← readReg PSTATE) with UAO := (0b0 : (BitVec 1)) }
      else (pure ())
      writeReg ELR_EL2 (← (__UNKNOWN_bits 64))
      writeReg ESR_EL2 (Mk_ESR_EL2_Type (← (__UNKNOWN_bits 64)))
      writeReg SPSR_EL2 (Mk_SPSR_EL2_Type (← (__UNKNOWN_bits 64)))
      writeReg DLR_EL0 (← (__UNKNOWN_bits 64))
      writeReg DSPSR_EL0 (Mk_DSPSR_EL0_Type (← (__UNKNOWN_bits 64)))
      bif (Bool.and
           (Bool.and (← (HaveIESB ()))
             (BEq.beq (_get_SCTLR_EL2_Type_IESB (← readReg SCTLR_EL2)) (0b1 : (BitVec 1))))
           (Bool.not (← (ConstrainUnpredictableBool Unpredictable_IESBinDebug))))
      then (pure (SynchronizeErrors ()))
      else (pure ()))
  (UpdateEDSCRFields ())

def decode_aarch32_instrs_DCPS2_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (Bool.not (HaveEL EL2))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch32_instrs_DCPS2_Op_A_txt ())

def execute_aarch32_instrs_DCPS3_Op_A_txt (_ : Unit) : SailM Unit := do
  let from_secure ← (( do (undefined_bool ()) ) : SailM Bool )
  let sync_errors ← (( do (undefined_bool ()) ) : SailM Bool )
  bif (Bool.or (Bool.not (← (Halted ())))
       (BEq.beq (_get_EDSCR_Type_SDD (← (EDSCR_read ()))) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (← (ELUsingAArch32 EL3))
  then
    (do
      let from_secure ← (( do (pure (eq_any (← (CurrentSecurityState ())) SS_Secure)) ) : SailM
        Bool )
      bif (BEq.beq (← readReg PSTATE).M M32_Monitor)
      then writeReg SCR (Sail.BitVec.updateSubrange (← readReg SCR) 0 0 (0b0 : (BitVec 1)))
      else (pure ())
      (AArch32_WriteMode M32_Monitor)
      bif (← (HavePANExt ()))
      then
        (do
          bif (Bool.not from_secure)
          then writeReg PSTATE { (← readReg PSTATE) with PAN := (0b0 : (BitVec 1)) }
          else
            (do
              bif (BEq.beq (_get_SCTLR_Type_SPAN (← (SCTLR_read__2 ()))) (0b0 : (BitVec 1)))
              then writeReg PSTATE { (← readReg PSTATE) with PAN := (0b1 : (BitVec 1)) }
              else (pure ())))
      else (pure ())
      writeReg PSTATE { (← readReg PSTATE) with E := (_get_SCTLR_Type_EE (← (SCTLR_read__2 ()))) }
      writeReg LR_mon (← (__UNKNOWN_bits 32))
      writeReg SPSR_mon (Mk_SPSR_mon_Type (← (__UNKNOWN_bits 32)))
      (DLR_write (← (__UNKNOWN_bits 32)))
      (DSPSR_write (Mk_DSPSR_Type (← (__UNKNOWN_bits 32)))))
  else
    (do
      (AArch64_MaybeZeroRegisterUppers ())
      (MaybeZeroSVEUppers EL3)
      writeReg PSTATE { (← readReg PSTATE) with nRW := (0b0 : (BitVec 1)) }
      writeReg PSTATE { (← readReg PSTATE) with SP := (0b1 : (BitVec 1)) }
      writeReg PSTATE { (← readReg PSTATE) with EL := EL3 }
      bif (← (HaveUAOExt ()))
      then writeReg PSTATE { (← readReg PSTATE) with UAO := (0b0 : (BitVec 1)) }
      else (pure ())
      writeReg ELR_EL3 (← (__UNKNOWN_bits 64))
      writeReg ESR_EL3 (Mk_ESR_EL3_Type (← (__UNKNOWN_bits 64)))
      writeReg SPSR_EL3 (Mk_SPSR_EL3_Type (← (__UNKNOWN_bits 64)))
      writeReg DLR_EL0 (← (__UNKNOWN_bits 64))
      writeReg DSPSR_EL0 (Mk_DSPSR_EL0_Type (← (__UNKNOWN_bits 64)))
      let sync_errors ← ((
        (pure (Bool.and (← (HaveIESB ()))
            (BEq.beq (_get_SCTLR_EL3_Type_IESB (← readReg SCTLR_EL3)) (0b1 : (BitVec 1))))) ) :
        SailM Bool )
      let sync_errors ← (( do
        bif (Bool.and
             (Bool.and (← (HaveDoubleFaultExt ()))
               (BEq.beq (← (EffectiveEA ())) (0b1 : (BitVec 1))))
             (BEq.beq (_get_SCR_EL3_Type_NMEA (← readReg SCR_EL3)) (0b1 : (BitVec 1))))
        then (pure true)
        else (pure sync_errors) ) : SailM Bool )
      let sync_errors ← (( do
        bif (Bool.not (← (ConstrainUnpredictableBool Unpredictable_IESBinDebug)))
        then (pure false)
        else (pure sync_errors) ) : SailM Bool )
      let _ : Unit :=
        bif sync_errors
        then (SynchronizeErrors ())
        else ()
      (pure ()))
  (UpdateEDSCRFields ())

def decode_aarch32_instrs_DCPS3_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (Bool.not (HaveEL EL3))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch32_instrs_DCPS3_Op_A_txt ())

def execute_aarch32_instrs_HLT_Op_A_txt (_ : Unit) : SailM Unit := do
  let is_async : Bool := false
  (Halt__1 DebugHalt_HaltInstruction is_async)

def decode_aarch32_instrs_HLT_A1enc_A_txt (cond : (BitVec 4)) (imm12 : (BitVec 12)) (imm4 : (BitVec 4)) : SailM Unit := do
  assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:42755.25-42755.26"
  bif (Bool.or (BEq.beq (_get_EDSCR_Type_HDE (← (EDSCR_read ()))) (0b0 : (BitVec 1)))
       (Bool.not (← (HaltingAllowed ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (bne cond (0xE : (BitVec 4)))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_HLT_Op_A_txt ())

def decode_aarch32_instrs_HLT_T1enc_A_txt (imm6 : (BitVec 6)) : SailM Unit := do
  bif (Bool.or (BEq.beq (_get_EDSCR_Type_HDE (← (EDSCR_read ()))) (0b0 : (BitVec 1)))
       (Bool.not (← (HaltingAllowed ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  (execute_aarch32_instrs_HLT_Op_A_txt ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDA_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit := (AArch32_SetLSInstructionSyndrome 4 false t true)
  (R_set t (← (MemO_read address 4)))

def decode_aarch32_instrs_LDA_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:42802.29-42802.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDA_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_LDA_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDA_Op_A_txt n t))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDAB_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit := (AArch32_SetLSInstructionSyndrome 1 false t true)
  (R_set t (zero_extend (← (MemO_read address 1)) 32))

def decode_aarch32_instrs_LDAB_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:42864.29-42864.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAB_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_LDAB_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAB_Op_A_txt n t))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDAEX_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  (AArch32_SetExclusiveMonitors address 4)
  let _ : Unit := (AArch32_SetLSInstructionSyndrome 4 false t true)
  (R_set t (← (MemO_read address 4)))

def decode_aarch32_instrs_LDAEX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:42927.29-42927.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAEX_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_LDAEX_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAEX_Op_A_txt n t))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDAEXB_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  (AArch32_SetExclusiveMonitors address 1)
  let _ : Unit := (AArch32_SetLSInstructionSyndrome 1 false t true)
  (R_set t (zero_extend (← (MemO_read address 1)) 32))

def decode_aarch32_instrs_LDAEXB_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:42990.29-42990.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAEXB_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_LDAEXB_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAEXB_Op_A_txt n t))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, t2 : Nat, 0 ≤ t2 ∧
  t2 ≤ 16 ∧ 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDAEXD_Op_A_txt (n : Nat) (t : Nat) (t2 : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  (AArch32_SetExclusiveMonitors address 8)
  let _ : Unit := (AArch32_SetLSInstructionSyndrome 8 false t true)
  let value_name ← (( do (MemO_read address 8) ) : SailM (BitVec 64) )
  (R_set t
    (← do
      bif (← (BigEndian AccessType_GPR))
      then (pure (Sail.BitVec.extractLsb value_name 63 32))
      else (pure (Sail.BitVec.extractLsb value_name 31 0))))
  (R_set t2
    (← do
      bif (← (BigEndian AccessType_GPR))
      then (pure (Sail.BitVec.extractLsb value_name 31 0))
      else (pure (Sail.BitVec.extractLsb value_name 63 32))))

def decode_aarch32_instrs_LDAEXD_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:43057.29-43057.30"
      let t := (UInt0 Rt)
      let t2 := (t +i 1)
      let n := (UInt0 Rn)
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Rt 0)]) (0b1 : (BitVec 1)))
             (BEq.beq t2 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAEXD_Op_A_txt n t t2))
  else (pure ())

def decode_aarch32_instrs_LDAEXD_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rt2 : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq t 15) (BEq.beq t2 15)) (BEq.beq t t2)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAEXD_Op_A_txt n t t2))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDAEXH_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  (AArch32_SetExclusiveMonitors address 2)
  let _ : Unit := (AArch32_SetLSInstructionSyndrome 2 false t true)
  (R_set t (zero_extend (← (MemO_read address 2)) 32))

def decode_aarch32_instrs_LDAEXH_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:43123.29-43123.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAEXH_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_LDAEXH_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAEXH_Op_A_txt n t))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_LDAH_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit := (AArch32_SetLSInstructionSyndrome 2 false t true)
  (R_set t (zero_extend (← (MemO_read address 2)) 32))

def decode_aarch32_instrs_LDAH_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:43185.29-43185.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAH_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_LDAH_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_LDAH_Op_A_txt n t))
  else (pure ())

def execute_aarch32_instrs_SEVL_Op_A_txt (_ : Unit) : SailM Unit := do
  (SendEventLocal ())

def decode_aarch32_instrs_SEVL_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:43243.29-43243.30"
      (execute_aarch32_instrs_SEVL_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_SEVL_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_SEVL_Op_A_txt ())
  else (pure ())

def decode_aarch32_instrs_SEVL_T2enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (execute_aarch32_instrs_SEVL_Op_A_txt ())
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_SHA1C_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let t ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  (CheckCryptoEnabled32 ())
  let x ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let y ← (( do (pure (Sail.BitVec.extractLsb (← (Q_read (Int.shiftl n 1))) 31 0)) ) : SailM
    (BitVec 32) )
  let w ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let (t, x, y) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := 3
    let mut loop_vars := (t, x, y)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (t, x, y) := loop_vars
      loop_vars ← do
        let t : (BitVec 32) :=
          (SHAchoose (Sail.BitVec.extractLsb x 63 32) (Sail.BitVec.extractLsb x 95 64)
            (Sail.BitVec.extractLsb x 127 96))
        let y ←
          (pure (((y + (← (ROL (Sail.BitVec.extractLsb x 31 0) 5))) + t) + (← (Elem_read w e 32))))
        let x ←
          (pure (Sail.BitVec.updateSubrange x 63 32 (← (ROL (Sail.BitVec.extractLsb x 63 32) 30))))
        let split_vec ← do (ROL (y ++ x) 32)
        let y : (BitVec 32) := (Sail.BitVec.extractLsb split_vec 159 128)
        let x : (BitVec 128) := (Sail.BitVec.extractLsb split_vec 127 0)
        (pure (t, x, y))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 128) × (BitVec 32)) )
  (Q_set (Int.shiftl d 1) x)

def decode_aarch32_instrs_SHA1C_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1C_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHA1C_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1C_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_SHA1H_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckCryptoEnabled32 ())
  (Q_set (Int.shiftl d 1)
    (zero_extend (← (ROL (Sail.BitVec.extractLsb (← (Q_read (Int.shiftl m 1))) 31 0) 30)) 128))

def decode_aarch32_instrs_SHA1H_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b10 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1H_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_SHA1H_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b10 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1H_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_SHA1M_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let t ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  (CheckCryptoEnabled32 ())
  let x ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let y ← (( do (pure (Sail.BitVec.extractLsb (← (Q_read (Int.shiftl n 1))) 31 0)) ) : SailM
    (BitVec 32) )
  let w ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let (t, x, y) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := 3
    let mut loop_vars := (t, x, y)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (t, x, y) := loop_vars
      loop_vars ← do
        let t : (BitVec 32) :=
          (SHAmajority (Sail.BitVec.extractLsb x 63 32) (Sail.BitVec.extractLsb x 95 64)
            (Sail.BitVec.extractLsb x 127 96))
        let y ←
          (pure (((y + (← (ROL (Sail.BitVec.extractLsb x 31 0) 5))) + t) + (← (Elem_read w e 32))))
        let x ←
          (pure (Sail.BitVec.updateSubrange x 63 32 (← (ROL (Sail.BitVec.extractLsb x 63 32) 30))))
        let split_vec ← do (ROL (y ++ x) 32)
        let y : (BitVec 32) := (Sail.BitVec.extractLsb split_vec 159 128)
        let x : (BitVec 128) := (Sail.BitVec.extractLsb split_vec 127 0)
        (pure (t, x, y))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 128) × (BitVec 32)) )
  (Q_set (Int.shiftl d 1) x)

def decode_aarch32_instrs_SHA1M_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1M_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHA1M_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1M_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_SHA1P_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  let t ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  (CheckCryptoEnabled32 ())
  let x ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let y ← (( do (pure (Sail.BitVec.extractLsb (← (Q_read (Int.shiftl n 1))) 31 0)) ) : SailM
    (BitVec 32) )
  let w ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let (t, x, y) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := 3
    let mut loop_vars := (t, x, y)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (t, x, y) := loop_vars
      loop_vars ← do
        let t : (BitVec 32) :=
          (SHAparity (Sail.BitVec.extractLsb x 63 32) (Sail.BitVec.extractLsb x 95 64)
            (Sail.BitVec.extractLsb x 127 96))
        let y ←
          (pure (((y + (← (ROL (Sail.BitVec.extractLsb x 31 0) 5))) + t) + (← (Elem_read w e 32))))
        let x ←
          (pure (Sail.BitVec.updateSubrange x 63 32 (← (ROL (Sail.BitVec.extractLsb x 63 32) 30))))
        let split_vec ← do (ROL (y ++ x) 32)
        let y : (BitVec 32) := (Sail.BitVec.extractLsb split_vec 159 128)
        let x : (BitVec 128) := (Sail.BitVec.extractLsb split_vec 127 0)
        (pure (t, x, y))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 128) × (BitVec 32)) )
  (Q_set (Int.shiftl d 1) x)

def decode_aarch32_instrs_SHA1P_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1P_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHA1P_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1P_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_SHA1SU0_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckCryptoEnabled32 ())
  let op1 ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let op2 ← (( do (Q_read (Int.shiftl n 1)) ) : SailM (BitVec 128) )
  let op3 ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let op2 : (BitVec 128) :=
    ((Sail.BitVec.extractLsb op2 63 0) ++ (Sail.BitVec.extractLsb op1 127 64))
  (Q_set (Int.shiftl d 1) ((op1 ^^^ op2) ^^^ op3))

def decode_aarch32_instrs_SHA1SU0_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1SU0_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHA1SU0_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1SU0_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_SHA1SU1_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckCryptoEnabled32 ())
  let X ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let Y ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let T : (BitVec 128) := (X ^^^ (Y >>> 32))
  let W0 ← (( do (ROL (Sail.BitVec.extractLsb T 31 0) 1) ) : SailM (BitVec 32) )
  let W1 ← (( do (ROL (Sail.BitVec.extractLsb T 63 32) 1) ) : SailM (BitVec 32) )
  let W2 ← (( do (ROL (Sail.BitVec.extractLsb T 95 64) 1) ) : SailM (BitVec 32) )
  let W3 ← (( do
    (pure ((← (ROL (Sail.BitVec.extractLsb T 127 96) 1)) ^^^ (← (ROL
            (Sail.BitVec.extractLsb T 31 0) 2)))) ) : SailM (BitVec 32) )
  (Q_set (Int.shiftl d 1) (((W3 ++ W2) ++ W1) ++ W0))

def decode_aarch32_instrs_SHA1SU1_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b10 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1SU1_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_SHA1SU1_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveSHA1Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b10 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA1SU1_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_SHA256H_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckCryptoEnabled32 ())
  let X ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let Y ← (( do (Q_read (Int.shiftl n 1)) ) : SailM (BitVec 128) )
  let W ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let part1 : Bool := true
  (Q_set (Int.shiftl d 1) (← (SHA256hash X Y W part1)))

def decode_aarch32_instrs_SHA256H_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSHA256Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA256H_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHA256H_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveSHA256Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA256H_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_SHA256H2_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckCryptoEnabled32 ())
  let X ← (( do (Q_read (Int.shiftl n 1)) ) : SailM (BitVec 128) )
  let Y ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let W ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let part1 : Bool := false
  (Q_set (Int.shiftl d 1) (← (SHA256hash X Y W part1)))

def decode_aarch32_instrs_SHA256H2_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSHA256Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA256H2_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHA256H2_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveSHA256Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA256H2_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_SHA256SU0_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  let elt ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  (CheckCryptoEnabled32 ())
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let x ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let y ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let t : (BitVec 128) := ((Sail.BitVec.extractLsb y 31 0) ++ (Sail.BitVec.extractLsb x 127 32))
  let (elt, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := 3
    let mut loop_vars := (elt, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (elt, result) := loop_vars
      loop_vars ← do
        let elt ← (Elem_read t e 32)
        let elt : (BitVec 32) := (((ROR elt 7) ^^^ (ROR elt 18)) ^^^ (elt >>> 3))
        let result ← (Elem_set result e 32 (elt + (← (Elem_read x e 32))))
        (pure (elt, result))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 128)) )
  (Q_set (Int.shiftl d 1) result)

def decode_aarch32_instrs_SHA256SU0_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSHA256Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b10 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA256SU0_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_SHA256SU0_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveSHA256Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne size (0b10 : (BitVec 2)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA256SU0_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_SHA256SU1_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckCryptoEnabled32 ())
  let elt ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let x ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let y ← (( do (Q_read (Int.shiftl n 1)) ) : SailM (BitVec 128) )
  let z ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let T0 : (BitVec 128) := ((Sail.BitVec.extractLsb z 31 0) ++ (Sail.BitVec.extractLsb y 127 32))
  let T1 : (BitVec 64) := (Sail.BitVec.extractLsb z 127 64)
  let (elt, result) ← (( do
    let loop_e_lower := 0
    let loop_e_upper := 1
    let mut loop_vars := (elt, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (elt, result) := loop_vars
      loop_vars ← do
        let elt ← (Elem_read T1 e 32)
        let elt : (BitVec 32) := (((ROR elt 17) ^^^ (ROR elt 19)) ^^^ (elt >>> 10))
        let elt ← (pure ((elt + (← (Elem_read x e 32))) + (← (Elem_read T0 e 32))))
        let result ← (Elem_set result e 32 elt)
        (pure (elt, result))
    (pure loop_vars) ) : SailM ((BitVec 32) × (BitVec 128)) )
  let T1 : (BitVec 64) := (Sail.BitVec.extractLsb result 63 0)
  let (elt, result) ← (( do
    let loop_e_lower := 2
    let loop_e_upper := 3
    let mut loop_vars_1 := (elt, result)
    for e in [loop_e_lower:loop_e_upper:1]i do
      let (elt, result) := loop_vars_1
      loop_vars_1 ← do
        let elt ← (Elem_read T1 (e -i 2) 32)
        let elt : (BitVec 32) := (((ROR elt 17) ^^^ (ROR elt 19)) ^^^ (elt >>> 10))
        let elt ← (pure ((elt + (← (Elem_read x e 32))) + (← (Elem_read T0 e 32))))
        let result ← (Elem_set result e 32 elt)
        (pure (elt, result))
    (pure loop_vars_1) ) : SailM ((BitVec 32) × (BitVec 128)) )
  (Q_set (Int.shiftl d 1) result)

def decode_aarch32_instrs_SHA256SU1_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSHA256Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA256SU1_Op_A_txt d m n))
  else (pure ())

def decode_aarch32_instrs_SHA256SU1_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.not (← (HaveSHA256Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (bne Q (0b1 : (BitVec 1)))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.or
           (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
             (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
           (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (D ++ Vd))
      let n := (UInt0 (N ++ Vn))
      let m := (UInt0 (M ++ Vm))
      (execute_aarch32_instrs_SHA256SU1_Op_A_txt d m n))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STL_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit := (AArch32_SetLSInstructionSyndrome 4 false t true)
  (MemO_set address 4 (← (R_read t)))

def decode_aarch32_instrs_STL_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:44146.29-44146.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STL_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_STL_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STL_Op_A_txt n t))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STLB_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit := (AArch32_SetLSInstructionSyndrome 1 false t true)
  (MemO_set address 1 (Sail.BitVec.extractLsb (← (R_read t)) 7 0))

def decode_aarch32_instrs_STLB_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:44208.29-44208.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLB_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_STLB_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLB_Op_A_txt n t))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_STLEX_Op_A_txt (d : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  bif (← (AArch32_ExclusiveMonitorsPass address 4))
  then
    (do
      let _ : Unit := (AArch32_SetLSInstructionSyndrome 4 false t true)
      (MemO_set address 4 (← (R_read t)))
      (R_set d (zero_extend (0b0 : (BitVec 1)) 32)))
  else (R_set d (zero_extend (0b1 : (BitVec 1)) 32))

def decode_aarch32_instrs_STLEX_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:44275.29-44275.30"
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLEX_Op_A_txt d n t))
  else (pure ())

def decode_aarch32_instrs_STLEX_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rd : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLEX_Op_A_txt d n t))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_STLEXB_Op_A_txt (d : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  bif (← (AArch32_ExclusiveMonitorsPass address 1))
  then
    (do
      let _ : Unit := (AArch32_SetLSInstructionSyndrome 1 false t true)
      (MemO_set address 1 (Sail.BitVec.extractLsb (← (R_read t)) 7 0))
      (R_set d (zero_extend (0b0 : (BitVec 1)) 32)))
  else (R_set d (zero_extend (0b1 : (BitVec 1)) 32))

def decode_aarch32_instrs_STLEXB_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:44352.29-44352.30"
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLEXB_Op_A_txt d n t))
  else (pure ())

def decode_aarch32_instrs_STLEXB_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rd : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLEXB_Op_A_txt d n t))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, t : Nat, t2 : Nat, 0 ≤ t2 ∧
  t2 ≤ 16 ∧ 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_STLEXD_Op_A_txt (d : Nat) (n : Nat) (t : Nat) (t2 : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let value_name ← (( do
    bif (← (BigEndian AccessType_GPR))
    then (pure ((← (R_read t)) ++ (← (R_read t2))))
    else (pure ((← (R_read t2)) ++ (← (R_read t)))) ) : SailM (BitVec 64) )
  bif (← (AArch32_ExclusiveMonitorsPass address 8))
  then
    (do
      let _ : Unit := (AArch32_SetLSInstructionSyndrome 8 false t true)
      (MemO_set address 8 value_name)
      (R_set d (zero_extend (0b0 : (BitVec 1)) 32)))
  else (R_set d (zero_extend (0b1 : (BitVec 1)) 32))

def decode_aarch32_instrs_STLEXD_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:44433.29-44433.30"
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let t2 := (t +i 1)
      let n := (UInt0 Rn)
      bif (Bool.or
           (Bool.or
             (Bool.or (BEq.beq d 15)
               (BEq.beq (BitVec.join1 [(BitVec.access Rt 0)]) (0b1 : (BitVec 1)))) (BEq.beq t2 15))
           (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (BEq.beq d n) (BEq.beq d t)) (BEq.beq d t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLEXD_Op_A_txt d n t t2))
  else (pure ())

def decode_aarch32_instrs_STLEXD_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rt2 : (BitVec 4)) (Rd : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let t2 := (UInt0 Rt2)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq t2 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (Bool.or (BEq.beq d n) (BEq.beq d t)) (BEq.beq d t2))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLEXD_Op_A_txt d n t t2))
  else (pure ())

/-- Type quantifiers: d : Nat, n : Nat, t : Nat, 0 ≤ t ∧
  t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 ∧ 0 ≤ d ∧ d ≤ 15 -/
def execute_aarch32_instrs_STLEXH_Op_A_txt (d : Nat) (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  bif (← (AArch32_ExclusiveMonitorsPass address 2))
  then
    (do
      let _ : Unit := (AArch32_SetLSInstructionSyndrome 2 false t true)
      (MemO_set address 2 (Sail.BitVec.extractLsb (← (R_read t)) 15 0))
      (R_set d (zero_extend (0b0 : (BitVec 1)) 32)))
  else (R_set d (zero_extend (0b1 : (BitVec 1)) 32))

def decode_aarch32_instrs_STLEXH_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rd : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:44509.29-44509.30"
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLEXH_Op_A_txt d n t))
  else (pure ())

def decode_aarch32_instrs_STLEXH_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) (Rd : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let d := (UInt0 Rd)
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (Bool.or (BEq.beq d 15) (BEq.beq t 15)) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      bif (Bool.or (BEq.beq d n) (BEq.beq d t))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLEXH_Op_A_txt d n t))
  else (pure ())

/-- Type quantifiers: n : Nat, t : Nat, 0 ≤ t ∧ t ≤ 15 ∧ 0 ≤ n ∧ n ≤ 15 -/
def execute_aarch32_instrs_STLH_Op_A_txt (n : Nat) (t : Nat) : SailM Unit := do
  let address ← (( do (R_read n) ) : SailM (BitVec 32) )
  let _ : Unit := (AArch32_SetLSInstructionSyndrome 2 false t true)
  (MemO_set address 2 (Sail.BitVec.extractLsb (← (R_read t)) 15 0))

def decode_aarch32_instrs_STLH_A1enc_A_txt (cond : (BitVec 4)) (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:44581.29-44581.30"
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLH_Op_A_txt n t))
  else (pure ())

def decode_aarch32_instrs_STLH_T1enc_A_txt (Rn : (BitVec 4)) (Rt : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      let t := (UInt0 Rt)
      let n := (UInt0 Rn)
      bif (Bool.or (BEq.beq t 15) (BEq.beq n 15))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_STLH_Op_A_txt n t))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCVTA_asimd_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (m : Nat) (regs : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  let d : Int := d__arg
  (CheckAdvSIMDEnabled ())
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let loop_r_lower := 0
  let loop_r_upper := (regs -i 1)
  let mut loop_vars := ()
  for r in [loop_r_lower:loop_r_upper:1]i do
    let () := loop_vars
    loop_vars ← do
      let loop_e_lower := 0
      let loop_e_upper := (elements -i 1)
      let mut loop_vars_1 := ()
      for e in [loop_e_lower:loop_e_upper:1]i do
        let () := loop_vars_1
        loop_vars_1 ← do
          (D_set (d +i r)
            (← (Elem_set (← (D_read (d +i r))) e esize
                (← (FPToFixed (← (Elem_read (← (D_read (m +i r))) e esize)) 0 is_unsigned
                    (← (StandardFPSCRValue ())) rounding esize)))))
      (pure loop_vars_1)
  (pure loop_vars)

def decode_aarch32_instrs_VCVTA_asimd_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (RM : (BitVec 2)) (op : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
       (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding ← (( do (FPDecodeRM RM) ) : SailM FPRounding )
  let is_unsigned : Bool := (BEq.beq op (0b1 : (BitVec 1)))
  let esize : Int := 16
  let elements : Int := 2
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let elements : Int := 2
        ())
      else ())
  let esize := esize
  let elements := elements
  let d := (UInt0 (D ++ Vd))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VCVTA_asimd_Op_A_txt d elements esize m regs rounding is_unsigned)

def decode_aarch32_instrs_VCVTA_asimd_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (RM : (BitVec 2)) (op : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
       (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding ← (( do (FPDecodeRM RM) ) : SailM FPRounding )
  let is_unsigned : Bool := (BEq.beq op (0b1 : (BitVec 1)))
  let esize : Int := 16
  let elements : Int := 2
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let elements : Int := 2
        ())
      else ())
  let esize := esize
  let elements := elements
  let d := (UInt0 (D ++ Vd))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VCVTA_asimd_Op_A_txt d elements esize m regs rounding is_unsigned)

/-- Type quantifiers: d : Nat, esize : Nat, k_is_unsigned : Bool, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VCVTA_vfp_Op_A_txt (d : Nat) (esize : Nat) (m : Nat) (rounding : FPRounding) (is_unsigned : Bool) : SailM Unit := do
  (CheckVFPEnabled true)
  match esize with
  | 16 => (S_set d
      (← (FPToFixed (Sail.BitVec.extractLsb (← (S_read m)) 15 0) 0 is_unsigned
          (← (FPSCR_read ())) rounding 32)))
  | 32 => (S_set d
      (← (FPToFixed (← (S_read m)) 0 is_unsigned (← (FPSCR_read ())) rounding 32)))
  | 64 => (S_set d
      (← (FPToFixed (← (D_read m)) 0 is_unsigned (← (FPSCR_read ())) rounding 32)))
  | _ => (pure ())

def decode_aarch32_instrs_VCVTA_vfp_A1enc_A_txt (D : (BitVec 1)) (RM : (BitVec 2)) (Vd : (BitVec 4)) (size : (BitVec 2)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
       (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding ← (( do (FPDecodeRM RM) ) : SailM FPRounding )
  let is_unsigned : Bool := (BEq.beq op (0b0 : (BitVec 1)))
  let d := (UInt0 (Vd ++ D))
  let esize : Int := 16
  let m ← (( do (undefined_range 0 31) ) : SailM Nat )
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let m : Nat := (UInt0 (Vm ++ M))
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let m : Nat := (UInt0 (Vm ++ M))
        ())
      else
        (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
        then
          (let esize : Int := 64
          let m : Nat := (UInt0 (M ++ Vm))
          ())
        else ()))
  let m := m
  let esize := esize
  (execute_aarch32_instrs_VCVTA_vfp_Op_A_txt d esize m rounding is_unsigned)

def decode_aarch32_instrs_VCVTA_vfp_T1enc_A_txt (D : (BitVec 1)) (RM : (BitVec 2)) (Vd : (BitVec 4)) (size : (BitVec 2)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
       (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding ← (( do (FPDecodeRM RM) ) : SailM FPRounding )
  let is_unsigned : Bool := (BEq.beq op (0b0 : (BitVec 1)))
  let d := (UInt0 (Vd ++ D))
  let esize : Int := 16
  let m ← (( do (undefined_range 0 31) ) : SailM Nat )
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let m : Nat := (UInt0 (Vm ++ M))
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let m : Nat := (UInt0 (Vm ++ M))
        ())
      else
        (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
        then
          (let esize : Int := 64
          let m : Nat := (UInt0 (M ++ Vm))
          ())
        else ()))
  let m := m
  let esize := esize
  (execute_aarch32_instrs_VCVTA_vfp_Op_A_txt d esize m rounding is_unsigned)

/-- Type quantifiers: k_advsimd : Bool, d__arg : Nat, elements : Int, esize : Nat, m : Nat, k_maximum
  : Bool, n : Nat, regs : Int, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VMAXNM_Op_A_txt (advsimd : Bool) (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (maximum : Bool) (n : Nat) (regs : Int) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let op2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDOrVFPEnabled true advsimd)
  bif advsimd
  then
    (do
      let (op1, op2) ← (( do
        let loop_r_lower := 0
        let loop_r_upper := (regs -i 1)
        let mut loop_vars := (op1, op2)
        for r in [loop_r_lower:loop_r_upper:1]i do
          let (op1, op2) := loop_vars
          loop_vars ← do
            let (op1, op2) ← (( do
              let loop_e_lower := 0
              let loop_e_upper := (elements -i 1)
              let mut loop_vars_1 := (op1, op2)
              for e in [loop_e_lower:loop_e_upper:1]i do
                let (op1, op2) := loop_vars_1
                loop_vars_1 ← do
                  let op1 ← (Elem_read (← (D_read (n +i r))) e esize)
                  let op2 ← (Elem_read (← (D_read (m +i r))) e esize)
                  bif maximum
                  then
                    (D_set (d +i r)
                      (← (Elem_set (← (D_read (d +i r))) e esize
                          (← (FPMaxNum op1 op2 (← (StandardFPSCRValue ())))))))
                  else
                    (D_set (d +i r)
                      (← (Elem_set (← (D_read (d +i r))) e esize
                          (← (FPMinNum op1 op2 (← (StandardFPSCRValue ())))))))
                  (pure (op1, op2))
              (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
            (pure (op1, op2))
        (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
      (pure ()))
  else
    (do
      match esize with
      | 16 => (do
          bif maximum
          then
            (S_set d
              ((Zeros (n := 16)) ++ (← (FPMaxNum (Sail.BitVec.extractLsb (← (S_read n)) 15 0)
                    (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ()))))))
          else
            (S_set d
              ((Zeros (n := 16)) ++ (← (FPMinNum (Sail.BitVec.extractLsb (← (S_read n)) 15 0)
                    (Sail.BitVec.extractLsb (← (S_read m)) 15 0) (← (FPSCR_read ())))))))
      | 32 => (do
          bif maximum
          then (S_set d (← (FPMaxNum (← (S_read n)) (← (S_read m)) (← (FPSCR_read ())))))
          else (S_set d (← (FPMinNum (← (S_read n)) (← (S_read m)) (← (FPSCR_read ()))))))
      | 64 => (do
          bif maximum
          then (D_set d (← (FPMaxNum (← (D_read n)) (← (D_read m)) (← (FPSCR_read ())))))
          else (D_set d (← (FPMinNum (← (D_read n)) (← (D_read m)) (← (FPSCR_read ()))))))
      | _ => (pure ()))

def decode_aarch32_instrs_VMAXNM_A1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
  let advsimd : Bool := true
  let esize : Int := 16
  let elements : Int := 2
  let _ : Unit :=
    let b__0 := sz
    bif (BEq.beq b__0 (0b0 : (BitVec 1)))
    then
      (let esize : Int := 32
      let elements : Int := 2
      ())
    else
      (let esize : Int := 16
      let elements : Int := 4
      ())
  let esize := esize
  let elements := elements
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VMAXNM_Op_A_txt advsimd d elements esize m maximum n regs)

def decode_aarch32_instrs_VMAXNM_A2enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  let elements ← (( do (undefined_int ()) ) : SailM Int )
  let regs ← (( do (undefined_int ()) ) : SailM Int )
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
       (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let regs := regs
  let elements := elements
  let advsimd : Bool := false
  let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
  let esize : Int := 16
  let d ← (( do (undefined_range 0 31) ) : SailM Nat )
  let n ← (( do (undefined_range 0 31) ) : SailM Nat )
  let m ← (( do (undefined_range 0 31) ) : SailM Nat )
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let d : Nat := (UInt0 (Vd ++ D))
      let n : Nat := (UInt0 (Vn ++ N))
      let m : Nat := (UInt0 (Vm ++ M))
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let d : Nat := (UInt0 (Vd ++ D))
        let n : Nat := (UInt0 (Vn ++ N))
        let m : Nat := (UInt0 (Vm ++ M))
        ())
      else
        (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
        then
          (let esize : Int := 64
          let d : Nat := (UInt0 (D ++ Vd))
          let n : Nat := (UInt0 (N ++ Vn))
          let m : Nat := (UInt0 (M ++ Vm))
          ())
        else ()))
  let n := n
  let m := m
  let esize := esize
  let d := d
  (execute_aarch32_instrs_VMAXNM_Op_A_txt advsimd d elements esize m maximum n regs)

def decode_aarch32_instrs_VMAXNM_T1enc_A_txt (D : (BitVec 1)) (op : (BitVec 1)) (sz : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq sz (0b1 : (BitVec 1))) (Bool.not (HaveFP16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
  let advsimd : Bool := true
  let esize : Int := 16
  let elements : Int := 2
  let _ : Unit :=
    let b__0 := sz
    bif (BEq.beq b__0 (0b0 : (BitVec 1)))
    then
      (let esize : Int := 32
      let elements : Int := 2
      ())
    else
      (let esize : Int := 16
      let elements : Int := 4
      ())
  let esize := esize
  let elements := elements
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VMAXNM_Op_A_txt advsimd d elements esize m maximum n regs)

def decode_aarch32_instrs_VMAXNM_T2enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  let elements ← (( do (undefined_int ()) ) : SailM Int )
  let regs ← (( do (undefined_int ()) ) : SailM Int )
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
       (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let regs := regs
  let elements := elements
  let advsimd : Bool := false
  let maximum : Bool := (BEq.beq op (0b0 : (BitVec 1)))
  let esize : Int := 16
  let d ← (( do (undefined_range 0 31) ) : SailM Nat )
  let n ← (( do (undefined_range 0 31) ) : SailM Nat )
  let m ← (( do (undefined_range 0 31) ) : SailM Nat )
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let d : Nat := (UInt0 (Vd ++ D))
      let n : Nat := (UInt0 (Vn ++ N))
      let m : Nat := (UInt0 (Vm ++ M))
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let d : Nat := (UInt0 (Vd ++ D))
        let n : Nat := (UInt0 (Vn ++ N))
        let m : Nat := (UInt0 (Vm ++ M))
        ())
      else
        (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
        then
          (let esize : Int := 64
          let d : Nat := (UInt0 (D ++ Vd))
          let n : Nat := (UInt0 (N ++ Vn))
          let m : Nat := (UInt0 (M ++ Vm))
          ())
        else ()))
  let n := n
  let m := m
  let esize := esize
  let d := d
  (execute_aarch32_instrs_VMAXNM_Op_A_txt advsimd d elements esize m maximum n regs)

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_exact : Bool, m : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRINTA_asimd_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (exact : Bool) (m : Nat) (regs : Nat) (rounding : FPRounding) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (op1, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, result) := loop_vars
      loop_vars ← do
        let (op1, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, result) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (m +i r))) e esize)
              let result ← (FPRoundInt op1 (← (StandardFPSCRValue ())) rounding exact)
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              (pure (op1, result))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VRINTA_asimd_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 3)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (bne (BitVec.join1 [(BitVec.access op 2)]) (BitVec.join1 [(BitVec.access op 0)]))
  then sailThrow ((Error_See "Related encodings"))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
       (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding ← (( do
    (FPDecodeRM
      ((BitVec.join1 [(BitVec.access op 2)]) ++ (Complement.complement
          (BitVec.join1 [(BitVec.access op 1)])))) ) : SailM FPRounding )
  let exact : Bool := false
  let esize : Int := 16
  let elements : Int := 2
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let elements : Int := 2
        ())
      else ())
  let esize := esize
  let elements := elements
  let d := (UInt0 (D ++ Vd))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VRINTA_asimd_Op_A_txt d elements esize exact m regs rounding)

def decode_aarch32_instrs_VRINTA_asimd_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (op : (BitVec 3)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (bne (BitVec.join1 [(BitVec.access op 2)]) (BitVec.join1 [(BitVec.access op 0)]))
  then sailThrow ((Error_See "Related encodings"))
  else (pure ())
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
       (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding ← (( do
    (FPDecodeRM
      ((BitVec.join1 [(BitVec.access op 2)]) ++ (Complement.complement
          (BitVec.join1 [(BitVec.access op 1)])))) ) : SailM FPRounding )
  let exact : Bool := false
  let esize : Int := 16
  let elements : Int := 2
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let elements : Int := 2
        ())
      else ())
  let esize := esize
  let elements := elements
  let d := (UInt0 (D ++ Vd))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VRINTA_asimd_Op_A_txt d elements esize exact m regs rounding)

/-- Type quantifiers: d : Nat, esize : Nat, k_exact : Bool, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VRINTA_vfp_Op_A_txt (d : Nat) (esize : Nat) (exact : Bool) (m : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckVFPEnabled true)
  match esize with
  | 16 => (S_set d
      ((Zeros (n := 16)) ++ (← (FPRoundInt (Sail.BitVec.extractLsb (← (S_read m)) 15 0)
            (← (FPSCR_read ())) rounding exact))))
  | 32 => (S_set d (← (FPRoundInt (← (S_read m)) (← (FPSCR_read ())) rounding exact)))
  | 64 => (D_set d (← (FPRoundInt (← (D_read m)) (← (FPSCR_read ())) rounding exact)))
  | _ => (pure ())

def decode_aarch32_instrs_VRINTA_vfp_A1enc_A_txt (D : (BitVec 1)) (RM : (BitVec 2)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
       (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding ← (( do (FPDecodeRM RM) ) : SailM FPRounding )
  let exact : Bool := false
  let esize : Int := 16
  let d ← (( do (undefined_range 0 31) ) : SailM Nat )
  let m ← (( do (undefined_range 0 31) ) : SailM Nat )
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let d : Nat := (UInt0 (Vd ++ D))
      let m : Nat := (UInt0 (Vm ++ M))
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let d : Nat := (UInt0 (Vd ++ D))
        let m : Nat := (UInt0 (Vm ++ M))
        ())
      else
        (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
        then
          (let esize : Int := 64
          let d : Nat := (UInt0 (D ++ Vd))
          let m : Nat := (UInt0 (M ++ Vm))
          ())
        else ()))
  let m := m
  let esize := esize
  let d := d
  (execute_aarch32_instrs_VRINTA_vfp_Op_A_txt d esize exact m rounding)

def decode_aarch32_instrs_VRINTA_vfp_T1enc_A_txt (D : (BitVec 1)) (RM : (BitVec 2)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
       (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding ← (( do (FPDecodeRM RM) ) : SailM FPRounding )
  let exact : Bool := false
  let esize : Int := 16
  let d ← (( do (undefined_range 0 31) ) : SailM Nat )
  let m ← (( do (undefined_range 0 31) ) : SailM Nat )
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let d : Nat := (UInt0 (Vd ++ D))
      let m : Nat := (UInt0 (Vm ++ M))
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let d : Nat := (UInt0 (Vd ++ D))
        let m : Nat := (UInt0 (Vm ++ M))
        ())
      else
        (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
        then
          (let esize : Int := 64
          let d : Nat := (UInt0 (D ++ Vd))
          let m : Nat := (UInt0 (M ++ Vm))
          ())
        else ()))
  let m := m
  let esize := esize
  let d := d
  (execute_aarch32_instrs_VRINTA_vfp_Op_A_txt d esize exact m rounding)

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_exact : Bool, m : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRINTX_asimd_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (exact : Bool) (m : Nat) (regs : Nat) (rounding : FPRounding) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (op1, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, result) := loop_vars
      loop_vars ← do
        let (op1, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, result) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (m +i r))) e esize)
              let result ← (FPRoundInt op1 (← (StandardFPSCRValue ())) rounding exact)
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              (pure (op1, result))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VRINTX_asimd_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
       (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding : FPRounding := FPRounding_TIEEVEN
  let exact : Bool := true
  let esize : Int := 16
  let elements : Int := 2
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let elements : Int := 2
        ())
      else ())
  let esize := esize
  let elements := elements
  let d := (UInt0 (D ++ Vd))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VRINTX_asimd_Op_A_txt d elements esize exact m regs rounding)

def decode_aarch32_instrs_VRINTX_asimd_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
       (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding : FPRounding := FPRounding_TIEEVEN
  let exact : Bool := true
  let esize : Int := 16
  let elements : Int := 2
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let elements : Int := 2
        ())
      else ())
  let esize := esize
  let elements := elements
  let d := (UInt0 (D ++ Vd))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_VRINTX_asimd_Op_A_txt d elements esize exact m regs rounding)

/-- Type quantifiers: d : Nat, esize : Nat, k_exact : Bool, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VRINTX_vfp_Op_A_txt (d : Nat) (esize : Nat) (exact : Bool) (m : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  let rounding ← (( do (FPRoundingMode (← (FPSCR_read ()))) ) : SailM FPRounding )
  match esize with
  | 16 => (S_set d
      ((Zeros (n := 16)) ++ (← (FPRoundInt (Sail.BitVec.extractLsb (← (S_read m)) 15 0)
            (← (FPSCR_read ())) rounding exact))))
  | 32 => (S_set d (← (FPRoundInt (← (S_read m)) (← (FPSCR_read ())) rounding exact)))
  | 64 => (D_set d (← (FPRoundInt (← (D_read m)) (← (FPSCR_read ())) rounding exact)))
  | _ => (pure ())

def decode_aarch32_instrs_VRINTX_vfp_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:45469.29-45469.30"
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let exact : Bool := true
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VRINTX_vfp_Op_A_txt d esize exact m))
  else (pure ())

def decode_aarch32_instrs_VRINTX_vfp_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let exact : Bool := true
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VRINTX_vfp_Op_A_txt d esize exact m))
  else (pure ())

/-- Type quantifiers: d__arg : Nat, elements : Nat, esize : Nat, k_exact : Bool, m : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32} ∧ elements ∈ {2, 4} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt (d__arg : Nat) (elements : Nat) (esize : Nat) (exact : Bool) (m : Nat) (regs : Nat) (rounding : FPRounding) : SailM Unit := do
  let d : Int := d__arg
  let op1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let result ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (op1, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (op1, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (op1, result) := loop_vars
      loop_vars ← do
        let (op1, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := (elements -i 1)
          let mut loop_vars_1 := (op1, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (op1, result) := loop_vars_1
            loop_vars_1 ← do
              let op1 ← (Elem_read (← (D_read (m +i r))) e esize)
              let result ← (FPRoundInt op1 (← (StandardFPSCRValue ())) rounding exact)
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) e esize result)))
              (pure (op1, result))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (op1, result))
    (pure loop_vars) ) : SailM ((BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VRINTZ_asimd_A1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
       (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding : FPRounding := FPRounding_ZERO
  let exact : Bool := false
  let esize : Int := 16
  let elements : Int := 2
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let elements : Int := 2
        ())
      else ())
  let esize := esize
  let elements := elements
  let d := (UInt0 (D ++ Vd))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  (execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt d elements esize exact m regs rounding)

def decode_aarch32_instrs_VRINTZ_asimd_T1enc_A_txt (D : (BitVec 1)) (size : (BitVec 2)) (Vd : (BitVec 4)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ())))
       (Bool.or (BEq.beq size (0b00 : (BitVec 2))) (BEq.beq size (0b11 : (BitVec 2)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let rounding : FPRounding := FPRounding_ZERO
  let exact : Bool := false
  let esize : Int := 16
  let elements : Int := 2
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let elements : Int := 4
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let elements : Int := 2
        ())
      else ())
  let esize := esize
  let elements := elements
  let d := (UInt0 (D ++ Vd))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  (execute_aarch32_instrs_VRINTZ_asimd_Op_A_txt d elements esize exact m regs rounding)

/-- Type quantifiers: d : Nat, esize : Nat, k_exact : Bool, m : Nat, 0 ≤ m ∧
  m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VRINTZ_vfp_Op_A_txt (d : Nat) (esize : Nat) (exact : Bool) (m : Nat) (rounding : FPRounding) : SailM Unit := do
  (CheckVFPEnabled true)
  match esize with
  | 16 => (S_set d
      ((Zeros (n := 16)) ++ (← (FPRoundInt (Sail.BitVec.extractLsb (← (S_read m)) 15 0)
            (← (FPSCR_read ())) rounding exact))))
  | 32 => (S_set d (← (FPRoundInt (← (S_read m)) (← (FPSCR_read ())) rounding exact)))
  | 64 => (D_set d (← (FPRoundInt (← (D_read m)) (← (FPSCR_read ())) rounding exact)))
  | _ => (pure ())

def decode_aarch32_instrs_VRINTZ_vfp_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:45698.29-45698.30"
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (bne cond (0xE : (BitVec 4))))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let rounding ← (( do
        bif (BEq.beq op (0b1 : (BitVec 1)))
        then (pure FPRounding_ZERO)
        else (FPRoundingMode (← (FPSCR_read ()))) ) : SailM FPRounding )
      let exact : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VRINTZ_vfp_Op_A_txt d esize exact m rounding))
  else (pure ())

def decode_aarch32_instrs_VRINTZ_vfp_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (size : (BitVec 2)) (op : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
           (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      bif (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (← (InITBlock ())))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      let rounding ← (( do
        bif (BEq.beq op (0b1 : (BitVec 1)))
        then (pure FPRounding_ZERO)
        else (FPRoundingMode (← (FPSCR_read ()))) ) : SailM FPRounding )
      let exact : Bool := false
      let esize : Int := 16
      let d ← (( do (undefined_range 0 31) ) : SailM Nat )
      let m ← (( do (undefined_range 0 31) ) : SailM Nat )
      let _ : Unit :=
        let b__0 := size
        bif (BEq.beq b__0 (0b01 : (BitVec 2)))
        then
          (let esize : Int := 16
          let d : Nat := (UInt0 (Vd ++ D))
          let m : Nat := (UInt0 (Vm ++ M))
          ())
        else
          (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let esize : Int := 32
            let d : Nat := (UInt0 (Vd ++ D))
            let m : Nat := (UInt0 (Vm ++ M))
            ())
          else
            (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
            then
              (let esize : Int := 64
              let d : Nat := (UInt0 (D ++ Vd))
              let m : Nat := (UInt0 (M ++ Vm))
              ())
            else ()))
      let m := m
      let esize := esize
      let d := d
      (execute_aarch32_instrs_VRINTZ_vfp_Op_A_txt d esize exact m rounding))
  else (pure ())

/-- Type quantifiers: d : Nat, esize : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VSEL_Op_A_txt (cond : (BitVec 4)) (d : Nat) (esize : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  match esize with
  | 16 => (S_set d
      ((Zeros (n := 16)) ++ (Sail.BitVec.extractLsb
          (← do
            bif (← (ConditionHolds cond))
            then (S_read n)
            else (S_read m)) 15 0)))
  | 32 => (S_set d
      (← do
        bif (← (ConditionHolds cond))
        then (S_read n)
        else (S_read m)))
  | 64 => (D_set d
      (← do
        bif (← (ConditionHolds cond))
        then (D_read n)
        else (D_read m)))
  | _ => (pure ())

def decode_aarch32_instrs_VSEL_A1enc_A_txt (D : (BitVec 1)) (cc : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
       (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize : Int := 16
  let d ← (( do (undefined_range 0 31) ) : SailM Nat )
  let n ← (( do (undefined_range 0 31) ) : SailM Nat )
  let m ← (( do (undefined_range 0 31) ) : SailM Nat )
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let d : Nat := (UInt0 (Vd ++ D))
      let n : Nat := (UInt0 (Vn ++ N))
      let m : Nat := (UInt0 (Vm ++ M))
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let d : Nat := (UInt0 (Vd ++ D))
        let n : Nat := (UInt0 (Vn ++ N))
        let m : Nat := (UInt0 (Vm ++ M))
        ())
      else
        (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
        then
          (let esize : Int := 64
          let d : Nat := (UInt0 (D ++ Vd))
          let n : Nat := (UInt0 (N ++ Vn))
          let m : Nat := (UInt0 (M ++ Vm))
          ())
        else ()))
  let n := n
  let m := m
  let esize := esize
  let d := d
  let cond : (BitVec 4) :=
    ((cc ++ ((BitVec.join1 [(BitVec.access cc 1)]) ^^^ (BitVec.join1 [(BitVec.access cc 0)]))) ++ (0b0 : (BitVec 1)))
  (execute_aarch32_instrs_VSEL_Op_A_txt cond d esize m n)

def decode_aarch32_instrs_VSEL_T1enc_A_txt (D : (BitVec 1)) (cc : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (size : (BitVec 2)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.or (BEq.beq size (0b00 : (BitVec 2)))
       (Bool.and (BEq.beq size (0b01 : (BitVec 2))) (Bool.not (HaveFP16Ext ()))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let esize : Int := 16
  let d ← (( do (undefined_range 0 31) ) : SailM Nat )
  let n ← (( do (undefined_range 0 31) ) : SailM Nat )
  let m ← (( do (undefined_range 0 31) ) : SailM Nat )
  let _ : Unit :=
    let b__0 := size
    bif (BEq.beq b__0 (0b01 : (BitVec 2)))
    then
      (let esize : Int := 16
      let d : Nat := (UInt0 (Vd ++ D))
      let n : Nat := (UInt0 (Vn ++ N))
      let m : Nat := (UInt0 (Vm ++ M))
      ())
    else
      (bif (BEq.beq b__0 (0b10 : (BitVec 2)))
      then
        (let esize : Int := 32
        let d : Nat := (UInt0 (Vd ++ D))
        let n : Nat := (UInt0 (Vn ++ N))
        let m : Nat := (UInt0 (Vm ++ M))
        ())
      else
        (bif (BEq.beq b__0 (0b11 : (BitVec 2)))
        then
          (let esize : Int := 64
          let d : Nat := (UInt0 (D ++ Vd))
          let n : Nat := (UInt0 (N ++ Vn))
          let m : Nat := (UInt0 (M ++ Vm))
          ())
        else ()))
  let n := n
  let m := m
  let esize := esize
  let d := d
  let cond : (BitVec 4) :=
    ((cc ++ ((BitVec.join1 [(BitVec.access cc 1)]) ^^^ (BitVec.join1 [(BitVec.access cc 0)]))) ++ (0b0 : (BitVec 1)))
  (execute_aarch32_instrs_VSEL_Op_A_txt cond d esize m n)

def execute_aarch32_instrs_SETPAN_Op_A_txt (value_name : (BitVec 1)) : SailM Unit := do
  bif (bne (← readReg PSTATE).EL EL0)
  then writeReg PSTATE { (← readReg PSTATE) with PAN := value_name }
  else (pure ())

def decode_aarch32_instrs_SETPAN_A1enc_A_txt (imm1 : (BitVec 1)) : SailM Unit := do
  bif (Bool.not (← (HavePANExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let value_name : (BitVec 1) := imm1
  (execute_aarch32_instrs_SETPAN_Op_A_txt value_name)

def decode_aarch32_instrs_SETPAN_T1enc_A_txt (imm1 : (BitVec 1)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HavePANExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let value_name : (BitVec 1) := imm1
  (execute_aarch32_instrs_SETPAN_Op_A_txt value_name)

def execute_aarch32_instrs_ESB_Op_A_txt (_ : Unit) : SailM Unit := do
  let _ : Unit := (SynchronizeErrors ())
  (AArch32_ESBOperation ())
  bif (Bool.and
       (Bool.or (BEq.beq (← readReg PSTATE).EL EL0) (BEq.beq (← readReg PSTATE).EL EL1))
       (← (EL2Enabled ())))
  then (AArch32_vESBOperation ())
  else (pure ())
  (TakeUnmaskedSErrorInterrupts ())

def decode_aarch32_instrs_ESB_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:45997.29-45997.30"
      bif (Bool.not (← (HaveRASExt ())))
      then (EndOfInstruction ())
      else (pure ())
      bif (bne cond (0xE : (BitVec 4)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ESB_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_ESB_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveRASExt ())))
      then (EndOfInstruction ())
      else (pure ())
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (execute_aarch32_instrs_ESB_Op_A_txt ()))
  else (pure ())

def execute_aarch32_instrs_TSB_Op_A_txt (_ : Unit) : Unit :=
  (TraceSynchronizationBarrier ())

def decode_aarch32_instrs_TSB_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:46053.29-46053.30"
      bif (Bool.not (← (HaveSelfHostedTrace ())))
      then (EndOfInstruction ())
      else (pure ())
      bif (bne cond (0xE : (BitVec 4)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (pure (execute_aarch32_instrs_TSB_Op_A_txt ())))
  else (pure ())

def decode_aarch32_instrs_TSB_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveSelfHostedTrace ())))
      then (EndOfInstruction ())
      else (pure ())
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (pure (execute_aarch32_instrs_TSB_Op_A_txt ())))
  else (pure ())

def execute_aarch32_instrs_CSDB_Op_A_txt (_ : Unit) : Unit :=
  (ConsumptionOfSpeculativeDataBarrier ())

def decode_aarch32_instrs_CSDB_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:46109.29-46109.30"
      bif (bne cond (0xE : (BitVec 4)))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (pure (execute_aarch32_instrs_CSDB_Op_A_txt ())))
  else (pure ())

def decode_aarch32_instrs_CSDB_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (pure (execute_aarch32_instrs_CSDB_Op_A_txt ())))
  else (pure ())

def execute_aarch32_instrs_SSBB_Op_A_txt (_ : Unit) : Unit :=
  (SpeculativeStoreBypassBarrierToVA ())

def decode_aarch32_instrs_SSBB_A1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_SSBB_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_SSBB_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (pure (execute_aarch32_instrs_SSBB_Op_A_txt ())))
  else (pure ())

def execute_aarch32_instrs_PSSBB_Op_A_txt (_ : Unit) : Unit :=
  (SpeculativeStoreBypassBarrierToPA ())

def decode_aarch32_instrs_PSSBB_A1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then (pure (execute_aarch32_instrs_PSSBB_Op_A_txt ()))
  else (pure ())

def decode_aarch32_instrs_PSSBB_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (← (InITBlock ()))
      then sailThrow ((Error_Unpredictable ()))
      else (pure ())
      (pure (execute_aarch32_instrs_PSSBB_Op_A_txt ())))
  else (pure ())

/-- Type quantifiers: d : Nat, esize : Nat, k_is_signed : Bool, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VDOT_Op_A_txt (d : Nat) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (is_signed : Bool) : SailM Unit := do
  let operand1 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  (CheckAdvSIMDEnabled ())
  let (operand1, operand2, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (operand1, operand2, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (operand1, operand2, result) := loop_vars
      loop_vars ← do
        let operand1 ← (D_read (n +i r))
        let operand2 ← (D_read (m +i r))
        let result ← (D_read (d +i r))
        let element1 ← (( do (undefined_int ()) ) : SailM Int )
        let element2 ← (( do (undefined_int ()) ) : SailM Int )
        let (element1, element2, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := 1
          let mut loop_vars_1 := (element1, element2, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (element1, element2, result) := loop_vars_1
            loop_vars_1 ← do
              let res : Int := 0
              let (element1, element2, res) ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := (element1, element2, res)
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let (element1, element2, res) := loop_vars_2
                  loop_vars_2 ← do
                    let (element1, element2) ← (( do
                      bif is_signed
                      then
                        (do
                          let element1 ←
                            (pure (sint
                                (← (Elem_read operand1 ((4 *i e) +i i) (ediv_nat esize 4)))))
                          let element2 ←
                            (pure (sint
                                (← (Elem_read operand2 ((4 *i e) +i i) (ediv_nat esize 4)))))
                          (pure (element1, element2)))
                      else
                        (do
                          let element1 ←
                            (pure (UInt0
                                (← (Elem_read operand1 ((4 *i e) +i i) (ediv_nat esize 4)))))
                          let element2 ←
                            (pure (UInt0
                                (← (Elem_read operand2 ((4 *i e) +i i) (ediv_nat esize 4)))))
                          (pure (element1, element2))) ) : SailM (Int × Int) )
                    let res : Int := (res +i (element1 *i element2))
                    (pure (element1, element2, res))
                (pure loop_vars_2) ) : SailM (Int × Int × Int) )
              let res := res
              let result ←
                (Elem_set result e esize (BitVec.addInt (← (Elem_read result e esize)) res))
              (pure (element1, element2, result))
          (pure loop_vars_1) ) : SailM (Int × Int × (BitVec 64)) )
        (D_set (d +i r) result)
        (pure (operand1, operand2, result))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_aarch32_instrs_VDOT_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (U : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveDOTPExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := (BEq.beq U (0b0 : (BitVec 1)))
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let esize := 32
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_VDOT_Op_A_txt d esize m n regs is_signed)

def decode_aarch32_instrs_VDOT_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (U : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveDOTPExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := (BEq.beq U (0b0 : (BitVec 1)))
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let esize := 32
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_VDOT_Op_A_txt d esize m n regs is_signed)

/-- Type quantifiers: d : Nat, esize : Nat, index : Nat, k_is_signed : Bool, m : Nat, n : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 15 ∧ index ∈ {0, 1} ∧ esize = 32 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VDOT_s_Op_A_txt (d : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (regs : Nat) (is_signed : Bool) : SailM Unit := do
  let operand1 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do (D_read m) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  (CheckAdvSIMDEnabled ())
  let (operand1, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (operand1, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (operand1, result) := loop_vars
      loop_vars ← do
        let operand1 ← (D_read (n +i r))
        let result ← (D_read (d +i r))
        let element1 ← (( do (undefined_int ()) ) : SailM Int )
        let element2 ← (( do (undefined_int ()) ) : SailM Int )
        let (element1, element2, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := 1
          let mut loop_vars_1 := (element1, element2, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (element1, element2, result) := loop_vars_1
            loop_vars_1 ← do
              let res : Int := 0
              let (element1, element2, res) ← (( do
                let loop_i_lower := 0
                let loop_i_upper := 3
                let mut loop_vars_2 := (element1, element2, res)
                for i in [loop_i_lower:loop_i_upper:1]i do
                  let (element1, element2, res) := loop_vars_2
                  loop_vars_2 ← do
                    let (element1, element2) ← (( do
                      bif is_signed
                      then
                        (do
                          let element1 ←
                            (pure (sint
                                (← (Elem_read operand1 ((4 *i e) +i i) (ediv_nat esize 4)))))
                          let element2 ←
                            (pure (sint
                                (← (Elem_read operand2 ((4 *i index) +i i) (ediv_nat esize 4)))))
                          (pure (element1, element2)))
                      else
                        (do
                          let element1 ←
                            (pure (UInt0
                                (← (Elem_read operand1 ((4 *i e) +i i) (ediv_nat esize 4)))))
                          let element2 ←
                            (pure (UInt0
                                (← (Elem_read operand2 ((4 *i index) +i i) (ediv_nat esize 4)))))
                          (pure (element1, element2))) ) : SailM (Int × Int) )
                    let res : Int := (res +i (element1 *i element2))
                    (pure (element1, element2, res))
                (pure loop_vars_2) ) : SailM (Int × Int × Int) )
              let res := res
              let result ←
                (Elem_set result e esize (BitVec.addInt (← (Elem_read result e esize)) res))
              (pure (element1, element2, result))
          (pure loop_vars_1) ) : SailM (Int × Int × (BitVec 64)) )
        (D_set (d +i r) result)
        (pure (operand1, result))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_aarch32_instrs_VDOT_s_A1enc_A_txt (op1 : (BitVec 1)) (D : (BitVec 1)) (op2 : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (U : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveDOTPExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := (BEq.beq U (0b0 : (BitVec 1)))
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (Sail.BitVec.extractLsb Vm 3 0))
  let index := (UInt0 M)
  let esize := 32
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_VDOT_s_Op_A_txt d esize index m n regs is_signed)

def decode_aarch32_instrs_VDOT_s_T1enc_A_txt (op1 : (BitVec 1)) (D : (BitVec 1)) (op2 : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (U : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveDOTPExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let is_signed : Bool := (BEq.beq U (0b0 : (BitVec 1)))
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (Sail.BitVec.extractLsb Vm 3 0))
  let index := (UInt0 M)
  let esize := 32
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_VDOT_s_Op_A_txt d esize index m n regs is_signed)

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VJCVT_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  let fltval ← (( do (D_read m) ) : SailM (BitVec 64) )
  let intval ← (( do (undefined_bitvector 32) ) : SailM (BitVec 32) )
  let Z ← (( do (undefined_bitvector 1) ) : SailM (BitVec 1) )
  let (tup__0, tup__1) ← do (FPToFixedJS fltval (← (FPSCR_read ())) false 32)
  let intval : (BitVec 32) := tup__0
  let Z : (BitVec 1) := tup__1
  (pure ())
  (FPSCR_write
    (Mk_FPSCR_Type
      (Sail.BitVec.updateSubrange (← (FPSCR_read__1 ())) 31 28
        (((0b0 : (BitVec 1)) ++ Z) ++ (0b00 : (BitVec 2))))))
  (S_set d intval)

def decode_aarch32_instrs_VJCVT_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:46459.25-46459.26"
  bif (Bool.not (← (HaveFJCVTZSExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (bne cond (0xE : (BitVec 4)))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let d := (UInt0 (Vd ++ D))
  let m := (UInt0 (M ++ Vm))
  (execute_aarch32_instrs_VJCVT_Op_A_txt d m)

def decode_aarch32_instrs_VJCVT_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveFJCVTZSExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  let d := (UInt0 (Vd ++ D))
  let m := (UInt0 (M ++ Vm))
  (execute_aarch32_instrs_VJCVT_Op_A_txt d m)

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCMLA_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (rot : (BitVec 2)) : SailM Unit := do
  let d : Int := d__arg
  let operand1 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand3 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let result2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (operand1, operand2, operand3, result1, result2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (operand1, operand2, operand3, result1, result2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (operand1, operand2, operand3, result1, result2) := loop_vars
      loop_vars ← do
        let operand1 ← (D_read (n +i r))
        let operand2 ← (D_read (m +i r))
        let operand3 ← (D_read (d +i r))
        let (result1, result2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := ((fdiv_int elements 2) -i 1)
          let mut loop_vars_1 := (result1, result2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (result1, result2) := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let element4 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let b__0 := rot
              bif (BEq.beq b__0 (0b00 : (BitVec 2)))
              then
                (do
                  let element1 ← (Elem_read operand2 (e *i 2) esize)
                  let element2 ← (Elem_read operand1 (e *i 2) esize)
                  let element3 ← (Elem_read operand2 ((e *i 2) +i 1) esize)
                  let element4 ← (Elem_read operand1 (e *i 2) esize)
                  (pure ()))
              else
                (do
                  bif (BEq.beq b__0 (0b01 : (BitVec 2)))
                  then
                    (do
                      let element1 ← (FPNeg (← (Elem_read operand2 ((e *i 2) +i 1) esize)))
                      let element2 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                      let element3 ← (Elem_read operand2 (e *i 2) esize)
                      let element4 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                      (pure ()))
                  else
                    (do
                      bif (BEq.beq b__0 (0b10 : (BitVec 2)))
                      then
                        (do
                          let element1 ← (FPNeg (← (Elem_read operand2 (e *i 2) esize)))
                          let element2 ← (Elem_read operand1 (e *i 2) esize)
                          let element3 ← (FPNeg (← (Elem_read operand2 ((e *i 2) +i 1) esize)))
                          let element4 ← (Elem_read operand1 (e *i 2) esize)
                          (pure ()))
                      else
                        (do
                          let element1 ← (Elem_read operand2 ((e *i 2) +i 1) esize)
                          let element2 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                          let element3 ← (FPNeg (← (Elem_read operand2 (e *i 2) esize)))
                          let element4 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                          (pure ()))))
              let element4 := element4
              let element3 := element3
              let element2 := element2
              let element1 := element1
              let result1 ←
                (FPMulAdd (← (Elem_read operand3 (e *i 2) esize)) element2 element1
                  (← (StandardFPSCRValue ())))
              let result2 ←
                (FPMulAdd (← (Elem_read operand3 ((e *i 2) +i 1) esize)) element4 element3
                  (← (StandardFPSCRValue ())))
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) (e *i 2) esize result1)))
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) ((e *i 2) +i 1) esize result2)))
              (pure (result1, result2))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (operand1, operand2, operand3, result1, result2))
    (pure loop_vars) ) : SailM
    ((BitVec 64) × (BitVec 64) × (BitVec 64) × (BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VCMLA_A1enc_A_txt (rot : (BitVec 2)) (D : (BitVec 1)) (S : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveFCADDExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let esize := (Int.shiftl 16 (UInt0 S))
  bif (Bool.and (Bool.not (HaveFP16Ext ())) (BEq.beq esize 16))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (fdiv_int 64 esize)
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  assert (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) "src/instrs32.sail:46581.41-46581.42"
  (execute_aarch32_instrs_VCMLA_Op_A_txt d elements esize m n regs rot)

def decode_aarch32_instrs_VCMLA_T1enc_A_txt (rot : (BitVec 2)) (D : (BitVec 1)) (S : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveFCADDExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let esize := (Int.shiftl 16 (UInt0 S))
  bif (Bool.and (Bool.not (HaveFP16Ext ())) (BEq.beq esize 16))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (fdiv_int 64 esize)
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  assert (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) "src/instrs32.sail:46620.41-46620.42"
  (execute_aarch32_instrs_VCMLA_Op_A_txt d elements esize m n regs rot)

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, index : Nat, m : Nat, n : Nat, regs
  : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 31 ∧ index ∈ {0, 1} ∧ esize ∈ {16, 32} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCMLA_idx_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (regs : Nat) (rot : (BitVec 2)) : SailM Unit := do
  let d : Int := d__arg
  let operand1 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand3 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let result2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (operand1, operand2, operand3, result1, result2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (operand1, operand2, operand3, result1, result2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (operand1, operand2, operand3, result1, result2) := loop_vars
      loop_vars ← do
        let operand1 ← (D_read (n +i r))
        let operand2 ← (Din_read m)
        let operand3 ← (D_read (d +i r))
        let (result1, result2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := ((fdiv_int elements 2) -i 1)
          let mut loop_vars_1 := (result1, result2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (result1, result2) := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let element2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let element4 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let b__0 := rot
              bif (BEq.beq b__0 (0b00 : (BitVec 2)))
              then
                (do
                  let element1 ← (Elem_read operand2 (index *i 2) esize)
                  let element2 ← (Elem_read operand1 (e *i 2) esize)
                  let element3 ← (Elem_read operand2 ((index *i 2) +i 1) esize)
                  let element4 ← (Elem_read operand1 (e *i 2) esize)
                  (pure ()))
              else
                (do
                  bif (BEq.beq b__0 (0b01 : (BitVec 2)))
                  then
                    (do
                      let element1 ← (FPNeg (← (Elem_read operand2 ((index *i 2) +i 1) esize)))
                      let element2 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                      let element3 ← (Elem_read operand2 (index *i 2) esize)
                      let element4 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                      (pure ()))
                  else
                    (do
                      bif (BEq.beq b__0 (0b10 : (BitVec 2)))
                      then
                        (do
                          let element1 ← (FPNeg (← (Elem_read operand2 (index *i 2) esize)))
                          let element2 ← (Elem_read operand1 (e *i 2) esize)
                          let element3 ←
                            (FPNeg (← (Elem_read operand2 ((index *i 2) +i 1) esize)))
                          let element4 ← (Elem_read operand1 (e *i 2) esize)
                          (pure ()))
                      else
                        (do
                          let element1 ← (Elem_read operand2 ((index *i 2) +i 1) esize)
                          let element2 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                          let element3 ← (FPNeg (← (Elem_read operand2 (index *i 2) esize)))
                          let element4 ← (Elem_read operand1 ((e *i 2) +i 1) esize)
                          (pure ()))))
              let element4 := element4
              let element3 := element3
              let element2 := element2
              let element1 := element1
              let result1 ←
                (FPMulAdd (← (Elem_read operand3 (e *i 2) esize)) element2 element1
                  (← (StandardFPSCRValue ())))
              let result2 ←
                (FPMulAdd (← (Elem_read operand3 ((e *i 2) +i 1) esize)) element4 element3
                  (← (StandardFPSCRValue ())))
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) (e *i 2) esize result1)))
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) ((e *i 2) +i 1) esize result2)))
              (pure (result1, result2))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (operand1, operand2, operand3, result1, result2))
    (pure loop_vars) ) : SailM
    ((BitVec 64) × (BitVec 64) × (BitVec 64) × (BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VCMLA_idx_A1enc_A_txt (S : (BitVec 1)) (D : (BitVec 1)) (rot : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveFCADDExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m :=
    bif (BEq.beq S (0b1 : (BitVec 1)))
    then (UInt0 (M ++ Vm))
    else (UInt0 Vm)
  let esize := (Int.shiftl 16 (UInt0 S))
  bif (Bool.and (Bool.not (HaveFP16Ext ())) (BEq.beq esize 16))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (fdiv_int 64 esize)
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  let index :=
    bif (BEq.beq S (0b1 : (BitVec 1)))
    then 0
    else (UInt0 M)
  assert (Bool.and (0 ≤b m) (Bool.and (m ≤b 31) (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)))) "src/instrs32.sail:46716.64-46716.65"
  (execute_aarch32_instrs_VCMLA_idx_Op_A_txt d elements esize index m n regs rot)

def decode_aarch32_instrs_VCMLA_idx_T1enc_A_txt (S : (BitVec 1)) (D : (BitVec 1)) (rot : (BitVec 2)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveFCADDExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m :=
    bif (BEq.beq S (0b1 : (BitVec 1)))
    then (UInt0 (M ++ Vm))
    else (UInt0 Vm)
  let esize := (Int.shiftl 16 (UInt0 S))
  bif (Bool.and (Bool.not (HaveFP16Ext ())) (BEq.beq esize 16))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (fdiv_int 64 esize)
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  let index :=
    bif (BEq.beq S (0b1 : (BitVec 1)))
    then 0
    else (UInt0 M)
  assert (Bool.and (0 ≤b m) (Bool.and (m ≤b 31) (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)))) "src/instrs32.sail:46756.64-46756.65"
  (execute_aarch32_instrs_VCMLA_idx_Op_A_txt d elements esize index m n regs rot)

/-- Type quantifiers: d__arg : Nat, elements : Int, esize : Nat, m : Nat, n : Nat, regs : Nat, regs
  ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ esize ∈ {16, 32} ∧ 0 ≤ d__arg ∧ d__arg ≤ 31 -/
def execute_aarch32_instrs_VCADD_Op_A_txt (d__arg : Nat) (elements : Int) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (rot : (BitVec 1)) : SailM Unit := do
  let d : Int := d__arg
  let operand1 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  let result2 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
  (CheckAdvSIMDEnabled ())
  let (operand1, operand2, result1, result2) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (operand1, operand2, result1, result2)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (operand1, operand2, result1, result2) := loop_vars
      loop_vars ← do
        let operand1 ← (D_read (n +i r))
        let operand2 ← (D_read (m +i r))
        let (result1, result2) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := ((fdiv_int elements 2) -i 1)
          let mut loop_vars_1 := (result1, result2)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (result1, result2) := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let element3 ← (( do (undefined_bitvector esize) ) : SailM (BitVec esize) )
              let b__0 := rot
              bif (BEq.beq b__0 (0b0 : (BitVec 1)))
              then
                (do
                  let element1 ← (FPNeg (← (Elem_read operand2 ((e *i 2) +i 1) esize)))
                  let element3 ← (Elem_read operand2 (e *i 2) esize)
                  (pure ()))
              else
                (do
                  let element1 ← (Elem_read operand2 ((e *i 2) +i 1) esize)
                  let element3 ← (FPNeg (← (Elem_read operand2 (e *i 2) esize)))
                  (pure ()))
              let element3 := element3
              let element1 := element1
              let result1 ←
                (FPAdd (← (Elem_read operand1 (e *i 2) esize)) element1
                  (← (StandardFPSCRValue ())))
              let result2 ←
                (FPAdd (← (Elem_read operand1 ((e *i 2) +i 1) esize)) element3
                  (← (StandardFPSCRValue ())))
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) (e *i 2) esize result1)))
              (D_set (d +i r) (← (Elem_set (← (D_read (d +i r))) ((e *i 2) +i 1) esize result2)))
              (pure (result1, result2))
          (pure loop_vars_1) ) : SailM ((BitVec esize) × (BitVec esize)) )
        (pure (operand1, operand2, result1, result2))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec esize) × (BitVec esize)) )
  (pure ())

def decode_aarch32_instrs_VCADD_A1enc_A_txt (rot : (BitVec 1)) (D : (BitVec 1)) (S : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveFCADDExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let esize := (Int.shiftl 16 (UInt0 S))
  bif (Bool.and (Bool.not (HaveFP16Ext ())) (BEq.beq esize 16))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (fdiv_int 64 esize)
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  assert (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) "src/instrs32.sail:46829.41-46829.42"
  (execute_aarch32_instrs_VCADD_Op_A_txt d elements esize m n regs rot)

def decode_aarch32_instrs_VCADD_T1enc_A_txt (rot : (BitVec 1)) (D : (BitVec 1)) (S : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveFCADDExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let esize := (Int.shiftl 16 (UInt0 S))
  bif (Bool.and (Bool.not (HaveFP16Ext ())) (BEq.beq esize 16))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let elements := (fdiv_int 64 esize)
  let regs :=
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then 1
    else 2
  assert (Bool.or (BEq.beq esize 16) (BEq.beq esize 32)) "src/instrs32.sail:46868.41-46868.42"
  (execute_aarch32_instrs_VCADD_Op_A_txt d elements esize m n regs rot)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, m : Nat, n : Nat, regs : Nat, k_sub_op :
  Bool, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧ m ≤ 31 ∧ esize = 32 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VFMAL_Op_A_txt (Q : (BitVec 1)) (d : Nat) (datasize : Nat) (esize : Nat) (m : Nat) (n : Nat) (regs : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let operand1 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let element1 ← (( do (undefined_bitvector (Int.ediv esize 2)) ) : SailM (BitVec (esize / 2)) )
  let element2 ← (( do (undefined_bitvector (Int.ediv esize 2)) ) : SailM (BitVec (esize / 2)) )
  let (operand1, operand2) ← (( do
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then
      (do
        assert (Bool.and (0 ≤b (datasize -i 1)) ((datasize -i 1) <b 32)) "src/instrs32.sail:46899.68-46899.69"
        let operand1 ← (pure (Sail.BitVec.extractLsb (← (S_read n)) (datasize -i 1) 0))
        let operand2 ← (pure (Sail.BitVec.extractLsb (← (S_read m)) (datasize -i 1) 0))
        (pure (operand1, operand2)))
    else
      (do
        let operand1 ← (pure (Sail.BitVec.extractLsb (← (D_read n)) (datasize -i 1) 0))
        let operand2 ← (pure (Sail.BitVec.extractLsb (← (D_read m)) (datasize -i 1) 0))
        (pure (operand1, operand2))) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
  let (element1, element2, operand3, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (element1, element2, operand3, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (element1, element2, operand3, result) := loop_vars
      loop_vars ← do
        let operand3 ← (D_read (d +i r))
        let (element1, element2, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := 1
          let mut loop_vars_1 := (element1, element2, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (element1, element2, result) := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (Elem_read operand1 ((2 *i r) +i e) (ediv_nat esize 2))
              let element2 ← (Elem_read operand2 ((2 *i r) +i e) (ediv_nat esize 2))
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec (esize / 2)) )
              let result ←
                (Elem_set result e esize
                  (← (FPMulAddH (← (Elem_read operand3 e esize)) element1 element2
                      (← (StandardFPSCRValue ())))))
              (pure (element1, element2, result))
          (pure loop_vars_1) ) : SailM ((BitVec (esize / 2)) × (BitVec (esize / 2)) × (BitVec 64))
          )
        (D_set (d +i r) result)
        (pure (element1, element2, operand3, result))
    (pure loop_vars) ) : SailM
    ((BitVec (esize / 2)) × (BitVec (esize / 2)) × (BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_aarch32_instrs_VFMAL_A1enc_A_txt (S : (BitVec 1)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then (UInt0 (N ++ Vn))
    else (UInt0 (Vn ++ N))
  let m :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then (UInt0 (M ++ Vm))
    else (UInt0 (Vm ++ M))
  let esize := 32
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  let datasize :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (BEq.beq S (0b1 : (BitVec 1)))
  assert (Bool.and (0 ≤b n) (Bool.and (n ≤b 31) (Bool.and (0 ≤b m) (m ≤b 31)))) "src/instrs32.sail:46936.64-46936.65"
  (execute_aarch32_instrs_VFMAL_Op_A_txt Q d datasize esize m n regs sub_op)

def decode_aarch32_instrs_VFMAL_T1enc_A_txt (S : (BitVec 1)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then (UInt0 (N ++ Vn))
    else (UInt0 (Vn ++ N))
  let m :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then (UInt0 (M ++ Vm))
    else (UInt0 (Vm ++ M))
  let esize := 32
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  let datasize :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (BEq.beq S (0b1 : (BitVec 1)))
  assert (Bool.and (0 ≤b n) (Bool.and (n ≤b 31) (Bool.and (0 ≤b m) (m ≤b 31)))) "src/instrs32.sail:46972.64-46972.65"
  (execute_aarch32_instrs_VFMAL_Op_A_txt Q d datasize esize m n regs sub_op)

/-- Type quantifiers: d : Nat, datasize : Nat, esize : Nat, index : Nat, m : Nat, n : Nat, regs :
  Nat, k_sub_op : Bool, regs ∈ {1, 2} ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  0 ≤ m ∧
  m ≤ 15 ∧
  index ∈ {0, 1, 2, 3} ∧ esize = 32 ∧ datasize ∈ {32, 64} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VFMAL_i_Op_A_txt (Q : (BitVec 1)) (d : Nat) (datasize : Nat) (esize : Nat) (index : Nat) (m : Nat) (n : Nat) (regs : Nat) (sub_op : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let operand1 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand2 ← (( do (undefined_bitvector datasize) ) : SailM (BitVec datasize) )
  let operand3 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let element1 ← (( do (undefined_bitvector (Int.ediv esize 2)) ) : SailM (BitVec (esize / 2)) )
  let (operand1, operand2) ← (( do
    bif (BEq.beq Q (0b0 : (BitVec 1)))
    then
      (do
        assert (Bool.and (0 ≤b (datasize -i 1)) ((datasize -i 1) <b 32)) "src/instrs32.sail:47001.68-47001.69"
        let operand1 ← (pure (Sail.BitVec.extractLsb (← (S_read n)) (datasize -i 1) 0))
        let operand2 ← (pure (Sail.BitVec.extractLsb (← (S_read m)) (datasize -i 1) 0))
        (pure (operand1, operand2)))
    else
      (do
        let operand1 ← (pure (Sail.BitVec.extractLsb (← (D_read n)) (datasize -i 1) 0))
        let operand2 ← (pure (Sail.BitVec.extractLsb (← (D_read m)) (datasize -i 1) 0))
        (pure (operand1, operand2))) ) : SailM ((BitVec datasize) × (BitVec datasize)) )
  let element2 ← (( do (Elem_read operand2 index (ediv_nat esize 2)) ) : SailM
    (BitVec (esize / 2)) )
  let (element1, operand3, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (element1, operand3, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (element1, operand3, result) := loop_vars
      loop_vars ← do
        let operand3 ← (D_read (d +i r))
        let (element1, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := 1
          let mut loop_vars_1 := (element1, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (element1, result) := loop_vars_1
            loop_vars_1 ← do
              let element1 ← (Elem_read operand1 ((2 *i r) +i e) (ediv_nat esize 2))
              let element1 ← (( do
                bif sub_op
                then
                  (do
                    (FPNeg element1))
                else (pure element1) ) : SailM (BitVec (esize / 2)) )
              let result ←
                (Elem_set result e esize
                  (← (FPMulAddH (← (Elem_read operand3 e esize)) element1 element2
                      (← (StandardFPSCRValue ())))))
              (pure (element1, result))
          (pure loop_vars_1) ) : SailM ((BitVec (esize / 2)) × (BitVec 64)) )
        (D_set (d +i r) result)
        (pure (element1, operand3, result))
    (pure loop_vars) ) : SailM ((BitVec (esize / 2)) × (BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_aarch32_instrs_VFMAL_i_A1enc_A_txt (D : (BitVec 1)) (S : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then (UInt0 (N ++ Vn))
    else (UInt0 (Vn ++ N))
  let m :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
    else (UInt0 ((Sail.BitVec.extractLsb Vm 2 0) ++ M))
  let index :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
    else (UInt0 (BitVec.join1 [(BitVec.access Vm 3)]))
  let esize := 32
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  let datasize :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (BEq.beq S (0b1 : (BitVec 1)))
  assert (Bool.and (0 ≤b n)
    (Bool.and (n ≤b 31)
      (Bool.and (0 ≤b m)
        (Bool.and (m ≤b 15)
          (Bool.or (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
            (BEq.beq index 3)))))) "src/instrs32.sail:47039.89-47039.90"
  (execute_aarch32_instrs_VFMAL_i_Op_A_txt Q d datasize esize index m n regs sub_op)

def decode_aarch32_instrs_VFMAL_i_T1enc_A_txt (D : (BitVec 1)) (S : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveFP16MulNoRoundingToFP32Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then (UInt0 (N ++ Vn))
    else (UInt0 (Vn ++ N))
  let m :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
    else (UInt0 ((Sail.BitVec.extractLsb Vm 2 0) ++ M))
  let index :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
    else (UInt0 (BitVec.join1 [(BitVec.access Vm 3)]))
  let esize := 32
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  let datasize :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 64
    else 32
  let sub_op : Bool := (BEq.beq S (0b1 : (BitVec 1)))
  assert (Bool.and (0 ≤b n)
    (Bool.and (n ≤b 31)
      (Bool.and (0 ≤b m)
        (Bool.and (m ≤b 15)
          (Bool.or (Bool.or (Bool.or (BEq.beq index 0) (BEq.beq index 1)) (BEq.beq index 2))
            (BEq.beq index 3)))))) "src/instrs32.sail:47076.89-47076.90"
  (execute_aarch32_instrs_VFMAL_i_Op_A_txt Q d datasize esize index m n regs sub_op)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VDOT_bf16_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  let operand1 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  (CheckAdvSIMDEnabled ())
  let (operand1, operand2, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (operand1, operand2, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (operand1, operand2, result) := loop_vars
      loop_vars ← do
        let operand1 ← (Din_read (n +i r))
        let operand2 ← (Din_read (m +i r))
        let result ← (Din_read (d +i r))
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := 1
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do
                (FPAdd_BF16 (← (BFMulH elt1_a elt2_a)) (← (BFMulH elt1_b elt2_b))) ) : SailM
                (BitVec 32) )
              (Elem_set result e 32 (← (FPAdd_BF16 (← (Elem_read result e 32)) sum)))
          (pure loop_vars_1) ) : SailM (BitVec 64) )
        (D_set (d +i r) result)
        (pure (operand1, operand2, result))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_aarch32_instrs_VDOT_bf16_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_VDOT_bf16_Op_A_txt d m n regs)

def decode_aarch32_instrs_VDOT_bf16_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_VDOT_bf16_Op_A_txt d m n regs)

/-- Type quantifiers: d : Nat, i : Nat, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 15 ∧ i ∈ {0, 1} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VDOT_bf16_i_Op_A_txt (d : Nat) (i : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  let operand1 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  (CheckAdvSIMDEnabled ())
  let operand2 ← (( do (Din_read m) ) : SailM (BitVec 64) )
  let (operand1, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (operand1, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (operand1, result) := loop_vars
      loop_vars ← do
        let operand1 ← (Din_read (n +i r))
        let result ← (Din_read (d +i r))
        let result ← (( do
          let loop_e_lower := 0
          let loop_e_upper := 1
          let mut loop_vars_1 := result
          for e in [loop_e_lower:loop_e_upper:1]i do
            let result := loop_vars_1
            loop_vars_1 ← do
              let elt1_a ← (( do (Elem_read operand1 ((2 *i e) +i 0) 16) ) : SailM (BitVec 16) )
              let elt1_b ← (( do (Elem_read operand1 ((2 *i e) +i 1) 16) ) : SailM (BitVec 16) )
              let elt2_a ← (( do (Elem_read operand2 ((2 *i i) +i 0) 16) ) : SailM (BitVec 16) )
              let elt2_b ← (( do (Elem_read operand2 ((2 *i i) +i 1) 16) ) : SailM (BitVec 16) )
              let sum ← (( do
                (FPAdd_BF16 (← (BFMulH elt1_a elt2_a)) (← (BFMulH elt1_b elt2_b))) ) : SailM
                (BitVec 32) )
              (Elem_set result e 32 (← (FPAdd_BF16 (← (Elem_read result e 32)) sum)))
          (pure loop_vars_1) ) : SailM (BitVec 64) )
        (D_set (d +i r) result)
        (pure (operand1, result))
    (pure loop_vars) ) : SailM ((BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_aarch32_instrs_VDOT_bf16_i_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 Vm)
  let i := (UInt0 M)
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_VDOT_bf16_i_Op_A_txt d i m n regs)

def decode_aarch32_instrs_VDOT_bf16_i_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 Vm)
  let i := (UInt0 M)
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_VDOT_bf16_i_Op_A_txt d i m n regs)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, 0 ≤ n ∧
  n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VMMLA_Op_A_txt (d : Nat) (m : Nat) (n : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let op1 ← (( do (Q_read (Int.shiftl n 1)) ) : SailM (BitVec 128) )
  let op2 ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let acc ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  (Q_set (Int.shiftl d 1) (← (BFMatMulAdd acc op1 op2)))

def decode_aarch32_instrs_VMMLA_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
       (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs := 2
  (execute_aarch32_instrs_VMMLA_Op_A_txt d m n)

def decode_aarch32_instrs_VMMLA_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
       (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs := 2
  (execute_aarch32_instrs_VMMLA_Op_A_txt d m n)

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VCVT_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  let operand ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  bif (← (ConditionPassed ()))
  then
    (do
      let _ : Unit := (EncodingSpecificOperations ())
      (CheckAdvSIMDEnabled ())
      let operand ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
      let result ← (( do
        let loop_e_lower := 0
        let loop_e_upper := 3
        let mut loop_vars := result
        for e in [loop_e_lower:loop_e_upper:1]i do
          let result := loop_vars
          loop_vars ← do
            let op ← (( do (Elem_read operand e 32) ) : SailM (BitVec 32) )
            (Elem_set result e 16 (← (FPConvertBF__1 op (← (StandardFPSCRValue ())))))
        (pure loop_vars) ) : SailM (BitVec 64) )
      (D_set d result))
  else (pure ())

def decode_aarch32_instrs_VCVT_A1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let m := (UInt0 (M ++ Vm))
  (execute_aarch32_instrs_VCVT_Op_A_txt d m)

def decode_aarch32_instrs_VCVT_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let m := (UInt0 (M ++ Vm))
  (execute_aarch32_instrs_VCVT_Op_A_txt d m)

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VCVTB_bf16_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  (S_set d
    (Sail.BitVec.updateSubrange (← (S_read d)) 15 0
      (← (FPConvertBF__1 (← (S_read m)) (← (FPSCR_read ()))))))

def decode_aarch32_instrs_VCVTB_bf16_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:47410.29-47410.30"
      bif (Bool.not (← (HaveAArch32BF16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (Vd ++ D))
      let m := (UInt0 (Vm ++ M))
      (execute_aarch32_instrs_VCVTB_bf16_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_VCVTB_bf16_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveAArch32BF16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (Vd ++ D))
      let m := (UInt0 (Vm ++ M))
      (execute_aarch32_instrs_VCVTB_bf16_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, m : Nat, 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VCVTT_Op_A_txt (d : Nat) (m : Nat) : SailM Unit := do
  (CheckVFPEnabled true)
  (S_set d
    (Sail.BitVec.updateSubrange (← (S_read d)) 31 16
      (← (FPConvertBF__1 (← (S_read m)) (← (FPSCR_read ()))))))

def decode_aarch32_instrs_VCVTT_A1enc_A_txt (cond : (BitVec 4)) (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:47467.29-47467.30"
      bif (Bool.not (← (HaveAArch32BF16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (Vd ++ D))
      let m := (UInt0 (Vm ++ M))
      (execute_aarch32_instrs_VCVTT_Op_A_txt d m))
  else (pure ())

def decode_aarch32_instrs_VCVTT_T1enc_A_txt (D : (BitVec 1)) (Vd : (BitVec 4)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveAArch32BF16Ext ())))
      then sailThrow ((Error_Undefined ()))
      else (pure ())
      let d := (UInt0 (Vd ++ D))
      let m := (UInt0 (Vm ++ M))
      (execute_aarch32_instrs_VCVTT_Op_A_txt d m))
  else (pure ())

/-- Type quantifiers: d : Nat, elements : Nat, m : Nat, n : Nat, sel : Nat, sel ∈ {0, 1} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ elements = 4 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VFMA_bf_Op_A_txt (d : Nat) (elements : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let operand1 ← (( do (Q_read (Int.shiftl n 1)) ) : SailM (BitVec 128) )
  let operand2 ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let operand3 ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do
          (pure ((← (Elem_read operand1 ((2 *i e) +i sel) 16)) ++ (Zeros (n := 16)))) ) : SailM
          (BitVec 32) )
        let element2 ← (( do
          (pure ((← (Elem_read operand2 ((2 *i e) +i sel) 16)) ++ (Zeros (n := 16)))) ) : SailM
          (BitVec 32) )
        let addend ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        (Elem_set result e 32
          (← (FPMulAdd addend element1 element2 (← (StandardFPSCRValue ())))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (Q_set (Int.shiftl d 1) result)

def decode_aarch32_instrs_VFMA_bf_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
       (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let elements := (ediv_nat 128 32)
  let sel := (UInt0 Q)
  (execute_aarch32_instrs_VFMA_bf_Op_A_txt d elements m n sel)

def decode_aarch32_instrs_VFMA_bf_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
       (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let elements := (ediv_nat 128 32)
  let sel := (UInt0 Q)
  (execute_aarch32_instrs_VFMA_bf_Op_A_txt d elements m n sel)

/-- Type quantifiers: d : Nat, elements : Nat, i : Nat, m : Nat, n : Nat, sel : Nat, sel ∈ {0, 1}
  ∧
  0 ≤ n ∧
  n ≤ 31 ∧
  m ∈ {0, 1, 2, 3, 4, 5, 6, 7} ∧ i ∈ {0, 1, 2, 3} ∧ elements = 4 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VFMA_bfs_Op_A_txt (d : Nat) (elements : Nat) (i : Nat) (m : Nat) (n : Nat) (sel : Nat) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let operand1 ← (( do (Q_read (Int.shiftl n 1)) ) : SailM (BitVec 128) )
  let operand2 ← (( do (D_read m) ) : SailM (BitVec 64) )
  let operand3 ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  let result ← (( do (undefined_bitvector 128) ) : SailM (BitVec 128) )
  let element2 ← (( do (pure ((← (Elem_read operand2 i 16)) ++ (Zeros (n := 16)))) ) : SailM
    (BitVec 32) )
  let result ← (( do
    let loop_e_lower := 0
    let loop_e_upper := (elements -i 1)
    let mut loop_vars := result
    for e in [loop_e_lower:loop_e_upper:1]i do
      let result := loop_vars
      loop_vars ← do
        let element1 ← (( do
          (pure ((← (Elem_read operand1 ((2 *i e) +i sel) 16)) ++ (Zeros (n := 16)))) ) : SailM
          (BitVec 32) )
        let addend ← (( do (Elem_read operand3 e 32) ) : SailM (BitVec 32) )
        (Elem_set result e 32
          (← (FPMulAdd addend element1 element2 (← (StandardFPSCRValue ())))))
    (pure loop_vars) ) : SailM (BitVec 128) )
  (Q_set (Int.shiftl d 1) result)

def decode_aarch32_instrs_VFMA_bfs_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
       (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
  let i := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
  let elements := (ediv_nat 128 32)
  let sel := (UInt0 Q)
  (execute_aarch32_instrs_VFMA_bfs_Op_A_txt d elements i m n sel)

def decode_aarch32_instrs_VFMA_bfs_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveAArch32BF16Ext ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
       (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (Sail.BitVec.extractLsb Vm 2 0))
  let i := (UInt0 (M ++ (BitVec.join1 [(BitVec.access Vm 3)])))
  let elements := (ediv_nat 128 32)
  let sel := (UInt0 Q)
  (execute_aarch32_instrs_VFMA_bfs_Op_A_txt d elements i m n sel)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned : Bool, 0 ≤
  n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_MMLA_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) : SailM Unit := do
  (CheckAdvSIMDEnabled ())
  let operand1 ← (( do (Q_read (Int.shiftl n 1)) ) : SailM (BitVec 128) )
  let operand2 ← (( do (Q_read (Int.shiftl m 1)) ) : SailM (BitVec 128) )
  let addend ← (( do (Q_read (Int.shiftl d 1)) ) : SailM (BitVec 128) )
  (Q_set (Int.shiftl d 1) (← (MatMulAdd addend operand1 operand2 op1_unsigned op2_unsigned)))

def decode_aarch32_instrs_MMLA_A1enc_A_txt (B : (BitVec 1)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (U : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveAArch32Int8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let op1_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let op2_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (B ++ U)
  bif (BEq.beq b__0 (0b00 : (BitVec 2)))
  then
    (let op1_unsigned : Bool := false
    let op2_unsigned : Bool := false
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0b01 : (BitVec 2)))
      then
        (let op1_unsigned : Bool := true
        let op2_unsigned : Bool := true
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let op1_unsigned : Bool := true
            let op2_unsigned : Bool := false
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let op2_unsigned := op2_unsigned
  let op1_unsigned := op1_unsigned
  bif (Bool.or
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
       (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  (execute_aarch32_instrs_MMLA_Op_A_txt d m n op1_unsigned op2_unsigned)

def decode_aarch32_instrs_MMLA_T1enc_A_txt (B : (BitVec 1)) (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (M : (BitVec 1)) (U : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveAArch32Int8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let op1_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let op2_unsigned ← (( do (undefined_bool ()) ) : SailM Bool )
  let b__0 := (B ++ U)
  bif (BEq.beq b__0 (0b00 : (BitVec 2)))
  then
    (let op1_unsigned : Bool := false
    let op2_unsigned : Bool := false
    (pure ()))
  else
    (do
      bif (BEq.beq b__0 (0b01 : (BitVec 2)))
      then
        (let op1_unsigned : Bool := true
        let op2_unsigned : Bool := true
        (pure ()))
      else
        (do
          bif (BEq.beq b__0 (0b10 : (BitVec 2)))
          then
            (let op1_unsigned : Bool := true
            let op2_unsigned : Bool := false
            (pure ()))
          else sailThrow ((Error_Undefined ()))))
  let op2_unsigned := op2_unsigned
  let op1_unsigned := op1_unsigned
  bif (Bool.or
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
       (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  (execute_aarch32_instrs_MMLA_Op_A_txt d m n op1_unsigned op2_unsigned)

/-- Type quantifiers: d : Nat, m : Nat, n : Nat, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 31 ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_VUSDOT_Op_A_txt (d : Nat) (m : Nat) (n : Nat) (regs : Nat) : SailM Unit := do
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let operand1 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let (element1, element2, operand1, operand2, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (element1, element2, operand1, operand2, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (element1, element2, operand1, operand2, result) := loop_vars
      loop_vars ← do
        let operand1 ← (Din_read (n +i r))
        let operand2 ← (Din_read (m +i r))
        let result ← (Din_read (d +i r))
        let (element1, element2, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := 1
          let mut loop_vars_1 := (element1, element2, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (element1, element2, result) := loop_vars_1
            loop_vars_1 ← do
              let res ← (( do (Elem_read result e 32) ) : SailM (BitVec 32) )
              let (element1, element2, res) ← (( do
                let loop_b_lower := 0
                let loop_b_upper := 3
                let mut loop_vars_2 := (element1, element2, res)
                for b in [loop_b_lower:loop_b_upper:1]i do
                  let (element1, element2, res) := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ← (pure (UInt0 (← (Elem_read operand1 ((4 *i e) +i b) 8))))
                    let element2 ← (pure (sint (← (Elem_read operand2 ((4 *i e) +i b) 8))))
                    let res : (BitVec 32) := (BitVec.addInt res (element1 *i element2))
                    (pure (element1, element2, res))
                (pure loop_vars_2) ) : SailM (Int × Int × (BitVec 32)) )
              let result ← (Elem_set result e 32 res)
              (pure (element1, element2, result))
          (pure loop_vars_1) ) : SailM (Int × Int × (BitVec 64)) )
        (D_set (d +i r) result)
        (pure (element1, element2, operand1, operand2, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec 64) × (BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_aarch32_instrs_VUSDOT_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveAArch32Int8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_VUSDOT_Op_A_txt d m n regs)

def decode_aarch32_instrs_VUSDOT_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveAArch32Int8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or
         (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
           (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1))))
         (BEq.beq (BitVec.join1 [(BitVec.access Vm 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 (M ++ Vm))
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_VUSDOT_Op_A_txt d m n regs)

/-- Type quantifiers: d : Nat, i : Nat, m : Nat, n : Nat, k_op1_unsigned : Bool, k_op2_unsigned :
  Bool, regs : Nat, regs ∈ {1, 2} ∧
  0 ≤ n ∧ n ≤ 31 ∧ 0 ≤ m ∧ m ≤ 15 ∧ i ∈ {0, 1} ∧ 0 ≤ d ∧ d ≤ 31 -/
def execute_aarch32_instrs_DOT_Op_A_txt (d : Nat) (i : Nat) (m : Nat) (n : Nat) (op1_unsigned : Bool) (op2_unsigned : Bool) (regs : Nat) : SailM Unit := do
  let element1 ← (( do (undefined_int ()) ) : SailM Int )
  let element2 ← (( do (undefined_int ()) ) : SailM Int )
  (CheckAdvSIMDEnabled ())
  let operand1 ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let result ← (( do (undefined_bitvector 64) ) : SailM (BitVec 64) )
  let operand2 ← (( do (Din_read m) ) : SailM (BitVec 64) )
  let (element1, element2, operand1, result) ← (( do
    let loop_r_lower := 0
    let loop_r_upper := (regs -i 1)
    let mut loop_vars := (element1, element2, operand1, result)
    for r in [loop_r_lower:loop_r_upper:1]i do
      let (element1, element2, operand1, result) := loop_vars
      loop_vars ← do
        let operand1 ← (Din_read (n +i r))
        let result ← (Din_read (d +i r))
        let (element1, element2, result) ← (( do
          let loop_e_lower := 0
          let loop_e_upper := 1
          let mut loop_vars_1 := (element1, element2, result)
          for e in [loop_e_lower:loop_e_upper:1]i do
            let (element1, element2, result) := loop_vars_1
            loop_vars_1 ← do
              let res ← (( do (Elem_read result e 32) ) : SailM (BitVec 32) )
              let (element1, element2, res) ← (( do
                let loop_b_lower := 0
                let loop_b_upper := 3
                let mut loop_vars_2 := (element1, element2, res)
                for b in [loop_b_lower:loop_b_upper:1]i do
                  let (element1, element2, res) := loop_vars_2
                  loop_vars_2 ← do
                    let element1 ←
                      (asl_Int (← (Elem_read operand1 ((4 *i e) +i b) 8)) op1_unsigned)
                    let element2 ←
                      (asl_Int (← (Elem_read operand2 ((4 *i i) +i b) 8)) op2_unsigned)
                    let res : (BitVec 32) := (BitVec.addInt res (element1 *i element2))
                    (pure (element1, element2, res))
                (pure loop_vars_2) ) : SailM (Int × Int × (BitVec 32)) )
              let result ← (Elem_set result e 32 res)
              (pure (element1, element2, result))
          (pure loop_vars_1) ) : SailM (Int × Int × (BitVec 64)) )
        (D_set (d +i r) result)
        (pure (element1, element2, operand1, result))
    (pure loop_vars) ) : SailM (Int × Int × (BitVec 64) × (BitVec 64)) )
  (pure ())

def decode_aarch32_instrs_DOT_A1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (U : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (Bool.not (← (HaveAArch32Int8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let op1_unsigned : Bool := (BEq.beq U (0b0 : (BitVec 1)))
  let op2_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 Vm)
  let i := (UInt0 M)
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_DOT_Op_A_txt d i m n op1_unsigned op2_unsigned regs)

def decode_aarch32_instrs_DOT_T1enc_A_txt (D : (BitVec 1)) (Vn : (BitVec 4)) (Vd : (BitVec 4)) (N : (BitVec 1)) (Q : (BitVec 1)) (M : (BitVec 1)) (U : (BitVec 1)) (Vm : (BitVec 4)) : SailM Unit := do
  bif (← (InITBlock ()))
  then sailThrow ((Error_Unpredictable ()))
  else (pure ())
  bif (Bool.not (← (HaveAArch32Int8MatMulExt ())))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  bif (Bool.and (BEq.beq Q (0b1 : (BitVec 1)))
       (Bool.or (BEq.beq (BitVec.join1 [(BitVec.access Vd 0)]) (0b1 : (BitVec 1)))
         (BEq.beq (BitVec.join1 [(BitVec.access Vn 0)]) (0b1 : (BitVec 1)))))
  then sailThrow ((Error_Undefined ()))
  else (pure ())
  let op1_unsigned : Bool := (BEq.beq U (0b0 : (BitVec 1)))
  let op2_unsigned : Bool := (BEq.beq U (0b1 : (BitVec 1)))
  let d := (UInt0 (D ++ Vd))
  let n := (UInt0 (N ++ Vn))
  let m := (UInt0 Vm)
  let i := (UInt0 M)
  let regs :=
    bif (BEq.beq Q (0b1 : (BitVec 1)))
    then 2
    else 1
  (execute_aarch32_instrs_DOT_Op_A_txt d i m n op1_unsigned op2_unsigned regs)

def execute_aarch32_instrs_CLRBHB_Op_A_txt (_ : Unit) : Unit :=
  (Hint_CLRBHB ())

def decode_aarch32_instrs_CLRBHB_A1enc_A_txt (cond : (BitVec 4)) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      assert (bne cond (0xF : (BitVec 4))) "src/instrs32.sail:47977.29-47977.30"
      bif (Bool.not (← (HaveFeatCLRBHB ())))
      then (EndOfInstruction ())
      else (pure ())
      (pure (execute_aarch32_instrs_CLRBHB_Op_A_txt ())))
  else (pure ())

def decode_aarch32_instrs_CLRBHB_T1enc_A_txt (_ : Unit) : SailM Unit := do
  bif (← (ConditionPassed ()))
  then
    (do
      bif (Bool.not (← (HaveFeatCLRBHB ())))
      then (EndOfInstruction ())
      else (pure ())
      (pure (execute_aarch32_instrs_CLRBHB_Op_A_txt ())))
  else (pure ())

